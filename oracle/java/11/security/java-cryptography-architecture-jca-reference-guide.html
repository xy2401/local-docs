<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <meta name="description" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <title>Java Cryptography Architecture (JCA) Reference Guide</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Security Developer’s Guide">
      <meta property="og:description" content='The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few.'>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Security Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="security-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T08:42:26-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="1993, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94828-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="troubleshooting-security.html" title="Previous" type="text/html">
      <link rel="next" href="howtoimplaprovider.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Security Developer Guide">
    <meta name="dcterms.isVersionOf" content="SECURITY">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="troubleshooting-security.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="howtoimplaprovider.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Security Developer’s Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Java Cryptography Architecture (JCA) Reference Guide</li>
            </ol>
            <a id="GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" name="GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190"></a>
            
            <h2 id="JSSEC-GUID-2BCFDD85-D533-4E6C-8CE9-29990DEB0190" class="sect2"><span class="enumeration_chapter">2 </span>Java Cryptography Architecture (JCA) Reference Guide
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>The Java Cryptography Architecture (JCA) is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few. </p>
            </div>
            <div class="sect2"><a id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231" name="GUID-815542FE-CF3D-407A-9673-CAE9840F6231"></a><h3 id="JSSEC-GUID-815542FE-CF3D-407A-9673-CAE9840F6231" class="sect3">Introduction to Java Cryptography Architecture</h3>
               <div>
                  <p>The Java platform strongly emphasizes security, including language safety, cryptography, public key infrastructure, authentication, secure communication, and access control.</p>
                  <p>The JCA is a major piece of the platform, and contains a "provider" architecture and a set of APIs for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few. These APIs allow developers to easily integrate security into their application code. The architecture was designed around the following principles:</p>
                  <ul style="list-style-type: disc;">
                     <li> 
                        <p><span class="bold">Implementation independence</span>: Applications do not need to implement security algorithms. Rather, they can request security services from the Java platform. Security services are implemented in providers (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">Cryptographic Service Providers</a>), which are plugged into the Java platform via a standard interface. An application may rely on multiple independent providers for security functionality.
                        </p> 
                     </li>
                     <li> 
                        <p><span class="bold">Implementation interoperability</span>: Providers are interoperable across applications. Specifically, an application is not bound to a specific provider, and a provider is not bound to a specific application.
                        </p> 
                     </li>
                     <li> 
                        <p><span class="bold">Algorithm extensibility</span>: The Java platform includes a number of built-in providers that implement a basic set of security services that are widely used today. However, some applications may rely on emerging standards not yet implemented, or on proprietary services. The Java platform supports the installation of custom providers that implement such services.
                        </p> 
                     </li>
                  </ul>
                  <p>Other cryptographic communication libraries available in the JDK use the JCA provider architecture, but are described elsewhere. The JSSE components provides access to Secure Socket Layer (SSL), Transport Layer Security (TLS), and Datagram Transport Layer Security (DTLS) implementations; see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" title="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">Java Secure Socket Extension (JSSE) Reference Guide</a>. You can use Java Generic Security Services (JGSS)  (via Kerberos) APIs, and Simple Authentication and Security Layer (SASL) to securely exchange messages between communicating applications; see <a href="introduction-jaas-and-java-gss-api-tutorials1.html">Introduction to JAAS and Java GSS-API Tutorials</a> and <a href="java-sasl-api-programming-and-deployment-guide1.html#GUID-6D78EE33-62E6-4D85-9695-322EED493F72">Java SASL API Programming and Deployment Guide</a>.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231__GUID-66BC8EAA-E1BC-42DA-BBC5-BF6BCF8E75B0">Notes on Terminology</p>
                     <ul style="list-style-type: disc;">
                        <li> 
                           <p>Prior to JDK 1.4, the JCE was an unbundled product, and as such, the JCA and JCE were regularly referred to as separate, distinct components. As JCE is now bundled in the JDK, the distinction is becoming less apparent. Since the JCE uses the same architecture as the JCA, the JCE should be more properly thought of as a part of the JCA.</p> 
                        </li>
                        <li> 
                           <p>The JCA within the JDK includes two software components:</p> 
                           <ul style="list-style-type: disc;">
                              <li>The framework that defines and supports cryptographic services for which providers supply implementations. This framework includes packages such as <code class="codeph">java.security</code>, <code class="codeph">javax.crypto</code>, <code class="codeph">javax.crypto.spec</code>, and <code class="codeph">javax.crypto.interfaces</code>.
                              </li>
                              <li>The actual providers such as <code class="codeph">Sun</code>, <code class="codeph">SunRsaSign</code>, <code class="codeph">SunJCE</code>, which contain the actual cryptographic implementations.
                              </li>
                           </ul>
                           <p>Whenever a specific JCA provider is mentioned, it will be referred to explicitly by the provider's name.</p> 
                        </li>
                     </ul>
                     <div class="infoboxnotewarn" id="GUID-815542FE-CF3D-407A-9673-CAE9840F6231__GUID-4604E723-D0C5-432A-B831-F3D6B61C1614">
                        <p class="notep1">WARNING:</p>The JCA makes it easy to incorporate security features into your application. However, this document does not cover the theory of security/cryptography beyond an elementary introduction to concepts necessary to discuss the APIs. This document also does not cover the strengths/weaknesses of specific algorithms, not does it cover protocol design. Cryptography is an advanced topic and one should consult a solid, preferably recent, reference in order to make best use of these tools.
                        <p>You should always understand what you are doing and why: DO NOT simply copy random code and expect it to fully solve your usage scenario. Many applications have been deployed that contain significant security or performance problems because the wrong tool or algorithm was selected.</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-71693272-7F57-4155-99F9-A2139271FD6D" name="GUID-71693272-7F57-4155-99F9-A2139271FD6D"></a><h4 id="JSSEC-GUID-71693272-7F57-4155-99F9-A2139271FD6D" class="sect4">JCA Design Principles</h4>
                  <div>
                     <p>The JCA was designed around these principles:</p>
                     <ul style="list-style-type: disc;">
                        <li>Implementation independence and interoperability</li>
                        <li>Algorithm independence and extensibility</li>
                     </ul>
                     <p>Implementation independence and algorithm independence are complementary; you can use cryptographic services, such as digital signatures and message digests, without worrying about the implementation details or even the algorithms that form the basis for these concepts. While complete algorithm-independence is not possible, the JCA provides standardized, algorithm-specific APIs. When implementation-independence is not desirable, the JCA lets developers indicate a specific implementation.</p>
                     <p>Algorithm independence is achieved by defining types of cryptographic "engines" (services), and defining classes that provide the functionality of these cryptographic engines. These classes are called <span class="variable" translate="no">engine classes</span>, and examples are the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/MessageDigest.html" target="_blank"><span class="apiname">MessageDigest</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/security/Signature.html" target="_blank"><span class="apiname">Signature</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyFactory.html" target="_blank"><span class="apiname">KeyFactory</span></a>, <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyPairGenerator.html" target="_blank"><span class="apiname">KeyPairGenerator</span></a>, and <a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/Cipher.html" target="_blank"><span class="apiname">Cipher</span></a> classes.
                     </p>
                     <p>Implementation independence is achieved using a "provider"-based architecture. The term Cryptographic Service Provider (CSP), which is used interchangeably with the term "provider," (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920">Cryptographic Service Providers</a>) refers to a package or set of packages that implement one or more cryptographic services, such as digital signature algorithms, message digest algorithms, and key conversion services. A program may simply request a particular type of object (such as a <code class="codeph">Signature</code> object) implementing a particular service (such as the DSA signature algorithm) and get an implementation from one of the installed providers. If desired, a program may instead request an implementation from a specific provider. Providers may be updated transparently to the application, for example when faster or more secure versions are available.
                     </p>
                     <p>Implementation interoperability means that various implementations can work with each other, use each other's keys, or verify each other's signatures. This would mean, for example, that for the same algorithms, a key generated by one provider would be usable by another, and a signature generated by one provider would be verifiable by another.</p>
                     <p>Algorithm extensibility means that new algorithms that fit in one of the supported engine classes can be added easily.</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859" name="GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859"></a><h4 id="JSSEC-GUID-EAB9FF73-4C69-4FD5-8A0C-5CF48211A859" class="sect4">Provider Architecture</h4>
                  <div>
                     <p>Providers contain a package (or a set of packages) that supply concrete implementations for the advertised cryptographic algorithms.</p>
                  </div>
                  <div class="sect4"><a id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920" name="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920"></a><h5 id="JSSEC-GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920" class="sect5">Cryptographic Service Providers</h5>
                     <div>
                        <p><code class="codeph">java.security.Provider</code> is the base class for all security providers. Each CSP contains an instance of this class which contains the provider's name and lists all of the security services/algorithms it implements. When an instance of a particular algorithm is needed, the JCA framework consults the provider's database, and if a suitable match is found, the instance is created.
                        </p>
                        <p>Providers contain a package (or a set of packages) that supply concrete implementations for the advertised cryptographic algorithms. Each JDK installation has one or more providers installed and configured by default. Additional providers may be added statically or dynamically. Clients may configure their runtime environment to specify the provider <span class="variable" translate="no">preference order</span>. The preference order is the order in which providers are searched for requested services when no specific provider is requested.
                        </p>
                        <p>To use the JCA, an application simply requests a particular type of object (such as a <code class="codeph">MessageDigest</code>) and a particular algorithm or service (such as the "SHA-256" algorithm), and gets an implementation from one of the installed providers. For example, the following statement requests a SHA-256 message digest from an installed provider: 
                        </p><pre class="codeblock"><code>    md = MessageDigest.getInstance("SHA-256");
</code></pre><p>Alternatively, the program can request the objects from a specific provider. Each provider has a name used to refer to it. For example, the following statement requests a SHA-256 message digest from the provider named ProviderC:</p><pre class="codeblock"><code>    md = MessageDigest.getInstance("SHA-256", "ProviderC");
</code></pre><p>The following figures illustrates requesting an SHA-256 message digest implementation. They show three different providers that implement various message digest algorithms (SHA-256, SHA-384, and SHA-512). The providers are ordered by preference from left to right (1-3). In <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTIMPLEMEN-0606134F">Figure 2-1</a>, an application requests a SHA-256 algorithm implementation <span class="bold">without</span> specifying a provider name. The providers are searched in preference order and the implementation from the first provider supplying that particular algorithm, ProviderB, is returned. In <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTWITHPROV-CB5635FE">Figure 2-2</a>, the application requests the SHA-256 algorithm implementation <span class="bold">from a specific provider</span>, ProviderC. This time, the implementation from ProviderC is returned, even though a provider with a higher preference order, ProviderB, also supplies an MD5 implementation.
                        </p>
                        <div class="figure" id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTIMPLEMEN-0606134F">
                           <p class="titleinfigure">Figure 2-1 Request SHA-256 Message Digest Implementation Without Specifying Provider</p><br><img src="img/security-overview-message-digest-wo-provider.png" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" longdesc="img_text/security-overview-message-digest-wo-provider.html"><br><a href="img_text/security-overview-message-digest-wo-provider.html">Description of "Figure 2-1 Request SHA-256 Message Digest Implementation Without Specifying Provider"</a><br></div>
                        <!-- class="figure" -->
                        <div class="figure" id="GUID-3E0744CE-6AC7-4A6D-A1F6-6C01199E6920__REQUESTSHA-256MESSAGEDIGESTWITHPROV-CB5635FE">
                           <p class="titleinfigure">Figure 2-2 Request SHA-256 Message Digest with ProviderC</p><br><img src="img/security-overview-message-digest-providerc.png" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" longdesc="img_text/security-overview-message-digest-providerc.html"><br><a href="img_text/security-overview-message-digest-providerc.html">Description of "Figure 2-2 Request SHA-256 Message Digest with ProviderC"</a><br></div>
                        <!-- class="figure" -->
                        <p>Cryptographic implementations in the JDK are distributed via several different providers (<code class="codeph">Sun</code>, <code class="codeph">SunJSSE</code>, <code class="codeph">SunJCE</code>, <code class="codeph">SunRsaSign</code>) primarily for historical reasons, but to a lesser extent by the type of functionality and algorithms they provide. Other Java runtime environments may not necessarily contain these providers, so applications should not request a provider-specific implementation unless it is known that a particular provider will be available.
                        </p>
                        <p>The JCA offers a set of APIs that allow users to query which providers are installed and what services they support.</p>
                        <p>This architecture also makes it easy for end-users to add additional providers. Many third party provider implementations are already available. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" title="In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (SUN, SunJCE, SunJSSE, SunRsaSign, etc.) that are already installed and registered. The following sections describe how to install and register additional providers.Each Provider class instance has a (currently case-sensitive) name, a version number, and a string description of the provider and its services.">The Provider Class</a> for more information on how providers are written, installed, and registered.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FD5163BD-E113-4B9D-A230-11184A668616" name="GUID-FD5163BD-E113-4B9D-A230-11184A668616"></a><h5 id="JSSEC-GUID-FD5163BD-E113-4B9D-A230-11184A668616" class="sect5">How Providers Are Actually Implemented</h5>
                     <div>
                        <p><span class="variable" translate="no">Algorithm independence</span> is achieved by defining a generic high-level Application Programming Interface (API) that all applications use to access a service type. <span class="variable" translate="no">Implementation independence</span> is achieved by having all provider implementations conform to well-defined interfaces. Instances of engine classes are thus "backed" by implementation classes which have the same method signatures. Application calls are routed through the engine class and are delivered to the underlying backing implementation. The implementation handles the request and return the proper results.
                        </p>
                        <div class="section">
                           <p>The application API methods in each engine class are routed to the provider's implementations through classes that implement the corresponding Service Provider Interface (SPI). That is, for each engine class, there is a corresponding abstract SPI class which defines the methods that each cryptographic service provider's algorithm must implement. The name of each SPI class is the same as that of the corresponding engine class, followed by <code class="codeph">Spi</code>. For example, the <code class="codeph">Signature</code> engine class provides access to the functionality of a digital signature algorithm. The actual provider implementation is supplied in a subclass of <code class="codeph">SignatureSpi</code>. Applications call the engine class' API methods, which in turn call the SPI methods in the actual implementation.
                           </p>
                           <p>Each SPI class is abstract. To supply the implementation of a particular type of service for a specific algorithm, a provider must subclass the corresponding SPI class and provide implementations for all the abstract methods.</p>
                           <p>For each engine class in the API, implementation instances are requested and instantiated by calling the <span class="apiname">getInstance()</span> <span class="variable" translate="no">factory method</span> in the engine class. A factory method is a static method that returns an instance of a class. The engine classes use the framework provider selection mechanism described above to obtain the actual backing implementation (SPI), and then creates the actual engine object. Each instance of the engine class encapsulates (as a private field) the instance of the corresponding SPI class, known as the SPI object. All API methods of an API object are declared final and their implementations invoke the corresponding SPI methods of the encapsulated SPI object.
                           </p>
                           <p>To make this clearer, review <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FD5163BD-E113-4B9D-A230-11184A668616__SAMPLECODEFORGETTINGANINSTANCEOFANE-724746B9">Example 2-1</a> and <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FD5163BD-E113-4B9D-A230-11184A668616__GUID-F8F97C84-B042-4576-B56D-1FD217F20400">Figure 2-3</a>:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-FD5163BD-E113-4B9D-A230-11184A668616__SAMPLECODEFORGETTINGANINSTANCEOFANE-724746B9">
                           <p class="titleinexample">Example 2-1 Sample Code for Getting an Instance of an Engine Class</p><pre class="codeblock"><code>
    import javax.crypto.*;

    Cipher c = Cipher.getInstance("AES");
    c.init(ENCRYPT_MODE, key);
</code></pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="figure" id="GUID-FD5163BD-E113-4B9D-A230-11184A668616__GUID-F8F97C84-B042-4576-B56D-1FD217F20400">
                              <p class="titleinfigure">Figure 2-3 Application Retrieves “AES” Cipher Instance</p><img src="img/aes-cipher.gif" alt="Description of Figure 2-3 follows" title="Description of Figure 2-3 follows" longdesc="img_text/aes-cipher.html"><br><a href="img_text/aes-cipher.html">Description of "Figure 2-3 Application Retrieves “AES” Cipher Instance"</a></div>
                           <!-- class="figure" -->
                           <p>Here an application wants an "AES" <code class="codeph">javax.crypto.Cipher</code> instance, and doesn't care which provider is used. The application calls the <code class="codeph">getInstance()</code> factory methods of the <code class="codeph">Cipher</code> engine class, which in turn asks the JCA framework to find the first provider instance that supports "AES". The framework consults each installed provider, and obtains the provider's instance of the <code class="codeph">Provider</code> class. (Recall that the <code class="codeph">Provider</code> class is a database of available algorithms.) The framework searches each provider, finally finding a suitable entry in CSP3. This database entry points to the implementation class <code class="codeph">com.foo.AESCipher</code> which extends <code class="codeph">CipherSpi</code>, and is thus suitable for use by the <code class="codeph">Cipher</code> engine class. An instance of <code class="codeph">com.foo.AESCipher</code> is created, and is encapsulated in a newly-created instance of <code class="codeph">javax.crypto.Cipher</code>, which is returned to the application. When the application now does the <span class="apiname">init()</span> operation on the <code class="codeph">Cipher</code> instance, the <code class="codeph">Cipher</code> engine class routes the request into the corresponding <span class="apiname">engineInit()</span> backing method in the <code class="codeph">com.foo.AESCipher</code> class.
                           </p> <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> lists the Standard Names defined for the Java environment. Other third-party providers may define their own implementations of these services, or even additional services.
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1" name="GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1"></a><h5 id="JSSEC-GUID-C730728A-DB4B-488F-8171-34FC04BD0FF1" class="sect5">Keystores</h5>
                     <div>
                        <p>A database called a "keystore" can be used to manage a repository of keys and certificates. Keystores are available to applications that need data for authentication, encryption, or signing purposes.</p>
                        <p>Applications can access a keystore via an implementation of the <code class="codeph">KeyStore</code> class, which is in the <code class="codeph">java.security</code> package.  As of JDK 9, the default and recommended keystore type (format) is "pkcs12", which is based on the RSA PKCS12 Personal Information Exchange Syntax Standard. Previously, the default keystore type was "jks", which is a proprietary format. Other keystore formats are available, such as "jceks", which is an alternate proprietary keystore format, and "pkcs11", which is based on the RSA PKCS11 Standard and supports access to cryptographic tokens such as hardware security modules and smartcards.
                        </p>
                        <p>Applications can choose different keystore implementations from different providers, using the same provider mechanism described previously. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" title='A database called a "keystore" can be used to manage a repository of keys and certificates. (A certificate is a digitally signed statement from one entity, saying that the public key of some other entity has a particular value.)'>Key Management</a>.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" name="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212"></a><h4 id="JSSEC-GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" class="sect4">Engine Classes and Algorithms</h4>
                  <div>
                     <p>An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider. </p>
                     <p>The engines provides one of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>cryptographic operations (encryption, digital signatures, message digests, etc.),</li>
                        <li>generators or converters of cryptographic material (keys and algorithm parameters), or</li>
                        <li>objects (keystores or certificates) that encapsulate the cryptographic data and can be used at higher layers of abstraction.</li>
                     </ul>
                     <p>The following engine classes are available:</p>
                     <ul style="list-style-type: disc;">
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36"><code class="codeph">SecureRandom</code></a>: used to generate random or pseudo-random numbers.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" title="Procedure to create a MessageDigest object.Procedure to update the Message Digest object.Procedure to compute the digest using different types of digest() methods."><code class="codeph">MessageDigest</code></a>: used to calculate the message digest (hash) of specified data.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" title="Signature objects are modal objects. This means that a Signature object is always in a given state, where it may only do one type of operation. The first step for signing or verifying a signature is to create a Signature instance.A Signature object must be initialized before it is used. The initialization method depends on whether the object is going to be used for signing or for verification."><code class="codeph">Signature</code></a>: initialized with keys, these are used to sign data and verify digital signatures.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566"><code class="codeph">Cipher</code></a>: initialized with keys, these used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk encryption (e.g. AES), asymmetric encryption (e.g. RSA), and password-based encryption (e.g. PBE).
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" title="Similar to a MessageDigest, a Message Authentication Code (MAC) provides a way to check the integrity of information transmitted over or stored in an unreliable medium, but includes a secret key in the calculation.">Message Authentication Codes (MAC)</a>: like <code class="codeph">MessageDigest</code>s, these also generate hash values, but are first initialized with keys to protect the integrity of messages.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A"><code class="codeph">KeyFactory</code></a>: used to convert existing opaque cryptographic keys of type <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects."><code class="codeph">Key</code></a> into key specifications (transparent representations of the underlying key material), and vice versa.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5E8F4099-779F-4484-9A95-F1CEA167601A"><code class="codeph">SecretKeyFactory</code></a>: used to convert existing opaque cryptographic keys of type <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects."><code class="codeph">SecretKey</code></a> into key specifications (transparent representations of the underlying key material), and vice versa. <code class="codeph">SecretKeyFactory</code>s are specialized <code class="codeph">KeyFactory</code>s that create secret (symmetric) keys only.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD"><code class="codeph">KeyPairGenerator</code></a>: used to generate a new pair of public and private keys suitable for use with a specified algorithm.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" title="A key generator is used to generate secret keys for symmetric algorithms."><code class="codeph">KeyGenerator</code></a>: used to generate new secret keys for use with a specified algorithm.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" title="Key agreement is a protocol by which 2 or more parties can establish the same cryptographic keys, without having to exchange any secret information."><code class="codeph">KeyAgreement</code></a>: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic operation.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" title="Like Keys and Keyspecs, an algorithm's initialization parameters are represented by either AlgorithmParameters or AlgorithmParameterSpecs."><code class="codeph">AlgorithmParameters</code></a>: used to store the parameters for a particular algorithm, including parameter encoding and decoding.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C"><code class="codeph">AlgorithmParameterGenerator</code></a> : used to generate a set of AlgorithmParameters suitable for a specified algorithm.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09050137-31F1-468A-A552-B051A4E35876" title="The KeyStore class supplies well-defined interfaces to access and modify the information in a keystore."><code class="codeph">KeyStore</code></a>: used to create and manage a <span class="variable" translate="no">keystore</span>. A keystore is a database of keys. Private keys in a keystore have a certificate chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from trusted entities.
                        </li>
                        <li><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" title="The CertificateFactory class defines the functionality of a certificate factory, which is used to generate certificate and certificate revocation list (CRL) objects from their encoding."><code class="codeph">CertificateFactory</code></a>: used to create public key certificates and Certificate Revocation Lists (CRLs).
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-BEFCC824-21C1-4AD3-B670-D0CA01F08D95" title="The CertPathBuilder class is an engine class used to build a certification path."><code class="codeph">CertPathBuilder</code></a>: used to build certificate chains (also known as certification paths).
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-808C1A6D-6A67-4026-A9DE-223A428EC80A" title="The CertPathValidator class is an engine class used to validate a certification path."><code class="codeph">CertPathValidator</code></a>: used to validate certificate chains.
                        </li>
                        <li><a href="java-pki-programmers-guide.html#GUID-5404B79C-3D49-4668-974C-1BACD1A98B73" title="The CertStore class is an engine class used to provide the functionality of a certificate and certificate revocation list (CRL) repository."><code class="codeph">CertStore</code></a>: used to retrieve <code class="codeph">Certificate</code>s and <code class="codeph">CRL</code>s from a repository.
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212__GUID-4ADAF14D-B1E3-451D-9708-F21608DCC42A">
                        <p class="notep1">Note:</p>A <span class="variable" translate="no">generator</span> creates objects with brand-new contents, whereas a <span class="variable" translate="no">factory</span> creates objects from existing material (for example, an encoding).
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F" name="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F"></a><h3 id="JSSEC-GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F" class="sect3">Core Classes and Interfaces</h3>
               <div>
                  <p>The following are the core classes and interfaces provided in the JCA.</p>
                  <ul style="list-style-type: disc;">
                     <li><code class="codeph">Provider</code> and <code class="codeph">Security</code></li>
                     <li><code class="codeph">SecureRandom</code>, <code class="codeph">MessageDigest</code>, <code class="codeph">Signature</code>, <code class="codeph">Cipher</code>, <code class="codeph">Mac</code>, <code class="codeph">KeyFactory</code>, <code class="codeph">SecretKeyFactory</code>, <code class="codeph">KeyPairGenerator</code>, <code class="codeph">KeyGenerator</code>, <code class="codeph">KeyAgreement</code>, <code class="codeph">AlgorithmParameter</code>, <code class="codeph">AlgorithmParameterGenerator</code>, <code class="codeph">KeyStore</code>, <code class="codeph">CertificateFactory</code>, and engine
                     </li>
                     <li><code class="codeph">Key Interface</code>, <code class="codeph">KeyPair</code></li>
                     <li><code class="codeph">AlgorithmParameterSpec Interface</code>, <code class="codeph">AlgorithmParameters</code>, <code class="codeph">AlgorithmParameterGenerator</code>, and algorithm parameter specification interfaces and classes in the <code class="codeph">java.security.spec</code> and <code class="codeph">javax.crypto.spec</code> packages.
                     </li>
                     <li><code class="codeph">KeySpec Interface</code>, <code class="codeph">EncodedKeySpec</code>, <code class="codeph">PKCS8EncodedKeySpec</code>, and <code class="codeph">X509EncodedKeySpec</code>.
                     </li>
                     <li><code class="codeph">SecretKeyFactory</code>, <code class="codeph">KeyFactory</code>, <code class="codeph">KeyPairGenerator</code>, <code class="codeph">KeyGenerator</code>, <code class="codeph">KeyAgreement</code>, and <code class="codeph">KeyStore</code>.
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-5C9A28FC-8B6B-45BA-8A71-6BEEA34EC27F__GUID-81034E79-9AB1-4E97-8EEA-5129FDBB3183">
                     <p class="notep1">Note:</p>See <code class="codeph">CertPathBuilder</code>, <code class="codeph">CertPathValidator</code>, and <code class="codeph">CertStore</code>engine classes in the <a href="java-pki-programmers-guide.html#GUID-650D0D53-B617-4055-AFD3-AF5C2629CBBF" title="The Java Certification Path API consists of classes and interfaces for handling certification paths, which are also called certification chains. If a certification path meets certain validation rules, it may be used to securely establish the mapping of a public key to a subject.">Java PKI Programmers Guide</a>.
                  </div>
                  <p>The guide will cover the most useful high-level classes first (Provider, Security, SecureRandom, MessageDigest, Signature, Cipher, and Mac), then delve into the various support classes. For now, it is sufficient to simply say that Keys (public, private, and secret) are generated and represented by the various JCA classes, and are used by the high-level classes as part of their operation.</p>
                  <p>This section shows the signatures of the main methods in each class and interface. Examples for some of these classes (MessageDigest, Signature, KeyPairGenerator, SecureRandom, KeyFactory, and key specification classes) are supplied in the corresponding <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-871FA938-5110-409E-A4EC-16F2A898093A">Code Examples</a> sections.
                  </p>
                  <p>The complete reference documentation for the relevant Security API packages can be found in the package summaries:</p>
                  <ul style="list-style-type: disc;">
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/package-summary.html" target="_blank"><code class="codeph">java.security</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/package-summary.html" target="_blank"><code class="codeph">javax.crypto</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/cert/package-summary.html" target="_blank"><code class="codeph">java.security.cert</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/package-summary.html" target="_blank"><code class="codeph">java.security.spec</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/package-summary.html" target="_blank"><code class="codeph">javax.crypto.spec</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/package-summary.html" target="_blank"><code class="codeph">java.security.interfaces</code></a></li>
                     <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/package-summary.html" target="_blank"><code class="codeph">javax.crypto.interfaces</code></a></li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" name="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307"></a><h4 id="JSSEC-GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307" class="sect4">The Provider Class</h4>
                  <div>
                     <p>The term "Cryptographic Service Provider" (used interchangeably with "provider" in this document) refers to a package or set of packages that supply a concrete implementation of a subset of the JDK Security API cryptography features. The <code class="codeph">Provider</code> <span class="italic">class</span> is the interface to such a package or set of packages. It has methods for accessing the provider name, version number, and other information. Please note that in addition to registering implementations of cryptographic services, the <code class="codeph">Provider</code> class can also be used to register implementations of other security services that might get defined as part of the JDK Security API or one of its extensions.
                     </p>
                     <p>To supply implementations of cryptographic services, an entity (e.g., a development group) writes the implementation code and creates a subclass of the <code class="codeph">Provider</code> class. The constructor of the <code class="codeph">Provider</code> subclass sets the values of various properties; the JDK Security API uses these values to look up the services that the provider implements. In other words, the subclass specifies the names of the classes implementing the services.
                     </p>
                     <div class="figure" id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307__GUID-DA3FDF88-BB48-44FA-A992-70FB7CA08DBF">
                        <p class="titleinfigure">Figure 2-4 Provider Class</p><img src="img/provider.png" alt="Description of Figure 2-4 follows" title="Description of Figure 2-4 follows" longdesc="img_text/provider.html"><br><a href="img_text/provider.html">Description of "Figure 2-4 Provider Class"</a></div>
                     <!-- class="figure" -->
                     <p>There are several types of services that can be implemented by provider packages; See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>.
                     </p>
                     <p>The different implementations may have different characteristics. Some may be software-based, while others may be hardware-based. Some may be platform-independent, while others may be platform-specific. Some provider source code may be available for review and evaluation, while some may not. The JCA lets both end-users and developers decide what their needs are.</p>
                     <p>You can find information about how end-users install the cryptography implementations that fit their needs, and how developers request the implementations that fit theirs.</p>
                     <div class="p">
                        <div class="infoboxnote" id="GUID-D8E30FE5-66B4-4F6A-88B7-280789E68307__GUID-8FA29B58-275F-40EE-B871-31BAF7A54250">
                           <p class="notep1">Note:</p>To implement a provider, see <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>.
                        </div> 
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741" name="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741"></a><h5 id="JSSEC-GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741" class="sect5">How Provider Implementations Are Requested and Supplied</h5>
                     <div>
                        <div class="section">
                           <p>For each engine class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>) in the API, a implementation instance is requested and instantiated by calling one of the <span class="apiname">getInstance</span> methods on the engine class, specifying the name of the desired algorithm and, optionally, the name of the provider (or the <code class="codeph">Provider</code> class) whose implementation is desired.
                           </p><pre class="codeblock"><code>
static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm)
    throws NoSuchAlgorithmException

static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm, String provider)
    throws NoSuchAlgorithmException, NoSuchProviderException

static <span class="variable" translate="no">EngineClassName</span> getInstance(String algorithm, Provider provider)
    throws NoSuchAlgorithmException
</code></pre><p> where </p>
                           <p><span class="italic">EngineClassName</span></p>
                           <p> is the desired engine type (MessageDigest/Cipher/etc). For example: </p><pre class="codeblock"><code>
    MessageDigest md = MessageDigest.getInstance("SHA-256");
    KeyAgreement ka = KeyAgreement.getInstance("DH", "SunJCE");
</code></pre><p> return an instance of the "SHA-256" MessageDigest and "DH" KeyAgreement objects, respectively. </p>
                           <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> contains the list of names that have been standardized for use with the Java environment. Some providers may choose to also include alias names that also refer to the same algorithm. For example, the "SHA256" algorithm might be referred to as "SHA-256". Applications should use standard names instead of an alias, as not all providers may alias algorithm names in the same way.
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741__GUID-123854F3-B43E-4650-8BB4-BF14004B3468">
                                 <p class="notep1">Note:</p>The algorithm name is not case-sensitive. For example, all the following calls are equivalent:<pre class="codeblock"><code>
MessageDigest.getInstance("SHA256")
MessageDigest.getInstance("sha256")
MessageDigest.getInstance("sHa256")
</code></pre></div>
                           </div>
                           <p>If no provider is specified, <code class="codeph">getInstance</code> searches the registered providers for an implementation of the requested cryptographic service associated with the named algorithm. In any given Java Virtual Machine (JVM), providers are installed in a given <span class="variable" translate="no">preference order</span>, the order in which the provider list is searched if a specific provider is not requested. (See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" title="In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (SUN, SunJCE, SunJSSE, SunRsaSign, etc.) that are already installed and registered. The following sections describe how to install and register additional providers.">Installing Providers</a>.) For example, suppose there are two providers installed in a JVM, <code class="codeph">PROVIDER_1</code> and <code class="codeph">PROVIDER_2</code>. Assume that:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li><code class="codeph">PROVIDER_1</code> implements SHA-256 and DESede. <code class="codeph">PROVIDER_1</code> has preference order 1 (the highest priority).
                              </li>
                              <li><code class="codeph">PROVIDER_2</code> implements SHA256withDSA, SHA-256, RC5, and RSA. <code class="codeph">PROVIDER_2</code> has preference order 2.
                              </li>
                           </ul>
                           <p> Now let's look at three scenarios: </p>
                           <ol>
                              <li>If we are looking for an SHA-256 implementation. Both providers supply such an implementation. The <code class="codeph">PROVIDER_1</code> implementation is returned since <code class="codeph">PROVIDER_1</code> has the highest priority and is searched first.
                              </li>
                              <li>If we are looking for an SHA256withDSA signature algorithm, <code class="codeph">PROVIDER_1</code> is first searched for it. No implementation is found, so <code class="codeph">PROVIDER_2</code> is searched. Since an implementation is found, it is returned.
                              </li>
                              <li>Suppose we are looking for a SHA256withRSA signature algorithm. Since no installed provider implements it, a <code class="codeph">NoSuchAlgorithmException</code> is thrown.
                              </li>
                           </ol>
                           <p>The <span class="apiname">getInstance</span> methods that include a provider argument are for developers who want to specify which provider they want an algorithm from. A federal agency, for example, will want to use a provider implementation that has received federal certification. Let's assume that the SHA256withDSA implementation from <code class="codeph">PROVIDER_1</code> has not received such certification, while the DSA implementation of <code class="codeph">PROVIDER_2</code> has received it.
                           </p>
                           <p>A federal agency program would then have the following call, specifying <code class="codeph">PROVIDER_2</code> since it has the certified implementation:
                           </p><pre class="codeblock"><code>Signature dsa = Signature.getInstance("SHA256withDSA", "PROVIDER_2");
</code></pre><p>In this case, if <code class="codeph">PROVIDER_2</code> was not installed, a <code class="codeph">NoSuchProviderException</code> would be thrown, even if another installed provider implements the algorithm requested.
                           </p>
                           <p>A program also has the option of getting a list of all the installed providers (using the <span class="apiname">getProviders</span> method in <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA">The Security Class</a> class) and choosing one from the list.
                           </p>
                           <div class="p">
                              <div class="infoboxnote" id="GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741__GUID-8A66CE47-C14C-4CBC-BA2E-E5BAAFBF9477">
                                 <p class="notep1">Note:</p>General purpose applications <span class="bold">SHOULD NOT</span> request cryptographic services from specific providers. Otherwise, applications are tied to specific providers which may not be available on other Java implementations. They also might not be able to take advantage of available optimized providers (for example hardware accelerators via PKCS11 or native OS implementations such as Microsoft's MSCAPI) that have a higher preference order than the specific requested provider.
                              </div> 
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" name="GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007"></a><h5 id="JSSEC-GUID-E28AC9F2-CBD7-49FC-85B8-5011A94D9007" class="sect5">Installing Providers</h5>
                     <div>
                        <p>In order to be used, a cryptographic provider must first be installed, then registered either statically or dynamically. There are a variety of Sun providers shipped with this release (<code class="codeph">SUN</code>, <code class="codeph">SunJCE</code>, <code class="codeph">SunJSSE</code>, <code class="codeph">SunRsaSign</code>, etc.) that are already installed and registered. The following sections describe how to install and register additional providers.
                        </p>
                        <p>All JDK providers are already installed and registered. However, if you require any third-party providers, see <a href="howtoimplaprovider.html#GUID-FB9C6DB2-DE9A-4EFE-89B4-C2C168C5982D" title="The next steps describe how to install and configure your new provider so that it is available via the JCA.">Step 8: Prepare for Testing</a> from <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a> for information about how to add providers to the class or module path, register providers (statically or dynamically), and add any required permissions.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8" name="GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8"></a><h5 id="JSSEC-GUID-F8089178-4CDC-4947-A118-7D02ED3EDFD8" class="sect5">Provider Class Methods</h5>
                     <div>
                        <p>Each <code class="codeph">Provider</code> class instance has a (currently case-sensitive) name, a version number, and a string description of the provider and its services.
                        </p>
                        <div class="section">
                           <p>You can query the <code class="codeph">Provider</code> instance for this information by calling the following methods:
                           </p><pre class="codeblock"><code>
public String getName()
public double getVersion()
public String getInfo()
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA" name="GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA"></a><h4 id="JSSEC-GUID-DE597505-1B42-4AE3-AE2D-45F9123138FA" class="sect4">The Security Class</h4>
                  <div>
                     <p>The <span class="apiname">Security</span> class manages installed providers and security-wide properties. It only contains static methods and is never instantiated. The methods for adding or removing providers, and for setting <code class="codeph">Security</code> properties, can only be executed by a trusted program. Currently, a "trusted program" is either
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>A local application not running under a security manager, or</li>
                        <li>An applet or application with permission to execute the specified method (see below).</li>
                     </ul>
                     <p> The determination that code is considered trusted to perform an attempted action (such as adding a provider) requires that the applet is granted the proper permission(s) for that particular action. The policy configuration file(s) for a JDK installation specify what permissions (which types of system resource accesses) are allowed by code from specified code sources. (See below and the <a href="permissions-jdk1.html#GUID-789089CA-8557-4017-B8B0-6899AD3BA18D">Default Policy Implementation and Policy File Syntax</a> and <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc.html" target="_blank">Java Security Architecture Specification</a> files.) 
                     </p>
                     <p>Code being executed is always considered to come from a particular "code source". The code source includes not only the location (URL) where the code originated from, but also a reference to any public key(s) corresponding to the private key(s) that may have been used to sign the code. Public keys in a code source are referenced by (symbolic) alias names from the user's .</p>
                     <p>In a policy configuration file, a code source is represented by two components: a code base (URL), and an alias name (preceded by <code class="codeph">signedBy</code>), where the alias name identifies the keystore entry containing the public key that must be used to verify the code's signature.
                     </p>
                     <p>Each "grant" statement in such a file grants a specified code source a set of permissions, specifying which actions are allowed.</p>
                     <p>Here is a sample policy configuration file:</p><pre class="codeblock"><code>grant codeBase "file:/home/sysadmin/", signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider";
    permission java.security.SecurityPermission "removeProvider";
    permission java.security.SecurityPermission "putProviderProperty.*";
};
</code></pre><p>This configuration file specifies that code loaded from a signed JAR file in the <code class="codeph">/home/sysadmin/</code> directory on the local file system can add or remove providers or set provider properties. (Note that the signature of the JAR file can be verified using the public key referenced by the alias name <code class="codeph">sysadmin</code>  in the user's keystore.).
                     </p>
                     <p>Either component of the code source (or both) may be missing. Here's an example of a configuration file where the <code class="codeph">codeBase</code> is omitted:
                     </p><pre class="codeblock"><code>
grant signedBy "sysadmin" {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</code></pre><p> If this policy is in effect, code that comes in a JAR File signed by <code class="codeph">/home/sysadmin/</code> directory on the local filesystem can add or remove providers. The code does not need to be signed.
                     </p>
                     <p>An example where neither <code class="codeph">codeBase</code> nor <code class="codeph">signedBy</code> is included is:
                     </p><pre class="codeblock"><code>
grant {
    permission java.security.SecurityPermission "insertProvider.*";
    permission java.security.SecurityPermission "removeProvider.*";
};
</code></pre><p> Here, with both code source components missing, any code (regardless of where it originates, or whether or not it is signed, or who signed it) can add/remove providers. Obviously, this is definitely not  recommended, as this grant could open a security hole. Untrusted code could install a Provider, thus affecting later code that is depending on a properly functioning implementation. (For example, a rogue <code class="codeph">Cipher</code>  object might capture and store the sensitive information it receives.) 
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90" name="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90"></a><h5 id="JSSEC-GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90" class="sect5">Managing Providers</h5>
                     <div>
                        <p>The following tables summarize the methods in the <code class="codeph">Security</code> class you can use to query which <code class="codeph">Provider</code>s are installed, as well as to install or remove providers at runtime.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-E1111DD9-08A0-42EC-8ACA-780019AF3E78">Querying Providers</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-2846E40D-F447-42D0-99BE-7A7C18C69B62">
                              <table cellpadding="4" cellspacing="0" class="Formal" title summary="Methods to query installed Providers" width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1213">Method</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1215">Description</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1219" headers="d30788e1213 "><code class="codeph">static Provider[] getProviders()</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1219 d30788e1215 ">Returns an array containing all the installed providers (technically, the <code class="codeph">Provider</code> subclass for each package provider). The order of the <code class="codeph">Provider</code>s in the array is their preference order.
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1231" headers="d30788e1213 "><code class="codeph">static Provider getProvider (String providerName)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1231 d30788e1215 ">Returns the <code class="codeph">Provider</code> named <code class="codeph">providerName</code>. It returns <code class="codeph">null</code> if the <code class="codeph">Provider</code> is not found.
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-C75C8051-F384-44C8-8911-9A760A0B2C17">Adding Providers</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-A7326F94-A51D-47F9-A638-D44E80710671">
                              <table cellpadding="4" cellspacing="0" class="Formal" title summary="Methods to add installed Providers " width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1259">Method</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1261">Description</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1265" headers="d30788e1259 "><code class="codeph">static int addProvider(Provider provider)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1265 d30788e1261 ">Adds a <code class="codeph">Provider</code> to the end of the list of installed <code class="codeph">Provider</code>s. It returns the preference position in which the <code class="codeph">Provider</code> was added, or <code class="codeph">-1</code> if the <code class="codeph">Provider</code> was not added because it was already installed.
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1286" headers="d30788e1259 "><code class="codeph">static int insertProviderAt (Provider provider, int position)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1286 d30788e1261 ">Adds a new <code class="codeph">Provider</code> at a specified position. If the given provider is installed at the requested position, the provider formerly at that position and all providers with a position greater than <code class="codeph">position</code> are shifted up one position (towards the end of the list). This method returns the preference position in which the <code class="codeph">Provider</code> was added, or <code class="codeph">-1</code> if the <code class="codeph">Provider</code> was not added because it was already installed.
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-CA265A2C-A101-4984-AEED-DF429CE17688">Removing Providers</p>
                           <div class="tblformal" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-B2A12498-B82E-48A3-8E2C-D2DE65AA3B61">
                              <table cellpadding="4" cellspacing="0" class="Formal" title summary="Methods to remove installed Providers " width="100%" frame="hsides" border="1" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1317">Method</th>
                                       <th rowspan="1" colspan="1" align="left" valign="bottom" id="d30788e1319">Description</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td rowspan="1" colspan="1" align="left" valign="top" id="d30788e1323" headers="d30788e1317 "><code class="codeph">static void removeProvider(String name)</code></td>
                                       <td rowspan="1" colspan="1" align="left" valign="top" headers="d30788e1323 d30788e1319 ">Removes the <code class="codeph">Provider</code> with the specified name. It returns silently if the provider is not installed. When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers).
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnote" id="GUID-F6337AB7-D5A0-4AEC-B026-20E885D41E90__GUID-D4EE4FE3-379E-451D-BDAE-FAC97B332CC4">
                              <p class="notep1">Note:</p> If you want to change the preference position of a provider, you must first remove it, and then insert it back in at the new preference position.
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E" name="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E"></a><h5 id="JSSEC-GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E" class="sect5">Security Properties</h5>
                     <div>
                        <p>The <code class="codeph">Security</code> class maintains a list of system-wide Security Properties. These properties are similar to the <code class="codeph">System</code> properties, but are security-related. These properties can be set statically (through the <code><span class="variable" translate="no">&lt;java-home&gt;</span>/conf/security/java.security</code> file) or dynamically (using an API). See <a href="howtoimplaprovider.html#GUID-831AA25F-F702-442D-A2E4-8DA6DEA16F33" title="Register your provider so that the JCE framework can find your provider, either with the ServiceLoader class or in the class path or module path.">Step 8.1: Configure the Provider</a> from <a href="howtoimplaprovider.html#GUID-CC161921-EBD2-48C6-B543-A956658B68B6" title="Follow these steps to implement a provider and integrate it into the JCA framework:">Steps to Implement and Integrate a Provider</a>. for an example of registering a provider statically with the <code class="codeph">security.provider.<span class="variable" translate="no">n</span></code> Security Property. If you want to set properties dynamically, trusted programs can use the following methods:
                        </p><pre class="codeblock"><code>static String getProperty(String key)
static void setProperty(String key, String datum)
</code></pre><div class="infoboxnote" id="GUID-BC5C75FC-DCF7-4E57-874C-42F7EDA8FF1E__GUID-35369CF0-AB08-463E-ACFC-DB1568B85F22">
                           <p class="notep1">Note:</p>The list of security providers is established during VM startup; therefore, the methods described above must be used to alter the provider list.
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36" name="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36"></a><h4 id="JSSEC-GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36" class="sect4">The SecureRandom Class</h4>
                  <div>
                     <p>The SecureRandom class is an engine class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>) that provides cryptographically strong random numbers, either by accessing a pseudo-random number generator (PRNG), a deterministic algorithm that produces a pseudo-random sequence from an initial seed value, or by reading a native source of randomness (for example, <code>/dev/random</code> or a true random number generator). One example of a PRNG is the Deterministic Random Bits Generator (DRBG) as specified in <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf" target="_blank">NIST SP 800-90Ar1</a>. Other implementations may produce true random numbers, and yet others may use a combination of both techniques. A cryptographically strong random number minimally complies with the statistical random number generator tests specified in <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf" target="_blank">FIPS 140-2, Security Requirements for Cryptographic Modules</a>, section 4.9.1.
                     </p>
                     <p>All Java SE implementations must indicate the strongest (most random) implementation of SecureRandom that they provide in the <code class="codeph">securerandom.strongAlgorithms</code> property of the <code class="codeph">java.security.Security</code> class. This implementation can be used when a particularly strong random value is required.
                     </p>
                     <p>The <code class="codeph">securerandom.drbg.config</code> property is used to specify the DRBG <code class="codeph">SecureRandom</code> configuration and implementations in the SUN provider. The <code class="codeph">securerandom.drbg.config</code> is a property of the <code class="codeph">java.security.Security</code> class. Other DRBG implementations can also use the <code class="codeph">securerandom.drbg.config</code> property.
                     </p>
                     <div class="figure" id="GUID-AEB77CD8-D28F-4BBE-B9E5-160B5DC35D36__GUID-BC14EED8-64AD-4750-9417-6E35322A2C07">
                        <p class="titleinfigure">Figure 2-5 SecureRandom class</p><img src="img/secure-random.png" alt="Description of Figure 2-5 follows" title="Description of Figure 2-5 follows" longdesc="img_text/secure-random.html"><br><a href="img_text/secure-random.html">Description of "Figure 2-5 SecureRandom class"</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div class="sect4"><a id="GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35" name="GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35"></a><h5 id="JSSEC-GUID-5E53C490-C1B5-4862-A32F-EAD6ADC0AE35" class="sect5">Creating a SecureRandom Object</h5>
                     <div>
                        <p>There are several ways to obtain an instance of <code class="codeph">SecureRandom</code>:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li> 
                              <p>All Java SE implementations provide a default <code class="codeph">SecureRandom</code> using the no-argument constructor: <code class="codeph">new SecureRandom()</code>. This constructor traverses the list of registered security providers, starting with the most preferred provider, then returns a new <span class="apiname">SecureRandom</span> object from the first provider that supports a <code class="codeph">SecureRandom</code> random number generator (RNG) algorithm. If none of the providers support a RNG algorithm, then it returns a <span class="apiname">SecureRandom</span> object that uses SHA1PRNG from the SUN provider.
                              </p> 
                           </li>
                           <li> 
                              <p>To get a specific implementation of <code class="codeph">SecureRandom</code>, use one of the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                              </p> 
                           </li>
                           <li> 
                              <p>Use the <code class="codeph">getInstanceStrong()</code> method to obtain a strong <code class="codeph">SecureRandom</code> implementation as defined by the <code class="codeph">securerandom.strongAlgorithms</code> property of the <code class="codeph">java.security.Security</code> class. This property lists platform implementations that are suitable for generating important values.
                              </p> 
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8" name="GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8"></a><h5 id="JSSEC-GUID-4E42B9E7-FF0B-4FD6-B67A-44F28F943BA8" class="sect5">Seeding or Re-Seeding the SecureRandom Object</h5>
                     <div>
                        <p>The <span class="apiname">SecureRandom</span> object is initialized with a random seed unless the call to <span class="apiname">getInstance()</span> is followed by a call to one of the following <span class="apiname">setSeed</span> methods. 
                        </p><pre class="codeblock"><code>    void setSeed(byte[] seed)
    void setSeed(long seed)
</code></pre><p>You must call <span class="apiname">setSeed</span> before the first <span class="apiname">nextBytes</span> call to prevent any environmental randomness.
                        </p>
                        <p>The randomness of the bits produced by the <span class="apiname">SecureRandom</span> object depends on the randomness of the seed bits
                        </p>
                        <p>At any time a <code class="codeph">SecureRandom</code> object may be re-seeded using one of the <code class="codeph">setSeed</code> or <code class="codeph">reseed</code> methods. The given seed for <code class="codeph">setSeed</code> supplements, rather than replaces, the existing seed; therefore, repeated calls are guaranteed never to reduce randomness.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD" name="GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD"></a><h5 id="JSSEC-GUID-2FCAEC55-8FB5-4FCD-9826-38ABA0AF26DD" class="sect5">Using a SecureRandom Object</h5>
                     <div>
                        <p>To get random bytes, a caller simply passes an array of any length, which is then filled with random bytes:</p><pre class="codeblock"><code>
    void nextBytes(byte[] bytes)
</code></pre></div>
                  </div>
                  <div class="sect4"><a id="GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340" name="GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340"></a><h5 id="JSSEC-GUID-B85818A1-2AAD-449C-BFB9-EC9146C1B340" class="sect5">Generating Seed Bytes</h5>
                     <div>
                        <p>If desired, it is possible to invoke the <span class="apiname">generateSeed</span> method to generate a given number of seed bytes (to seed other random number generators, for example):
                        </p><pre class="codeblock"><code>
byte[] <span class="apiname">generateSeed</span>(int numBytes)
</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" name="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7"></a><h4 id="JSSEC-GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7" class="sect4">The MessageDigest Class</h4>
                  <div>
                     <p>The <code class="codeph">MessageDigest</code> class is an engine class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>) designed to provide the functionality of cryptographically secure message digests such as SHA-256 or SHA-512. A cryptographically secure message digest takes arbitrary-sized input (a byte array), and generates a fixed-size output, called a <span class="variable" translate="no">digest</span> or hash.
                     </p>
                     <div class="figure" id="GUID-FB0090CA-2BCC-4D2C-BD2F-6F0A97197BD7__GUID-55B0CED3-CB64-479F-9599-A95FD2B243FC">
                        <p class="titleinfigure">Figure 2-6 MessageDigest Class</p><img src="img/message-digest.png" alt="Description of Figure 2-6 follows" title="Description of Figure 2-6 follows" longdesc="img_text/message-digest.html"><br><a href="img_text/message-digest.html">Description of "Figure 2-6 MessageDigest Class"</a></div>
                     <!-- class="figure" -->
                     <p>For example, the SHA-256 algorithm produces a 32-byte digest, and SHA-512's is 64 bytes.</p>
                     <p>A digest has two properties:</p>
                     <ul style="list-style-type: disc;">
                        <li>It should be computationally infeasible to find two messages that hash to the same value.</li>
                        <li>The digest should not reveal anything about the input that was used to generate it.</li>
                     </ul>
                     <p>Message digests are used to produce unique and reliable identifiers of data. They are sometimes called "checksums" or the "digital fingerprints" of the data. Changes to just one bit of the message should produce a different digest value.</p>
                     <p>Message digests have many uses and can determine when data has been modified, intentionally or not. Recently, there has been considerable effort to determine if there are any weaknesses in popular algorithms, with mixed results. When selecting a digest algorithm, one should always consult a recent reference to determine its status and appropriateness for the task at hand.</p>
                  </div>
                  <div class="sect4"><a id="GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A" name="GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A"></a><h5 id="JSSEC-GUID-2F162F9E-8A5F-4586-8E3A-CEF37ECD5E2A" class="sect5">Creating a MessageDigest Object</h5>
                     <div>
                        <p>Procedure to create a <code class="codeph">MessageDigest</code> object.
                        </p>
                        <ul>
                           <li class="stepexpand"><span>To compute a digest, create a message digest instance. The <code class="codeph">MessageDigest</code> objects are obtained by using one of the <span class="apiname">getInstance()</span> methods in the <code class="codeph">MessageDigest</code> class. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.</span><div>The factory method returns an initialized message digest object. It thus does not need further initialization.</div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" name="GUID-72106C04-D90A-4CB8-B320-1F4F864221DC"></a><h5 id="JSSEC-GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" class="sect5">Updating a Message Digest Object</h5>
                     <div>
                        <p>Procedure to update the Message Digest object.</p>
                        <ul>
                           <li class="stepexpand"><span>To calculate the digest of some data, you have to supply the data to the initialized message digest object. It can be provided all at once, or in chunks. Pieces can be fed to the message digest by calling one of the <code class="codeph">update</code> methods:</span><div><pre class="codeblock"><code>
void update(byte input)
void update(byte[] input)
void update(byte[] input, int offset, int len)
</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789" name="GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789"></a><h5 id="JSSEC-GUID-616B5D4B-F334-46B4-9969-6CB4ADF29789" class="sect5">Computing the Digest</h5>
                     <div>
                        <p>Procedure to compute the digest using different types of <span class="apiname">digest()</span> methods.
                        </p>
                        <div class="p">The data chunks have to be supplied by calls to <code class="codeph">update</code> method. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-72106C04-D90A-4CB8-B320-1F4F864221DC" title="Procedure to update the Message Digest object.">Updating a Message Digest Object</a>.
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>The digest is computed using a call to one of the <code class="codeph">digest</code> methods:</span><div><pre class="codeblock"><code>
byte[] digest()
byte[] digest(byte[] input)
int digest(byte[] buf, int offset, int len)
</code></pre></div>
                              <ol>
                                 <li><span>The <code class="codeph">byte[] digest()</code>  method return the computed digest.</span></li>
                                 <li><span>The <code class="codeph">byte[] digest(byte[] input)</code> method does a final <code class="codeph">update(input)</code> with the input byte array before calling <code class="codeph"><span class="apiname">digest()</span></code>, which returns the digest byte array.</span></li>
                                 <li><span>The <code class="codeph">int digest(byte[] buf, int offset, int len)</code> method stores the computed digest in the provided buffer <code class="codeph">buf</code>, starting at <code class="codeph">offset</code>. <code class="codeph">len</code>  is the number of bytes in <code class="codeph">buf</code> allotted for the digest, the method returns the number of bytes actually stored in <code class="codeph">buf</code>. If there is not enough room in the buffer, the method will throw an exception.</span></li>
                              </ol>
                              <div>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" title="An example describing the procedure to compute a MessageDigest object.">Computing a MessageDigest Object</a>.
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" name="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF"></a><h4 id="JSSEC-GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF" class="sect4">The Signature Class</h4>
                  <div>
                     <p>The <code class="codeph">Signature</code> class is an engine class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>( designed to provide the functionality of a cryptographic digital signature algorithm such as SHA256withDSA or SHA512withRSA. A cryptographically secure signature algorithm takes arbitrary-sized input and a private key and generates a relatively short (often fixed-size) string of bytes, called the <span class="variable" translate="no">signature</span>, with the following properties:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>Only the owner of a private/public key pair is able to create a signature. It should be computationally infeasible for anyone having only the public key and a number of signatures to recover the private key.</li>
                        <li>Given the public key corresponding to the private key used to generate the signature, it should be possible to verify the authenticity and integrity of the input.</li>
                     </ul>
                     <div class="figure" id="GUID-9CF09CE2-9443-4F4E-8095-5CBFC7B697CF__GUID-9CD447B5-97F4-4E45-B883-77C9EAFCB7B6">
                        <p class="titleinfigure">Figure 2-7 Signature Class</p><img src="img/signature.png" alt="Description of Figure 2-7 follows" title="Description of Figure 2-7 follows" longdesc="img_text/signature.html"><br><a href="img_text/signature.html">Description of "Figure 2-7 Signature Class"</a></div>
                     <!-- class="figure" -->
                     <p>A <span class="apiname">Signature</span> object is initialized for signing with a Private Key and is given the data to be signed. The resulting signature bytes are typically kept with the signed data. When verification is needed, another <span class="apiname">Signature</span> object is created and initialized for verification and given the corresponding Public Key. The data and the signature bytes are fed to the signature object, and if the data and signature match, the <span class="apiname">Signature</span> object reports success.
                     </p>
                     <p>Even though a signature seems similar to a message digest, they have very different purposes in the type of protection they provide. In fact, algorithms such as "SHA256WithRSA" use the message digest "SHA256" to initially "compress" the large data sets into a more manageable form, then sign the resulting 32 byte message digest with the "RSA" algorithm.</p>
                     <p>For an example for signing and verifying data, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" title="Examples of generating and verifying a signature using generated keys.">Generating and Verifying a Signature Using Generated Keys</a>.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE" name="GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE"></a><h5 id="JSSEC-GUID-3586E054-8F23-4D2B-BEA4-47635DAB4EEE" class="sect5">Signature Object States</h5>
                     <div>
                        <p><code class="codeph">Signature</code> objects are modal objects. This means that a <code class="codeph">Signature</code> object is always in a given state, where it may only do one type of operation. 
                        </p>
                        <p>States are represented as final integer constants defined in their respective classes.</p>
                        <p>The three states a <code class="codeph">Signature</code> object may have are:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">UNINITIALIZED</code></li>
                           <li><code class="codeph">SIGN</code></li>
                           <li><code class="codeph">VERIFY</code></li>
                        </ul>
                        <p> When it is first created, a <code class="codeph">Signature</code> object is in the <code class="codeph">UNINITIALIZED</code>  state. The <code class="codeph">Signature</code>  class defines two initialization methods, <code class="codeph">initSign</code> and <code class="codeph">initVerify</code>, which change the state to <code class="codeph">SIGN</code> and <code class="codeph">VERIFY</code> , respectively.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6" name="GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6"></a><h5 id="JSSEC-GUID-1240FDC5-818E-4067-9C3C-D9635DF7D8A6" class="sect5">Creating a Signature Object</h5>
                     <div>
                        <p>The first step for signing or verifying a signature is to create a <code class="codeph">Signature</code> instance.
                        </p>
                        <p><code class="codeph">Signature</code> objects are obtained by using one of the <code class="codeph">Signature</code> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6" name="GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6"></a><h5 id="JSSEC-GUID-B3C371AB-A447-4F28-9C6E-1349FAC889E6" class="sect5">Initializing a Signature Object</h5>
                     <div>
                        <p>A <code class="codeph">Signature</code> object must be initialized before it is used. The initialization method depends on whether the object is going to be used for signing or for verification.
                        </p>
                        <p>If it is going to be used for signing, the object must first be initialized with the private key of the entity whose signature is going to be generated. This initialization is done by calling the method:</p><pre class="codeblock"><code>
final void initSign(PrivateKey privateKey)
</code></pre><p>This method puts the <code class="codeph">Signature</code> object in the <code class="codeph">SIGN</code>  state. If instead the <code class="codeph">Signature</code> object is going to be used for verification, it must first be initialized with the public key of the entity whose signature is going to be verified. This initialization is done by calling either of these methods:
                        </p><pre class="codeblock"><code>
    final void initVerify(PublicKey publicKey)

    final void initVerify(Certificate certificate)
</code></pre><p>This method puts the <code class="codeph">Signature</code> object in the <code class="codeph">VERIFY</code> state.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA" name="GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA"></a><h5 id="JSSEC-GUID-93D13151-06F6-4BEA-8F83-074CDB5809DA" class="sect5">Signing with a Signature Object</h5>
                     <div>
                        <p>If the <code class="codeph">Signature</code> object has been initialized for signing (if it is in the <code class="codeph">SIGN</code> state), the data to be signed can then be supplied to the object. This is done by making one or more calls to one of the <code class="codeph">update</code> methods:
                        </p><pre class="codeblock"><code>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</code></pre><p>Calls to the <code class="codeph">update</code> method(s) should be made until all the data to be signed has been supplied to the <code class="codeph">Signature</code> object.
                        </p>
                        <p>To generate the signature, simply call one of the <code class="codeph">sign</code> methods:
                        </p><pre class="codeblock"><code>
final byte[] sign()
final int sign(byte[] outbuf, int offset, int len)
</code></pre><p>The first method returns the signature result in a byte array. The second stores the signature result in the provided buffer <span class="variable" translate="no">outbuf</span>, starting at <span class="variable" translate="no">offset</span>. <span class="variable" translate="no">len</span> is the number of bytes in <span class="variable" translate="no">outbuf</span> allotted for the signature. The method returns the number of bytes actually stored.
                        </p>
                        <p>Signature encoding is algorithm specific. See <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> to know more about the use of ASN.1 encoding in the Java Cryptography Architecture.
                        </p>
                        <p>A call to a <code class="codeph">sign</code> method resets the signature object to the state it was in when previously initialized for signing via a call to <code class="codeph">initSign</code>. That is, the object is reset and available to generate another signature with the same private key, if desired, via new calls to <code class="codeph">update</code> and <code class="codeph">sign</code>.
                        </p>
                        <p>Alternatively, a new call can be made to <code class="codeph">initSign</code> specifying a different private key, or to <code class="codeph">initVerify</code> (to initialize the <code class="codeph">Signature</code> object to verify a signature).
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A" name="GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A"></a><h5 id="JSSEC-GUID-1B8AD667-3717-4D9E-B92E-322CFF8C832A" class="sect5">Verifying with a Signature Object</h5>
                     <div>
                        <p>If the <code class="codeph">Signature</code> object has been initialized for verification (if it is in the <code class="codeph">VERIFY</code> state), it can then verify if an alleged signature is in fact the authentic signature of the data associated with it. To start the process, the data to be verified (as opposed to the signature itself) is supplied to the object. The data is passed to the object by calling one of the <code class="codeph">update</code> methods:
                        </p><pre class="codeblock"><code>
final void update(byte b)
final void update(byte[] data)
final void update(byte[] data, int off, int len)
</code></pre><p>Calls to the <code class="codeph">update</code> method(s) should be made until all the data to be verified has been supplied to the <code class="codeph">Signature</code> object. The signature can now be verified by calling one of the <code class="codeph">verify</code> methods:
                        </p><pre class="codeblock"><code>
final boolean verify(byte[] signature)

final boolean verify(byte[] signature, int offset, int length)
</code></pre><p>The argument must be a byte array containing the signature. This byte array would hold the signature bytes which were returned by a previous call to one of the <code class="codeph">sign</code> methods.
                        </p>
                        <p>The <code class="codeph">verify</code> method returns a <code class="codeph">boolean</code> indicating whether or not the encoded signature is the authentic signature of the data supplied to the <code class="codeph">update</code> method(s).
                        </p>
                        <p>A call to the <code class="codeph">verify</code> method resets the signature object to its state when it was initialized for verification via a call to <code class="codeph">initVerify</code>. That is, the object is reset and available to verify another signature from the identity whose public key was specified in the call to <code class="codeph">initVerify</code>.
                        </p>
                        <p>Alternatively, a new call can be made to <code class="codeph">initVerify</code> specifying a different public key (to initialize the <code class="codeph">Signature</code> object for verifying a signature from a different entity), or to <code class="codeph">initSign</code> (to initialize the <code class="codeph">Signature</code> object for generating a signature).
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566" name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566"></a><h4 id="JSSEC-GUID-94225C88-F2F1-44D1-A781-1DD9D5094566" class="sect4">The Cipher Class</h4>
                  <div>
                     <p>The <code class="codeph">Cipher</code> class provides the functionality of a cryptographic cipher used for encryption and decryption. Encryption is the process of taking data (called <span class="variable" translate="no">cleartext</span>) and a <span class="variable" translate="no">key</span>, and producing data (<span class="variable" translate="no">ciphertext</span>) meaningless to a third-party who does not know the key. Decryption is the inverse process: that of taking ciphertext and a key and producing cleartext.
                     </p>
                     <div class="figure" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-25964623-7C57-4290-9086-29968AA379B1">
                        <p class="titleinfigure">Figure 2-8 The Cipher Class</p><img src="img/cipher.gif" alt="Description of Figure 2-8 follows" title="Description of Figure 2-8 follows" longdesc="img_text/cipher.html"><br><a href="img_text/cipher.html">Description of "Figure 2-8 The Cipher Class"</a></div>
                     <!-- class="figure" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-88B6E4EB-FA21-4834-ACD6-957B97D559F6">Symmetric vs. Asymmetric Cryptography</p>
                        <p>There are two major types of encryption: <span class="variable" translate="no">symmetric</span> (also known as <span class="variable" translate="no">secret key</span>), and <span class="variable" translate="no">asymmetric</span> (or <span class="variable" translate="no">public key cryptography</span>). In symmetric cryptography, the same secret key to both encrypt and decrypt the data. Keeping the key private is critical to keeping the data confidential. On the other hand, asymmetric cryptography uses a public/private key pair to encrypt data. Data encrypted with one key is decrypted with the other. A user first generates a public/private key pair, and then publishes the public key in a trusted database that anyone can access. A user who wishes to communicate securely with that user encrypts the data using the retrieved public key. Only the holder of the private key will be able to decrypt. Keeping the private key confidential is critical to this scheme.
                        </p>
                        <p>Asymmetric algorithms (such as RSA) are generally much slower than symmetric ones. These algorithms are not designed for efficiently protecting large amounts of data. In practice, asymmetric algorithms are used to exchange smaller secret keys which are used to initialize symmetric algorithms.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-DDE676A1-290F-45FE-BE6C-CD84D2470469">Stream vs. Block Ciphers</p>
                        <p>There are two major types of ciphers: <span class="variable" translate="no">block</span> and <span class="variable" translate="no">stream</span>. Block ciphers process entire blocks at a time, usually many bytes in length. If there is not enough data to make a complete input block, the data must be <span class="variable" translate="no">padded</span>: that is, before encryption, dummy bytes must be added to make a multiple of the cipher's block size. These bytes are then stripped off during the decryption phase. The padding can either be done by the application, or by initializing a cipher to use a padding type such as "PKCS5PADDING". In contrast, stream ciphers process incoming data one small unit (typically a byte or even a bit) at a time. This allows for ciphers to process an arbitrary amount of data without padding.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MODESOFOPERATION-A64768C7">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MODESOFOPERATION-A6473469">Modes Of Operation</p>
                        <p>When encrypting using a simple block cipher, two identical blocks of plaintext will always produce an identical block of cipher text. Cryptanalysts trying to break the ciphertext will have an easier job if they note blocks of repeating text. A cipher mode of operation makes the ciphertext less predictable with output block alterations based on block position or the values of other ciphertext blocks. The first block will need an initial value, and this value is called the <span class="variable" translate="no">initialization vector (IV)</span>. Since the IV simply alters the data before any encryption, the IV should be random but does not necessarily need to be kept secret. There are a variety of modes, such as CBC (Cipher Block Chaining), CFB (Cipher Feedback Mode), and OFB (Output Feedback Mode). ECB (Electronic Codebook Mode) is a mode in which there is no influence from block position or other ciphertext blocks. Because ECB ciphertexts are the same if they use the same plaintext/key, this mode is not typically suitable for cryptographic applications and should not be used. 
                        </p>
                        <p>Some algorithms such as AES and RSA allow for keys of different lengths, but others are fixed, such as 3DES. Encryption using a longer key generally implies a stronger resistance to message recovery. As usual, there is a trade off between security and time, so choose the key length appropriately.</p>
                        <p>Most algorithms use binary keys. Most humans do not have the ability to remember long sequences of binary numbers, even when represented in hexadecimal. Character passwords are much easier to recall. Because character passwords are generally chosen from a small number of characters (for example, [a-zA-Z0-9]), protocols such as "Password-Based Encryption" (PBE) have been defined which take character passwords and generate strong binary keys. In order to make the task of getting from password to key very time-consuming for an attacker (via so-called "rainbow table attacks" or "precomputed dictionary attacks" where common dictionary word-&gt;value mappings are precomputed), most PBE implementations will mix in a random number, known as a <span class="variable" translate="no">salt</span>, to reduce the usefulness of precomputed tables.
                        </p>
                        <p>Newer cipher modes such as Authenticated Encryption with Associated Data (AEAD) (for example, <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf" target="_blank"> Galois/Counter Mode (GCM)</a>) encrypt data and authenticate the resulting message simultaneously. Additional Associated Data (AAD) can be used during the calculation of the resulting AEAD tag (MAC), but this AAD data is not output as ciphertext. (For example, some data might not need to be kept confidential, but should figure into the tag calculation to detect modifications.) The <span class="apiname">Cipher.updateAAD()</span> methods can be used to include AAD in the tag calculations.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-6B8936D6-E7FA-4C94-824A-D4B6D78847B5">Using an AES Cipher with GCM Mode</p>
                        <p>AES Cipher with GCM is an AEAD Cipher which has different usage patterns than the non-AEAD ciphers. Apart from the regular data, it also takes AAD which is optional for encryption/decryption but AAD must be supplied before data for encryption/decryption. In addition, in order to use GCM securely, callers should not re-use key and IV combinations for encryption. This means that the cipher object should be explicitly re-initialized with a different set of parameters every time for each encryption operation.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__SECRETKEYMYKEY...BYTEMYAAD...BYTEPL-7249BF00">
                        <p class="titleinexample">Example 2-2 Sample Code for Using an AES Cipher with GCM Mode</p><pre class="codeblock"><code>
	SecretKey myKey = ...
	byte[] myAAD = ...
	byte[] plainText = ...
        int myTLen = ... 
        byte[] myIv = ...

	GCMParameterSpec myParams = new GCMParameterSpec(myTLen, myIv);
	Cipher c = Cipher.getInstance("AES/GCM/NoPadding");
	c.init(Cipher.ENCRYPT_MODE, myKey, myParams);

	// AAD is optional, if present, it must be supplied before any update/doFinal calls.
	c.updateAAD(myAAD);  // if AAD is non-null
	byte[] cipherText = new byte[c.getOutputSize(plainText.length)];
	// conclusion of encryption operation
	int actualOutputLen = c.doFinal(plainText, 0, plainText.length, cipherText);
 
	// To decrypt, same AAD and GCM parameters must be supplied
	c.init(Cipher.DECRYPT_MODE, myKey, myParams);
	c.updateAAD(myAAD);
	byte[] recoveredText = c.doFinal(cipherText, 0, actualOutputLen);

	// MUST CHANGE IV VALUE if the same key were to be used again for encryption
     	byte[] newIv = ...;
	myParams = new GCMParameterSpec(myTLen, newIv);
</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-687A68F7-2023-44E6-B9B5-3CDBE3FC75F0">Creating a Cipher Object</p>
                        <p><code class="codeph">Cipher</code> objects are obtained by using one of the <code class="codeph">Cipher</code> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>. Here, the algorithm name is slightly different than with other engine classes, in that it specifies not just an algorithm name, but a "transformation". A transformation is a string that describes the operation (or set of operations) to be performed on the given input to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., <code class="codeph">AES</code>), and may be followed by a mode and padding scheme.
                        </p>
                        <p>A transformation is of the form:</p>
                        <ul style="list-style-type: disc;">
                           <li>"<span class="variable" translate="no">algorithm/mode/padding</span>" or
                           </li>
                           <li>"<span class="variable" translate="no">algorithm</span>"
                           </li>
                        </ul>
                        <p>For example, the following are valid transformations:</p><pre class="codeblock"><code>
    "<span class="variable" translate="no">AES/CBC/PKCS5Padding</span>"

    "<span class="variable" translate="no">AES</span>"
</code></pre><p>If just a transformation name is specified, the system will determine if there is an implementation of the requested transformation available in the environment, and if there is more than one, returns there is a preferred one.</p>
                        <p>If both a transformation name and a package provider are specified, the system will determine if there is an implementation of the requested transformation in the package requested, and throw an exception if there is not.</p>
                        <p>It is recommended to use a transformation that fully specifies the algorithm, mode, and padding. By not doing so, the provider will use a default. For example, the SunJCE and SunPKCS11 providers use ECB as the default mode, and PKCS5Padding as the default padding for many symmetric ciphers.</p>
                        <p>This means that in the case of the <code class="codeph">SunJCE</code> provider:
                        </p><pre class="codeblock"><code>    Cipher c1 = Cipher.getInstance("<span class="variable" translate="no">AES/ECB/PKCS5Padding</span>");
</code></pre><p> and </p><pre class="codeblock"><code>    Cipher c1 = Cipher.getInstance("<span class="variable" translate="no">AES</span>");
</code></pre><p>are equivalent statements.</p>
                        <div class="p">
                           <div class="infoboxnote" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-CAFC698A-6EE6-4448-98F8-9FE612C86FDA">
                              <p class="notep1">Note:</p>ECB mode is the easiest block cipher mode to use and is the default in the JDK and JRE. ECB works for single blocks of data when using different keys, but it absolutely should not be used for multiple data blocks. Other cipher modes such as Cipher Block Chaining (CBC) or Galois/Counter Mode (GCM) are more appropriate.
                           </div>
                        </div>
                        <p>Using modes such as CFB and OFB, block ciphers can encrypt data in units smaller than the cipher's actual block size. When requesting such a mode, you may optionally specify the number of bits to be processed at a time by appending this number to the mode name as shown in the "<span class="variable" translate="no">AES/CFB8/NoPadding</span>" and "<span class="variable" translate="no">AES/OFB32/PKCS5Padding</span>" transformations. If no such number is specified, a provider-specific default is used. (For example, the <code class="codeph">SunJCE</code> provider uses a default of 128 bits for AES.) Thus, block ciphers can be turned into byte-oriented stream ciphers by using an 8 bit mode such as CFB8 or OFB8.
                        </p>
                        <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> contains a list of standard names that can be used to specify the algorithm name, mode, and padding scheme components of a transformation.
                        </p>
                        <p>The objects returned by factory methods are uninitialized, and must be initialized before they become usable.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-C3874333-8A0C-4AAB-ADD6-6D7F885EF075">Initializing a Cipher Object</p>
                        <p>A Cipher object obtained via <code class="codeph">getInstance</code> must be initialized for one of four modes, which are defined as final integer constants in the <code class="codeph">Cipher</code> class. The modes can be referenced by their symbolic names, which are shown below along with a description of the purpose of each mode:
                        </p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-7CD0B30D-A692-401F-8B7F-1D8CAF2558AA">
                                 <!-- --></a>ENCRYPT_MODE
                           </dt>
                           <dd>Encryption of data.</dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-5E5D22CB-35E7-4472-BB46-C85985D27707">
                                 <!-- --></a>DECRYPT_MODE
                           </dt>
                           <dd>Decryption of data.</dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-53BB5B82-CDCF-4FA4-83F9-5F0B82EC715C">
                                 <!-- --></a>WRAP_MODE
                           </dt>
                           <dd>Wrapping a <code class="codeph">java.security.Key</code> into bytes so that the key can be securely transported.
                           </dd>
                           <dt class="dlterm"><a name="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-17922D9E-7BE5-4179-B8E0-0C06E4BAFD60">
                                 <!-- --></a>UNWRAP_MODE
                           </dt>
                           <dd>Unwrapping of a previously wrapped key into a <code class="codeph">java.security.Key</code> object.
                           </dd>
                        </dl>
                        <p>Each of the Cipher initialization methods takes an operational mode parameter (<code class="codeph">opmode</code>), and initializes the Cipher object for that mode. Other parameters include the key (<code class="codeph">key</code>) or certificate containing the key (<code class="codeph">certificate</code>), algorithm parameters (<code class="codeph">params</code>), and a source of randomness (<code class="codeph">random</code>).
                        </p>
                        <p>To initialize a Cipher object, call one of the following <code class="codeph">init</code> methods:
                        </p><pre class="codeblock"><code>
    public void init(int opmode, Key key);

    public void init(int opmode, Certificate certificate);

    public void init(int opmode, Key key, SecureRandom random);

    public void init(int opmode, Certificate certificate,
                     SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params, SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameters params);

    public void init(int opmode, Key key,
                     AlgorithmParameters params, SecureRandom random);
</code></pre><p>If a Cipher object that requires parameters (e.g., an initialization vector) is initialized for encryption, and no parameters are supplied to the <code class="codeph">init</code> method, the underlying cipher implementation is supposed to supply the required parameters itself, either by generating random parameters or by using a default, provider-specific set of parameters.
                        </p>
                        <p>However, if a Cipher object that requires parameters is initialized for decryption, and no parameters are supplied to the <code class="codeph">init</code> method, an <code class="codeph">InvalidKeyException</code> or <code class="codeph">InvalidAlgorithmParameterException</code> exception will be raised, depending on the <code class="codeph">init</code> method that has been used.
                        </p>
                        <p>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MANAGINGALGORITHMPARAMETERS-63E08852">Managing Algorithm Parameters</a>.
                        </p>
                        <p>The same parameters that were used for encryption must be used for decryption.</p>
                        <p>Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher, and initializing it. For example, if a Cipher is first initialized for decryption with a given key, and then initialized for encryption, it will lose any state acquired while in decryption mode.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-013270DA-8041-4A87-B328-92D84F2359F2">Encrypting and Decrypting Data</p>
                        <p>Data can be encrypted or decrypted in one step (<span class="variable" translate="no">single-part operation</span>) or in multiple steps (<span class="variable" translate="no">multiple-part operation</span>). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once.
                        </p>
                        <p>To encrypt or decrypt data in a single step, call one of the <code class="codeph">doFinal</code> methods:
                        </p><pre class="codeblock"><code>
    public byte[] doFinal(byte[] input);

    public byte[] doFinal(byte[] input, int inputOffset, int inputLen);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output);

    public int doFinal(byte[] input, int inputOffset,
                       int inputLen, byte[] output, int outputOffset)
</code></pre><p>To encrypt or decrypt data in multiple steps, call one of the <code class="codeph">update</code> methods:
                        </p><pre class="codeblock"><code>
    public byte[] update(byte[] input);

    public byte[] update(byte[] input, int inputOffset, int inputLen);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output, int outputOffset)
</code></pre><p>A multiple-part operation must be terminated by one of the above <code class="codeph">doFinal</code> methods (if there is still some input data left for the last step), or by one of the following <code class="codeph">doFinal</code> methods (if there is no input data left for the last step):
                        </p><pre class="codeblock"><code>
    public byte[] doFinal();

    public int doFinal(byte[] output, int outputOffset);
</code></pre><p>All the <code class="codeph">doFinal</code> methods take care of any necessary padding (or unpadding), if padding (or unpadding) has been requested as part of the specified transformation.
                        </p>
                        <p>A call to <code class="codeph">doFinal</code> resets the Cipher object to the state it was in when initialized via a call to <code class="codeph">init</code>. That is, the Cipher object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to <code class="codeph">init</code>) more data.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__WRAPPINGANDUNWRAPPINGKEYS-74578038">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-337B0BAB-8284-44B3-BDCA-CA856B004611">Wrapping and Unwrapping Keys</p>
                        <p>Wrapping a key enables secure transfer of the key from one place to another.</p>
                        <p>The <code class="codeph">wrap/unwrap</code> API makes it more convenient to write code since it works with key objects directly. These methods also enable the possibility of secure transfer of hardware-based keys.
                        </p>
                        <p>To <span class="bold">wrap</span> a Key, first initialize the Cipher object for WRAP_MODE, and then call the following:
                        </p><pre class="codeblock"><code>
    public final byte[] wrap(Key key);
</code></pre><p>If you are supplying the wrapped key bytes (the result of calling <code class="codeph">wrap</code>) to someone else who will unwrap them, be sure to also send additional information the recipient will need in order to do the <code class="codeph">unwrap</code>:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>The name of the key algorithm.</li>
                           <li>The type of the wrapped key (one of <code class="codeph">Cipher.SECRET_KEY</code>, <code class="codeph">Cipher.PRIVATE_KEY</code>, or <code class="codeph">Cipher.PUBLIC_KEY</code>).
                           </li>
                        </ul>
                        <p>The key algorithm name can be determined by calling the <code class="codeph">getAlgorithm</code> method from the Key interface:
                        </p><pre class="codeblock"><code>
    public String getAlgorithm();
</code></pre><p>To <span class="bold">unwrap</span> the bytes returned by a previous call to <code class="codeph">wrap</code>, first initialize a Cipher object for UNWRAP_MODE, then call the following:
                        </p><pre class="codeblock"><code>
    public final Key unwrap(byte[] wrappedKey,
                            String wrappedKeyAlgorithm,
                            int wrappedKeyType));
</code></pre><p>Here, <code class="codeph">wrappedKey</code> is the bytes returned from the previous call to wrap, <code class="codeph">wrappedKeyAlgorithm</code> is the algorithm associated with the wrapped key, and <code class="codeph">wrappedKeyType</code> is the type of the wrapped key. This must be one of <code class="codeph">Cipher.SECRET_KEY</code>, <code class="codeph">Cipher.PRIVATE_KEY</code>, or <code class="codeph">Cipher.PUBLIC_KEY</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__MANAGINGALGORITHMPARAMETERS-63E08852">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-776F1F5C-451D-4210-8557-C85AC5E64D21">Managing Algorithm Parameters</p>
                        <p>The parameters being used by the underlying <span class="apiname">Cipher</span> implementation, which were either explicitly passed to the <code class="codeph">init</code> method by the application or generated by the underlying implementation itself, can be retrieved from the <span class="apiname">Cipher</span> object by calling its <code class="codeph">getParameters</code> method, which returns the parameters as a <code class="codeph">java.security.AlgorithmParameters</code> object (or <code class="codeph">null</code> if no parameters are being used). If the parameter is an initialization vector (IV), it can also be retrieved by calling the <code class="codeph">getIV</code> method.
                        </p>
                        <p>In the following example, a <span class="apiname">Cipher</span> object implementing password-based encryption (PBE) is initialized with just a key and no parameters. However, the selected algorithm for password-based encryption requires two parameters - a <span class="variable" translate="no">salt</span> and an <span class="variable" translate="no">iteration count</span>. Those will be generated by the underlying algorithm implementation itself. The application can retrieve the generated parameters from the <span class="apiname">Cipher</span> object, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1314-724A0BB7">Example 2-3</a>.
                        </p>
                        <p>The same parameters that were used for encryption must be used for decryption. They can be instantiated from their encoding and used to initialize the corresponding Cipher object for decryption, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1315-724A0E25">Example 2-4</a>.
                        </p>
                        <p>If you did not specify any parameters when you initialized a Cipher object, and you are not sure whether or not the underlying implementation uses any parameters, you can find out by simply calling the <code class="codeph">getParameters</code> method of your Cipher object and checking the value returned. A return value of <code class="codeph">null</code> indicates that no parameters were used.
                        </p>
                        <p>The following cipher algorithms implemented by the <code class="codeph">SunJCE</code> provider use parameters:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>AES, DES-EDE, and Blowfish, when used in feedback (i.e., CBC, CFB, OFB, or PCBC) mode, use an initialization vector (IV). The <code class="codeph">javax.crypto.spec.IvParameterSpec</code> class can be used to initialize a <span class="apiname">Cipher</span> object with a given IV. In addition, CTR and GCM modes require an IV.
                           </li>
                           <li>PBE <span class="apiname">Cipher</span> algorithms use a set of parameters, comprising a salt and an iteration count. The <code class="codeph">javax.crypto.spec.PBEParameterSpec</code> class can be used to initialize a <span class="apiname">Cipher</span> object implementing a PBE algorithm (for example: PBEWithHmacSHA256AndAES_256) with a given salt and iteration count.
                           </li>
                        </ul>
                        <p>Note that you do not have to worry about storing or transferring any algorithm parameters for use by the decryption operation if you use the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" title="This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.">The SealedObject Class</a> class. This class attaches the parameters used for sealing (encryption) to the encrypted object contents, and uses the same parameters for unsealing (decryption).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1314-724A0BB7">
                        <p class="titleinexample">Example 2-3 Sample Code for Retrieving Parameters from the Cipher Object</p>
                        <p>The application can retrieve the generated parameters for encryption from the Cipher object as follows:</p><pre class="codeblock"><code>
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for encryption, without supplying
    // any parameters. Here, "myKey" is assumed to refer
    // to an already-generated key.
    c.init(Cipher.ENCRYPT_MODE, myKey);

    // encrypt some data and store away ciphertext
    // for later decryption
    byte[] cipherText = c.doFinal("This is just an example".getBytes());

    // retrieve parameters generated by underlying cipher
    // implementation
    AlgorithmParameters algParams = c.getParameters();

    // get parameter encoding and store it away
    byte[] encodedAlgParams = algParams.getEncoded();
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__EXAMPLE-1315-724A0E25">
                        <p class="titleinexample">Example 2-4 Sample Code for Initializing the Cipher Object for Decryption</p>
                        <p>The same parameters that were used for encryption must be used for decryption. They can be instantiated from their encoding and used to initialize the corresponding Cipher object for decryption as follows:</p><pre class="codeblock"><code>
    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get parameter object for password-based encryption
    AlgorithmParameters algParams;
    algParams = AlgorithmParameters.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize with parameter encoding from above
    algParams.init(encodedAlgParams);

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // initialize cipher for decryption, using one of the
    // init() methods that takes an AlgorithmParameters
    // object, and pass it the algParams object from above
    c.init(Cipher.DECRYPT_MODE, myKey, algParams);
</code></pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-94225C88-F2F1-44D1-A781-1DD9D5094566__GUID-3944EBCA-4728-4F30-9E6A-73528AE0E89B">Cipher Output Considerations</p>
                        <p>Some of the <code class="codeph">update</code> and <code class="codeph">doFinal</code> methods of Cipher allow the caller to specify the output buffer into which to encrypt or decrypt the data. In these cases, it is important to pass a buffer that is large enough to hold the result of the encryption or decryption operation.
                        </p>
                        <p>The following method in Cipher can be used to determine how big the output buffer should be:</p><pre class="codeblock"><code>
    public int getOutputSize(int inputLen)
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836" name="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836"></a><h4 id="JSSEC-GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836" class="sect4">Other Cipher-based Classes</h4>
                  <div>
                     <p>There are some helper classes which internally use <code class="codeph">Cipher</code>s to provide easy access to common cipher uses.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-F64C7E9B-12B4-4BFA-A4E7-B2877400C836__GUID-384607A1-E0B1-459E-9772-48459EF59CD1">Topics</p>
                        <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" title="The CipherInputStream and CipherOutputStream classes are Cipher stream classes.">The Cipher Stream Classes</a></p>
                        <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" title="This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.">The SealedObject Class</a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" name="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF"></a><h5 id="JSSEC-GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF" class="sect5">The Cipher Stream Classes</h5>
                     <div>
                        <p>The <code class="codeph">CipherInputStream</code> and <code class="codeph">CipherOutputStream</code> classes are Cipher stream classes.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__GUID-C4E63681-24B8-4A4C-9CCD-C20F8AD22918">The CipherInputStream Class</p>
                           <p>This class is a <code class="codeph">FilterInputStream</code> that encrypts or decrypts the data passing through it. It is composed of an <code class="codeph">InputStream</code>. <span class="apiname">CipherInputStream</span> represents a secure input stream into which a <span class="apiname">Cipher</span> object has been interposed. The <code class="codeph">read</code> methods of <span class="apiname">CipherInputStream</span> return data that are read from the underlying <span class="apiname">InputStream</span> but have additionally been processed by the embedded <span class="apiname">Cipher</span> object. The <span class="apiname">Cipher</span> object must be fully initialized before being used by a CipherInputStream.
                           </p>
                           <p>For example, if the embedded <span class="apiname">Cipher</span> has been initialized for decryption, the <span class="apiname">CipherInputStream</span> will attempt to decrypt the data it reads from the underlying <span class="apiname">InputStream</span> before returning them to the application.
                           </p>
                           <p>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes <code class="codeph">java.io.FilterInputStream</code> and <code class="codeph">java.io.InputStream</code>. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that the data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes. In particular, the <code class="codeph">skip(long)</code> method skips only data that has been processed by the <span class="apiname">Cipher</span>.
                           </p>
                           <p>It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to <span class="apiname">CipherInputStream</span>. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORENCRYPTINGINPUTSTREAMD-74CAEA35">Example 2-5</a> for its usage, suppose <code class="codeph">cipher1</code> has been initialized for encryption. The program reads and encrypts the content from the file <code class="codeph">/tmp/a.txt</code> and then stores the result (the encrypted bytes) in <code class="codeph">/tmp/b.txt</code>.
                           </p>
                           <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__THEFOLLOWINGEXAMPLEDEMONSTRATESHOWT-74CAEEB6">Example 2-6</a> demonstrates how to easily connect several instances of <code class="codeph">CipherInputStream</code> and <code class="codeph">FileInputStream</code>. In this example, assume that <code class="codeph">cipher1</code> and <code class="codeph">cipher2</code> have been initialized for encryption and decryption (with corresponding keys), respectively. The program copies the content from file <code class="codeph">/tmp/a.txt</code> to <code class="codeph">/tmp/b.txt</code>, except that the content is first encrypted and then decrypted back when it is read from <code class="codeph">/tmp/a.txt</code>. Of course since this program simply encrypts text and decrypts it back right away, it's actually not very useful except as a simple way of illustrating chaining of <code class="codeph">CipherInputStreams</code>.
                           </p>
                           <p>Note that the read methods of the <code class="codeph">CipherInputStream</code> will block until data is returned from the underlying cipher. If a block cipher is used, a full block of cipher text will have to be obtained from the underlying <code class="codeph">InputStream</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORENCRYPTINGINPUTSTREAMD-74CAEA35">
                           <p class="titleinexample">Example 2-5 Sample Code for Using CipherInputStream and FileInputStream</p>
                           <p>The code below demonstrates how to use a <code class="codeph">CipherInputStream</code> containing that cipher and a <code class="codeph">FileInputStream</code> in order to encrypt input stream data:
                           </p><pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
CipherInputStream cis = new CipherInputStream(fis, cipher1);
FileOutputStream fos = new FileOutputStream("/tmp/b.txt")) {
    byte[] b = new byte[8];
    int i = cis.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis.read(b);
    }
}</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__THEFOLLOWINGEXAMPLEDEMONSTRATESHOWT-74CAEEB6">
                           <p class="titleinexample">Example 2-6 Sample Code for Connecting CipherInputStream and FileInputStream</p>
                           <p>The following example demonstrates how to easily connect several instances of <span class="apiname">CipherInputStream</span> and <span class="apiname">FileInputStream</span>. In this example, assume that <code class="codeph">cipher1</code> and <code class="codeph">cipher2</code> have been initialized for encryption and decryption (with corresponding keys), respectively:
                           </p><pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        CipherInputStream cis1 = new CipherInputStream(fis, cipher1);
        CipherInputStream cis2 = new CipherInputStream(cis1, cipher2);
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt")) {
    byte[] b = new byte[8];
    int i = cis2.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis2.read(b);
    }
}  </code></pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__GUID-80F9ECCB-D464-422B-B365-CCE8763A7F76">The CipherOutputStream Class</p>
                           <p>This class is a <code class="codeph">FilterOutputStream</code> that encrypts or decrypts the data passing through it. It is composed of an <code class="codeph">OutputStream</code>, or one of its subclasses, and a <code class="codeph">Cipher</code>. <span class="apiname">CipherOutputStream</span> represents a secure output stream into which a <span class="apiname">Cipher</span> object has been interposed. The <code class="codeph">write</code> methods of <span class="apiname">CipherOutputStream</span> first process the data with the embedded <span class="apiname">Cipher</span> object before writing them out to the underlying <span class="apiname">OutputStream</span>. The <span class="apiname">Cipher</span> object must be fully initialized before being used by a <span class="apiname">CipherOutputStream</span>.
                           </p>
                           <p>For example, if the embedded <span class="apiname">Cipher</span> has been initialized for encryption, the <code class="codeph">CipherOutputStream</code> will encrypt its data, before writing them out to the underlying output stream.
                           </p>
                           <p>This class adheres strictly to the semantics, especially the failure semantics, of its ancestor classes <code class="codeph">java.io.OutputStream</code> and <code class="codeph">java.io.FilterOutputStream</code>. This class has exactly those methods specified in its ancestor classes, and overrides them all, so that all data are additionally processed by the embedded cipher. Moreover, this class catches all exceptions that are not thrown by its ancestor classes.
                           </p>
                           <p>It is crucial for a programmer using this class not to use methods that are not defined or overridden in this class (such as a new method or constructor that is later added to one of the super classes), because the design and implementation of those methods are unlikely to have considered security impact with regard to <code class="codeph">CipherOutputStream</code>.
                           </p>
                           <p>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">Example 2-7</a> , for its usage, suppose <code class="codeph">cipher1</code> has been initialized for encryption. The program reads the content from the file <code class="codeph">/tmp/a.txt</code>, then encrypts and stores the result (the encrypted bytes) in <code class="codeph">/tmp/b.txt</code>.
                           </p>
                           <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">Example 2-7</a> demonstrates how to easily connect several instances of <code class="codeph">CipherOutputStream</code> and <code class="codeph">FileOutputStream</code>. In this example, assume that <code class="codeph">cipher1</code> and <code class="codeph">cipher2</code> have been initialized for decryption and encryption (with corresponding keys), respectively. The program copies the content from file <code class="codeph">/tmp/a.txt</code> to <code class="codeph">/tmp/b.txt</code>, except that the content is first encrypted and then decrypted back before it is written to <code class="codeph">/tmp/b.txt</code>.
                           </p>
                           <p>One thing to keep in mind when using <span class="variable" translate="no">block</span> cipher algorithms is that a full block of plaintext data must be given to the <code class="codeph">CipherOutputStream</code> before the data will be encrypted and sent to the underlying output stream.
                           </p>
                           <p>There is one other important difference between the <code class="codeph">flush</code> and <code class="codeph">close</code> methods of this class, which becomes even more relevant if the encapsulated <span class="apiname">Cipher</span> object implements a block cipher algorithm with padding turned on:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li><code class="codeph">flush</code> flushes the underlying <span class="apiname">OutputStream</span> by forcing any buffered output bytes that have already been processed by the encapsulated Cipher object to be written out. Any bytes buffered by the encapsulated <span class="apiname">Cipher</span> object and waiting to be processed by it will <span class="bold">not</span> be written out.
                              </li>
                              <li><code class="codeph">close</code> closes the underlying <span class="apiname">OutputStream</span> and releases any system resources associated with it. It invokes the <code class="codeph">doFinal</code> method of the encapsulated <span class="apiname">Cipher</span> object, causing any bytes buffered by it to be processed and written out to the underlying stream by calling its <code class="codeph">flush</code> method.
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORUSINGCIPHEROUTPUTSTREA-74D596DC">
                           <p class="titleinexample">Example 2-7 Sample Code for Using CipherOutputStream and FileOutputStream</p>The code demonstrates how to use a <code class="codeph">CipherOutputStream</code> containing that cipher and a <code class="codeph">FileOutputStream</code> in order to encrypt data to be written to an output stream:<pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt");
        CipherOutputStream cos = new CipherOutputStream(fos, cipher1)) {
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos.write(b, 0, i);
        i = fis.read(b);
    }
    cos.flush();
}</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-C0283BC0-8B88-480D-82B1-7B01EAC3D8DF__SAMPLECODEFORCONNECTINGCIPHEROUTPUT-74D599F3">
                           <p class="titleinexample">Example 2-8 Sample Code for Connecting CipherOutputStream and FileOutputStream</p>The code demonstrates how to easily connect several instances of <span class="apiname">CipherOutputStream</span> and <span class="apiname">FileOutputStream</span>. In this example, assume that <code class="codeph">cipher1</code> and <code class="codeph">cipher2</code> have been initialized for decryption and encryption (with corresponding keys), respectively:<pre class="codeblock"><code>try (FileInputStream fis = new FileInputStream("/tmp/a.txt");
        FileOutputStream fos = new FileOutputStream("/tmp/b.txt");
        CipherOutputStream cos1 = new CipherOutputStream(fos, cipher1);
        CipherOutputStream cos2 = new CipherOutputStream(cos1, cipher2)) {
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos2.write(b, 0, i);
        i = fis.read(b);
    }
    cos2.flush();
}</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" name="GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8"></a><h5 id="JSSEC-GUID-33BA4D9F-5253-4A53-81C1-38569E8FFCA8" class="sect5">The SealedObject Class</h5>
                     <div>
                        <p>This class enables a programmer to create an object and protect its confidentiality with a cryptographic algorithm.</p>
                        <div class="section">
                           <p>Given any object that implements the <code class="codeph">java.io.Serializable</code> interface, one can create a <code class="codeph">SealedObject</code> that encapsulates the original object, in serialized format (i.e., a "deep copy"), and seals (encrypts) its serialized contents, using a cryptographic algorithm such as AES, to protect its confidentiality. The encrypted content can later be decrypted (with the corresponding algorithm using the correct decryption key) and de-serialized, yielding the original object.
                           </p>
                           <p>A typical usage is illustrated in the following code segment: In order to seal an object, you create a <code class="codeph">SealedObject</code> from the object to be sealed and a fully initialized <code class="codeph">Cipher</code> object that will encrypt the serialized object contents. In this example, the String "This is a secret" is sealed using the AES algorithm. Note that any algorithm parameters that may be used in the sealing operation are stored inside of <code class="codeph">SealedObject</code>:
                           </p><pre class="codeblock"><code>
    // create Cipher object
    // NOTE: sKey is assumed to refer to an already-generated
    // secret AES key.
    Cipher c = Cipher.getInstance("AES");
    c.init(Cipher.ENCRYPT_MODE, sKey);

    // do the sealing
    SealedObject so = new SealedObject("This is a secret", c);
</code></pre><p>The original object that was sealed can be recovered in two different ways:</p>
                           <ul style="list-style-type: disc;">
                              <li>by using a <code class="codeph">Cipher</code> object that has been initialized with the exact same algorithm, key, padding scheme, etc., that were used to seal the object: <pre class="codeblock"><code>
    c.init(Cipher.DECRYPT_MODE, sKey);
    try {
        String s = (String)so.getObject(c);
    } catch (Exception e) {
        // do something
    };
</code></pre> <p>This approach has the advantage that the party who unseals the sealed object does not require knowledge of the decryption key. For example, after one party has initialized the cipher object with the required decryption key, it could hand over the cipher object to another party who then unseals the sealed object.</p> 
                              </li>
                              <li>by using the appropriate decryption key (since AES is a symmetric encryption algorithm, we use the same key for sealing and unsealing): <pre class="codeblock"><code>
    try {
        String s = (String)so.getObject(sKey);
    } catch (Exception e) {
        // do something
    };
</code></pre> <p>In this approach, the <code class="codeph">getObject</code> method creates a cipher object for the appropriate decryption algorithm and initializes it with the given decryption key and the algorithm parameters (if any) that were stored in the sealed object. This approach has the advantage that the party who unseals the object does not need to keep track of the parameters (e.g., the IV) that were used to seal the object.
                                 </p> 
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" name="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A"></a><h4 id="JSSEC-GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A" class="sect4">The Mac Class</h4>
                  <div>
                     <p>Similar to a <code class="codeph">MessageDigest</code>, a Message Authentication Code (MAC) provides a way to check the integrity of information transmitted over or stored in an unreliable medium, but includes a secret key in the calculation.
                     </p>
                     <div class="section">
                        <p>Only someone with the proper key will be able to verify the received message. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties.</p>
                        <div class="figure" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-53D5C5FD-6E47-42AC-AEA2-C8BDCFB8B566">
                           <p class="titleinfigure">Figure 2-9 The Mac Class</p><img src="img/mac-class.png" alt="Description of Figure 2-9 follows" title="Description of Figure 2-9 follows" longdesc="img_text/mac-class.html"><br><a href="img_text/mac-class.html">Description of "Figure 2-9 The Mac Class"</a></div>
                        <!-- class="figure" -->
                        <p>A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC. HMAC can be used with any cryptographic hash function, e.g., SHA-256, in combination with a secret shared key.</p>
                        <p>The <code class="codeph">Mac</code> class provides the functionality of a Message Authentication Code (MAC). See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" title="The following is a sample program that demonstrates how to generate a secret-key object for HMAC-SHA256, and initialize a HMAC-SHA256 object with it.">HMAC-SHA256 Example</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-8DBAA334-4A7A-4A83-BC28-CEF9C6EDEB5F">Creating a Mac Object</p><code class="codeph">Mac</code> objects are obtained by using one of the <code class="codeph">Mac</code> <span class="apiname"> getInstance() </span>static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-7B481699-5CC9-444F-BD4A-3BD0C290FE7E">Initializing a Mac Object</p>
                        <p>A Mac object is always initialized with a (secret) key and may optionally be initialized with a set of parameters, depending on the underlying MAC algorithm.</p>
                        <p>To initialize a Mac object, call one of its <span class="apiname">init</span> methods:
                        </p><pre class="codeblock"><code>
    public void <span class="apiname">init(Key key)</span>;

    public void <span class="apiname">init(Key key, AlgorithmParameterSpec params)</span>;
</code></pre><p>You can initialize your Mac object with any (secret-)key object that implements the <code class="codeph">javax.crypto.SecretKey</code> interface. This could be an object returned by <span class="apiname">javax.crypto.KeyGenerator.generateKey()</span>, or one that is the result of a key agreement protocol, as returned by <span class="apiname">javax.crypto.KeyAgreement.generateSecret()</span>, or an instance of <code class="codeph">javax.crypto.spec.SecretKeySpec</code>.
                        </p>
                        <p>With some MAC algorithms, the (secret-)key algorithm associated with the (secret-)key object used to initialize the Mac object does not matter (this is the case with the HMAC-MD5 and HMAC-SHA1 implementations of the <code class="codeph">SunJCE</code> provider). With others, however, the (secret-)key algorithm does matter, and an <code class="codeph">InvalidKeyException</code> is thrown if a (secret-)key object with an inappropriate (secret-)key algorithm is used.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8E014689-EBBB-4DE1-B6E0-24CE59AD8B9A__GUID-F30CAFF4-D4EB-4EFF-A27A-05D28513FF1D">Computing a MAC</p>
                        <p>A MAC can be computed in one step (<span class="variable" translate="no">single-part operation</span>) or in multiple steps (<span class="variable" translate="no">multiple-part operation</span>). A multiple-part operation is useful if you do not know in advance how long the data is going to be, or if the data is too long to be stored in memory all at once.
                        </p>
                        <p>To compute the MAC of some data in a single step, call the following <span class="apiname">doFinal</span> method:
                        </p><pre class="codeblock"><code>
    public byte[] <span class="apiname">doFinal(byte[] input)</span>;
</code></pre><p>To compute the MAC of some data in multiple steps, call one of the <code class="codeph">update</code> methods:
                        </p><pre class="codeblock"><code>
    public void <span class="apiname">update(byte input)</span>;

    public void <span class="apiname">update(byte[] input)</span>;

    public void <span class="apiname">update(byte[] input, int inputOffset, int inputLen)</span>;
</code></pre><p>A multiple-part operation must be terminated by the above <code class="codeph">doFinal</code> method (if there is still some input data left for the last step), or by one of the following <code class="codeph">doFinal</code> methods (if there is no input data left for the last step):
                        </p><pre class="codeblock"><code>
    public byte[] <span class="apiname">doFinal()</span>;

    public void <span class="apiname">doFinal(byte[] output, int outOffset)</span>;
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC"></a><h4 id="JSSEC-GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" class="sect4">Key Interfaces</h4>
                  <div>
                     <p>The <code class="codeph">java.security.Key</code> interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.
                     </p>
                     <p>To this point, we have focused the high-level uses of the JCA without getting lost in the details of what keys are and how they are generated/represented. It is now time to turn our attention to keys.</p>
                     <p>An <span class="variable" translate="no">opaque</span> key representation is one in which you have no direct access to the key material that constitutes a key. In other words: "opaque" gives you limited access to the key--just the three methods defined by the <code class="codeph">Key</code> interface (see below): <code class="codeph">getAlgorithm</code>, <code class="codeph">getFormat</code>, and <code class="codeph">getEncoded</code>.
                     </p>
                     <p>This is in contrast to a <span class="variable" translate="no">transparent</span> representation, in which you can access each key material value individually, through one of the <code class="codeph">get</code> methods defined in the corresponding <span class="apiname">KeySpec</span> interface (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.">The KeySpec Interface</a>).
                     </p>
                     <p>All opaque keys have three characteristics:</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-5B43C71A-CA72-4787-B3AE-F8FA11DF7866">
                              <!-- --></a><span class="bold">An Algorithm</span></dt>
                        <dd>The key algorithm for that key. The key algorithm is usually an encryption or asymmetric operation algorithm (such as <code class="codeph">AES</code>, <code class="codeph">DSA</code> or <code class="codeph">RSA</code>), which will work with those algorithms and with related algorithms (such as <code class="codeph">SHA256withRSA</code>). The name of the algorithm of a key is obtained using this method: <pre class="codeblock"><code>
String getAlgorithm()
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-5D585F10-ECBA-4A07-AC3D-5C3ABA919A6A">
                              <!-- --></a><span class="bold">An Encoded Form</span></dt>
                        <dd>The external encoded form for the key used when a standard representation of the key is needed outside the Java Virtual Machine, as when transmitting the key to some other party. The key is encoded according to a standard format (such as X.509 or PKCS8), and is returned using the method: <pre class="codeblock"><code>
byte[] getEncoded()
</code></pre></dd>
                        <dt class="dlterm"><a name="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-EC833FCD-5697-4E38-9933-6E336A126496">
                              <!-- --></a><span class="bold">A Format</span></dt>
                        <dd>The name of the format of the encoded key. It is returned by the method: <pre class="codeblock"><code>
String getFormat()
</code></pre></dd>
                     </dl>
                     <p>Keys are generally obtained through key generators such as the <span class="apiname">KeyGenerator</span> class and the <span class="apiname">KeyPairGenerator</span> class, certificates, key specifications (see the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.">The KeySpec Interface</a>) using a <span class="apiname">KeyFactory</span>, or a <span class="apiname">Keystore</span> implementation accessing a keystore database used to manage keys. It is possible to parse encoded keys, in an algorithm-dependent manner, using a <span class="apiname">KeyFactory</span>.
                     </p>
                     <p>It is also possible to parse certificates, using a <span class="apiname">CertificateFactory</span>.
                     </p>
                     <p>Here is a list of interfaces which extend the <code class="codeph">Key</code> interface in the <code class="codeph">java.security.interfaces</code> and <code class="codeph">javax.crypto.interfaces</code> packages:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/SecretKey.html" target="_blank"><span class="apiname">SecretKey</span></a><ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/PBEKey.html" target="_blank"><span class="apiname">PBEKey</span></a></li>
                           </ul>
                        </li>
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/PrivateKey.html" target="_blank"><span class="apiname">PrivateKey</span></a><ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPrivateKey.html" target="_blank"><span class="apiname">DHPrivateKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPrivateKey.html" target="_blank"><span class="apiname">DSAPrivateKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/ECPrivateKey.html" target="_blank"><span class="apiname">ECPrivateKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAMultiPrimePrivateCrtKey.html" target="_blank"><span class="apiname">RSAMultiPrimePrivateCrtKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateCrtKey.html" target="_blank"><span class="apiname">RSAPrivateCrtKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPrivateKey.html" target="_blank"><span class="apiname">RSAPrivateKey</span></a></li>
                           </ul>
                        </li>
                        <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/PublicKey.html" target="_blank"><span class="apiname">PublicKey</span></a><ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/interfaces/DHPublicKey.html" target="_blank"><span class="apiname">DHPublicKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/DSAPublicKey.html" target="_blank"><span class="apiname">DSAPublicKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/ECPublicKey.html" target="_blank"><span class="apiname">ECPublicKey</span></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/interfaces/RSAPublicKey.html" target="_blank"><span class="apiname">RSAPublicKey</span></a></li>
                           </ul>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC__GUID-8D6CDB98-51C1-4211-8A4A-30BDD16FA7FD">The PublicKey and PrivateKey Interfaces</p>
                        <p>The <code class="codeph">PublicKey</code> and <code class="codeph">PrivateKey</code> interfaces (which both extend the <code class="codeph">Key</code> interface) are methodless interfaces, used for type-safety and type-identification.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B" name="GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B"></a><h4 id="JSSEC-GUID-9A793484-AE6A-4513-A603-BFEAE887DD8B" class="sect4">The KeyPair Class</h4>
                  <div>
                     <p>The <code class="codeph">KeyPair</code> class is a simple holder for a key pair (a public key and a private key).
                     </p>
                     <div class="section">
                        <p> It has two public methods, one for returning the private key, and the other for returning the public key:</p><pre class="codeblock"><code>
PrivateKey getPrivate()
PublicKey getPublic()
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" name="GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0"></a><h4 id="JSSEC-GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" class="sect4">Key Specification Interfaces and Classes</h4>
                  <div>
                     <p><code class="codeph">Key</code> objects and key specifications (<code class="codeph">KeySpec</code>s) are two different representations of key data. <code class="codeph">Cipher</code>s use <code class="codeph">Key</code> objects to initialize their encryption algorithms, but keys may need to be converted into a more portable format for transmission or storage.
                     </p>
                     <div class="section">
                        <p>A <span class="variable" translate="no">transparent</span> representation of keys means that you can access each key material value individually, through one of the <code class="codeph">get</code> methods defined in the corresponding specification class. For example, <code class="codeph">DSAPrivateKeySpec</code> defines <code class="codeph">getX</code>, <code class="codeph">getP</code>, <code class="codeph">getQ</code>, and <code class="codeph">getG</code> methods, to access the private key <code class="codeph">x</code>, and the DSA algorithm parameters used to calculate the key: the prime <code class="codeph">p</code>, the sub-prime <code class="codeph">q</code>, and the base <code class="codeph">g</code>. If the key is stored on a hardware device, its specification may contain information that helps identify the key on the device.
                        </p>
                        <p>This representation is contrasted with an <span class="variable" translate="no">opaque</span> representation, as defined by the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.">Key Interfaces</a> interface, in which you have no direct access to the key material fields. In other words, an "opaque" representation gives you limited access to the key--just the three methods defined by the <code class="codeph">Key</code> interface: <code class="codeph">getAlgorithm</code>, <code class="codeph">getFormat</code>, and <code class="codeph">getEncoded</code>.
                        </p>
                        <p>A key may be specified in an algorithm-specific way, or in an algorithm-independent encoding format (such as ASN.1). For example, a DSA private key may be specified by its components <code class="codeph">x</code>, <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code> (see <a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><code class="codeph">DSAPrivateKeySpec</code></a>), or it may be specified using its DER encoding (see <a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><code class="codeph">PKCS8EncodedKeySpec</code></a>).
                        </p>
                        <p>The <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A">The KeyFactory Class</a> and <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5E8F4099-779F-4484-9A95-F1CEA167601A">The SecretKeyFactory Class</a> classes can be used to convert between opaque and transparent key representations (that is, between <code class="codeph">Key</code>s and <code class="codeph">KeySpec</code>s, assuming that the operation is possible. (For example, private keys on smart cards might not be able leave the card. Such <code class="codeph">Key</code>s are not convertible.)
                        </p>
                        <p>In the following sections, we discuss the key specification interfaces and classes in the <code class="codeph">java.security.spec</code> package.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" name="GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF"></a><h5 id="JSSEC-GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" class="sect5">The KeySpec Interface</h5>
                     <div>
                        <p>This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E" name="GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E"></a><h5 id="JSSEC-GUID-5DE3B786-8E76-4679-B66B-6B3EC098075E" class="sect5">The KeySpec Subinterfaces</h5>
                     <div>
                        <p>Like the <code class="codeph">Key</code> interface, there are a similar set of <code class="codeph">KeySpec</code> interfaces.
                        </p>
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/SecretKeySpec.html" target="_blank"><code class="codeph">SecretKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/EncodedKeySpec.html" target="_blank"><code class="codeph">EncodedKeySpec</code></a> 
                                 <ul style="list-style-type: disc;">
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PKCS8EncodedKeySpec.html" target="_blank"><code class="codeph">PKCS8EncodedKeySpec</code></a></li>
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/X509EncodedKeySpec.html" target="_blank"><code class="codeph">X509EncodedKeySpec</code></a></li>
                                 </ul> 
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DESKeySpec.html" target="_blank"><code class="codeph">DESKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DESedeKeySpec.html" target="_blank"><code class="codeph">DESedeKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/PBEKeySpec.html" target="_blank"><code class="codeph">PBEKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHPrivateKeySpec.html" target="_blank"><code class="codeph">DHPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPrivateKeySpec.html" target="_blank"><code class="codeph">DSAPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECPrivateKeySpec.html" target="_blank"><code class="codeph">ECPrivateKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPrivateKeySpec.html" target="_blank"><code class="codeph">RSAPrivateKeySpec</code></a> 
                                 <ul style="list-style-type: disc;">
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.html" target="_blank"><code class="codeph">RSAMultiPrimePrivateCrtKeySpec</code></a></li>
                                    <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPrivateCrtKeySpec.html" target="_blank"><code class="codeph">RSAPrivateCrtKeySpec</code></a></li>
                                 </ul> 
                              </li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHPublicKeySpec.html" target="_blank"><code class="codeph">DHPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAPublicKeySpec.html" target="_blank"><code class="codeph">DSAPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECPublicKeySpec.html" target="_blank"><code class="codeph">ECPublicKeySpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAPublicKeySpec.html" target="_blank"><code class="codeph">RSAPublicKeySpec</code></a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4" name="GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4"></a><h5 id="JSSEC-GUID-8EAA36B1-5CD8-40FC-944E-099C71E716B4" class="sect5">The EncodedKeySpec Class</h5>
                     <div>
                        <div class="section">
                           <p>This abstract class (which implements the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.">The KeySpec Interface</a> interface) represents a public or private key in encoded format. Its <span class="apiname">getEncoded</span> method returns the encoded key:
                           </p><pre class="codeblock"><code>
abstract byte[] getEncoded();
</code></pre><p> and its <span class="apiname">getFormat</span>  method returns the name of the encoding format: 
                           </p><pre class="codeblock"><code>
abstract String getFormat();
</code></pre><p>See the next sections for the concrete implementations <code class="codeph">PKCS8EncodedKeySpec</code> and <code class="codeph">X509EncodedKeySpec</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div class="sect5"><a id="GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E" name="GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E"></a><h6 id="JSSEC-GUID-7E6373D0-273A-4C5C-B3EB-14ABBE6B759E" class="sect6">The PKCS8EncodedKeySpec Class</h6>
                        <div>
                           <p>This class, which is a subclass of <code class="codeph">EncodedKeySpec</code>, represents the DER encoding of a private key, according to the format specified in the PKCS8 standard.
                           </p>
                           <div class="section">
                              <p> Its <span class="apiname">getEncoded</span> method returns the key bytes, encoded according to the PKCS8 standard. Its <span class="apiname">getFormat</span> method returns the string "PKCS#8".
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" name="GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC"></a><h6 id="JSSEC-GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" class="sect6">The X509EncodedKeySpec Class</h6>
                        <div>
                           <p>This class, which is a subclass of <code class="codeph">EncodedKeySpec</code>, represents the DER encoding of a public key, according to the format specified in the X.509 standard.
                           </p>
                           <div class="section">Its <code class="codeph">getEncoded</code> method returns the key bytes, encoded according to the X.509 standard. Its <code class="codeph">getFormat</code> method returns the string "X.509".
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578" name="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578"></a><h4 id="JSSEC-GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578" class="sect4">Generators and Factories</h4>
                  <div>
                     <p>Newcomers to Java and the JCA APIs in particular sometimes do not grasp the distinction between generators and factories.</p>
                     <div class="figure" id="GUID-D4A4B706-6C4F-436D-B5ED-A29C98260578__GUID-39757065-9091-43DE-8CEC-C1E00A75DF36">
                        <p class="titleinfigure">Figure 2-10 Generators and Factories</p><img src="img/genrator-factory.gif" alt="Description of Figure 2-10 follows" title="Description of Figure 2-10 follows" longdesc="img_text/genrator-factory.html"><br><a href="img_text/genrator-factory.html">Description of "Figure 2-10 Generators and Factories"</a></div>
                     <!-- class="figure" -->
                     <p>Generators are used to <span class="bold">generate brand new objects</span>. Generators can be initialized in either an algorithm-dependent or algorithm-independent way. For example, to create a Diffie-Hellman (DH) keypair, an application could specify the necessary P and G values, or the generator could simply be initialized with the appropriate key length, and the generator will select appropriate P and G values. In both cases, the generator will produce brand new keys based on the parameters.
                     </p>
                     <p>On the other hand, factories are used to <span class="bold">convert data from one existing object type to another</span>. For example, an application might have available the components of a DH private key and can package them as a <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CFF50556-89F9-4AB0-9EDE-D5763B900BFF" title="This interface contains no methods or constants. Its only purpose is to group and provide type safety for all key specifications. All key specifications must implement this interface.">The KeySpec Interface</a>, but needs to convert them into a <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.">PrivateKey</a> object that can be used by a <code class="codeph">KeyAgreement</code> object, or vice-versa. Or they might have the byte array of a certificate, but need to use a <code class="codeph">CertificateFactory</code> to convert it into a <code class="codeph">X509Certificate</code> object. Applications use factory objects to do the conversion.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A" name="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A"></a><h5 id="JSSEC-GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A" class="sect5">The KeyFactory Class</h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">KeyFactory</code> class is an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a> designed to perform conversions between opaque cryptographic <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.">Key Interfaces</a> and <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" title="Key objects and key specifications (KeySpecs) are two different representations of key data. Ciphers use Key objects to initialize their encryption algorithms, but keys may need to be converted into a more portable format for transmission or storage.">Key Specification Interfaces and Classes</a> (transparent representations of the underlying key material).
                           </p>
                           <div class="figure" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-A3F628B1-EA36-4F80-9FB3-18565C99D33D">
                              <p class="titleinfigure">Figure 2-11 KeyFactory Class</p><img src="img/keyfactory.gif" alt="Description of Figure 2-11 follows" title="Description of Figure 2-11 follows" longdesc="img_text/keyfactory.html"><br><a href="img_text/keyfactory.html">Description of "Figure 2-11 KeyFactory Class"</a></div>
                           <!-- class="figure" -->
                           <p>Key factories are bi-directional. They allow you to build an opaque key object from a given key specification (key material), or to retrieve the underlying key material of a key object in a suitable format.</p>
                           <p>Multiple compatible key specifications can exist for the same key. For example, a DSA public key may be specified by its components <code class="codeph">y</code>, <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code> (see <code class="codeph">java.security.spec.DSAPublicKeySpec</code>), or it may be specified using its DER encoding according to the X.509 standard (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F41053CD-D1F3-4BAE-B97D-72C53A9892DC" title="This class, which is a subclass of EncodedKeySpec, represents the DER encoding of a public key, according to the format specified in the X.509 standard.">The X509EncodedKeySpec Class</a>).
                           </p>
                           <p>A key factory can be used to translate between compatible key specifications. Key parsing can be achieved through translation between compatible key specifications, e.g., when you translate from <code class="codeph">X509EncodedKeySpec</code> to <code class="codeph">DSAPublicKeySpec</code>, you basically parse the encoded key into its components. For an example, see the end of the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="Sample code that is used to generate and verify signatures using key specifications and KeyFactory.">Generating/Verifying Signatures Using Key Specifications and KeyFactory</a> section.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-6E7550BC-EB9D-4DEA-B0DD-4702CB60B8FB">Creating a KeyFactory Object</p>
                           <p><code class="codeph">KeyFactory</code> objects are obtained by using one of the <code class="codeph">KeyFactory</code>getInstance() static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-44809676-3275-4B3B-A0DF-D22B66E32E8F">Converting Between a Key Specification and a Key Object</p>
                           <p>If you have a key specification for a public key, you can obtain an opaque <code class="codeph">PublicKey</code> object from the specification by using the <code class="codeph">generatePublic</code> method:
                           </p><pre class="codeblock"><code>
PublicKey generatePublic(KeySpec keySpec)
</code></pre><p>Similarly, if you have a key specification for a private key, you can obtain an opaque <code class="codeph">PrivateKey</code> object from the specification by using the <code class="codeph">generatePrivate</code> method:
                           </p><pre class="codeblock"><code>
PrivateKey generatePrivate(KeySpec keySpec)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A__GUID-80B6E726-0D4C-4527-BE7C-DBEC57850569">Converting Between a Key Object and a Key Specification</p>
                           <p>If you have a <code class="codeph">Key</code> object, you can get a corresponding key specification object by calling the <code class="codeph">getKeySpec</code> method:
                           </p><pre class="codeblock"><code>
KeySpec getKeySpec(Key key, Class keySpec)
</code></pre><p><code class="codeph">keySpec</code> identifies the specification class in which the key material should be returned. It could, for example, be <code class="codeph">DSAPublicKeySpec.class</code> , to indicate that the key material should be returned in an instance of the <code class="codeph">DSAPublicKeySpec</code>  class. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="Sample code that is used to generate and verify signatures using key specifications and KeyFactory.">Generating/Verifying Signatures Using Key Specifications and KeyFactory</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A" name="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A"></a><h5 id="JSSEC-GUID-5E8F4099-779F-4484-9A95-F1CEA167601A" class="sect5">The SecretKeyFactory Class</h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">SecretKeyFactory</code> class represents a factory for secret keys. Unlike the <span class="apiname">KeyFactory</span> class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-09C8DF67-7C78-453C-95B4-E7E7DEAD446A">The KeyFactory Class</a>), a <code class="codeph">javax.crypto.SecretKeyFactory</code> object operates only on secret (symmetric) keys, whereas a <code class="codeph">java.security.KeyFactory</code> object processes the public and private key components of a key pair.
                           </p>
                           <div class="figure" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-B147D33F-7429-4584-82BD-71838EA98DE1">
                              <p class="titleinfigure">Figure 2-12 SecretKeyFactory Class</p><img src="img/secretkeyfactory.png" alt="Description of Figure 2-12 follows" title="Description of Figure 2-12 follows" longdesc="img_text/secretkeyfactory.html"><br><a href="img_text/secretkeyfactory.html">Description of "Figure 2-12 SecretKeyFactory Class"</a></div>
                           <!-- class="figure" -->
                           <p>Key factories are used to convert <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BD91C9BC-CFC6-4125-B46F-772C638FA5DC" title="The java.security.Key interface is the top-level interface for all opaque keys. It defines the functionality shared by all opaque key objects.">Key Interfaces</a> (opaque cryptographic keys of type <code class="codeph">java.security.Key</code>) into <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-D1EA35A1-710A-4EBC-8ABB-10875411EBB0" title="Key objects and key specifications (KeySpecs) are two different representations of key data. Ciphers use Key objects to initialize their encryption algorithms, but keys may need to be converted into a more portable format for transmission or storage.">Key Specification Interfaces and Classes</a> (transparent representations of the underlying key material in a suitable format), and vice versa.
                           </p>
                           <p>Objects of type <code class="codeph">java.security.Key</code>, of which <code class="codeph">java.security.PublicKey</code>, <code class="codeph">java.security.PrivateKey</code>, and <code class="codeph">javax.crypto.SecretKey</code> are subclasses, are opaque key objects, because you cannot tell how they are implemented. The underlying implementation is provider-dependent, and may be software or hardware based. Key factories allow providers to supply their own implementations of cryptographic keys.
                           </p>
                           <p>For example, if you have a key specification for a Diffie-Hellman public key, consisting of the public value <code class="codeph">y</code>, the prime modulus <code class="codeph">p</code>, and the base <code class="codeph">g</code>, and you feed the same specification to Diffie-Hellman key factories from different providers, the resulting <code class="codeph">PublicKey</code> objects will most likely have different underlying implementations.
                           </p>
                           <p>A provider should document the key specifications supported by its secret key factory. For example, the <code class="codeph">SecretKeyFactory</code> for DES keys supplied by the <code class="codeph">SunJCE</code> provider supports <code class="codeph">DESKeySpec</code> as a transparent representation of DES keys, the <code class="codeph">SecretKeyFactory</code> for DES-EDE keys supports <code class="codeph">DESedeKeySpec</code> as a transparent representation of DES-EDE keys, and the <code class="codeph">SecretKeyFactory</code> for PBE supports <code class="codeph">PBEKeySpec</code> as a transparent representation of the underlying password.
                           </p>
                           <p>The following is an example of how to use a <code class="codeph">SecretKeyFactory</code> to convert secret key data into a <code class="codeph">SecretKey</code> object, which can be used for a subsequent <code class="codeph">Cipher</code> operation:
                           </p><pre class="codeblock"><code>    // Note the following bytes are not realistic secret key data
    // bytes but are simply supplied as an illustration of using data
    // bytes (key material) you already have to build a DESedeKeySpec.

    byte[] desEdeKeyData = getKeyData();
    DESedeKeySpec desEdeKeySpec = new DESedeKeySpec(desEdeKeyData);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");
    SecretKey secretKey = keyFactory.generateSecret(desEdeKeySpec);
</code></pre><p>In this case, the underlying implementation of <code class="codeph">SecretKey</code> is based on the provider of <code class="codeph">KeyFactory</code>.
                           </p>
                           <p>An alternative, provider-independent way of creating a functionally equivalent <code class="codeph">SecretKey</code> object from the same key material is to use the <code class="codeph">javax.crypto.spec.SecretKeySpec</code> class, which implements the <code class="codeph">javax.crypto.SecretKey</code> interface:
                           </p><pre class="codeblock"><code>    byte[] aesKeyData = getKeyData();
    SecretKeySpec secretKey = new SecretKeySpec(aesKeyData, "AES");</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-38991B45-AE09-4FF3-AD97-D94141BB6B6D">Creating a SecretKeyFactory Object</p>
                           <p><span class="apiname">SecretKeyFactory</span> objects are obtained by using one of the <span class="apiname">SecretKeyFactory</span> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-984E30C8-DB95-46BF-AC9C-3300225E5369">Converting Between a Key Specification and a Secret Key Object</p>
                           <p>If you have a key specification for a secret key, you can obtain an opaque <span class="apiname">SecretKey</span> object from the specification by using the <span class="apiname">generateSecret</span> method:
                           </p><pre class="pre codeblock"><code>SecretKey generateSecret(KeySpec keySpec)</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-5E8F4099-779F-4484-9A95-F1CEA167601A__GUID-AB93CE9F-2B82-451F-ABDF-FB57D6BBE3D1">Converting Between a Secret Key Object and a Key Specification</p>
                           <p>If you have a <span class="apiname">SecretKey</span> object, you can get a corresponding key specification object by calling the <span class="apiname">getKeySpec</span> method:
                           </p><pre class="pre codeblock"><code>KeySpec getKeySpec(Key key, Class keySpec)</code></pre><p><span class="apiname">keySpec</span> identifies the specification class in which the key material should be returned. It could, for example, be<code class="codeph"> DESKeySpec.class</code>, to indicate that the key material should be returned in an instance of the <span class="apiname">DESKeySpec</span> class.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD" name="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD"></a><h5 id="JSSEC-GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD" class="sect5">The KeyPairGenerator Class</h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">KeyPairGenerator</code> class is an engine class (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>) used to generate pairs of public and private keys.
                           </p>
                           <div class="figure" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-3DB89ACB-BF5C-4155-B2BF-E3ED4BEACE8D">
                              <p class="titleinfigure">Figure 2-13 KeyPairGenerator Class</p><img src="img/keypairgenerator.gif" alt="Description of Figure 2-13 follows" title="Description of Figure 2-13 follows" longdesc="img_text/keypairgenerator.html"><br><a href="img_text/keypairgenerator.html">Description of "Figure 2-13 KeyPairGenerator Class"</a></div>
                           <!-- class="figure" -->
                           <p>There are two ways to generate a key pair: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object.</p>
                           <p>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " dsa" (digital signature algorithm), and use this keypair in future examples. we will generate keys with a 2048-bit modulus. don't care which provider supplies the algorithm implementation.">Generating a Pair of Keys</a> for examples of calls to the methods documented below.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-1BBCE846-5B0A-49B6-8EF0-4A61D7933250">Creating a KeyPairGenerator</p>
                           <p>All key pair generation starts with a <code class="codeph">KeyPairGenerator</code>. <code class="codeph">KeyPairGenerator</code> objects are obtained by using one of the <code class="codeph">KeyPairGenerator</code> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-671069E3-BACA-4C28-9F68-4B4E0F9C8B1E">Initializing a KeyPairGenerator</p>
                           <p>A key pair generator for a particular algorithm creates a public/private key pair that can be used with this algorithm. It also associates algorithm-specific parameters with each of the generated keys.</p>
                           <p>A key pair generator needs to be initialized before it can generate keys. In most cases, algorithm-independent initialization is sufficient. But in other cases, algorithm-specific initialization can be used.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-FC22CAF1-9AD8-4679-A908-D4E426C90F94">Algorithm-Independent Initialization</p>
                           <p>All key pair generators share the concepts of a keysize and a source of randomness. The keysize is interpreted differently for different algorithms. For example, in the case of the DSA algorithm, the keysize corresponds to the length of the modulus. (See <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> for information about the keysizes for specific algorithms.)
                           </p>
                           <p>An <code class="codeph">initialize</code> method takes two universally shared types of arguments:
                           </p><pre class="codeblock"><code>void initialize(int keysize, SecureRandom random)
</code></pre><p> Another <code class="codeph">initialize</code> method takes only a <code class="codeph">keysize</code>  argument; it uses a system-provided source of randomness:
                           </p><pre class="codeblock"><code>void initialize(int keysize)
</code></pre><p>Since no other parameters are specified when you call the above algorithm-independent <code class="codeph">initialize</code> methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys.
                           </p>
                           <p>If the algorithm is a "DSA" algorithm, and the modulus size (keysize) is 512, 768, 1024, 2048, or 3072, then the <code class="codeph">SUN</code> provider uses a set of precomputed values for the <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code> parameters. If the modulus size is not one of the above values, the <code class="codeph">SUN</code> provider creates a new set of parameters. Other providers might have precomputed parameter sets for more than just the three modulus sizes mentioned above. Still others might not have a list of precomputed parameters at all and instead always create new parameter sets.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-0A3EC297-448C-4202-A12E-4D236E540D05">Algorithm-Specific Initialization</p>
                           <p>For situations where a set of algorithm-specific parameters already exists (such as "community parameters" in DSA), there are two <code class="codeph">initialize</code> methods that have an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-190C91B4-991D-416E-A932-C0E37B33A86D" title="AlgorithmParameterSpec is an interface to a transparent specification of cryptographic parameters. This interface contains no methods or constants. Its only purpose is to group (and provide type safety for) all parameter specifications. All parameter specifications must implement this interface.">The AlgorithmParameterSpec Interface</a> argument. One also has a <code class="codeph">SecureRandom</code> argument, while the source of randomness is system-provided for the other:
                           </p><pre class="codeblock"><code>void initialize(AlgorithmParameterSpec params,
                SecureRandom random)

void initialize(AlgorithmParameterSpec params)
</code></pre><p>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " dsa" (digital signature algorithm), and use this keypair in future examples. we will generate keys with a 2048-bit modulus. don't care which provider supplies the algorithm implementation.">Generating a Pair of Keys</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7EA29AC2-28B5-405D-BD2F-7055EC9E1EDD__GUID-385C2D11-785F-437E-BEA9-A3FAE8259954">Generating a Key Pair</p>
                           <p>The procedure for generating a key pair is always the same, regardless of initialization (and of the algorithm). You always call the following method from <code class="codeph">KeyPairGenerator</code>:
                           </p><pre class="codeblock"><code>KeyPair generateKeyPair()
</code></pre><p>Multiple calls to <code class="codeph">generateKeyPair</code> will yield different key pairs.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" name="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1"></a><h5 id="JSSEC-GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1" class="sect5">The KeyGenerator Class</h5>
                     <div>
                        <p>A key generator is used to generate secret keys for symmetric algorithms.</p>
                        <div class="section">
                           <p></p>
                           <div class="figure" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-E128C2F7-1771-4798-AD6F-023E341AE627">
                              <p class="titleinfigure">Figure 2-14 The KeyGenerator Class</p><img src="img/keygenerator.gif" alt="Description of Figure 2-14 follows" title="Description of Figure 2-14 follows" longdesc="img_text/keygenerator.html"><br><a href="img_text/keygenerator.html">Description of "Figure 2-14 The KeyGenerator Class"</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-740D1207-E50A-4EF4-963D-A2120557B06F">Creating a <code class="codeph">KeyGenerator</code></p>
                           <p> <code class="codeph">KeyGenerator</code> objects are obtained by using one of the <code class="codeph">KeyGenerator</code> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-BAF56E68-3D3B-49C4-BB0F-C04C3263C59F">Initializing a KeyGenerator Object</p>
                           <p>A key generator for a particular symmetric-key algorithm creates a symmetric key that can be used with that algorithm. It also associates algorithm-specific parameters (if any) with the generated key.</p>
                           <p>There are two ways to generate a key: in an algorithm-independent manner, and in an algorithm-specific manner. The only difference between the two is the initialization of the object:</p>
                           <ul style="list-style-type: disc;">
                              <li><span class="bold">Algorithm-Independent Initialization</span> 
                                 <p>All key generators share the concepts of a <span class="variable" translate="no">keysize</span> and a <span class="variable" translate="no">source of randomness</span>. There is an <code class="codeph">init</code> method that takes these two universally shared types of arguments. There is also one that takes just a <code class="codeph">keysize</code> argument, and uses a system-provided source of randomness, and one that takes just a source of randomness:
                                 </p> <pre class="codeblock"><code>

    public void init(SecureRandom random);

    public void init(int keysize);

    public void init(int keysize, SecureRandom random);
</code></pre> <p>Since no other parameters are specified when you call the above algorithm-independent <code class="codeph">init</code> methods, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with the generated key.
                                 </p> 
                              </li>
                              <li><span class="bold">Algorithm-Specific Initialization</span> 
                                 <p>For situations where a set of algorithm-specific parameters already exists, there are two <code class="codeph">init</code> methods that have an <code class="codeph">AlgorithmParameterSpec</code> argument. One also has a <code class="codeph">SecureRandom</code> argument, while the source of randomness is system-provided for the other:
                                 </p> <pre class="codeblock"><code>
    public void init(AlgorithmParameterSpec params);

    public void init(AlgorithmParameterSpec params, SecureRandom random);
</code></pre></li>
                           </ul>
                           <p>In case the client does not explicitly initialize the KeyGenerator (via a call to an <code class="codeph">init</code> method), each provider must supply (and document) a default initialization.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-F178CBC3-D25F-48B6-9F2F-ABB586E713A1__GUID-86C7A73B-30DE-4CBA-A744-815938F78741">Creating a Key</p>
                           <p>The following method generates a secret key:</p><pre class="codeblock"><code>
    public SecretKey generateKey();
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" name="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31"></a><h4 id="JSSEC-GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31" class="sect4">The KeyAgreement Class</h4>
                  <div>
                     <p>Key agreement is a protocol by which 2 or more parties can establish the same cryptographic keys, without having to exchange any secret information.</p>
                     <div class="section">
                        <div class="figure" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-98958A82-0755-47FC-9ABD-EF5482B7C7E7">
                           <p class="titleinfigure">Figure 2-15 The KeyAgreement Class</p><img src="img/keyagreement.gif" alt="Description of Figure 2-15 follows" title="Description of Figure 2-15 follows" longdesc="img_text/keyagreement.html"><br><a href="img_text/keyagreement.html">Description of "Figure 2-15 The KeyAgreement Class"</a></div>
                        <!-- class="figure" -->
                        <p>Each party initializes their key agreement object with their private key, and then enters the public keys for each party that will participate in the communication. In most cases, there are just two parties, but algorithms such as Diffie-Hellman allow for multiple parties (3 or more) to participate. When all the public keys have been entered, each <code class="codeph">KeyAgreement</code> object will generate (agree upon) the same key.
                        </p>
                        <p>The KeyAgreement class provides the functionality of a key agreement protocol. The keys involved in establishing a shared secret are created by one of the key generators (<code class="codeph">KeyPairGenerator</code> or <code class="codeph">KeyGenerator</code>), a <code class="codeph">KeyFactory</code>, or as a result from an intermediate phase of the key agreement protocol.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-7A60031C-0F65-435C-BABE-CC97DC6E9B1D">Creating a KeyAgreement Object</p>
                        <p>Each party involved in the key agreement has to create a KeyAgreement object. <code class="codeph">KeyAgreement</code> objects are obtained by using one of the <code class="codeph">KeyAgreement</code> <span class="apiname">getInstance()</span> static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-80712056-629B-48EB-87D7-65AE14AEC64F">Initializing a KeyAgreement Object</p>
                        <p>You initialize a KeyAgreement object with your private information. In the case of Diffie-Hellman, you initialize it with your Diffie-Hellman private key. Additional initialization information may contain a source of randomness and/or a set of algorithm parameters. Note that if the requested key agreement algorithm requires the specification of algorithm parameters, and only a key, but no parameters are provided to initialize the KeyAgreement object, the key must contain the required algorithm parameters. (For example, the Diffie-Hellman algorithm uses a prime modulus <code class="codeph">p</code> and a base generator <code class="codeph">g</code> as its parameters.)
                        </p>
                        <p>To initialize a KeyAgreement object, call one of its <code class="codeph">init</code> methods:
                        </p><pre class="codeblock"><code>
    public void init(Key key);

    public void init(Key key, SecureRandom random);

    public void init(Key key, AlgorithmParameterSpec params);

    public void init(Key key, AlgorithmParameterSpec params,
                     SecureRandom random);
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-8E5226BB-CAE3-4CCF-A501-139EB5F1F258">Executing a KeyAgreement Phase</p>
                        <p>Every key agreement protocol consists of a number of phases that need to be executed by each party involved in the key agreement.</p>
                        <p>To execute the next phase in the key agreement, call the <span class="apiname">doPhase</span> method:
                        </p><pre class="codeblock"><code>
    public Key doPhase(Key key, boolean lastPhase);
</code></pre><p>The <code class="codeph">key</code> parameter contains the key to be processed by that phase. In most cases, this is the public key of one of the other parties involved in the key agreement, or an intermediate key that was generated by a previous phase. <code class="codeph">doPhase</code> may return an intermediate key that you may have to send to the other parties of this key agreement, so they can process it in a subsequent phase.
                        </p>
                        <p>The <code class="codeph">lastPhase</code> parameter specifies whether or not the phase to be executed is the last one in the key agreement: A value of <code class="codeph">FALSE</code> indicates that this is not the last phase of the key agreement (there are more phases to follow), and a value of <code class="codeph">TRUE</code> indicates that this is the last phase of the key agreement and the key agreement is completed, i.e., <code class="codeph">generateSecret</code> can be called next.
                        </p>
                        <p>In the example of <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" title="The program runs the Diffie-Hellman key agreement protocol between 2 parties.">Diffie-Hellman Key Exchange between 2 Parties</a> , you call <code class="codeph">doPhase</code> once, with <code class="codeph">lastPhase</code> set to <code class="codeph">TRUE</code>. In the example of Diffie-Hellman between three parties, you call <code class="codeph">doPhase</code> twice: the first time with <code class="codeph">lastPhase</code> set to <code class="codeph">FALSE</code>, the 2nd time with <code class="codeph">lastPhase</code> set to <code class="codeph">TRUE</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C4D8A5D0-ECA7-4686-A8F0-636115500C31__GUID-A5713E1A-EA50-4F0B-8059-1B355A8D559E">Generating the Shared Secret</p>
                        <p>After each party has executed all the required key agreement phases, it can compute the shared secret by calling one of the <span class="apiname">generateSecret</span> methods:
                        </p><pre class="codeblock"><code>
    public byte[] generateSecret();

    public int generateSecret(byte[] sharedSecret, int offset);

    public SecretKey generateSecret(String algorithm);
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" name="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA"></a><h4 id="JSSEC-GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA" class="sect4">Key Management</h4>
                  <div>
                     <p>A database called a "keystore" can be used to manage a repository of keys and certificates. (A <span class="variable" translate="no">certificate</span> is a digitally signed statement from one entity, saying that the public key of some other entity has a particular value.)
                     </p>
                     <div class="section" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__KEYSTORELOCATION-86EBB624">
                        <p class="subhead3" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-B8BFF73B-B9BA-4A1E-B465-6C186EA054DD">Keystore Location</p>
                        <p>The user keystore is by default stored in a file named <code class="codeph">.keystore</code> in the user's home directory, as determined by the <code class="codeph">user.home</code> system property whose default value depends on the operating system:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>Solaris, Linux, and MacOS: <code class="codeph">/home/<span class="variable" translate="no">username</span>/</code></li>
                           <li>Windows: <code class="codeph">C:\Users\<span class="variable" translate="no">username</span>\</code></li>
                        </ul>
                        <p>Of course, keystore files can be located as desired. In some environments, it may make sense for multiple keystores to exist. For example, one keystore might hold a user's private keys, and another might hold certificates used to establish trust relationships.</p>
                        <p>In addition to the user's keystore, the JDK also maintains a system-wide keystore which is used to store trusted certificates from a variety of Certificate Authorities (CA's). These CA certificates can be used to help make trust decisions. For example, in SSL/TLS/DTLS when the <code class="codeph">SunJSSE</code> provider is presented with certificates from a remote peer, the default trustmanager will consult one of the following files to determine if the connection is to be trusted:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>Solaris, Linux, and MacOS: <code class="codeph"><span class="variable" translate="no">&lt;java-home&gt;</span>/lib/security/cacerts</code></li>
                           <li>Windows: <code class="codeph"><span class="variable" translate="no">&lt;java-home&gt;</span>\lib\security\cacerts</code></li>
                        </ul>
                        <p>Instead of using the system-wide <code class="codeph">cacerts</code> keystore, applications can set up and use their own keystores, or even use the user keystore described above.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__KEYSTOREIMPLEMENTATION-86EBBA97">
                        <p class="subhead3" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-F8DDBE94-9E8B-410D-B772-3F2188373D58">Keystore Implementation</p>
                        <p>The <code class="codeph">KeyStore</code> class supplies well-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular <span class="variable" translate="no">type</span> of keystore.
                        </p>
                        <p>Currently, there are two command-line tools that make use of <code class="codeph">KeyStore</code>: <span class="bold"><code class="codeph">keytool</code></span> and <span class="bold"><code class="codeph">jarsigner</code></span>, and also a GUI-based tool named <span class="bold"><code class="codeph">policytool</code></span>. It is also used by the <code class="codeph">Policy</code> reference implementation when it processes policy files specifying the permissions (allowed accesses to system resources) to be granted to code from various sources. Since <code class="codeph">KeyStore</code> is publicly available, JDK users can write additional security applications that use it.
                        </p>
                        <p>Applications can choose different <span class="variable" translate="no">types</span> of keystore implementations from different providers, using the <code class="codeph">getInstance</code> factory method in the <code class="codeph">KeyStore</code> class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible. 
                        </p>
                        <p>The default keystore implementation is "pkcs12". This is a cross-platform keystore based on the RSA PKCS12 Personal Information Exchange Syntax Standard. This standard is primarily meant for  storing or transporting a user's private keys, certificates, and miscellaneous secrets. Arbitrary attributes can be  associated with individual entries in a PKCS12 keystore.</p><pre class="codeblock"><code>    keystore.type=pkcs12
</code></pre><p>To have tools and other applications use a different default keystore implementation, you can change that line to specify a different type.</p>
                        <p>Some applications, such as <code class="codeph">keytool</code>, also let you override the default keystore type (via the <code class="codeph">-storetype</code> command-line parameter).
                        </p>
                        <div class="infoboxnote" id="GUID-AB51DEFD-5238-4F96-967F-082F6D34FBEA__GUID-AFAA8199-86D1-45F8-B282-F34CAEFAA44A">
                           <p class="notep1">Note:</p>Keystore type designations are case-insensitive. For example, "jks" would be considered the same as "JKS".
                        </div>
                        <p>PKCS12 is the default and recommened keystore type. However, there are three other types of keystores that come with the JDK implementation.</p>
                        <ol>
                           <li><span class="bold">"jceks"</span> is an alternate proprietary keystore format to "jks" that uses Password-Based Encryption with Triple-DES. 
                              <p>The "jceks" implementation can parse and convert a "jks" keystore file to the "jceks" format. You may upgrade your keystore of type "jks" to a keystore of type "jceks" by changing the password of a private-key entry in your keystore and specifying <code class="codeph">"-storetype jceks"</code> as the keystore type. To apply the cryptographically strong(er) key protection supplied to a private key named "signkey" in your default keystore, use the following command, which will prompt you for the old and new key passwords:
                              </p> <pre class="codeblock"><code>    keytool -keypass -alias signkey -storetype jceks
</code></pre>See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/security&amp;id=JSWOR-GUID-5990A2E4-78E3-47B7-AE75-6D1826259549" target="_blank">keytool</a> in <span><cite>Java Platform, Standard Edition Tools Reference</cite></span> .
                           </li>
                           <li><span class="bold">"jks"</span> is another option. It implements the keystore as  a file, utilizing a proprietary keystore type (format). It protects each private key with its own individual password, and also protects  the integrity of the entire keystore with a (possibly different) password.
                           </li>
                           <li><span class="bold">"dks"</span> is a domain keystore. It is a collection of keystores presented as a single logical keystore. The keystores that comprise a given domain are specified by configuration data whose syntax is described in <a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a>.
                           </li>
                        </ol>
                        <p>Keystore implementations are provider-based. If you want to write your own KeyStore implementations, see <a href="howtoimplaprovider.html#GUID-C485394F-08C9-4D35-A245-1B82CDDBC031" title="This document describes what you need to do in order to integrate your provider into Java SE so that algorithms and other services can be found when Java Security API clients request them.">How to Implement a Provider in the Java Cryptography Architecture</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-09050137-31F1-468A-A552-B051A4E35876" name="GUID-09050137-31F1-468A-A552-B051A4E35876"></a><h5 id="JSSEC-GUID-09050137-31F1-468A-A552-B051A4E35876" class="sect5">The KeyStore Class</h5>
                     <div>
                        <p>The <code class="codeph">KeyStore</code> class supplies well-defined interfaces to access and modify the information in a keystore.
                        </p>
                        <div class="section">
                           <p>The <code class="codeph">KeyStore</code> class is an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>. 
                           </p>
                           <div class="figure" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-E500AFDF-303F-4F6A-8F30-B78446C385BC">
                              <p class="titleinfigure">Figure 2-16 KeyStore Class</p><img src="img/keystore.png" alt="Description of Figure 2-16 follows" title="Description of Figure 2-16 follows" longdesc="img_text/keystore.html"><br><a href="img_text/keystore.html">Description of "Figure 2-16 KeyStore Class"</a></div>
                           <!-- class="figure" -->
                           <p>This class represents an in-memory collection of keys and certificates. <code class="codeph">KeyStore</code> manages two types of entries:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="bold">Key Entry</span>: This type of keystore entry holds very sensitive cryptographic key information, which must be protected from unauthorized access. Typically, a key stored in this type of entry is a secret key, or a private key accompanied by the certificate chain authenticating the corresponding public key.
                                 </p>
                                 <p>Private keys and certificate chains are used by a given entity for self-authentication using digital signatures. For example, software distribution organizations digitally sign JAR files as part of releasing and/or licensing software.</p>
                              </li>
                              <li>
                                 <p><span class="bold">Trusted Certificate Entry</span>: This type of entry contains a single public key certificate belonging to another party. It is called a <span class="variable" translate="no">trusted certificate</span> because the keystore owner trusts that the public key in the certificate indeed belongs to the identity identified by the <span class="variable" translate="no">subject</span> (owner) of the certificate.
                                 </p> 
                                 <p>This type of entry can be used to authenticate other parties.</p>
                              </li>
                           </ul>
                           <p>Each entry in a keystore is identified by an "alias" string. In the case of private keys and their associated certificate chains, these strings distinguish among the different ways in which the entity may authenticate itself. For example, the entity may authenticate itself using different certificate authorities, or using different public key algorithms.</p>
                           <p>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This convention allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</p>
                           <p>The main <code class="codeph">KeyStore</code> methods are described below.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-10CBBC1C-9B28-406F-868B-905F60CBBB7B">Creating a KeyStore Object</p>
                           <p>KeyStore objects are obtained by using one of the KeyStore getInstance() method. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-0D63C81B-715D-42F3-8E1D-035E950EA8A8">Loading a Particular Keystore into Memory</p>
                           <p>Before a <code class="codeph">KeyStore</code> object can be used, the actual keystore data must be loaded into memory via the <span class="apiname">load</span> method:
                           </p><pre class="codeblock"><code>
final void load(InputStream stream, char[] password)
</code></pre><p>The optional password is used to check the integrity of the keystore data. If no password is supplied, no integrity check is performed.</p>
                           <p>To create an empty keystore, you pass <code class="codeph">null</code> as the <code class="codeph">InputStream</code> argument to the <span class="apiname">load</span> method.
                           </p>
                           <p>A DKS keystore is loaded by passing a <a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a> to the alternative load method:
                           </p><pre class="codeblock"><code>
final void load(KeyStore.LoadStoreParameter param)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-C472C461-E71E-43C3-B647-D0E1C1AC6423">Getting a List of the Keystore Aliases</p>
                           <p>All keystore entries are accessed via unique <span class="variable" translate="no">aliases</span>. The <code class="codeph">aliases</code> method returns an enumeration of the alias names in the keystore:
                           </p><pre class="codeblock"><code>
final Enumeration aliases()
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-C394000F-70E5-47EF-927B-405E6D15E2A9">Determining Keystore Entry Types</p>
                           <p>As stated in the KeyStore class, there are two different types of entries in a keystore. The following methods determine whether the entry specified by the given alias is a key/certificate or a trusted certificate entry, respectively:</p><pre class="codeblock"><code>
final boolean isKeyEntry(String alias)
final boolean isCertificateEntry(String alias)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-1DEA7EF6-2C1D-4B27-B6D2-254BD157FFE0">Adding/Setting/Deleting Keystore Entries</p>
                           <p>The <span class="apiname">setCertificateEntry</span> method assigns a certificate to a specified alias:
                           </p><pre class="codeblock"><code>
final void setCertificateEntry(String alias, Certificate cert)
</code></pre><p>If <code class="codeph">alias</code> doesn't exist, a trusted certificate entry with that alias is created. If <code class="codeph">alias</code> exists and identifies a trusted certificate entry, the certificate associated with it is replaced by <code class="codeph">cert</code>.
                           </p>
                           <p>The <span class="apiname">setKeyEntry</span> methods add (if <code class="codeph">alias</code> doesn't yet exist) or set key entries:
                           </p><pre class="codeblock"><code>
final void setKeyEntry(String alias,
                       Key key,
                       char[] password,
                       Certificate[] chain)

final void setKeyEntry(String alias,
                       byte[] key,
                       Certificate[] chain)
</code></pre><p>In the method with <code class="codeph">key</code> as a byte array, it is the bytes for a key in protected format. For example, in the keystore implementation supplied by the <code class="codeph">SUN</code> provider, the <code class="codeph">key</code> byte array is expected to contain a protected private key, encoded as an <code class="codeph">EncryptedPrivateKeyInfo</code> as defined in the PKCS8 standard. In the other method, the <code class="codeph">password</code> is the password used to protect the key.
                           </p>
                           <p>The <span class="apiname">deleteEntry</span> method deletes an entry:
                           </p><pre class="codeblock"><code>
final void deleteEntry(String alias)
</code></pre><p>PKCS #12 keystores support entries containing arbitrary attributes. Use the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/PKCS12Attribute.html" target="_blank"><code class="codeph">PKCS12Attribute</code></a> class to create the attributes. When creating the new keystore entry use a constructor method that accepts attributes. Finally, use the following method to add the entry to the keystore:
                           </p><pre class="codeblock"><code>
final void setEntry(String alias, Entry entry, 
                    ProtectionParameter protParam)
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-478CD418-9E37-4225-BE10-5465BD82F295">Getting Information from the Keystore</p>
                           <p>The <code class="codeph">getKey</code> method returns the key associated with the given alias. The key is recovered using the given password:
                           </p><pre class="codeblock"><code>
final Key getKey(String alias, char[] password)
</code></pre><p>The following methods return the certificate, or certificate chain, respectively, associated with the given alias:</p><pre class="codeblock"><code>
final Certificate getCertificate(String alias)
final Certificate[] getCertificateChain(String alias)
</code></pre><p>You can determine the name (<code class="codeph">alias</code>) of the first entry whose certificate matches a given certificate via the following:
                           </p><pre class="codeblock"><code>
final String getCertificateAlias(Certificate cert)
</code></pre><p>PKCS #12 keystores support entries containing arbitrary attributes. Use the following method to retrieve an entry that may contain attributes:</p><pre class="codeblock"><code>
final Entry getEntry(String alias, ProtectionParameter protParam)
</code></pre><p>and then use the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Entry.html#getAttributes--" target="_blank"><code class="codeph">KeyStore.Entry.getAttributes</code></a> method to extract such attributes and use the methods of the <a href="https://docs.oracle.com/javase/10/docs/api/java/security/KeyStore.Entry.Attribute.html" target="_blank"><code class="codeph">KeyStore.Entry.Attribute</code></a> interface to examine them.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-09050137-31F1-468A-A552-B051A4E35876__GUID-361C2D21-1088-4E98-AC59-C32B9572294A">Saving the KeyStore</p>
                           <p>The in-memory keystore can be saved via the <code class="codeph">store</code> method:
                           </p><pre class="codeblock"><code>
final void store(OutputStream stream, char[] password)
</code></pre><p>The password is used to calculate an integrity checksum of the keystore data, which is appended to the keystore data.</p>
                           <p>A DKS keystore is stored by passing a <a href="https://docs.oracle.com/javase/10/docs/api/java/security/DomainLoadStoreParameter.html" target="_blank"><code class="codeph">DomainLoadStoreParameter</code></a> to the alternative store method:
                           </p><pre class="codeblock"><code>
final void store(KeyStore.LoadStoreParameter param)
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" name="GUID-33407B4E-D819-4294-94AB-C6FABF96A93D"></a><h4 id="JSSEC-GUID-33407B4E-D819-4294-94AB-C6FABF96A93D" class="sect4">Algorithm Parameters Classes</h4>
                  <div>
                     <p>Like <code class="codeph">Key</code>s and <code class="codeph">Keyspec</code>s, an algorithm's initialization parameters are represented by either <code class="codeph">AlgorithmParameter</code>s or <code class="codeph">AlgorithmParameterSpec</code>s.
                     </p>
                     <p> Depending on the use situation, algorithms can use the parameters directly, or the parameters might need to be converted into a more portable format for transmission or storage.</p>
                     <p>A <span class="variable" translate="no">transparent</span> representation of a set of parameters (via <code class="codeph">AlgorithmParameterSpec</code>) means that you can access each parameter value in the set individually. You can access these values through one of the <code class="codeph">get</code> methods defined in the corresponding specification class (e.g., <code class="codeph">DSAParameterSpec</code> defines <code class="codeph">getP</code>, <code class="codeph">getQ</code>, and <code class="codeph">getG</code> methods, to access <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code>, respectively).
                     </p>
                     <p>In contrast, the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" title="The AlgorithmParameters class provides an opaque representation of cryptographic parameters.">The AlgorithmParameters Class</a> class supplies an <span class="variable" translate="no">opaque</span> representation, in which you have no direct access to the parameter fields. You can only get the name of the algorithm associated with the parameter set (via <code class="codeph">getAlgorithm</code>) and some kind of encoding for the parameter set (via <code class="codeph">getEncoded</code>).
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-190C91B4-991D-416E-A932-C0E37B33A86D" name="GUID-190C91B4-991D-416E-A932-C0E37B33A86D"></a><h5 id="JSSEC-GUID-190C91B4-991D-416E-A932-C0E37B33A86D" class="sect5">The AlgorithmParameterSpec Interface</h5>
                     <div>
                        <p><code class="codeph">AlgorithmParameterSpec</code> is an interface to a transparent specification of cryptographic parameters. This interface contains no methods or constants. Its only purpose is to group (and provide type safety for) all parameter specifications. All parameter specifications must implement this interface.
                        </p>
                        <div class="section">
                           <p>The following are the algorithm parameter specification interfaces and classes in the <code class="codeph">java.security.spec</code> and <code class="codeph">javax.crypto.spec</code> packages:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHParameterSpec.html" target="_blank"><code class="codeph">DHParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/DHGenParameterSpec.html" target="_blank"><code class="codeph">DHGenParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/DSAParameterSpec.html" target="_blank"><code class="codeph">DSAParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECGenParameterSpec.html" target="_blank"><code class="codeph">ECGenParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/ECParameterSpec.html" target="_blank"><code class="codeph">ECParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/GCMParameterSpec.html" target="_blank"><code class="codeph">GCMParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/IvParameterSpec.html" target="_blank"><code class="codeph">IvParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/MGF1ParameterSpec.html" target="_blank"><code class="codeph">MGF1ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/OAEPParameterSpec.html" target="_blank"><code class="codeph">OAEPParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/PBEParameterSpec.html" target="_blank"><code class="codeph">PBEParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/PSSParameterSpec.html" target="_blank"><code class="codeph">PSSParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/RC2ParameterSpec.html" target="_blank"><code class="codeph">RC2ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/crypto/spec/RC5ParameterSpec.html" target="_blank"><code class="codeph">RC5ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/java/security/spec/RSAKeyGenParameterSpec.html" target="_blank"><code class="codeph">RSAKeyGenParameterSpec</code></a></li>
                           </ul>
                           <p>The following algorithm parameter specs are used specifically for XML digital signatures.</p>
                           <ul style="list-style-type: disc;">
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/C14NMethodParameterSpec.html" target="_blank"><code class="codeph">Interface C14NMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/DigestMethodParameterSpec.html" target="_blank"><code class="codeph">Interface DigestMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/SignatureMethodParameterSpec.html" target="_blank"><code class="codeph">Interface SignatureMethodParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/TransformParameterSpec.html" target="_blank"><code class="codeph">Interface TransformParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/ExcC14NParameterSpec.html" target="_blank"><code class="codeph">Interface ExcC14NParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/HMACParameterSpec.html" target="_blank"><code class="codeph">Interface HMACParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XPathFilter2ParameterSpec.html" target="_blank"><code class="codeph">Interface XPathFilter2ParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XPathFilterParameterSpec.html" target="_blank"><code class="codeph">Interface XPathFilterParameterSpec</code></a></li>
                              <li><a href="https://docs.oracle.com/javase/10/docs/api/javax/xml/crypto/dsig/spec/XSLTTransformParameterSpec.html" target="_blank"><code class="codeph">XSLTTransformParameterSpec</code></a></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" name="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0"></a><h5 id="JSSEC-GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0" class="sect5">The AlgorithmParameters Class</h5>
                     <div>
                        <p>The <code class="codeph">AlgorithmParameters</code> class provides an opaque representation of cryptographic parameters.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-D4D0754B-36F3-4C9E-95F5-9A4C7AE055DA">The AlgorithmParameters Class</p>
                           <p>The <code class="codeph">AlgorithmParameters</code> class is an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a> .You can initialize the <code class="codeph">AlgorithmParameters</code> class using a specific <code class="codeph">AlgorithmParameterSpec</code> object, or by encoding the parameters in a recognized format. You can retrieve the resulting specification with the <span class="apiname">getParameterSpec</span> method (see the following section).
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-93AC8926-8EB7-4B31-9FD2-71D002D6C230">Creating an AlgorithmParameters Object</p>
                           <p><code class="codeph">AlgorithmParameters</code> objects are obtained by using one of the <code class="codeph">AlgorithmParameters</code> getInstance() static factory methods. For more information, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-9AB97E16-E8EF-456D-9E9F-92C765BF6DD2">Initializing an AlgorithmParameters Object</p>
                           <p>Once an <code class="codeph">AlgorithmParameters</code> object is instantiated, it must be initialized via a call to <code class="codeph">init</code>, using an appropriate parameter specification or parameter encoding:
                           </p><pre class="codeblock"><code>
void init(AlgorithmParameterSpec paramSpec)
void init(byte[] params)
void init(byte[] params, String format)
</code></pre><p>In these <code class="codeph">init</code> methods, <code class="codeph">params</code> is an array containing the encoded parameters, and <code class="codeph">format</code> is the name of the decoding format. In the <code class="codeph">init</code> method with a <code class="codeph">params</code> argument but no <code class="codeph">format</code> argument, the primary decoding format for parameters is used. The primary decoding format is ASN.1, if an ASN.1 specification for the parameters exists.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-0D673859-E908-4D79-ACBD-08657FB13092">Obtaining the Encoded Parameters</p>
                           <p>A byte encoding of the parameters represented in an <code class="codeph">AlgorithmParameters</code> object may be obtained via a call to <code class="codeph">getEncoded</code>:
                           </p><pre class="codeblock"><code>
byte[] getEncoded()
</code></pre><p>This method returns the parameters in their primary encoding format. The primary encoding format for parameters is ASN.1, if an ASN.1 specification for this type of parameters exists.</p>
                           <p>If you want the parameters returned in a specified encoding format, use</p><pre class="codeblock"><code>
byte[] getEncoded(String format)
</code></pre><p> If <code class="codeph">format</code> is null, the primary encoding format for parameters is used, as in the other <span class="apiname">getEncoded</span>  method. 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF3A257D-5489-472A-8297-7E9952A5AAB0__GUID-1CFCC9C2-CF4B-45C3-A219-10DA07E59161">Converting an AlgorithmParameters Object to a Transparent Specification</p>
                           <p>A transparent parameter specification for the algorithm parameters may be obtained from an <code class="codeph">AlgorithmParameters</code> object via a call to <code class="codeph">getParameterSpec</code>:
                           </p><pre class="codeblock"><code>
AlgorithmParameterSpec getParameterSpec(Class paramSpec)
</code></pre><p><code class="codeph">paramSpec</code> identifies the specification class in which the parameters should be returned. The specification class could be, for example, <code class="codeph">DSAParameterSpec.class</code> to indicate that the parameters should be returned in an instance of the <code class="codeph">DSAParameterSpec</code> class. (This class is in the <code class="codeph">java.security.spec</code> package.)
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C" name="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C"></a><h5 id="JSSEC-GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C" class="sect5">The AlgorithmParameterGenerator Class</h5>
                     <div>
                        <div class="section">
                           <p>The <code class="codeph">AlgorithmParameterGenerator</code> class is an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a> used to generate a set of <span class="bold">brand-new</span> parameters suitable for a certain algorithm (the algorithm is specified when an <code class="codeph">AlgorithmParameterGenerator</code> instance is created). This object is used when you do not have an existing set of algorithm parameters, and want to generate one from scratch.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-1639E5D1-1F84-409B-84F8-D736371E44C2">Creating an AlgorithmParameterGenerator Object</p>
                           <p><code class="codeph">AlgorithmParameterGenerator</code> objects are obtained by using one of the <code class="codeph">AlgorithmParameterGenerator</code> getInstance() static factory methods. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-7B09D9AD-4B5E-444A-950C-A4D5165A7C61">Initializing an AlgorithmParameterGenerator Object</p>
                           <p>The <code class="codeph">AlgorithmParameterGenerator</code> object can be initialized in two different ways: an algorithm-independent manner or an algorithm-specific manner.
                           </p>
                           <p>The algorithm-independent approach uses the fact that all parameter generators share the concept of a "size" and a source of randomness. The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms. For example, in the case of parameters for the DSA algorithm, "size" corresponds to the size of the prime modulus, in bits. (See <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> to know more about the sizes for specific algorithms.) When using this approach, algorithm-specific parameter generation values--if any--default to some standard values. One <code class="codeph">init</code> method that takes these two universally shared types of arguments:
                           </p><pre class="codeblock"><code>
void init(int size, SecureRandom random);
</code></pre><p>Another <code class="codeph">init</code> method takes only a <code class="codeph">size</code> argument and uses a system-provided source of randomness:
                           </p><pre class="codeblock"><code>
void init(int size)
</code></pre><p>A third approach initializes a parameter generator object using algorithm-specific semantics, which are represented by a set of algorithm-specific parameter generation values supplied in an <code class="codeph">AlgorithmParameterSpec</code> object:
                           </p><pre class="codeblock"><code>
void init(AlgorithmParameterSpec genParamSpec,
                          SecureRandom random)

void init(AlgorithmParameterSpec genParamSpec)
</code></pre><p>To generate Diffie-Hellman system parameters, for example, the parameter generation values usually consist of the size of the prime modulus and the size of the random exponent, both specified in number of bits.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-921D1B8C-5A16-403E-B3A6-D9C6EC684D1C__GUID-D4CF78C6-CED0-4E4D-A690-B7DB2B05FDC8">Generating Algorithm Parameters</p>
                           <p>Once you have created and initialized an AlgorithmParameterGenerator object, you can use the generateParameters method to generate the algorithm parameters:</p><code class="codeph">AlgorithmParameters generateParameters()</code></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" name="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA"></a><h4 id="JSSEC-GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA" class="sect4">The CertificateFactory Class</h4>
                  <div>
                     <p>The <code class="codeph">CertificateFactory</code> class defines the functionality of a certificate factory, which is used to generate certificate and certificate revocation list (CRL) objects from their encoding.
                     </p>
                     <div class="section">
                        <p>The <code class="codeph">CertificateFactory</code> class is an <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-A7EEDE25-C4C0-4C28-94EA-262858AE9212" title="An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider.">Engine Classes and Algorithms</a>.
                        </p>
                        <p>A certificate factory for X.509 must return certificates that are an instance of <code class="codeph">java.security.cert.X509Certificate</code>, and CRLs that are an instance of <code class="codeph">java.security.cert.X509CRL</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-8415E441-2028-4476-9A95-DBD09998E407">Creating a CertificateFactory Object</p>
                        <p><code class="codeph">CertificateFactory</code> objects are obtained by using one of the <code class="codeph">getInstance()</code> static factory methods. For more information, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-2DCBD20D-2D5E-4ECA-81A8-1FCE9E961741">How Provider Implementations Are Requested and Supplied</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-5379762D-6D25-4ED7-A22C-A72ED8F1AA80">Generating Certificate Objects</p>
                        <p>To generate a certificate object and initialize it with the data read from an input stream, use the <code class="codeph">generateCertificate</code> method:
                        </p><pre class="codeblock"><code>
final Certificate generateCertificate(InputStream inStream)
</code></pre><p>To return a (possibly empty) collection view of the certificates read from a given input stream, use the <code class="codeph">generateCertificates</code> method:
                        </p><pre class="codeblock"><code>
final Collection generateCertificates(InputStream inStream)
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-ED452EA8-B0FA-4C83-A722-194EBF8853DC">Generating CRL Objects</p>
                        <p>To generate a certificate revocation list (CRL) object and initialize it with the data read from an input stream, use the <code class="codeph">generateCRL</code> method:
                        </p><pre class="codeblock"><code>
final CRL generateCRL(InputStream inStream)
</code></pre><p> To return a (possibly empty) collection view of the CRLs read from a given input stream, use the <code class="codeph">generateCRLs</code>  method: 
                        </p><pre class="codeblock"><code>
final Collection generateCRLs(InputStream inStream)
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9A581FBA-EDF7-4BCA-8244-4CE2C75E4CEA__GUID-72360D6D-E10F-4091-9DA9-88D86B325A83">Generating CertPath Objects</p>
                        <p>The certificate path builder and validator for PKIX is defined by the Internet X.509 Public Key Infrastructure Certificate and CRL Profile, <a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">RFC 5280</a>.
                        </p>
                        <p>A certificate store implementation for retrieving certificates and CRLs from Collection and LDAP directories, using the PKIX LDAP V2 Schema is also available from the IETF as <a href="http://www.ietf.org/rfc/rfc2587.txt" target="_blank">RFC 2587</a>.
                        </p>
                        <p>To generate a <code class="codeph">CertPath</code> object and initialize it with data read from an input stream, use one of the following <code class="codeph">generateCertPath</code> methods (with or without specifying the encoding to be used for the data):
                        </p><pre class="codeblock"><code>
final CertPath generateCertPath(InputStream inStream)

final CertPath generateCertPath(InputStream inStream,
                                String encoding)
</code></pre><p>To generate a <code class="codeph">CertPath</code> object and initialize it with a list of certificates, use the following method:
                        </p><pre class="codeblock"><code>
final CertPath generateCertPath(List certificates)
</code></pre><p>To retrieve a list of the <code class="codeph">CertPath</code> encoding supported by this certificate factory, you can call the <code class="codeph">getCertPathEncodings</code> method:
                        </p><pre class="codeblock"><code>
final Iterator getCertPathEncodings()
</code></pre><p> The default encoding will be listed first. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229" name="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229"></a><h3 id="JSSEC-GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229" class="sect3">How the JCA Might Be Used in a SSL/TLS Implementation</h3>
               <div>
                  <p>With an understanding of the JCA classes, consider how these classes might be combined to implement an advanced network protocol like SSL/TLS.</p>
                  <div class="section">
                     <p>The SSL/TLS Overview section in the <a href="java-security-overview1.html#GUID-FCF419A7-B856-46DD-A36F-C6F88F9AF37F">TLS and DTLS Protocols</a> describes at a high level how the protocols work. As asymmetric (public key) cipher operations are much slower than symmetric operations (secret key), public key cryptography is used to establish secret keys which are then used to protect the actual application data. Vastly simplified, the SSL/TLS handshake involves exchanging initialization data, performing some public key operations to arrive at a secret key, and then using that key to encrypt further traffic.
                     </p>
                     <div class="infoboxnote" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-33252E3C-D0BD-4073-9D36-C31CBC961EF5">
                        <p class="notep1">Note:</p>The details presented here simply show how some of the above classes might be employed. This section will not present sufficient information for building a SSL/TLS implementation. For more information, see <a href="java-secure-socket-extension-jsse-reference-guide.html#GUID-93DEEE16-0B70-40E5-BBE7-55C3FD432345" title="The Java Secure Socket Extension (JSSE) enables secure Internet communications. It provides a framework and an implementation for a Java version of the TLS and DTLS protocols and includes functionality for data encryption, server authentication, message integrity, and optional client authentication.">Java Secure Socket Extension (JSSE) Reference Guide</a> and <a href="https://tools.ietf.org/html/rfc5246" target="_blank">RFC 5246: The Transport Layer Security (TLS) Protocol, Version 1.2</a>.
                     </div>
                     <p>Assume that this SSL/TLS implementation will be made available as a JSSE provider. A concrete implementation of the <code class="codeph">Provider</code> class is first written that will eventually be registered in the <code class="codeph">Security</code> class' list of providers. This provider mainly provides a mapping from algorithm names to actual implementation classes. (that is: "SSLContext.TLS"-&gt;"com.foo.TLSImpl") When an application requests an "TLS" instance (via <code class="codeph">SSLContext.getInstance("TLS")</code>), the provider's list is consulted for the requested algorithm, and an appropriate instance is created.
                     </p>
                     <p>Before discussing details of the actual handshake, a quick review of some of the JSSE's architecture is needed. The heart of the JSSE architecture is the <code class="codeph">SSLContext</code>. The context eventually creates end objects (<code class="codeph">SSLSocket</code> and <code class="codeph">SSLEngine</code>) which actually implement the SSL/TLS protocol. <code class="codeph">SSLContext</code>s are initialized with two callback classes, <code class="codeph">KeyManager</code> and <code class="codeph">TrustManager</code>, which allow applications to first select authentication material to send and second to verify credentials sent by a peer.
                     </p>
                     <p>A JSSE <code class="codeph">KeyManager</code> is responsible for choosing which credentials to present to a peer. Many algorithms are possible, but a common strategy is to maintain a RSA or DSA public/private key pair along with a <code class="codeph">X509Certificate</code> in a <code class="codeph">KeyStore</code> backed by a disk file. When a <code class="codeph">KeyStore</code> object is initialized and loaded from the file, the file's raw bytes are converted into <code class="codeph">PublicKey</code> and <code class="codeph">PrivateKey</code> objects using a <code class="codeph">KeyFactory</code>, and a certificate chain's bytes are converted using a <code class="codeph">CertificateFactory</code>. When a credential is needed, the <code class="codeph">KeyManager</code> simply consults this <code class="codeph">KeyStore</code> object and determines which credentials to present.
                     </p>
                     <p>A <code class="codeph">KeyStore</code>'s contents might have originally been created using a utility such as <code class="codeph">keytool</code>. <code class="codeph">keytool</code> creates a RSA or DSA <code class="codeph">KeyPairGenerator</code> and initializes it with an appropriate keysize. This generator is then used to create a <code class="codeph">KeyPair</code> which <code class="codeph">keytool</code> would store along with the newly-created certificate in the <code class="codeph">KeyStore</code>, which is eventually written to disk.
                     </p>
                     <p>A JSSE <code class="codeph">TrustManager</code> is responsible for verifying the credentials received from a peer. There are many ways to verify credentials: one of them is to create a <code class="codeph">CertPath</code> object, and let the JDK's built-in Public Key Infrastructure (PKI) framework handle the validation. Internally, the CertPath implementation might create a <code class="codeph">Signature</code> object, and use that to verify that the each of the signatures in the certificate chain.
                     </p>
                     <p>With this basic understanding of the architecture, we can look at some of the steps in the SSL/TLS handshake. The client begins by sending a ClientHello message to the server. The server selects a ciphersuite to use, and sends that back in a ServerHello message, and begins creating JCA objects based on the suite selection. We'll use server-only authentication in the following examples.</p>
                     <div class="figure" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-882646E9-0A5E-4ED7-B681-DFFB0FD15668">
                        <p class="titleinfigure">Figure 2-17 SSL/TLS Messages</p><img src="img/ssl-client.png" alt="Description of Figure 2-17 follows" title="Description of Figure 2-17 follows" longdesc="img_text/ssl-client.html"><br><a href="img_text/ssl-client.html">Description of "Figure 2-17 SSL/TLS Messages"</a></div>
                     <!-- class="figure" -->
                     <p>Server-only authentication is described in the following examples. The examples are vastly simplified, but gives an idea of how the JSSE classes might be combined to create a higher level protocol:</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-3C2B038D-8282-4518-9923-9E4598F7200A">
                     <p class="titleinexample">Example 2-9 SSL/TLS Server Uses a RSA-based ciphersuite Such as TLS_RSA_WITH_AES_128_CBC_SHA</p>The server's <code class="codeph">KeyManager</code> is queried, and returns an appropriate RSA entry. The server's credentials (that is: certificate/public key) are sent in the server's Certificate message. The client's <code class="codeph">TrustManager</code> verifies the server's certificate, and if accepted, the client generates some random bytes using a <code class="codeph">SecureRandom</code> object. This is then encrypted using an encrypting asymmetric RSA <code class="codeph">Cipher</code> object that has been initialized with the <code class="codeph">PublicKey</code> found in the server's certificate. This encrypted data is sent in a Client Key Exchange message. The server would use its corresponding <code class="codeph">PrivateKey</code> to recover the bytes using a similar <code class="codeph">Cipher</code> in decrypt mode. These bytes are then used to establish the actual encryption keys.
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C9C9DD6C-3A6B-4759-B41E-AAAC502C0229__GUID-44DAB934-48B2-4359-8E56-57B01B5D5FA0">
                     <p class="titleinexample">Example 2-10 Choose an Ephemeral Diffie-Hellman Key Agreement Algorithm Along with the DSA Signature Algorithm such as TLS_DHE_DSS_WITH_AES_128_CBC_SHA</p>The two sides must each establish a new temporary DH public/private keypair using a <code class="codeph">KeyPairGenerator</code>. Each generator creates DH keys which can then be further converted into pieces using the <code class="codeph">KeyFactory</code> and <code class="codeph">DHPublicKeySpec</code> classes. Each side then creates a <code class="codeph">KeyAgreement</code> object and initializes it with their respective DH <code class="codeph">PrivateKey</code>s. The server sends its public key pieces in a <code class="codeph">ServerKeyExchange</code> message (protected by the DSA signature algorithm, and the client sends its public key in a ClientKeyExchange message. When the public keys are reassembled using another <code class="codeph">KeyFactory</code>, they are fed into the agreement objects. The <code class="codeph">KeyAgreement</code> objects then generate agreed-upon bytes that are then used to establish the actual encryption keys.
                     <p>Once the actual encryption keys have been established, the secret key is used to initialize a symmetric <code class="codeph">Cipher</code> object, and this cipher is used to protect all data in transit. To help determine if the data has been modified, a <code class="codeph">MessageDigest</code> is created and receives a copy of the data destined for the network. When the packet is complete, the digest (hash) is appended to data, and the entire packet is encrypted by the <code class="codeph">Cipher</code>. If a block cipher such as AES is used, the data must be padded to make a complete block. On the remote side, the steps are simply reversed.
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1" name="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1"></a><h3 id="JSSEC-GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1" class="sect3">Cryptographic Strength Configuration</h3>
               <div>
                  <p></p>
                  <p>You can configure the cryptographic strength of the Java Cryptography Extension (JCE) architecture using jurisdiction policy files (see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F2CF205E-744E-4C16-B504-B6F79781E762">Jurisdiction Policy File Format</a>) and the security properties file.
                  </p>
                  <p>Prior to Oracle Java JDK 9, the default cryptographic strength allowed by Oracle implementations was “strong but limited” (for example AES keys limited to 128 bits). To remove this restriction, administrators could download and install a separate “unlimited strength” Jurisdiction Policy Files bundle. The Jurisdiction Policy File mechanism was reworked for JDK 9. It now allows for much more flexible configuration. The Oracle JDK now ships with a default value of “unlimited” rather than “limited”. As always, administrators and users must still continue to follow all import/export guidelines for their geographical locations. The active cryptographic strength is now determined using a Security Property (typically set in the <code class="codeph">java.security</code> properties file), in combination with the jurisdiction policy files found in the configuration directory.
                  </p>
                  <p>All the necessary JCE policy files to provide either unlimited cryptographic strength or strong but limited cryptographic strength are bundled with the JDK.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-4ACF175C-144C-48E2-818D-263236EDC52D">Cryptographic Strength Settings</p>
                     <p>Each directory under <code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/policy</code> represents a set of policy configurations defined by the jurisdiction policy files that they contain. You activate a particular cryptographic strength setting represented by the policy files in a directory by setting the <code class="codeph">crypto.policy</code> Security Property (configured in the file <code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/java.security</code>) to point to that directory.
                     </p>
                     <div class="p">The JDK comes bundled with two such directories, <code class="codeph">limited</code> and <code class="codeph">unlimited</code>, each containing a number of policy files. By default, the <code class="codeph">crypto.policy</code> Security Property is set to: <pre class="pre codeblock"><code>crypto.policy = unlimited</code></pre></div>
                     <p>The overall value is the intersection of the files contained within the directory. These policy files settings are VM-wide, and affect all applications running on this VM. If you want to override cryptographic strength at the application level, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">How to Make Applications Exempt from Cryptographic Restrictions</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-ED64129F-57BF-44D2-8689-AD3378C36F1F">Unlimited Directory Contents</p>
                     <p>The <code class="codeph">unlimited</code> directory contains the following policy files:
                     </p>
                     <div class="p">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/unlimited/default_US_export.policy</code></p>
                              <div class="p"><pre class="pre codeblock"><code>// Default US Export policy file.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-5E09236A-26C9-4879-95CB-6E5F2EC1B6C3">
                                    <p class="notep1">Note:</p>As there are no current restrictions on export of cryptography from the United States, the <code>default_US_export.policy</code> file is set with no restrictions.
                                 </div>
                              </div>
                           </li>
                           <li>
                              <div class="p"><code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/unlimited/default_local.policy</code><pre class="pre codeblock"><code>// Country specific policy file for countries with no limits on crypto strength.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-44F8E9BD-3982-4E54-8907-05AC7B28453A">
                                    <p class="notep1">Note:</p>Depending on the country, there may be local restrictions, but as this policy file is located in the <code class="codeph">unlimited</code> directory, there are no restrictions listed here.
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p>To select unlimited cryptographic strength as defined in these two files set <code class="codeph">crypto.policy = unlimited</code> in the file <code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/java.security</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-82032A75-0FAB-4BEF-97E0-862E04C6AE7A">Limited Directory Contents</p>
                     <p>The <code class="codeph">limited</code> directory currently contains the following policy files:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <div class="p"><code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/limited/default_US_export.policy</code><pre class="pre codeblock"><code>// Default US Export policy file.  
grant {     
// There is no restriction to any algorithms.
     permission javax.crypto.CryptoAllPermission;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-297C34B0-18F6-4D2B-802F-B11D6B0FC233">
                                 <p class="notep1">Note:</p>Even though this is in the <code class="codeph">limited</code> directory, as there are no current restrictions on export of cryptography from the United States, the <code>default_US_export.policy</code> file is set with no restrictions.
                              </div>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/limited/default_local.policy</code></p><pre class="pre codeblock"><code>// Some countries have import limits on crypto strength. This policy file
// is worldwide importable.

grant {
    permission javax.crypto.CryptoPermission "DES", 64;
    permission javax.crypto.CryptoPermission "DESede", *;
    permission javax.crypto.CryptoPermission "RC2", 128, 
                                     "javax.crypto.spec.RC2ParameterSpec", 128;
    permission javax.crypto.CryptoPermission "RC4", 128;
    permission javax.crypto.CryptoPermission "RC5", 128, 
          "javax.crypto.spec.RC5ParameterSpec", *, 12, *;
    permission javax.crypto.CryptoPermission "RSA", *;
    permission javax.crypto.CryptoPermission *, 128;
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-53F6BA3F-7413-4B06-AA40-24359147478D">
                              <p class="notep1">Note:</p>This local policy file shows the default restrictions. It should be allowed by any country, including those that have import restrictions, but please obtain legal guidance.
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/limited/exempt_local.policy</code></p><pre class="pre codeblock"><code>// Some countries have import limits on crypto strength, but may allow for
// these exemptions if the exemption mechanism is used.

grant {
    // There is no restriction to any algorithms if KeyRecovery is enforced.
    permission javax.crypto.CryptoPermission *, "KeyRecovery"; 

    // There is no restriction to any algorithms if KeyEscrow is enforced.
    permission javax.crypto.CryptoPermission *, "KeyEscrow"; 

    // There is no restriction to any algorithms if KeyWeakening is enforced. 
    permission javax.crypto.CryptoPermission *, "KeyWeakening";
};</code></pre><div class="infoboxnote" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-9AA5D629-D309-4DF2-9BCE-66BD1DDC8E76">
                              <p class="notep1">Note:</p>Countries that have import restrictions should use “limited”, but these restrictions could be relaxed if the exemption mechanism can be employed. See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D">How to Make Applications Exempt from Cryptographic Restrictions</a>. Please obtain legal guidance for your situation.
                           </div>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1__GUID-6273F861-FD0B-4E50-BFFE-116B161FD487">Custom Cryptographic Strength Settings</p>
                     <p>To set up restrictions to cryptographic strength that are different than the settings in the policy files in the <code class="codeph">limited</code> or <code class="codeph">unlimited</code> directory, you can create a new directory, parallel with <code class="codeph">limited</code> and <code class="codeph">unlimited</code>, and place your policy files there. For example, you may create a directory called <code class="codeph">custom</code>. In this <code class="codeph">custom</code> directory you include the files <code class="codeph">default_*export.policy</code> and/or <code class="codeph">exempt_*local.policy</code>. 
                     </p>
                     <p>To select cryptographic strength as defined in the files in the <code class="codeph">custom</code> directory, set <code class="codeph">crypto.policy = custom</code> in the file <code class="codeph"><span class="variable" translate="no">&lt;java_home&gt;</span>/conf/security/java.security</code>.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-F2CF205E-744E-4C16-B504-B6F79781E762" name="GUID-F2CF205E-744E-4C16-B504-B6F79781E762"></a><h3 id="JSSEC-GUID-F2CF205E-744E-4C16-B504-B6F79781E762" class="sect3">Jurisdiction Policy File Format</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>JCA represents its jurisdiction policy files as Java-style policy files with corresponding permission statements. As described in <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">Cryptographic Strength Configuration</a>, a Java policy file specifies what permissions are allowed for code from specified code sources. A permission represents access to a system resource. In the case of JCA, the "resources" are cryptography algorithms, and code sources do not need to be specified, because the cryptographic restrictions apply to all code.
                     </p>
                     <p>A jurisdiction policy file consists of a very basic "grant entry" containing one or more "permission entries."</p><pre class="codeblock"><code>grant {
    <span class="variable" translate="no">&lt;permission entries&gt;</span>;
};
</code></pre><p>The format of a permission entry in a jurisdiction policy file is:</p><pre class="codeblock"><code>permission <span class="variable" translate="no">&lt;crypto permission class name&gt;
</span>    [<span class="variable" translate="no">&lt;alg_name&gt;</span>
        [
            [, <span class="variable" translate="no">&lt;exemption mechanism name&gt;</span>]
            [, <span class="variable" translate="no">&lt;maxKeySize&gt;</span>
                [, <span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span>,
                       <span class="variable" translate="no">&lt;parameters for constructing an AlgorithmParameterSpec object&gt;</span>
                ]
            ]
        ]
    ];
</code></pre><p>A sample jurisdiction policy file that includes restricting the AES algorithm to maximum key sizes of 128 bits is:</p><pre class="codeblock"><code>    grant {
        permission javax.crypto.CryptoPermission "AES", 128;
        // ...
    };
</code></pre><p>A permission entry must begin with the word <code class="codeph">permission</code>. Items that appear in a permission entry must appear in the specified order. An entry is terminated with a semicolon. Case is unimportant for the identifiers (<code class="codeph">grant</code>, <code class="codeph">permission</code>) but is significant for the <code class="codeph"><span class="variable" translate="no">&lt;crypto permission class name&gt;</span></code> or for any string that is passed in as a value. An asterisk (<code class="codeph">*</code>) can be used as a wildcard for any permission entry option. For example, an asterisk for an <code class="codeph"><span class="variable" translate="no">&lt;alg_name&gt;</span></code> option means "all algorithms."
                     </p>
                     <p>The following table describes a permission entry's options:</p>
                     <div class="tblformal" id="GUID-F2CF205E-744E-4C16-B504-B6F79781E762__GUID-4B590C91-3FAE-4242-AE13-89EE1D99FE3B">
                        <p class="titleintable">Table 2-1 Permission Entry Options</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Permission Entry Options" summary="Permission entry options and their descriptions" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d30788e5998">Option</th>
                                 <th align="left" valign="bottom" id="d30788e6000">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6004" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;crypto permission class name&gt;</span></code></td>
                                 <td align="left" valign="top" headers="d30788e6004 d30788e6000 ">
                                    <p>Specific permission class name, such as <code class="codeph">javax.crypto.CryptoPermission</code>. Required.
                                    </p>
                                    <p>A crypto permission class reflects the ability of an application to use certain algorithms with certain key sizes in certain environments. There are two crypto permission classes: <code class="codeph">CryptoPermission</code> and <code class="codeph">CryptoAllPermission</code>. The special <code class="codeph">CryptoAllPermission</code> class implies all cryptography-related permissions, that is, it specifies that there are no cryptography-related restrictions.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6026" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;alg_name&gt;</span> </code></td>
                                 <td align="left" valign="top" headers="d30788e6026 d30788e6000 ">
                                    <p>Quoted string specifying the standard name of a cryptography algorithm, such as "AES" or "RSA". Optional.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6035" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;exemption mechanism name&gt;</span></code></td>
                                 <td align="left" valign="top" headers="d30788e6035 d30788e6000 ">
                                    <p>Quoted string indicating an exemption mechanism which, if enforced, enables a reduction in cryptographic restrictions. Optional.</p>
                                    <p>Exemption mechanism names that can be used include "KeyRecovery" "KeyEscrow", and "KeyWeakening".</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6045" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;maxKeySize&gt;</span></code></td>
                                 <td align="left" valign="top" headers="d30788e6045 d30788e6000 ">
                                    <p>Integer specifying the maximum key size (in bits) allowed for the specified algorithm. Optional.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6053" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span></code></td>
                                 <td align="left" valign="top" headers="d30788e6053 d30788e6000 ">
                                    <p>Class name that specifies the strength of the algorithm. Optional.</p>
                                    <p>For some algorithms, it may not be sufficient to specify the algorithm strength in terms of just a key size. For example, in the case of the "RC5" algorithm, the number of rounds must also be considered. For algorithms whose strength needs to be expressed as more than a key size, use this option to specify the <code class="codeph">AlgorithmParameterSpec</code> class name that does this (such as <code class="codeph">javax.crypto.spec.RC5ParameterSpec</code> for the "RC5" algorithm).
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d30788e6069" headers="d30788e5998 "><code class="codeph"><span class="variable" translate="no">&lt;parameters for constructing an AlgorithmParameterSpec object&gt;</span></code></td>
                                 <td align="left" valign="top" headers="d30788e6069 d30788e6000 ">List of parameters for constructing the specified <code class="codeph">AlgorithmParameterSpec</code> object. Required if <code class="codeph"> <span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span></code> has been specified and requires parameters.
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D" name="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D"></a><h3 id="JSSEC-GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D" class="sect3">How to Make Applications Exempt from Cryptographic Restrictions</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-CD61A0CD-BB98-4CF9-B958-D75C1DF166A1">
                        <p class="notep1">Attention:</p>This section should be ignored by most application developers. It is only for people whose applications may be exported to those few countries whose governments mandate cryptographic restrictions, if it is desired that such applications have fewer cryptographic restrictions than those mandated.
                     </div>
                     <p>By default, an application can use cryptographic algorithms of any strength. However, due to import control restrictions by the governments of a few countries, you may have to limit those algorithms' strength. The JCA framework includes an ability to enforce restrictions regarding the maximum strengths of cryptographic algorithms available to applications in different jurisdiction contexts (locations). You specify these restrictions in jurisdiction policy files. For more information about jurisdiction policy files and how to create and configure them, see <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-EFA5AC2D-644E-4CD9-8523-C6D3936D5FB1">Cryptographic Strength Configuration</a>.
                     </p>
                     <p>It is possible that the governments of some or all such countries may allow certain applications to become exempt from some or all cryptographic restrictions. For example, they may consider certain types of applications as "special" and thus exempt. Or they may exempt any application that utilizes an "exemption mechanism," such as key recovery. Applications deemed to be exempt could get access to stronger cryptography than that allowed for non-exempt applications in such countries.</p>
                     <p>In order for an application to be recognized as "exempt" at runtime, it must meet the following conditions:</p>
                     <ul style="list-style-type: disc;">
                        <li>It must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any).</li>
                        <li>The JAR file containing the application and the permission policy file must have been signed using a code-signing certificate issued after the application was accepted as exempt.</li>
                     </ul>
                     <p>Below are sample steps required in order to make an application exempt from some cryptographic restrictions. This is a basic outline that includes information about what is required by JCA in order to recognize and treat applications as being exempt. You will need to know the exemption requirements of the particular country or countries in which you would like your application to be able to be run but whose governments require cryptographic restrictions. You will also need to know the requirements of a JCA framework vendor that has a process in place for handling exempt applications. Consult such a vendor for further information.</p>
                     <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-870A208D-FE85-4D1E-A1C1-BA8B9616650D">
                        <p class="notep1">Note:</p>The <code class="codeph">SunJCE</code> provider does not supply an implementation of the <code class="codeph">ExemptionMechanismSpi</code> class
                     </div>
                     <ol>
                        <li>Write and Compile Your Application Code</li>
                        <li>Create a Permission Policy File Granting Appropriate Cryptographic Permissions</li>
                        <li>Prepare for Testing 
                           <ol type="a">
                              <li>Apply for Government Approval From the Government Mandating Restrictions.</li>
                              <li>Get a Code-Signing Certificate</li>
                              <li>Bundle the Application and Permission Policy File into a JAR file</li>
                              <li><a href="howtoimplaprovider.html#GUID-434AACF7-0D2C-494A-B32A-508A6B605F62" title="The next step is to request a code-signing certificate so that you can use it to sign your provider prior to testing. The certificate will be good for both testing and production. It will be valid for 5 years.">Step 7.1: Get a Code-Signing Certificate</a></li>
                              <li>Set Up Your Environment Like That of a User in a Restricted Country</li>
                              <li>(only for applications using exemption mechanisms) Install a Provider Implementing the Exemption Mechanism Specified by the entry in the Permission Policy File</li>
                           </ol> 
                        </li>
                        <li>Test Your Application</li>
                        <li>Apply for U.S. Government Export Approval If Required</li>
                        <li>Deploy Your Application</li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-92A89D36-C09D-4970-8A4B-2912436E0CEC">Special Code Requirements for Applications that Use Exemption Mechanisms</p>
                     <p>When an application has a permission policy file associated with it (in the same JAR file) and that permission policy file specifies an exemption mechanism, then when the <span class="apiname">Cipher</span> <code class="codeph">getInstance</code> method is called to instantiate a <span class="apiname">Cipher</span>, the JCA code searches the installed providers for one that implements the specified exemption mechanism. If it finds such a provider, JCA instantiates an <code class="codeph">ExemptionMechanism</code> API object associated with the provider's implementation, and then associates the <code class="codeph">ExemptionMechanism</code> object with the <span class="apiname">Cipher</span> returned by <code class="codeph">getInstance</code>.
                     </p>
                     <p>After instantiating a Cipher, and prior to initializing it (via a call to the Cipher <code class="codeph">init</code> method), your code must call the following <span class="apiname">Cipher</span> method:
                     </p><pre class="codeblock"><code>    public ExemptionMechanism getExemptionMechanism()
</code></pre><p>This call returns the <code class="codeph">ExemptionMechanism</code> object associated with the Cipher. You must then initialize the exemption mechanism implementation by calling the following method on the returned <code class="codeph">ExemptionMechanism</code>:
                     </p><pre class="codeblock"><code>    public final void init(Key key)
</code></pre><p>The argument you supply should be the same as the argument of the same types that you will subsequently supply to a Cipher <code class="codeph">init</code> method.
                     </p>
                     <p>Once you have initialized the <code class="codeph">ExemptionMechanism</code>, you can proceed as usual to initialize and use the Cipher.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-35BFD164-6C13-4FBA-82C6-1332AC04AA8A">Permission Policy Files</p>
                     <p>In order for an application to be recognized at runtime as being "exempt" from some or all cryptographic restrictions, it must have a permission policy file bundled with it in a JAR file. The permission policy file specifies what cryptography-related permissions the application has, and under what conditions (if any).</p>
                     <p>The format of a permission entry in a permission policy file that accompanies an exempt application is the same as the format for a jurisdiction policy file downloaded with the JDK, which is:</p><pre class="codeblock"><code>permission <span class="variable" translate="no">&lt;crypto permission class name&gt;
</span>    [<span class="variable" translate="no">&lt;alg_name&gt;</span>
        [
            [, <span class="variable" translate="no">&lt;exemption mechanism name&gt;</span>]
            [, <span class="variable" translate="no">&lt;maxKeySize&gt;</span>
                [, <span class="variable" translate="no">&lt;AlgorithmParameterSpec class name&gt;</span>,
                       <span class="variable" translate="no">&lt;parameters for constructing an AlgorithmParameterSpec object&gt;</span>
                ]
            ]
        ]
    ];
</code></pre><p>See <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F2CF205E-744E-4C16-B504-B6F79781E762">Jurisdiction Policy File Format</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-15A113AE-5507-4312-A513-1AC8BD2200B7">Permission Policy Files for Exempt Applications</p>
                     <p>Some applications may be allowed to be completely unrestricted. Thus, the permission policy file that accompanies such an application usually just needs to contain the following:</p><pre class="codeblock"><code>grant {
    // There are no restrictions to any algorithms.
    permission javax.crypto.CryptoAllPermission;
};
</code></pre><p>If an application just uses a single algorithm (or several specific algorithms), then the permission policy file could simply mention that algorithm (or algorithms) explicitly, rather than granting <span class="apiname">CryptoAllPermission</span>.
                     </p>
                     <p>For example, if an application just uses the Blowfish algorithm, the permission policy file doesn't have to grant <span class="apiname">CryptoAllPermission</span> to all algorithms. It could just specify that there is no cryptographic restriction if the Blowfish algorithm is used. In order to do this, the permission policy file would look like the following:
                     </p><pre class="codeblock"><code>grant {
    permission javax.crypto.CryptoPermission "Blowfish";
};
</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-3814F089-D790-4662-A51B-DFDD3B21F3DC">Permission Policy Files for Applications Exempt Due to Exemption Mechanisms</p>
                     <p>If an application is considered "exempt" if an exemption mechanism is enforced, then the permission policy file that accompanies the application must specify one or more exemption mechanisms. At run time, the application will be considered exempt if any of those exemption mechanisms is enforced. Each exemption mechanism must be specified in a permission entry that looks like the following:</p><pre class="codeblock"><code>    // No algorithm restrictions if specified
    // exemption mechanism is enforced.
    permission javax.crypto.CryptoPermission *,
        "<span class="variable" translate="no">&lt;ExemptionMechanismName&gt;</span>";
</code></pre><p>where <code class="codeph"><span class="variable" translate="no">&lt;ExemptionMechanismName&gt;</span></code> specifies the name of an exemption mechanism. The list of possible exemption mechanism names includes:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li><code class="codeph">KeyRecovery</code></li>
                        <li><code class="codeph">KeyEscrow</code></li>
                        <li><code class="codeph">KeyWeakening</code></li>
                     </ul>
                     <p> As an example, suppose your application is exempt if either key recovery or key escrow is enforced. Then your permission policy file should contain the following: </p><pre class="codeblock"><code>grant {
    // No algorithm restrictions if KeyRecovery is enforced.
    permission javax.crypto.CryptoPermission *, "KeyRecovery";

    // No algorithm restrictions if KeyEscrow is enforced.
    permission javax.crypto.CryptoPermission *, "KeyEscrow";
};
</code></pre><div class="p">
                        <div class="infoboxnote" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-04F2AC6B-93B0-4124-9B04-99B8D7672EFE">
                           <p class="notep1">Note:</p>Permission entries that specify exemption mechanisms should <span class="variable" translate="no">not</span> also specify maximum key sizes. The allowed key sizes are actually determined from the installed exempt jurisdiction policy files, as described in the next section.
                        </div>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-B74786B8-A0AD-4DC3-8A2D-2EF41084CE3D__GUID-5EA84500-8409-491D-B03D-8F922C6EC10C">How Bundled Permission Policy Files Affect Cryptographic Permissions</p>
                     <p>At runtime, when an application instantiates a <span class="apiname">Cipher</span> (via a call to its <code class="codeph">getInstance</code> method) and that application has an associated permission policy file, JCA checks to see whether the permission policy file has an entry that applies to the algorithm specified in the <code class="codeph">getInstance</code> call. If it does, and the entry grants <span class="apiname">CryptoAllPermission</span> or does not specify that an exemption mechanism must be enforced, it means there is no cryptographic restriction for this particular algorithm.
                     </p>
                     <p>If the permission policy file has an entry that applies to the algorithm specified in the <code class="codeph">getInstance</code> call and the entry <span class="variable" translate="no">does</span> specify that an exemption mechanism must be enforced, then the exempt jurisdiction policy file(s) are examined. If the exempt permissions include an entry for the relevant algorithm and exemption mechanism, and that entry is implied by the permissions in the permission policy file bundled with the application, and if there is an implementation of the specified exemption mechanism available from one of the registered providers, then the maximum key size and algorithm parameter values for the <span class="apiname">Cipher</span> are determined from the exempt permission entry.
                     </p>
                     <p>If there is no exempt permission entry implied by the relevant entry in the permission policy file bundled with the application, or if there is no implementation of the specified exemption mechanism available from any of the registered providers, then the application is only allowed the standard default cryptographic permissions.</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469" name="GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469"></a><h3 id="JSSEC-GUID-6EA080B2-D6B3-4FAD-8369-2170756E0469" class="sect3">Standard Names</h3>
               <div>
                  <p>The Standard Names document contains information about the algorithm specifications.</p>
                  <div class="section">
                     <p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html" target="_blank">Java Security Standard Algorithm Names</a> describes the standard names for algorithms, certificate and keystore types that the JDK Security API requires and uses. It also contains more information about the algorithm specifications. Specific provider information can be found in <a href="oracle-providers.html#GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313" title="This document contains the technical details of the providers that are included in the JDK. It is assumed that readers have a strong understanding of the Java Cryptography Architecture and Provider Architecture.">JDK Providers Documentation</a>.
                     </p>
                     <p>Cryptographic implementations in the JDK are distributed through several different providers primarily for historical reasons (<code class="codeph">Sun</code>, <code class="codeph">SunJSSE</code>, <code class="codeph">SunJCE</code>, <code class="codeph">SunRsaSign</code>). Note these providers may not be available on all JDK implementations, and therefore, truly portable applications should call <span class="apiname">getInstance()</span> without specifying specific providers. Applications specifying a particular provider may not be able to take advantage of native providers tuned for an underlying operating environment (such as PKCS or Microsoft's CAPI).
                     </p>
                     <p>The <code class="codeph">SunPKCS11</code> provider itself does not contain any cryptographic algorithms, but instead, directs requests into an underlying PKCS11 implementation. Consult <a href="pkcs11-reference-guide1.html#GUID-30E98B63-4910-40A1-A6DD-663EAF466991">PKCS#11 Reference Guide</a> and the underlying PKCS11 implementation to determine if a desired algorithm will be available through the PKCS11 provider. Likewise, on Windows systems, the <code class="codeph">SunMSCAPI</code> provider does not provide any cryptographic functionality, but instead routes requests to the underlying Operating System for handling.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C" name="GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C"></a><h3 id="JSSEC-GUID-4FE9F3DF-5D49-44F6-8F28-7541114D520C" class="sect3">Packaging Your Application</h3>
               <div>
                  <p></p>
                  <p>You can package an application in three different kinds of modules:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Named or explicit module: A module that appears on the module path and contains module configuration information in the <code>module-info.class</code> file.
                        </p>
                     </li>
                     <li>
                        <p>Automatic module: &nbsp;A module that appears on the module path, but does not contain module configuration information in a <code>module-info.class</code> file (essentially a "regular" JAR file).
                        </p>
                     </li>
                     <li>
                        <p>Unnamed module: A module that appears on the class path. It may or may not have a <code>module-info.class</code> file; this file is ignored.
                        </p>
                     </li>
                  </ul>
                  <p>It is recommended that you package your applications in named modules as they provide better performance, stronger encapsulation, and simpler configuration. They also offer greater flexibility; you can use them with non-modular JDKs or even as unnamed modules by specifying them in a modular JDK's class path.</p>
                  <p> For more information about modules, see <a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/" target="_blank">The State of the Module System</a> and <a href="http://openjdk.java.net/jeps/261" target="_blank">JEP 261: Module System</a></p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-871FA938-5110-409E-A4EC-16F2A898093A" name="GUID-871FA938-5110-409E-A4EC-16F2A898093A"></a><h3 id="JSSEC-GUID-871FA938-5110-409E-A4EC-16F2A898093A" class="sect3">Additional JCA Code Samples</h3>
               <div>
                  <p></p>
                  <p>These examples illustrate use of several JCA mechanisms. See also <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" title="The following are sample programs for Diffie-Hellman key exchange, AES/GCM, and HMAC-SHA256.">Sample Programs for Diffie-Hellman Key Exchange, AES/GCM, and HMAC-SHA256</a></p>
                  <div class="section">
                     <p class="subhead2" id="GUID-871FA938-5110-409E-A4EC-16F2A898093A__GUID-08F32763-225D-4D48-BEE3-04D3D93F27BD">Topics</p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" title="An example describing the procedure to compute a MessageDigest object.">Computing a MessageDigest Object</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " dsa" (digital signature algorithm), and use this keypair in future examples. we will generate keys with a 2048-bit modulus. don't care which provider supplies the algorithm implementation.">Generating a Pair of Keys</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" title="Examples of generating and verifying a signature using generated keys.">Generating and Verifying a Signature Using Generated Keys</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" title="Sample code that is used to generate and verify signatures using key specifications and KeyFactory.">Generating/Verifying Signatures Using Key Specifications and KeyFactory</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" title="Example code for determining if two keys are equal.">Determining If Two Keys Are Equal</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8">Reading Base64-Encoded Certificates</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A">Parsing a Certificate Reply</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" title="This section takes the user through the process of generating a key, creating and initializing a cipher object, encrypting a file, and then decrypting it. Throughout this example, we use the Advanced Encryption Standard (AES).">Using Encryption</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4">Using Password-Based Encryption</a></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" name="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1"></a><h4 id="JSSEC-GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1" class="sect4">Computing a MessageDigest Object</h4>
                  <div>
                     <p>An example describing the procedure to compute a MessageDigest object.</p>
                     <ol>
                        <li class="stepexpand"><span>Create the <code class="codeph">MessageDigest</code> object, as in the following example:</span><div><pre class="codeblock"><code>
   MessageDigest sha = MessageDigest.getInstance("SHA-256");
</code></pre><p> This call assigns a properly initialized message digest object to the <code class="codeph">sha</code> variable. The implementation implements the Secure Hash Algorithm (SHA-256), as defined in the National Institute for Standards and Technology's (NIST) <a href="http://csrc.nist.gov/publications/fips/index.html" target="_blank">FIPS 180-2 document</a>.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Suppose we have three byte arrays, <code class="codeph">i1</code>, <code class="codeph">i2</code> and <code class="codeph">i3</code>, which form the total input whose message digest we want to compute. This digest (or "hash") could be calculated via the following calls:</span><div><pre class="codeblock"><code>
   sha.update(i1);
   sha.update(i2);
   sha.update(i3);
   byte[] hash = sha.digest();
</code></pre></div>
                        </li>
                        <li class="stepexpand"><strong>Optional: </strong><span>An equivalent alternative series of calls would be:</span><div><pre class="codeblock"><code>
   sha.update(i1);
   sha.update(i2);
   byte[] hash = sha.digest(i3);
</code></pre></div>
                           <div>
                              <p> After the message digest has been calculated, the message digest object is automatically reset and ready to receive new data and calculate its digest. All former state (i.e., the data supplied to <code class="codeph">update</code> calls) is lost.
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-330AF0AF-315C-4418-8882-6CF8F4C9E551">
                        <p class="titleinexample">Example 2-11 Hash Implementations Through Cloning</p>
                        <p>Some hash implementations may support intermediate hashes through cloning. Suppose we want to calculate separate hashes for:</p>
                        <ul style="list-style-type: disc;">
                           <li><code class="codeph">i1</code></li>
                           <li><code class="codeph">i1 and i2</code></li>
                           <li><code class="codeph">i1, i2, and i3</code></li>
                        </ul>
                        <p>The following is one way to calculate these hashes; however, this code works only if the SHA-256 implementation is cloneable:</p><pre class="codeblock"><code>/* compute the hash for i1 */
sha.update(i1);
byte[] i1Hash = sha.clone().digest();

/* compute the hash for i1 and i2 */
sha.update(i2);
byte[] i12Hash = sha.clone().digest();

/* compute the hash for i1, i2 and i3 */
sha.update(i3);
byte[] i123hash = sha.digest();
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-B26EFA90-D3F5-4D84-BC21-4463D144473D">
                        <p class="titleinexample">Example 2-12 Determine if the Hash Implementation is Cloneable or not Cloneable</p>Some implementations of message digests are cloneable, others are not. To determine whether or not cloning is possible, attempt to clone the <code class="codeph">MessageDigest</code> object and catch the potential exception as follows: <pre class="codeblock"><code>try {
    // try and clone it
    /* compute the hash for i1 */
    sha.update(i1);
    byte[] i1Hash = sha.clone().digest();
    // ...
    byte[] i123hash = sha.digest();
} catch (CloneNotSupportedException cnse) {
    // do something else, such as the code shown below
}
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-6E9FB890-F011-450E-9EC5-EBB358E1D8A1__GUID-27A86AA9-D666-434E-9132-6714C46CF320">
                        <p class="titleinexample">Example 2-13 Compute Intermediate Digests if the Hash Implementation is not Cloneable</p> If a message digest is not cloneable, the other, less elegant way to compute intermediate digests is to create several digests. In this case, the number of intermediate digests to be computed must be known in advance: <pre class="codeblock"><code>   MessageDigest md1 = MessageDigest.getInstance("SHA-256");
   MessageDigest md2 = MessageDigest.getInstance("SHA-256");
   MessageDigest md3 = MessageDigest.getInstance("SHA-256");

   byte[] i1Hash = md1.digest(i1);

   md2.update(i1);
   byte[] i12Hash = md2.digest(i2);

   md3.update(i1);
   md3.update(i2);
   byte[] i123Hash = md3.digest(i3);
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" name="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6"></a><h4 id="JSSEC-GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" class="sect4">Generating a Pair of Keys</h4>
                  <div>
                     <p>In this example we will generate a public-private key pair for the algorithm named "DSA" (Digital Signature Algorithm), and use this keypair in future examples. We will generate keys with a 2048-bit modulus. We don't care which provider supplies the algorithm implementation.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-E0DA036D-2F50-477A-976A-716A58BAB38E">Creating the Key Pair Generator</p>
                        <p>The first step is to get a key pair generator object for generating keys for the DSA algorithm:</p><pre class="codeblock"><code>
	KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA");
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-F9CB599A-4B78-4EA1-AA7C-9F8886A42D0D">Initializing the Key Pair Generator</p>
                        <p>The next step is to initialize the key pair generator. In most cases, algorithm-independent initialization is sufficient, but in some cases, algorithm-specific initialization is used.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-B61F273F-CE81-434C-BA40-ABA5D951104B">Algorithm-Independent Initialization</p>
                        <p>All key pair generators share the concepts of a keysize and a source of randomness. The <code class="codeph">KeyPairGenerator</code> class initialization methods at a minimum needs a keysize. If the source of randomness is not explicitly provided, a <code class="codeph">SecureRandom</code> implementation of the highest-priority installed provider will be used. Thus to generate keys with a keysize of 2048, simply call:
                        </p><pre class="codeblock"><code>    keyGen.initialize(2048);
</code></pre><p>The following code illustrates how to use a specific, additionally seeded <code class="codeph">SecureRandom </code>object: 
                        </p><pre class="codeblock"><code>    SecureRandom random = SecureRandom.getInstance("DRBG", "SUN");
    random.setSeed(userSeed);
    keyGen.initialize(2048, random);
</code></pre><p>Since no other parameters are specified when you call the above algorithm-independent <span class="apiname">initialize</span>  method, it is up to the provider what to do about the algorithm-specific parameters (if any) to be associated with each of the keys. The provider may use precomputed parameter values or may generate new values. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-3818AF4B-55DB-4A14-89C9-E26AC60BD770">Algorithm-Specific Initialization</p>
                        <p>For situations where a set of algorithm-specific parameters already exists (such as "community parameters" in DSA), there are two <code class="codeph">initialize</code> methods that have an <code class="codeph">AlgorithmParameterSpec</code> argument. Suppose your key pair generator is for the "DSA" algorithm, and you have a set of DSA-specific parameters, <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code>, that you would like to use to generate your key pair. You could execute the following code to initialize your key pair generator (recall that <code class="codeph">DSAParameterSpec</code> is an <code class="codeph">AlgorithmParameterSpec</code>):
                        </p><pre class="codeblock"><code>    DSAParameterSpec dsaSpec = new DSAParameterSpec(p, q, g);
    keyGen.initialize(dsaSpec);
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6__GUID-3F758987-03FF-45E5-B72D-856E01D3C219">Generating the Pair of Keys</p>
                        <p>The final step is actually generating the key pair. No matter which type of initialization was used (algorithm-independent or algorithm-specific), the same code is used to generate the <code class="codeph"> KeyPair</code>:
                        </p><pre class="codeblock"><code>    KeyPair pair = keyGen.generateKeyPair();
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" name="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A"></a><h4 id="JSSEC-GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A" class="sect4">Generating and Verifying a Signature Using Generated Keys</h4>
                  <div>
                     <p>Examples of generating and verifying a signature using generated keys.</p>
                     <div class="section">The following signature generation and verification examples use the <code class="codeph">KeyPair</code> generated in the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " dsa" (digital signature algorithm), and use this keypair in future examples. we will generate keys with a 2048-bit modulus. don't care which provider supplies the algorithm implementation.">Generating a Pair of Keys</a> .
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A__GUID-90D8DCA9-8573-4901-AB93-D6D00A0D9CDA">Generating a Signature</p>
                        <p>We first create a Signature Class object:</p><pre class="codeblock"><code>
    Signature dsa = Signature.getInstance("SHA256withDSA");
</code></pre><p>Next, using the key pair generated in the key pair example, we initialize the object with the private key, then sign a byte array called <code class="codeph">data</code>.
                        </p><pre class="codeblock"><code>
   /* Initializing the object with a private key */
    PrivateKey priv = pair.getPrivate();
    dsa.initSign(priv);

   /* Update and sign the data */
    dsa.update(data);
    byte[] sig = dsa.sign();
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7389E94B-A595-4020-A4D2-73FB0DD5A05A__GUID-AF402D39-046E-4E3B-878E-498A51ED5378">Verifying a Signature</p>
                        <p>Verifying the signature is straightforward. (Note that here we also use the key pair generated in the key pair example.)</p><pre class="codeblock"><code>
   /* Initializing the object with the public key */
   PublicKey pub = pair.getPublic();
   dsa.initVerify(pub);

   /* Update and verify the data */
   dsa.update(data);
   boolean verifies = dsa.verify(sig);
   System.out.println("signature verifies: " + verifies);
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" name="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406"></a><h4 id="JSSEC-GUID-5514BAFF-5F0F-403C-9943-56A632D6E406" class="sect4">Generating/Verifying Signatures Using Key Specifications and KeyFactory</h4>
                  <div>
                     <p>Sample code that is used to generate and verify signatures using key specifications and <code class="codeph">KeyFactory</code>.
                     </p>
                     <div class="section">
                        <p>Suppose that, rather than having a public/private key pair (as, for example, was generated in the <a href="java-cryptography-architecture-jca-reference-guide.html#GUID-ED6EDA78-8D20-4059-92E1-FBDDE4D3DFE6" title="In this example we will generate a public-private key pair for the algorithm named " dsa" (digital signature algorithm), and use this keypair in future examples. we will generate keys with a 2048-bit modulus. don't care which provider supplies the algorithm implementation.">Generating a Pair of Keys</a> above), you simply have the components of your DSA private key: <code class="codeph">x</code> (the private key), <code class="codeph">p</code> (the prime), <code class="codeph">q</code> (the sub-prime), and <code class="codeph">g</code> (the base).
                        </p>
                        <p>Further suppose you want to use your private key to digitally sign some data, which is in a byte array named <code class="codeph">someData</code>. You would do the following steps, which also illustrate creating a key specification and using a key factory to obtain a <code class="codeph">PrivateKey</code> from the key specification (<code class="codeph">initSign</code> requires a <code class="codeph">PrivateKey</code>):
                        </p><pre class="codeblock"><code>
    DSAPrivateKeySpec dsaPrivKeySpec = new DSAPrivateKeySpec(x, p, q, g);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PrivateKey privKey = keyFactory.generatePrivate(dsaPrivKeySpec);

    Signature sig = Signature.getInstance("SHA256withDSA");
    sig.initSign(privKey);
    sig.update(someData);
    byte[] signature = sig.sign();
</code></pre><p>Suppose Alice wants to use the data you signed. In order for her to do so, and to verify your signature, you need to send her three things:</p>
                        <ol>
                           <li>The data</li>
                           <li>The signature</li>
                           <li>The public key corresponding to the private key you used to sign the data</li>
                        </ol>
                        <p>You can store the <code class="codeph">someData</code> bytes in one file, and the <code class="codeph">signature</code> bytes in another, and send those to Alice.
                        </p>
                        <p>For the public key, assume, as in the signing example above, you have the components of the DSA public key corresponding to the DSA private key used to sign the data. Then you can create a <code class="codeph">DSAPublicKeySpec</code> from those components:
                        </p><pre class="codeblock"><code>
    DSAPublicKeySpec dsaPubKeySpec = new DSAPublicKeySpec(y, p, q, g);
</code></pre><p>You still need to extract the key bytes so that you can put them in a file. To do so, you can first call the <code class="codeph">generatePublic</code> method on the DSA key factory already created in the example above:
                        </p><pre class="codeblock"><code>  
    PublicKey pubKey = keyFactory.generatePublic(dsaPubKeySpec);
</code></pre><p> Then you can extract the (encoded) key bytes via the following: </p><pre class="codeblock"><code>
    byte[] encKey = pubKey.getEncoded();
</code></pre><p>You can now store these bytes in a file, and send it to Alice along with the files containing the data and the signature.</p>
                        <p>Now, assume Alice has received these files, and she copied the data bytes from the data file to a byte array named <code class="codeph">data</code>, the signature bytes from the signature file to a byte array named <code class="codeph">signature</code>, and the encoded public key bytes from the public key file to a byte array named <code class="codeph">encodedPubKey</code>.
                        </p>
                        <p>Alice can now execute the following code to verify the signature. The code also illustrates how to use a key factory in order to instantiate a DSA public key from its encoding (<code class="codeph">initVerify</code> requires a <code class="codeph">PublicKey</code>).
                        </p><pre class="codeblock"><code>
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encodedPubKey);

    KeyFactory keyFactory = KeyFactory.getInstance("DSA");
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);

    Signature sig = Signature.getInstance("SHA256withDSA");
    sig.initVerify(pubKey);
    sig.update(data);
    sig.verify(signature);
</code></pre><div class="p"> 
                           <div class="infoboxnote" id="GUID-5514BAFF-5F0F-403C-9943-56A632D6E406__GUID-6139C985-28C3-43D0-8F90-5B1DF9F45ABE">
                              <p class="notep1">Note:</p>In the above, Alice needed to generate a <code class="codeph">PublicKey</code> from the encoded key bits, since <code class="codeph">initVerify</code>  requires a <code class="codeph">PublicKey</code> . Once she has a <code class="codeph">PublicKey</code>, she could also use the <code class="codeph">KeyFactory</code><code class="codeph">getKeySpec</code> method to convert it to a <code class="codeph">DSAPublicKeySpec</code>  so that she can access the components, if desired, as in: 
                           </div>
                        </div><pre class="codeblock"><code>
    DSAPublicKeySpec dsaPubKeySpec =
        (DSAPublicKeySpec)keyFactory.getKeySpec(pubKey, DSAPublicKeySpec.class);</code></pre><p>Now she can access the DSA public key components <code class="codeph">y</code>, <code class="codeph">p</code>, <code class="codeph">q</code>, and <code class="codeph">g</code> through the corresponding "get" methods on the <code class="codeph">DSAPublicKeySpec</code> class (<code class="codeph">getY</code>, <code class="codeph">getP</code>, <code class="codeph">getQ</code>, and <code class="codeph">getG</code>). 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-36893ED5-E3CA-496B-BC78-B13EE971C736" name="GUID-36893ED5-E3CA-496B-BC78-B13EE971C736"></a><h4 id="JSSEC-GUID-36893ED5-E3CA-496B-BC78-B13EE971C736" class="sect4">Generating Random Numbers</h4>
                  <div>
                     <p>The following code sample illustrates generating random numbers configured with different security strengths using a DRBG implementation of the <span class="apiname">SecureRandom</span> class:
                     </p>
                     <div class="section"><pre class="pre codeblock"><code>    SecureRandom drbg;
    byte[] buffer = new byte[32];

    // Any DRBG can be provided 
    drbg = SecureRandom.getInstance("DRBG");
    drbg.nextBytes(buffer);

    SecureRandomParameters params = drbg.getParameters();
    if (params instanceof DrbgParameters.Instantiation) {
        DrbgParameters.Instantiation ins = (DrbgParameters.Instantiation) params;
        if (ins.getCapability().supportsReseeding()) {
            drbg.reseed();
        }
    } 

    // The following call requests a weak DRBG instance. It is only
    // guaranteed to support 112 bits of security strength.
    drbg = SecureRandom.getInstance("DRBG",
        DrbgParameters.instantiation(112, NONE, null));

    // Both the next two calls will likely fail, because drbg could be
    // instantiated with a smaller strength with no prediction resistance
    // support.
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(256, false, "more".getBytes()));
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(112, true, "more".getBytes()));

    // The following call requests a strong DRBG instance, with a
    // personalization string. If it successfully returns an instance,
    // that instance is guaranteed to support 256 bits of security strength
    // with prediction resistance available.
    drbg = SecureRandom.getInstance("DRBG", DrbgParameters.instantiation(
        256, PR_AND_RESEED, "hello".getBytes()));

    // Prediction resistance is not requested in this single call,
    // but an additional input is used.
    drbg.nextBytes(buffer,
        DrbgParameters.nextBytes(-1, false, "more".getBytes()));

    // Same for this call.
    drbg.reseed(DrbgParameters.reseed(false, "extra".getBytes()));</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" name="GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC"></a><h4 id="JSSEC-GUID-F7F401C9-63E6-4BE4-9F32-A28B3568EBCC" class="sect4">Determining If Two Keys Are Equal</h4>
                  <div>
                     <p>Example code for determining if two keys are equal.</p>
                     <div class="section">
                        <p>In many cases you would like to know if two keys are equal; however, the default method <code class="codeph">java.lang.Object.equals</code> may not give the desired result. The most provider-independent approach is to compare the encoded keys. If this comparison isn't appropriate (for example, when comparing an <code class="codeph">RSAPrivateKey</code> and an <code class="codeph">RSAPrivateCrtKey</code>), you should compare each component. 
                        </p>
                        <p>The following code demonstrates this idea:</p><pre class="codeblock"><code>
   static boolean keysEqual(Key key1, Key key2) {
       if (key1.equals(key2)) {
          return true;
       }

       if (Arrays.equals(key1.getEncoded(), key2.getEncoded())) {
          return true;
       }

    // More code for different types of keys here.
    // For example, the following code can check if
    // an RSAPrivateKey and an RSAPrivateCrtKey are equal:
    // if ((key1 instanceof RSAPrivateKey) &amp;&amp;
    //     (key2 instanceof RSAPrivateKey)) {
    //     if ((key1.getModulus().equals(key2.getModulus())) &amp;&amp;
    //         (key1.getPrivateExponent().equals(
    //                                      key2.getPrivateExponent()))) {
    //         return true;
    //     }
    // }

        return false;
    }
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8" name="GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8"></a><h4 id="JSSEC-GUID-CD24C31B-45FA-480C-AFCA-C108C01689D8" class="sect4">Reading Base64-Encoded Certificates</h4>
                  <div>
                     <div class="section">
                        <p>The following example reads a file with Base64-encoded certificates, which are each bounded at the beginning by</p><pre class="codeblock"><code>-----BEGIN CERTIFICATE-----
</code></pre><p> and at the end by </p><pre class="codeblock"><code>-----END CERTIFICATE-----
</code></pre><p> We convert the <code class="codeph">FileInputStream</code> (which does not support <code class="codeph">mark</code> and <code class="codeph">reset</code> ) to a <code class="codeph">ByteArrayInputStream</code> (which supports those methods), so that each call to <code class="codeph">generateCertificate</code> consumes only one certificate, and the read position of the input stream is positioned to the next certificate in the file:
                        </p><pre class="codeblock"><code>    try (FileInputStream fis = new FileInputStream(filename);
        BufferedInputStream bis = new BufferedInputStream(fis)) {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        while (bis.available() &gt; 0) {
            Certificate cert = cf.generateCertificate(bis); 
            System.out.println(cert.toString());
        }
   }</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A" name="GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A"></a><h4 id="JSSEC-GUID-8001F1B9-7DBF-4135-A5F3-0042F803E58A" class="sect4">Parsing a Certificate Reply</h4>
                  <div>
                     <div class="section">
                        <p>The following example parses a PKCS7-formatted certificate reply stored in a file and extracts all the certificates from it:</p><pre class="codeblock"><code>
   try (FileInputStream fis = new FileInputStream(filename)) {
      CertificateFactory cf = CertificateFactory.getInstance("X.509");

      Collection&lt;? extends Certificate&gt; c = cf.generateCertificates(fis);
      for (Certificate cert : c) {
          System.out.println(cert);
      }

      // Or use the aggregate operations below for the above for-loop
      // c.stream().forEach(e -&gt; System.out.println(e));
   }</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" name="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF"></a><h4 id="JSSEC-GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF" class="sect4">Using Encryption</h4>
                  <div>
                     <p>This section takes the user through the process of generating a key, creating and initializing a cipher object, encrypting a file, and then decrypting it. Throughout this example, we use the Advanced Encryption Standard (AES).</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF__GUID-00354A2E-2E83-4526-8641-493E8355827F">Generating a Key</p>
                        <p>To create an AES key, we have to instantiate a <span class="apiname">KeyGenerator</span> for AES. We do not specify a provider, because we do not care about a particular AES key generation implementation. Since we do not initialize the <span class="apiname">KeyGenerator</span>, a system-provided source of randomness and a default keysize will be used to create the AES key:
                        </p><pre class="codeblock"><code>
    KeyGenerator keygen = KeyGenerator.getInstance("AES");
    keygen.init(128);
    SecretKey aesKey = keygen.generateKey();
</code></pre><p>After the key has been generated, the same KeyGenerator object can be re-used to create further keys.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AA678E6B-7EAB-44F3-A8CD-F59BEA201BBF__GUID-E7EF09E3-A93B-455B-B8E7-0ACB190996E1">Creating a Cipher</p>
                        <p>The next step is to create a <span class="apiname">Cipher</span> instance. To do this, we use one of the <code class="codeph">getInstance</code> factory methods of the <span class="apiname">Cipher</span> class. We must specify the name of the requested transformation, which includes the following components, separated by slashes (/):
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>the algorithm name</li>
                           <li>the mode (optional)</li>
                           <li>the padding scheme (optional)</li>
                        </ul>
                        <p>In this example, we create an AES cipher in Cipher Block Chaining mode, with PKCS5-style padding. We do not specify a provider, because we do not care about a particular implementation of the requested transformation.</p>
                        <p>The standard algorithm name for AES is "AES", the standard name for the Cipher Block Chaining mode is "CBC", and the standard name for PKCS5-style padding is "PKCS5Padding":</p><pre class="codeblock"><code>
    Cipher aesCipher;

    // Create the cipher
    aesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
</code></pre><p>We use the generated <code class="codeph">aesKey</code> from above to initialize the <span class="apiname">Cipher</span> object for encryption:
                        </p><pre class="codeblock"><code>    // Initialize the cipher for encryption
    aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);

    // Our cleartext
    byte[] cleartext = "This is just an example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = aesCipher.doFinal(cleartext);

    // Retrieve the parameters used during encryption to properly  
    // initialize the cipher for decryption
    AlgorithmParameters params = aesCipher.getParameters();

    // Initialize the same cipher for decryption
    aesCipher.init(Cipher.DECRYPT_MODE, aesKey, params);

    // Decrypt the ciphertext
    byte[] cleartext1 = aesCipher.doFinal(ciphertext);</code></pre><p><code class="codeph">cleartext</code> and <code class="codeph">cleartext1</code> are identical.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4" name="GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4"></a><h4 id="JSSEC-GUID-C9F76AFB-6B20-45A7-B84F-96756C8A94B4" class="sect4">Using Password-Based Encryption</h4>
                  <div>
                     <div class="section">
                        <p>In this example, we prompt the user for a password from which we derive an encryption key.</p>
                        <p>It would seem logical to collect and store the password in an object of type <code class="codeph">java.lang.String</code>. However, here's the caveat: Objects of type <code class="codeph">String</code> are immutable, i.e., there are no methods defined that allow you to change (overwrite) or zero out the contents of a <code class="codeph">String</code> after usage. This feature makes <code class="codeph">String</code> objects unsuitable for storing security sensitive information such as user passwords. You should always collect and store security sensitive information in a char array instead. For that reason, the <code class="codeph">javax.crypto.spec.PBEKeySpec</code> class takes (and returns) a password as a char array.
                        </p>
                        <p>In order to use Password-Based Encryption (PBE) as defined in PKCS5, we have to specify a <span class="variable" translate="no">salt</span> and an <span class="variable" translate="no">iteration count</span>. The same salt and iteration count that are used for encryption must be used for decryption. Newer PBE algorithms use an iteration count of at least 1000.
                        </p><pre class="codeblock"><code>    PBEKeySpec pbeKeySpec;
    PBEParameterSpec pbeParamSpec;
    SecretKeyFactory keyFac;

    // Salt
    byte[] salt = new SecureRandom().nextBytes(salt);

    // Iteration count
    int count = 1000;

    // Create PBE parameter set
    pbeParamSpec = new PBEParameterSpec(salt, count);

    // Prompt user for encryption password.
    // Collect user password as char array, and convert
    // it into a SecretKey object, using a PBE key
    // factory.
    char[] password = System.console.readPassword("Enter encryption password: ");
    pbeKeySpec = new PBEKeySpec(password);
    keyFac = SecretKeyFactory.getInstance("PBEWithHmacSHA256AndAES_256");
    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

    // Create PBE Cipher
    Cipher pbeCipher = Cipher.getInstance("PBEWithHmacSHA256AndAES_256");

    // Initialize PBE Cipher with key and parameters
    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

    // Our cleartext
    byte[] cleartext = "This is another example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = pbeCipher.doFinal(cleartext);

</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" name="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0"></a><h3 id="JSSEC-GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0" class="sect3">Sample Programs for Diffie-Hellman Key Exchange, AES/GCM, and HMAC-SHA256</h3>
               <div>
                  <p>The following are sample programs for Diffie-Hellman key exchange, AES/GCM, and HMAC-SHA256.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-725B837C-9DB3-4B9F-A8D8-1E1C72B558E0__GUID-FDC020B3-4193-4DD5-88E1-4DA6CBDB346E">Topics</p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" title="The program runs the Diffie-Hellman key agreement protocol between 2 parties.">Diffie-Hellman Key Exchange between 2 Parties</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" title="The program runs the Diffie-Hellman key agreement protocol between 3 parties.">Diffie-Hellman Key Exchange between 3 Parties</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" title="The following is a sample program to demonstrate AES/GCM usage to encrypt/decrypt data.">AES/GCM Example</a></p>
                     <p><a href="java-cryptography-architecture-jca-reference-guide.html#GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" title="The following is a sample program that demonstrates how to generate a secret-key object for HMAC-SHA256, and initialize a HMAC-SHA256 object with it.">HMAC-SHA256 Example</a></p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" name="GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4"></a><h4 id="JSSEC-GUID-98B5A57E-E5BA-46F2-BE35-2056F43C58A4" class="sect4">Diffie-Hellman Key Exchange between 2 Parties</h4>
                  <div>
                     <p>The program runs the Diffie-Hellman key agreement protocol  between 2 parties.</p>
                     <div class="section"><pre class="pre codeblock"><code>/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

public class DHKeyAgreement2 {
    private DHKeyAgreement2() {}
    public static void main(String argv[]) throws Exception {
        
        /*
         * Alice creates her own DH key pair with 2048-bit key size
         */
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(2048);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
        
        // Alice creates and initializes her DH KeyAgreement object
        System.out.println("ALICE: Initialization ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());
        
        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
        
        /*
         * Let's turn over to Bob. Bob has received Alice's public key
         * in encoded format.
         * He instantiates a DH public key from the encoded key material.
         */
        KeyFactory bobKeyFac = KeyFactory.getInstance("DH");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(alicePubKeyEnc);

        PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);

        /*
         * Bob gets the DH parameters associated with Alice's public key.
         * He must use the same parameters when he generates his own key
         * pair.
         */
        DHParameterSpec dhParamFromAlicePubKey = ((DHPublicKey)alicePubKey).getParams();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhParamFromAlicePubKey);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Bob creates and initializes his DH KeyAgreement object
        System.out.println("BOB: Initialization ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Bob encodes his public key, and sends it over to Alice.
        byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instantiate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance("DH");
        x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println("ALICE: Execute PHASE1 ...");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * Bob uses Alice's public key for the first (and only) phase
         * of his version of the DH
         * protocol.
         */
        System.out.println("BOB: Execute PHASE1 ...");
        bobKeyAgree.doPhase(alicePubKey, true);

        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        try {
            byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
            int aliceLen = aliceSharedSecret.length;
            byte[] bobSharedSecret = new byte[aliceLen];
            int bobLen;
        } catch (ShortBufferException e) {
            System.out.println(e.getMessage());
        }        // provide output buffer of required size
        bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);
        System.out.println("Alice secret: " +
                toHexString(aliceSharedSecret));
        System.out.println("Bob secret: " +
                toHexString(bobSharedSecret));
        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Shared secrets differ");
        System.out.println("Shared secrets are the same");

        /*
         * Now let's create a SecretKey object using the shared secret
         * and use it for encryption. First, we generate SecretKeys for the
         * "AES" algorithm (based on the raw shared secret data) and
         * Then we use AES in CBC mode, which requires an initialization
         * vector (IV) parameter. Note that you have to use the same IV
         * for encryption and decryption: If you use a different IV for
         * decryption than you used for encryption, decryption will fail.
         *
         * If you do not specify an IV when you initialize the Cipher
         * object for encryption, the underlying implementation will generate
         * a random one, which you have to retrieve using the
         * javax.crypto.Cipher.getParameters() method, which returns an
         * instance of java.security.AlgorithmParameters. You need to transfer
         * the contents of that object (e.g., in encoded format, obtained via
         * the AlgorithmParameters.getEncoded() method) to the party who will
         * do the decryption. When initializing the Cipher for decryption,
         * the (reinstantiated) AlgorithmParameters object must be explicitly
         * passed to the Cipher.init() method.
         */
        System.out.println("Use shared secret as SecretKey object ...");
        SecretKeySpec bobAesKey = new SecretKeySpec(bobSharedSecret, 0, 16, "AES");
        SecretKeySpec aliceAesKey = new SecretKeySpec(aliceSharedSecret, 0, 16, "AES");

        /*
         * Bob encrypts, using AES in CBC mode
         */
        Cipher bobCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobAesKey);
        byte[] cleartext = "This is just an example".getBytes();
        byte[] ciphertext = bobCipher.doFinal(cleartext);

        // Retrieve the parameter that was used, and transfer it to Alice in
        // encoded format
        byte[] encodedParams = bobCipher.getParameters().getEncoded();

        /*
         * Alice decrypts, using AES in CBC mode
         */

        // Instantiate AlgorithmParameters object from parameter encoding
        // obtained from Bob
        AlgorithmParameters aesParams = AlgorithmParameters.getInstance("AES");
        aesParams.init(encodedParams);
        Cipher aliceCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceAesKey, aesParams);
        byte[] recovered = aliceCipher.doFinal(ciphertext);
        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("AES in CBC mode recovered text is " +
                    "different from cleartext");
        System.out.println("AES in CBC mode recovered text is "
                "same as cleartext");
    }

    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private static void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private static String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();
        int len = block.length;
        for (int i = 0; i &lt; len; i++) {
            byte2hex(block[i], buf);
            if (i &lt; len-1) {
                buf.append(":");
            }
        }
        return buf.toString();
    }
}</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" name="GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E"></a><h4 id="JSSEC-GUID-3DADAE4E-EBC1-46CE-A47B-A09AD9E2A01E" class="sect4">Diffie-Hellman Key Exchange between 3 Parties</h4>
                  <div>
                     <p>The program runs the Diffie-Hellman key agreement protocol  between 3 parties.</p>
                     <div class="section"><pre class="codeblock"><code>
/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
   /*
    * This program executes the Diffie-Hellman key agreement protocol between
    * 3 parties: Alice, Bob, and Carol using a shared 2048-bit DH parameter.
    */
    public class DHKeyAgreement3 {
        private DHKeyAgreement3() {}
        public static void main(String argv[]) throws Exception {
        // Alice creates her own DH key pair with 2048-bit key size
            System.out.println("ALICE: Generate DH keypair ...");
            KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
            aliceKpairGen.initialize(2048);
            KeyPair aliceKpair = aliceKpairGen.generateKeyPair();
        // This DH parameters can also be constructed by creating a
        // DHParameterSpec object using agreed-upon values
            DHParameterSpec dhParamShared = ((DHPublicKey)aliceKpair.getPublic()).getParams();
        // Bob creates his own DH key pair using the same params
            System.out.println("BOB: Generate DH keypair ...");
            KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
            bobKpairGen.initialize(dhParamShared);
            KeyPair bobKpair = bobKpairGen.generateKeyPair();
        // Carol creates her own DH key pair using the same params
            System.out.println("CAROL: Generate DH keypair ...");
            KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance("DH");
            carolKpairGen.initialize(dhParamShared);
            KeyPair carolKpair = carolKpairGen.generateKeyPair();
        // Alice initialize
            System.out.println("ALICE: Initialize ...");
            KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
            aliceKeyAgree.init(aliceKpair.getPrivate());
        // Bob initialize
            System.out.println("BOB: Initialize ...");
            KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
            bobKeyAgree.init(bobKpair.getPrivate());
        // Carol initialize
            System.out.println("CAROL: Initialize ...");
            KeyAgreement carolKeyAgree = KeyAgreement.getInstance("DH");
            carolKeyAgree.init(carolKpair.getPrivate());
        // Alice uses Carol's public key
            Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);
        // Bob uses Alice's public key
            Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);
        // Carol uses Bob's public key
            Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false);
        // Alice uses Carol's result from above
            aliceKeyAgree.doPhase(cb, true);
        // Bob uses Alice's result from above
            bobKeyAgree.doPhase(ac, true);
        // Carol uses Bob's result from above
            carolKeyAgree.doPhase(ba, true);
        // Alice, Bob and Carol compute their secrets
            byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
            System.out.println("Alice secret: " + toHexString(aliceSharedSecret));
            byte[] bobSharedSecret = bobKeyAgree.generateSecret();
            System.out.println("Bob secret: " + toHexString(bobSharedSecret));
            byte[] carolSharedSecret = carolKeyAgree.generateSecret();
            System.out.println("Carol secret: " + toHexString(carolSharedSecret));
        // Compare Alice and Bob
            if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
                throw new Exception("Alice and Bob differ");
            System.out.println("Alice and Bob are the same");
        // Compare Bob and Carol
            if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))
                throw new Exception("Bob and Carol differ");
            System.out.println("Bob and Carol are the same");
        }
    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
        private static void byte2hex(byte b, StringBuffer buf) {
            char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                                '9', 'A', 'B', 'C', 'D', 'E', 'F' };
            int high = ((b &amp; 0xf0) &gt;&gt; 4);
            int low = (b &amp; 0x0f);
            buf.append(hexChars[high]);
            buf.append(hexChars[low]);
        }
    /*
     * Converts a byte array to hex string
     */
        private static String toHexString(byte[] block) {
            StringBuffer buf = new StringBuffer();
            int len = block.length;
            for (int i = 0; i &lt; len; i++) {
                byte2hex(block[i], buf);
                if (i &lt; len-1) {
                    buf.append(":");
                }
            }
            return buf.toString();
        }
    }
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" name="GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85"></a><h4 id="JSSEC-GUID-BCF9A664-EA76-49C9-AB0C-662FD7542B85" class="sect4">AES/GCM Example</h4>
                  <div>
                     <p>The following is a sample program to demonstrate AES/GCM usage to encrypt/decrypt data. </p><pre class="pre codeblock"><code>/*
 * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.AlgorithmParameters;
import java.util.Arrays;
import javax.crypto.*;

public class AESGCMTest {

    public static void main(String[] args) throws Exception {
        // Slightly longer than 1 AES block (128 bits) to show PADDING
        // is "handled" by GCM.
        byte[] data = {
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
            0x10};

        // Create a 128-bit AES key.
        KeyGenerator kg = KeyGenerator.getInstance("AES");
        kg.init(128);
        SecretKey key = kg.generateKey();

        // Obtain a AES/GCM cipher to do the enciphering. Must obtain
        // and use the Parameters for successful decryption.
        Cipher encCipher = Cipher.getInstance("AES/GCM/NOPADDING");
        encCipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] enc = encCipher.doFinal(data);
        AlgorithmParameters ap = encCipher.getParameters();

        // Obtain a similar cipher, and use the parameters.
        Cipher decCipher = Cipher.getInstance("AES/GCM/NOPADDING");
        decCipher.init(Cipher.DECRYPT_MODE, key, ap);
        byte[] dec = decCipher.doFinal(enc);

        if (Arrays.compare(data, dec) != 0) {
            throw new Exception("Original data != decrypted data");
        }
    }
}</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" name="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A"></a><h4 id="JSSEC-GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A" class="sect4">HMAC-SHA256 Example</h4>
                  <div>
                     <p>The following is a sample program that demonstrates how to generate a secret-key object for  HMAC-SHA256, and initialize a HMAC-SHA256 object with it.</p>
                     <div class="example" id="GUID-1B141C6A-7BB3-4DA2-A112-ADEBCE7F4B4A__GUID-4C1C7226-F8A7-4780-8B85-40DFD7702C31">
                        <p class="titleinexample">Example 2-14 Generate a Secret-key Object for HMAC-SHA256</p><pre class="codeblock"><code>/*
 * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.*;
import javax.crypto.*;

    /**
     * This program demonstrates how to generate a secret-key object for
     * HMACSHA256, and initialize an HMACSHA256 object with it.
     */

    public class initMac {

        public static void main(String[] args) throws Exception {

            // Generate secret key for HmacSHA256
            KeyGenerator kg = KeyGenerator.getInstance("HmacSHA256");
            SecretKey sk = kg.generateKey();

            // Get instance of Mac object implementing HmacSHA256, and
            // initialize it with the above secret key
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(sk);
            byte[] result = mac.doFinal("Hi There".getBytes());
        }
    }
</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
