<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <meta name="description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <title>Serialization Filtering</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-20T08:11:40-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E94895-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="java-core-libraries1.html" title="Previous" type="text/html">
      <link rel="next" href="enhanced-deprecation1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-core-libraries1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="enhanced-deprecation1.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Core Libraries</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Serialization Filtering</li>
            </ol>
            <a id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" name="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A"></a>
            
            <h2 id="JSCOR-GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" class="sect2"><span class="enumeration_chapter">2 </span>Serialization Filtering
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A__GUID-A1F99FA7-F03B-4A05-AC6A-BBC71C48F7D2">Topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" title="An application that accepts untrusted data and deserializes it is vulnerable to attacks. You can create filters to screen incoming streams of serialized objects before they are deserialized.">Addressing Deserialization Vulnerabilities</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" title="The Java serialization filtering mechanism screens incoming streams of serialized objects to help improve security and robustness. Filters can validate incoming classes before they are deserialized.">Java Serialization Filters</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" title="Whitelists and blacklists can be implemented using pattern-based filters or custom filters. These lists allow you to take proactive and defensive approaches to protect your applications.">Whitelists and Blacklists</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-91735293-E38E-4A81-85DC-719AFEB36026" title="Pattern-based filters are filters that you define without changing your application code. You add process-wide filters in properties files, or application-specific filters on the java command line.">Creating Pattern-Based Filters</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" title="Custom filters are filters you specify in your application’s code. They are set on an individual stream or on all streams in a process. You can implement a custom filter as a pattern, a method, a lambda expression, or a class.">Creating Custom Filters</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.">Built-in Filters</a></p>
                     </li>
                     <li>
                        <p><a href="serialization-filtering1.html#GUID-6A048F49-052E-4591-9183-2775DC50831E" title="You can turn on logging to record the initialization, rejections, and acceptances of calls to serialization filters. Use the log output as a diagnostic tool to see what's being deserialized, and to confirm your settings when you configure whitelists and blacklists.">Logging Filter Actions</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" name="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480"></a><h3 id="JSCOR-GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" class="sect3">Addressing Deserialization Vulnerabilities </h3>
               <div>
                  <p>An application that accepts untrusted data and deserializes it is vulnerable to attacks. You can create filters to screen incoming streams of serialized objects before they are deserialized. </p>
                  <p>An object is serialized when its state is converted to a byte stream. That stream can be sent to a file, to a database, or over a network. A Java object is serializable if its class or any of its superclasses implements either the <span class="apiname">java.io.Serializable</span> interface or the <span class="apiname">java.io.Externalizable</span> subinterface. In the JDK, serialization is used in many areas, including &nbsp;Remote Method Invocation (RMI), custom RMI for interprocess communication (IPC) protocols (such as the Spring HTTP invoker), Java Management Extensions (JMX), and Java Messaging Service (JMS).
                  </p>
                  <p>An object is deserialized when its serialized form is converted to a copy of the object. It is important to ensure the security of this conversion. Deserialization is code execution, because the <span class="apiname">readObject</span> method of the class that is being deserialized can contain custom code.&nbsp;Serializable classes, also known as <span class="q">"gadget classes"</span>, can do arbitrary reflective actions such as create classes and invoke methods on them.&nbsp;If your application deserializes these classes, they can cause a denial of service or remote code execution. 
                  </p>
                  <p>When you create a filter, you can specify which classes are acceptable to an application, and which should be rejected. You can control the object graph size and complexity during deserialization so that the object graph doesn’t exceed reasonable limits. Filters can be configured as properties, or implemented programmatically.</p>
                  <div class="p">Besides creating filters, you can take the following actions to help prevent deserialization vulnerabilities:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Do not deserialized untrusted data.</p>
                        </li>
                        <li>
                           <p>Use SSL to encrypt and authenticate the connections between applications.</p>
                        </li>
                        <li>
                           <p>Validate field values before assignment, including checking object invariants by using the <span class="apiname">readObject</span> method. 
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnote" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-87B52F1C-9D44-483B-80AA-B2C8A4B0C06E">
                     <p class="notep1">Note:</p>Built-in filters are provided for RMI. However, you should use these built-in filters as starting points only. Configure blacklists and/or extend the whitelist to add additional protection for your application that uses RMI. See <a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.">Built-in Filters</a>.
                  </div>
                  <p>For more information about these and other strategies, see <span class="q">"Serialization and Deserialization"</span> in <a href="http://www.oracle.com/technetwork/java/seccodeguide-139067.html" target="_blank">Secure Coding Guidelines for Java SE</a>.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" name="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66"></a><h3 id="JSCOR-GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" class="sect3">Java Serialization Filters</h3>
               <div>
                  <p>The Java serialization filtering mechanism screens incoming streams of serialized objects to help improve security and robustness. Filters can validate incoming classes before they are deserialized.</p>
                  <div class="p">As stated in JEP 290, the goals of the Java serialization filtering mechanism are to:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Provide a way to narrow the classes that can be deserialized down to a context-appropriate set of classes.</p>
                        </li>
                        <li>
                           <p>Provide metrics to the filter for graph size and complexity during deserialization to validate normal graph behaviors.</p>
                        </li>
                        <li>
                           <p>Allow RMI-exported objects to validate the classes expected in invocations.</p>
                        </li>
                     </ul>
                  </div>
                  <p>You can implement serialization filters in the following ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Pattern-based filters do not require you to modify your application. They consist of a sequence of patterns that are defined in properties, in a configuration file or on the command line. Pattern-based filters can accept or reject specific classes, packages, or modules. They can place limits on array sizes, graph depth, total references, and stream size. A typical use case is to blacklist classes that have been identified as potentially compromising the Java runtime. Pattern-based filters are defined for one application or all applications in a process.</p>
                     </li>
                     <li>
                        <p>Custom filters are implemented using the <span class="apiname">ObjectInputFilter</span> API. They allow an application to integrate finer control than pattern-based filters, because they can be specific to each <span class="apiname">ObjectInputStream</span>. Custom filters are set on an individual input stream or on all streams in a process.
                        </p>
                     </li>
                  </ul>
                  <p>The filter mechanism is called for each new object in the stream. If more than one active filter (process-wide filter, application filter, or stream-specific filter) exists, only the most specific filter is called. </p>
                  <p> In most cases, a custom filter should check if a process-wide filter is set. If one exists, the custom filter should invoke it and use the process-wide filter’s result, unless the status is <code class="codeph">UNDECIDED</code>.
                  </p>
                  <p>Support for serialization filters is included starting with JDK 9, and in Java CPU releases starting with 8u121, 7u131, and 6u141.</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" name="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25"></a><h3 id="JSCOR-GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" class="sect3">Whitelists and Blacklists</h3>
               <div>
                  <p>Whitelists and blacklists can be implemented using pattern-based filters or custom filters. These lists allow you to take proactive and defensive approaches to protect your applications. </p>
                  <p>The proactive approach uses whitelists to accept only the classes that are recognized and trusted. You can implement whitelists in your code when you develop your application, or later by defining pattern-based filters. If your application only deals with a small set of classes then this approach can work very well. You can implement whitelists by specifying the classes, packages, or modules that are allowed.</p>
                  <p>The defensive approach uses blacklists to reject classes that are not trusted. Usually, blacklists are implemented after an attack that reveals that a class is a problem. A class can be added to a blacklist, without a code change, by defining a pattern-based filter.</p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-91735293-E38E-4A81-85DC-719AFEB36026" name="GUID-91735293-E38E-4A81-85DC-719AFEB36026"></a><h3 id="JSCOR-GUID-91735293-E38E-4A81-85DC-719AFEB36026" class="sect3">Creating Pattern-Based Filters</h3>
               <div>
                  <p>Pattern-based filters are filters that you define without changing your application code. You add process-wide filters in properties files, or application-specific filters on the <code class="codeph">java</code> command line.
                  </p>
                  <p>A pattern-based filter is a sequence of patterns. Each pattern is matched against the name of a class in the stream or a resource limit. Class-based and resource limit patterns can be combined in one filter string, with each pattern separated by a semicolon (;). </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-EC22FEC6-A855-4152-9049-23F38E590256">Pattern-based Filter Syntax</p>
                     <div class="p">When you create a filter that is composed of patterns, use the following guidelines:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Separate patterns by semicolons. For example:</p><pre class="pre codeblock"><code>pattern1.*;pattern2.*</code></pre></li>
                           <li>
                              <p>White space is significant and is considered part of the pattern.</p>
                           </li>
                           <li>
                              <p>Put the limits first in the string. They are evaluated first regardless of where they are in the string, so putting them first reinforces the ordering. Otherwise, patterns are evaluated from left to right.</p>
                           </li>
                           <li>
                              <div class="p">A class that matches a pattern that is preceded by <code class="codeph">!</code> is rejected. A class that matches a pattern without <code class="codeph">!</code> is accepted. The following filter rejects <code class="codeph">pattern1.MyClass</code> but accepts <code class="codeph">pattern2.MyClass</code>:  <pre class="pre codeblock"><code>!pattern1.*;pattern2.*</code></pre></div>
                           </li>
                           <li>
                              <div class="p">Use the wildcard symbol (<code class="codeph">*</code>) to represent unspecified classes in a pattern as shown in the following examples: 
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>To match every class, use <code class="codeph">*</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p>To match every class in <code class="codeph">mypackage</code>, use <code class="codeph">mypackage.*</code> 
                                       </p>
                                    </li>
                                    <li>
                                       <p>To match every class in <code class="codeph">mypackage</code> and its subpackages, use <code class="codeph">mypackage.**</code></p>
                                    </li>
                                    <li>
                                       <p>To  match every class that starts with <code class="codeph">text</code>, use <code class="codeph">text*</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p>If a class doesn’t match any filter, then it is accepted. If you want to accept only certain classes, then your filter must reject everything that doesn’t match. To reject all classes other than those specified, include <code class="codeph">!*</code> as the last pattern in a class filter.
                     </p>
                     <p>For a complete description of the syntax for the patterns, see the <code class="codeph">conf/security/java.security</code> file, or see <a href="http://openjdk.java.net/jeps/290" target="_blank">JEP 290</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-B3365B18-7AA0-4B9A-A305-DD22D21F0602">Pattern-Based Filter Limitations</p>
                     <p>Pattern-based filters are used for simple acceptance or rejection. These filters have some limitations. For example:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Patterns can’t allow different sizes of arrays based on the class.</p>
                        </li>
                        <li>
                           <p>Patterns can’t match classes based on the supertype or interfaces of the class.</p>
                        </li>
                        <li>
                           <p>Patterns have no state and can’t make choices depending on the earlier classes deserialized in the stream.</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5D6D5344-3E6F-468E-8CBB-05767E04B254">Define a Pattern-Based Filter for One Application</p>
                     <p>You can define a pattern-based filter as a system property for one application. A system property supersedes a Security Property value.</p>
                     <p>To create a filter that only applies to one application, and only to a single invocation of Java, define the <code class="codeph">jdk.serialFilter</code> system property in the command line. 
                     </p>
                     <p>The following example shows how to limit resource usage for an individual application:</p><pre class="pre codeblock"><code>java -Djdk.serialFilter=maxarray=100000;maxdepth=20;maxrefs=500&nbsp;com.example.test.Application</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__DEFINEAPATTERN-BASEDFILTERFORONEAPP-631AE055">Define a Pattern-Based Filter for All Applications in a Process</p>
                     <p>You can define a pattern-based filter as a Security Property, for all applications in a process. A system property supersedes a Security Property value.</p>
                     <ol>
                        <li>
                           <div class="p">Edit the <code>java.security</code> properties file.
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>JDK 9 and later: <code>$JAVA_HOME/conf/security/java.security</code></p>
                                 </li>
                                 <li>
                                    <p>JDK 8,7,6: <code>$JAVA_HOME/lib/security/java.security</code>&nbsp; 
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>Add the pattern to the <code class="codeph">jdk.serialFilter</code> Security Property.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5CE8B605-78A3-4B10-9DE8-5108EEB452A7">Define a Class Filter</p>
                     <p>You can create a pattern-based class filter that is applied globally. For example, the pattern might be a class name or a package with wildcard.</p>
                     <div class="p">In the following example, the filter rejects one class from a package (<code class="codeph">!example.somepackage.SomeClass</code>), and accepts all other classes in the package: <pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;</code></pre></div>
                     <div class="p">The previous example filter accepts all other classes, not just those in <code class="codeph">example.somepackage.*</code>. To reject all other classes, add <code class="codeph">!*</code>:<pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;<span class="bold">!*</span></code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-F0AE9610-1379-44D6-A051-8F67E5522065">Define a Resource Limit Filter</p>
                     <div class="p">A resource filter limits graph complexity and size. You can create filters for the following parameters to control the resource usage for each application:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Maximum allowed array size. For example: <code class="codeph">maxarray=100000;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum depth of a graph. For example: <code class="codeph">maxdepth=20;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum references in a graph between objects. For example: <code class="codeph">maxrefs=500;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum number of bytes in a stream. For example: <code class="codeph">maxbytes=500000;</code> 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" name="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E"></a><h3 id="JSCOR-GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" class="sect3">Creating Custom Filters</h3>
               <div>
                  <p>Custom filters are filters you specify in your application’s code. They are set on an individual stream or on all streams in a process. You can implement a custom filter as a pattern, a method, a lambda expression, or a class.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__DESERIALIZINGOBJECTSFROMASTREAM-50A5362A">Reading a Stream of Serialized Objects</p>
                     <p>You can set a custom filter on one <code class="codeph">ObjectInputStream</code>, or, to apply the same filter to every stream, set a process-wide filter. If an <code class="codeph">ObjectInputStream</code> doesn’t have a filter defined for it, the process-wide filter is called, if there is one.
                     </p>
                     <p>While the stream is being decoded, the following actions occur:</p>
                     <ul style="list-style-type: disc;">
                        <li> 
                           <p>For each new object in the stream, the filter is called before the object is instantiated and deserialized. </p>
                        </li>
                        <li>
                           <p>For each class in the stream, the filter is called with the resolved class. It is called separately for each supertype and interface in the stream. </p>
                        </li>
                        <li>
                           <p>The filter can examine each class referenced in the stream, including the class of objects to be created, supertypes of those classes, and their interfaces.</p>
                        </li>
                        <li>
                           <p>For each array in the stream, whether it is an array of primitives, array of strings, or array of objects, the filter is called with the array class and the array length.</p>
                        </li>
                        <li>
                           <p>For each reference to an object already read from the stream, the filter is called so it can check the depth, number of references, and stream length. The depth starts at&nbsp;1&nbsp;and increases for each nested object and decreases when each nested call returns.</p>
                        </li>
                        <li>
                           <p>The filter is not called for primitives or for <span class="apiname">java.lang.String</span> instances that are encoded concretely in the stream. 
                           </p>
                        </li>
                        <li>
                           <p>The filter returns a status of accept, reject, or undecided.</p>
                        </li>
                        <li>
                           <p>Filter actions are logged if logging is enabled.</p>
                        </li>
                     </ul>
                     <p>Unless a filter rejects the object, the object is accepted.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__SETTINGAFILTERFORANINDIVIDUALSTREAM-51012200">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-8BB4703B-04A7-4205-9257-7B79C9BB96D4">Setting a Custom Filter for an Individual Stream</p>
                     <p>You can set a filter on an individual <span class="apiname">ObjectInputStream</span> when the input to the stream is untrusted and the filter has a limited set of classes or constraints to enforce. For example, you could ensure that a stream only contains numbers, strings, and other application-specified types. 
                     </p>
                     <p>A custom filter is set using the <span class="apiname">setObjectInputFilter​</span> method. The custom filter must be set before objects are read from the stream.
                     </p>
                     <p>In the following example, the <span class="apiname">setObjectInputFilter</span>method is invoked with the <code class="codeph">dateTimeFilter</code> method. This filter only accepts classes from the <span class="apiname">java.time</span> package. The <code class="codeph">dateTimeFilter</code> method is defined in a code sample in <a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__IMPLEMENTINGACUSTOMFILTERASAMETHOD-54AED1D7">Setting a Custom Filter as a Method</a>.
                     </p>
                     <div class="p"><pre class="pre codeblock"><code>    LocalDateTime readDateTime(InputStream is) throws IOException {
        try (ObjectInputStream ois = new ObjectInputStream(is)) {
            ois.setObjectInputFilter(FilterClass::dateTimeFilter);
            return (LocalDateTime) ois.readObject();
        } catch (ClassNotFoundException ex) {
            IOException ioe = new StreamCorruptedException("class missing");
            ioe.initCause(ex);
            throw ioe;
        }
    }</code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-182FDEED-AA81-4EFF-9762-76390C1AACFE">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-02A2A232-D1EE-48C5-9456-DA11C24BA5A7">Setting a Process-Wide Custom Filter</p>
                     <p>You can set a process-wide filter that applies to every use of <span class="apiname">ObjectInputStream</span> unless it is overridden on a specific stream. If you can identify every type and condition that is needed by the entire application, the filter can allow those and reject the rest. Typically, process-wide filters are used to reject specific classes or packages, or to limit array sizes, graph depth, or total graph size.
                     </p>
                     <p>A process-wide filter is set once using the methods of the <span class="apiname">ObjectInputFilter.Config</span> class. The filter can be an instance of a class, a lambda expression, a method reference, or a pattern.
                     </p><pre class="pre codeblock"><code>    ObjectInputFilter filter = ...
    ObjectInputFilter.Config.setSerialFilter(filter);
</code></pre><p>In the following example, the process-wide filter is set by using a lambda expression.</p><pre class="pre codeblock"><code>    ObjectInputFilter.Config.setSerialFilter(info -&gt; info.depth() &gt; 10 ? Status.REJECTED : Status.UNDECIDED);
</code></pre><p>In the following example, the process-wide filter is set by using an instance of a class.</p><pre class="pre codeblock"><code>    ObjectInputFilter.Config.setSerialFilter(FilterClass::dateTimeFilter);</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-57F34BA4-3982-421D-89CD-F4C83FC7EF0B">Setting a Custom Filter Using a Pattern</p>
                     <p>A pattern-based custom filter, which is convenient for simple cases, can be created by using the <span class="apiname">ObjectInputFilter.Config.createFilter</span> method. You can create a pattern-based filter as a system property or Security Property. Implementing a pattern-based filter as a method or a lambda expression gives you more flexibility.
                     </p>
                     <p>The filter patterns can accept or reject specific classes, packages, modules, and can place limits on array sizes, graph depth, total references, and stream size.  Patterns cannot match the supertype or interfaces of the class.</p>
                     <div class="p">In the following example, the filter allows <code class="codeph">example.File</code> and rejects <code class="codeph">example.Directory</code> classes.<pre class="pre codeblock"><code>    ObjectInputFilter filesOnlyFilter = ObjectInputFilter.Config.createFilter("example.File;!example.Directory");
</code></pre></div>
                     <div class="p">This example allows only <code class="codeph">example.File</code>. All other classes are rejected.<pre class="pre codeblock"><code>    ObjectInputFilter filesOnlyFilter = ObjectInputFilter.Config.createFilter("example.File;!*");
</code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-50E87F6F-2E7B-4F73-9E1B-ADD031551256">Setting a Custom Filter as a Class</p>
                     <p>A custom filter can be implemented as a class implementing the <span class="apiname">java.io.ObjectInputFilter</span> interface, as a lambda expression, or as a method. 
                     </p>
                     <p>A filter is typically stateless and performs checks solely on the input parameters.&nbsp; However, you may implement a filter that, for example, maintains state between calls to the <code class="codeph">checkInput</code> method to count artifacts in the stream.
                     </p>
                     <p>In the following example, the <code class="codeph">FilterNumber</code> class allows any object that is an instance of the <code class="codeph">Number</code> class and rejects all others.
                     </p><pre class="pre codeblock"><code>    class FilterNumber implements ObjectInputFilter {
        public Status checkInput(FilterInfo filterInfo) {
            Class&lt;?&gt; clazz = filterInfo.serialClass();
            if (clazz != null) {
                return (Number.class.isAssignableFrom(clazz)) ? Status.ALLOWED : Status.REJECTED;
            }
            return Status.UNDECIDED;
        }
    }</code></pre><p>In the example:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The <code class="codeph">checkInput</code> method accepts an <code class="codeph">ObjectInputFilter.FilterInfo</code> object.&nbsp; The object’s methods provide access to the class to be checked, array size, current depth, number of references to existing objects, and stream size read so far.
                           </p>
                        </li>
                        <li>
                           <p>If <code class="codeph">serialClass</code> is not null, indicating that a new object is being created, the value is checked to see if the class of the object is <code class="codeph">Number</code>. If so, it is accepted, otherwise it is rejected.
                           </p>
                        </li>
                        <li>
                           <p>Any other combination of arguments returns <code class="codeph">UNDECIDED</code>. Deserialization continues, and any remaining filters are run until the object is accepted or rejected. If there are no other filters, the object is accepted.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__IMPLEMENTINGACUSTOMFILTERASAMETHOD-54AED1D7">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-2D9120BA-1262-4CD0-8C0F-2D7B2FE09DC7">Setting a Custom Filter as a Method</p>
                     <p>A custom filter can also be implemented as a method. The method reference is used instead of an inline lambda expression. </p>
                     <p>The <code class="codeph">dateTimeFilter</code> method that is defined in the following example is used by the code sample in <a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__SETTINGAFILTERFORANINDIVIDUALSTREAM-51012200">Setting a Custom Filter for an Individual Stream</a>.
                     </p><pre class="pre codeblock"><code>    public class FilterClass {
        static ObjectInputFilter.Status dateTimeFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getPackageName().equals("java.time")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
        }
    }</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-8C13D401-0AF8-4E0D-8240-798915982690">Example: Filter for Classes in the java.base Module</p>
                     <p>This custom filter, which is also implemented as a method, allows only the classes found in the base module of the JDK. This example works with JDK 9 and later.</p><pre class="pre codeblock"><code>        static ObjectInputFilter.Status baseFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getModule().getName().equals("java.base")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
       }</code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" name="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841"></a><h3 id="JSCOR-GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" class="sect3">Built-in Filters</h3>
               <div>
                  <p>The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-4A6545F6-C1BA-4F4B-B5FB-1A0FFC17EE58">Filters for RMI Registry</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-2EDDE4F4-6635-4724-BE9B-E250436F23AE">
                        <p class="notep1">Note:</p>Use these built-in filters as starting points only. Edit the <code class="codeph">sun.rmi.registry.registryFilter</code> system property to configure blacklists and/or extend the whitelist to add additional protection for the RMI Registry. To protect the whole application, add the patterns to the <code class="codeph">jdk.serialFilter</code> global system property to increase protection for other serialization users that do not have their own custom filters.
                     </div>
                     <p>The RMI Registry has a built-in whitelist filter that allows objects to be bound in the registry. It includes instances of the <code class="codeph">java.rmi.Remote</code>, <code class="codeph">java.lang.Number</code>, <code class="codeph">java.lang.reflect.Proxy</code>, <code class="codeph">java.rmi.server.UnicastRef</code>,  <code class="codeph">java.rmi.activation.ActivationId</code>, <code class="codeph">java.rmi.server.UID</code>, <code class="codeph">java.rmi.server.RMIClientSocketFactory</code>,  and <code class="codeph">java.rmi.server.RMIServerSocketFactory</code> classes.
                     </p>
                     <div class="p">The built-in filter includes size limits:&nbsp;<pre class="pre codeblock"><code> maxarray=1000000,maxdepth=20</code></pre></div>
                     <p>Supersede the built-in filter by defining a filter using the <code class="codeph">sun.rmi.registry.registryFilter</code> system property with a pattern. If the filter that you define either accepts classes passed to the filter, or rejects classes or sizes, the built-in filter is not invoked.&nbsp; If your filter does not accept or reject anything, the built-filter is invoked.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-1FA9EA68-C15E-4D08-B938-368EB4B3CF58">Filters for RMI Distributed Garbage Collector</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-5C6D93BF-3B7B-41DA-9F7C-A1D387A9A2F6">
                        <p class="notep1">Note:</p>Use these built-in filters as starting points only. Edit the <code class="codeph">sun.rmi.transport.dgcFilter</code> system property to configure blacklists and/or extend the whitelist to add additional protection for Distributed Garbage Collector.  To protect the whole application, add the patterns to the <code class="codeph">jdk.serialFilter</code> global system property to increase protection for other serialization users that do not have their own custom filters.
                     </div>
                     <p>The RMI Distributed Garbage Collector has a built-in whitelist filter that accepts a limited set of classes. It includes instances of the <code class="codeph">java.rmi.server.ObjID</code>, <code class="codeph">java.rmi.server.UID</code>, <code class="codeph">java.rmi.dgc.VMID</code>, and <code class="codeph">java.rmi.dgc.Lease</code> classes.
                     </p>
                     <div class="p">The built-in filter includes size limits:&nbsp; <pre class="pre codeblock"><code>maxarray=1000000,maxdepth=20</code></pre></div>
                     <p>Supersede the built-in filter by defining a filter using the <code class="codeph">sun.rmi.transport.dgcFilter</code> system property with a pattern. If the filter accepts classes passed to the filter, or rejects classes or sizes, the built-in filter is not invoked.&nbsp; If the superseding filter does not accept or reject anything, the built-filter is invoked.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-AD9BEFEA-80D5-49C8-88EC-766F2D2BE3C9">Filters for JMX</p>You can specify the deserialization filter pattern strings to be used while making an <span class="apiname">RMIServer.newClient</span> remote call and while sending deserializing parameters over RMI to the server. You can also provide a filter pattern string to the default agent by using the <code class="codeph">management.properties</code> file.
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6A048F49-052E-4591-9183-2775DC50831E" name="GUID-6A048F49-052E-4591-9183-2775DC50831E"></a><h3 id="JSCOR-GUID-6A048F49-052E-4591-9183-2775DC50831E" class="sect3">Logging Filter Actions</h3>
               <div>
                  <p>You can turn on logging to record the initialization, rejections, and acceptances of calls to serialization filters. Use the log output as a diagnostic tool to see what's being deserialized, and to confirm your settings when you configure whitelists and blacklists.</p>
                  <p> When logging is enabled, filter actions are logged to the <span class="apiname">java.io.serialization</span> logger. 
                  </p>
                  <p>To enable serialization filter logging, edit the <code class="codeph">$JDK_HOME/conf/logging.properties</code> file.
                  </p>
                  <div class="p">To log calls that are rejected, add <pre class="pre codeblock"><code>java.io.serialization.level = FINER</code></pre> </div>
                  <div class="p">To log all filter results, add <pre class="pre codeblock"><code>java.io.serialization.level = FINEST</code></pre> </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
