<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Using JConsole</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Monitoring and Management Guide">
      <meta property="og:description" content>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Monitoring and Management Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-se-monitoring-and-management-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2018-09-21T10:39:15-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2006, 2018">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="E95200-01">
      
      <meta name="dcterms.product" content="en/java/javase/11">
      <meta name="dcterms.release" content="11">
      <link rel="prev" href="monitoring-and-management-using-jmx-technology.html" title="Previous" type="text/html">
      <link rel="next" href="using-platform-mbean-server-and-platform-mxbeans.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"11","element_name":"11","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java SE Monitoring and Management Guide">
    <meta name="dcterms.isVersionOf" content="MANAGEMENT">
  <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="monitoring-and-management-using-jmx-technology.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-platform-mbean-server-and-platform-mxbeans.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Monitoring and Management Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Using JConsole</li>
            </ol>
            <a id="GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5" name="GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5"></a>
            
            <h2 id="JSMGM-GUID-77416B38-7F15-4E35-B3D1-34BFD88350B5" class="sect2"><span class="enumeration_chapter">3 </span>Using JConsole
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>The JConsole graphical user interface is a monitoring tool that complies with the Java Management Extensions (JMX) specification. JConsole uses the extensive instrumentation of the Java Virtual Machine (Java VM) to provide information about the performance and resource consumption of applications running on the Java platform.</p>
               <p>JConsole has been updated to present the look and feel of the Windows and GNOME desktops (other platforms will present the standard Java graphical look and feel). The screen captures presented in this document are taken from an instance of the interface running on Windows XP.</p>
            </div>
            <div class="sect2"><a id="GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955" name="GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955"></a><h3 id="JSMGM-GUID-A2AE31B2-6C50-47B4-B854-5212C5AE4955" class="sect3">Starting JConsole</h3>
               <div>
                  <p>The <code class="codeph">jconsole</code> executable file can be found in <code class="codeph"><span class="codeinlineitalic">JDK_HOME</span>/bin</code>, where <code class="codeph"><span class="codeinlineitalic">JDK_HOME</span></code> is the directory in which the Java Development Kit (JDK) is installed. If this directory is in your system path, then you can start JConsole by simply entering <code class="codeph">jconsole</code> in a command (shell) prompt. Otherwise, you have to enter the full path to the executable file.
                  </p>
               </div>
               <div class="sect3"><a id="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE" name="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE"></a><h4 id="JSMGM-GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE" class="sect4">Command Syntax</h4>
                  <div>
                     <p>You can use JConsole to monitor both local applications, namely those running on the same system as JConsole, as well as remote applications, namely those running on other systems.</p>
                     <div class="infoboxnote" id="GUID-0FAC766D-A99A-4E98-B6BC-1D5711C71CAE__GUID-C7398F1E-047B-4390-B8DC-A94BAF6F98BE">
                        <p class="notep1">Note:</p> Using JConsole to monitor a local application is useful for development and for creating prototypes, but is not recommended for production environments, because JConsole itself consumes significant system resources. Remote monitoring is recommended to isolate the JConsole application from the platform being monitored.
                     </div>
                     <p>See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&amp;id=JSWOR-GUID-02BB4CB1-9C56-436A-9CEC-6D61984D48C1" target="_blank"><code class="codeph">jconsole</code></a> in the <span><cite>Java Platform, Standard Edition Tools Reference</cite></span> for the complete syntax. 
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE" name="GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE"></a><h5 id="JSMGM-GUID-EFDD2B40-6E4B-45E9-84B2-5E6D609065AE" class="sect5">Setting Up Local Monitoring</h5>
                     <div>
                        <p>Start JConsole using the following command:</p><pre class="pre codeblock"><code>% jconsole
</code></pre><p>When JConsole starts, select the required Java applications running locally that JConsole can connect to.</p>
                        <p>If you want to monitor a specific application, and you know that application's process ID, then start JConsole so that it connects to that application. This application must be running with the same user ID as JConsole. Use the following command syntax to start JConsole for local monitoring of a specific application:</p><pre class="pre codeblock"><code>% jconsole <span class="variable" translate="no">processID</span>
</code></pre><p><code class="codeph"><span class="variable" translate="no">processID</span></code> is the application's process ID (PID). You can determine an application's PID in the following ways:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>On Solaris, Linux, or macOS systems, you can use the <code class="codeph">ps</code> command to find the PID of the <code class="codeph">java</code> instance that is running.
                              </p>
                           </li>
                           <li>
                              <p>On Windows systems, you can use the Task Manager to find the PID of <code class="codeph">java</code> or <code class="codeph">javaw</code>.
                              </p>
                           </li>
                           <li>
                              <p>You can also use the <code class="codeph">jps</code> command-line utility to determine PIDs. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&amp;id=JSWOR-GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank"><code class="codeph">jps</code></a> in <span><cite>Java Platform, Standard Edition Tools Reference</cite></span>.
                              </p>
                           </li>
                        </ul>
                        <p>For example, if the process ID of the <code class="codeph">Notepad</code> application is <code class="codeph">2956</code>, then start JConsole with the following command:
                        </p><pre class="pre codeblock"><code>% jconsole 2956
</code></pre><p>Both JConsole and the application must by executed by the same user. The management and monitoring system uses the operating system's file permissions. If you do not specify a process ID, JConsole will automatically detect all local Java applications, and display a dialog box that lets you select which one you want to monitor (see <a href="using-jconsole.html#GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC">Connecting to a JMX Agent</a>).
                        </p>
                        <p>See <a href="monitoring-and-management-using-jmx-technology.html#GUID-096EA656-4D07-4B09-A493-9EDEF83ABF28">Local Monitoring and Management</a>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-3668A05B-F532-4254-B7C9-8ACD87371162" name="GUID-3668A05B-F532-4254-B7C9-8ACD87371162"></a><h5 id="JSMGM-GUID-3668A05B-F532-4254-B7C9-8ACD87371162" class="sect5">Setting Up Remote Monitoring</h5>
                     <div>
                        <p>To start JConsole for remote monitoring, use the following command syntax:</p><pre class="pre codeblock"><code>% jconsole <span class="variable" translate="no">hostName</span>:<span class="variable" translate="no">portNum</span>
</code></pre><p>The <code class="codeph"><span class="variable" translate="no">hostName</span></code> is the name of the system running the application and <code class="codeph"><span class="variable" translate="no">portNum</span></code> is the port number you specified when you enabled the JMX agent while starting the Java VM. See <a href="monitoring-and-management-using-jmx-technology.html#GUID-F08985BB-629A-4FBF-A0CB-8762DF7590E0">Remote Monitoring and Management</a>.
                        </p>
                        <p>If you do not specify a host name/port number combination, then JConsole will display a connection dialog box (<a href="using-jconsole.html#GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC">Connecting to a JMX Agent</a>) to enable you to enter a host name and port number.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E" name="GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E"></a><h5 id="JSMGM-GUID-584162F0-EC4D-4FC1-9514-1E820AC9204E" class="sect5">Setting Up Secure Remote Monitoring</h5>
                     <div>
                        <p>You can also start JConsole so that monitoring will be performed over a connection that is secured using Secure Sockets Layer (SSL). See <a href="monitoring-and-management-using-jmx-technology.html#GUID-8CF90313-3A12-45BD-93C1-3495139D0457">Remote Monitoring with JConsole with SSL Enabled</a> for the command to start JConsole with a secure connection.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC" name="GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC"></a><h4 id="JSMGM-GUID-258E47A7-78AC-4B73-B4E1-E06E4DD4FDDC" class="sect4">Connecting to a JMX Agent</h4>
                  <div>
                     <p>If you start JConsole with arguments specifying a JMX agent to connect to, then it will automatically start monitoring the specified Java VM. You can connect to a different host at any time by selecting <span class="bold">Connection</span> and <span class="bold">New Connection</span>, and entering the necessary information.
                     </p>
                     <p>Otherwise, if you do not provide any arguments when you start JConsole, then the first thing that you see is the connection dialog box. This dialog box has two options, allowing connections to either Local or Remote processes.</p>
                  </div>
                  <div class="sect4"><a id="GUID-08D3C963-BE4D-4007-A797-980E975EF526" name="GUID-08D3C963-BE4D-4007-A797-980E975EF526"></a><h5 id="JSMGM-GUID-08D3C963-BE4D-4007-A797-980E975EF526" class="sect5">Connecting JConsole to a Local Process</h5>
                     <div>
                        <p>If you start JConsole without providing a specific JMX agent to connect to, then you will see the following dialog box:</p>
                        <p id="GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05"><span class="bold">Figure&nbsp;3-1 Creating a Connection to a Local Process</span></p><img src="img/connect.gif" alt="The dialog box for creating connections to local processes" title="The dialog box for creating connections to local processes"><p>The Local Process option lists any Java VMs running on the local system that were started with the same user ID as JConsole, along with their process ID and their class or argument information. To connect JConsole to your application, select the application that you want to monitor, then click <span class="bold">Connect</span>. The list of local processes includes applications running in the following types of Java VM:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Applications with the management agent enabled: These include applications on the Java SE platform that were started with the <code class="codeph">-Dcom.sun.management.jmxremote</code> option or with the <code class="codeph">-Dcom.sun.management.jmxremote.port</code> option specified. In addition, the list also includes any applications that were started on the Java SE platform without any management properties, but are attached to by JConsole, which enables the management agent at runtime.
                              </p>
                           </li>
                           <li>
                              <p>Applications that are attachable, with the management agent disabled: These include an <span class="variable" translate="no">attachable</span> application that supports loading of the management agent at runtime. Attachable applications include applications that are started on the Java SE platform, which support the Attach API. Applications that support dynamic attach do not require the management agent to be started by specifying the <code class="codeph">com.sun.management.jmxremote</code> or <code class="codeph">com.sun.management.jmxremote.port</code> options at the command line. JConsole does not need to connect to the management agent before the application is started. If you select this application, then a note is displayed on screen that the management agent will be enabled when the connection is made. In the example, connection dialog box that is shown in <a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">Figure&nbsp;3-1</a>, the NetBeans IDE and JConsole are started within a Java SE platform VM. Both appear in normal text, meaning that JConsole can connect to them. In <a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">Figure&nbsp;3-1</a>, JConsole is selected and the note is visible.
                              </p>
                           </li>
                           <li>
                              <p>Applications that are not attachable, with the management agent disabled: These include applications started on a Java SE platform without the <code class="codeph">-Dcom.sun.management.jmxremote</code> or <code class="codeph">com.sun.management.jmxremote.port</code> options. These applications appear grayed-out in the table and JConsole cannot connect to them. In the example connection dialog box shown in <a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-1CREATINGACONNECTIONTOALOCA-8F101A05">Figure&nbsp;3-1</a>, the <code class="codeph">Anagrams</code> application was started with a Java SE platform VM without any of the management properties to enable the JMX agent, and consequently shows up in gray and cannot be selected.
                              </p>
                           </li>
                        </ul>
                        <p id="GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-2ATTEMPTINGTOCONNECTTOANAPP-8F10456B"><span class="bold">Figure&nbsp;3-2 Attempting to Connect to an Application Without the Management Agent Enabled</span></p><img src="img/noconnect.gif" alt="Attempting to connect to a local process without the management agent enabled. JConsole cannot connect to this application." title="Attempting to connect to a local process without the management agent enabled. JConsole cannot connect to this application."><p>In the example connection dialog box shown in <a href="using-jconsole.html#GUID-08D3C963-BE4D-4007-A797-980E975EF526__FIGURE3-2ATTEMPTINGTOCONNECTTOANAPP-8F10456B">Figure&nbsp;3-2</a>, you can see that the <code class="codeph">Anagrams</code> application is selected, but <span class="bold">Connect</span> remains grayed-out, and a note has appeared informing you that the management agent is not enabled for this process. JConsole cannot connect to <code class="codeph">Anagrams</code> because it was not started with the correct Java VM or with the correct options.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5" name="GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5"></a><h5 id="JSMGM-GUID-EEEDF8A3-F9C9-44D9-94FF-7D5E719BB9E5" class="sect5">Connecting JConsole to a Remote Process</h5>
                     <div>
                        <p>When the connection dialog box opens, you are also given the option of connecting to a remote process.</p>
                        <p><span class="bold">Figure&nbsp;3-3 Creating a Connection to a Remote Process</span></p><img src="img/connectrem.gif" alt="The dialog box for creating connections to remote processes" title="The dialog box for creating connections to remote processes"><p>To monitor a process running on a remote Java VM, you must provide the following information:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Host name: The name of the machine on which the Java VM is running.</p>
                           </li>
                           <li>
                              <p>Port number: The JMX agent port number you specified when you started the Java VM.</p>
                           </li>
                           <li>
                              <p>User name and password: The user name and password to use (required only if monitoring a Java VM through a JMX agent that requires password authentication).</p>
                           </li>
                        </ul>
                        <p>To set the port number of the JMX agent, see <a href="monitoring-and-management-using-jmx-technology.html#GUID-E17343B0-FED2-4050-88D7-E4793E704ED5">Enabling the Ready-to-Use Management</a>. 
                        </p>
                        <p>See <a href="monitoring-and-management-using-jmx-technology.html#GUID-D4CBA2D6-2E24-4856-A7D8-62B3DFFB76EA">Using Password and Access Files</a>.
                        </p>
                        <p>To monitor the Java VM that is running JConsole, click <span class="bold">Connect</span> and enter host as <code class="codeph">localhost</code> and the port <code class="codeph">0</code>.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-4448A647-D858-443C-8DCF-49F552AA1745" name="GUID-4448A647-D858-443C-8DCF-49F552AA1745"></a><h5 id="JSMGM-GUID-4448A647-D858-443C-8DCF-49F552AA1745" class="sect5">Connecting Using a JMX Service URL</h5>
                     <div>
                        <p>You can also use the Remote Process option to connect to other JMX agents by specifying their JMX service URL, and the user name and password. The syntax of a JMX service URL requires that you provide the transport protocol used to make the connection, as well as a service access point. The full syntax for a JMX service URL is described in the API documentation for <code class="codeph">javax.management.remote.JMXServiceURL</code>.
                        </p>
                        <p><span class="bold">Figure&nbsp;3-4 Connecting to a JMX Agent Using the JMX Service URL</span></p><img src="img/connectadv.gif" alt="Connecting to a JMX Agent Using the JMX Service URL" title="Connecting to a JMX Agent Using the JMX Service URL"><p>If the JMX agent uses a connector that is not included in the Java platform, then you must add the connector classes to the class path when you run the <code class="codeph">jconsole</code> command, as follows:
                        </p><pre class="pre codeblock"><code>% jconsole -J-Djava.class.path=<span class="variable" translate="no">JAVA_HOME</span>/lib/jconsole.jar:<span class="variable" translate="no">JAVA_HOME</span>/lib/tools.jar:<span class="variable" translate="no">connector-path</span>
</code></pre><p><code class="codeph"><span class="variable" translate="no">connector-path</span></code> is the directory or the Java archive (JAR) file containing the connector classes that are not included in the JDK, to be used by JConsole.
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245" name="GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245"></a><h4 id="JSMGM-GUID-BC433FB0-51AD-4DF9-9BAF-FF6449509245" class="sect4">Presenting the JConsole Tabs</h4>
                  <div>
                     <p>After you have connected JConsole to an application, JConsole displays the following six tabs:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Overview: Displays overview information about the Java VM and monitored values</p>
                        </li>
                        <li>
                           <p>Memory: Displays information about memory use</p>
                        </li>
                        <li>
                           <p>Threads: Displays information about thread use</p>
                        </li>
                        <li>
                           <p>Classes: Displays information about class loading</p>
                        </li>
                        <li>
                           <p>VM: Displays information about the Java VM</p>
                        </li>
                        <li>
                           <p>MBeans: Displays information about MBeans</p>
                        </li>
                     </ul>
                     <p>Use the green connection status icon in the upper right-hand corner of JConsole to disconnect from or reconnect to a running Java VM. You can connect to any number of running Java VMs at a time by selecting <span class="bold">Connection</span>, then <span class="bold">New Connection</span> from the drop-down menu.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-E40C6B77-957C-455E-AAE1-D003C61331BA" name="GUID-E40C6B77-957C-455E-AAE1-D003C61331BA"></a><h5 id="JSMGM-GUID-E40C6B77-957C-455E-AAE1-D003C61331BA" class="sect5">Viewing Overview Information</h5>
                     <div>
                        <p>The Overview tab displays graphical monitoring information about CPU usage, memory usage, thread counts, and the classes loaded in the Java VM, all in a single screen.</p>
                        <p><span class="bold">Figure&nbsp;3-5 Overview Tab</span></p><img src="img/overviewtab.gif" height="306" width="417" alt="The JConsole Overview tab" title="The JConsole Overview tab"><p>The Overview tab provides an easy way to correlate information that was previously available only by switching between multiple tabs.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA" name="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA"></a><h5 id="JSMGM-GUID-FD200C08-6B7D-45F1-800F-306A68B655CA" class="sect5">Saving Chart Data</h5>
                     <div>
                        <p>JConsole allows you to save the data presented in the charts in a comma-separated values (CSV) file. To save data from a chart, right-click on any chart, select <span class="bold">Save data as...</span>, and then specify the file in which the data will be saved. You can save the data from any of the charts displayed in any of JConsole's different tabs in this way.
                        </p>
                        <p id="GUID-FD200C08-6B7D-45F1-800F-306A68B655CA__GDKCK">The CSV format is commonly used for data exchange between spreadsheet applications. The CSV file can be imported into spreadsheet applications and can be used to create diagrams in these applications. The data is presented as two or more named columns, where the first column represents the time stamps. After importing the file into a spreadsheet application, you will usually need to select the first column and change its format to be <kbd class="userinput">date</kbd> or <kbd class="userinput">date/time </kbd> as appropriate.
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-139C787E-E180-4305-8A9F-B13D38149502" name="GUID-139C787E-E180-4305-8A9F-B13D38149502"></a><h5 id="JSMGM-GUID-139C787E-E180-4305-8A9F-B13D38149502" class="sect5">Monitoring Memory Consumption</h5>
                     <div>
                        <p>The Memory tab provides information about memory consumption and memory pools.</p>
                        <p><span class="bold">Figure&nbsp;3-6 Memory Tab</span></p><img src="img/memtab.gif" height="305" width="417" alt="The JConsole Memory tab." title="The JConsole Memory tab."><p>Click <span class="bold">Perform GC</span> in the Memory tab to perform garbage collection whenever you want. The chart shows the memory use of the Java VM over time, for heap and nonheap memory, as well as for specific memory pools. The memory pools available depend on the version of the Java VM being used. For the HotSpot Java VM, the memory pools for serial garbage collection are the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Eden Space (heap): The pool from which memory is initially allocated for most objects.</p>
                           </li>
                           <li>
                              <p>Survivor Space (heap): The pool containing objects that have survived the garbage collection of the Eden space.</p>
                           </li>
                           <li>
                              <p>Tenured Generation (heap): The pool containing objects that have existed for some time in the survivor space.</p>
                           </li>
                           <li>
                              <p>Permanent Generation (nonheap): The pool containing all the reflective data of the virtual machine itself, such as class and method objects. With Java VMs that use class data sharing, this generation is divided into read-only and read/write areas.</p>
                           </li>
                           <li>
                              <p>Code Cache (nonheap): The HotSpot Java VM also includes a code cache, containing memory that is used for compilation and storage of native code.</p>
                           </li>
                        </ul>
                        <p>You can display different charts for charting the consumption of these memory pools by selecting the required options in the <span class="bold">Chart</span> drop-down menu. Also, clicking either the Heap or Nonheap bar charts in the bottom right-hand corner will switch the chart displayed. Finally, you can specify the time range over which you track memory usage, by selecting the required options in the <span class="bold">Time Range</span> drop-down menu.
                        </p>
                        <p>See <a href="using-jconsole.html#GUID-A81AE10A-0693-462A-B129-5E292F46523E">Garbage Collection</a>.
                        </p>
                        <p>The <span class="bold">Details</span> area shows several current memory metrics:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Used: The amount of memory currently used, including the memory occupied by all objects, both reachable and unreachable.</p>
                           </li>
                           <li>
                              <p>Committed: The amount of memory guaranteed to be available for use by the Java VM. The amount of committed memory may change over time. The Java virtual machine may release memory to the system and the amount of committed memory could be less than the amount of memory initially allocated at startup. The amount of committed memory will always be greater than or equal to the amount of used memory.</p>
                           </li>
                           <li>
                              <p>Max: The maximum amount of memory that can be used for memory management. Its value may change or be undefined. A memory allocation may fail if the Java VM attempts to increase the used memory to be greater than committed memory, even if the amount used is less than or equal to <code class="codeph">max</code> (for example, when the system is low on virtual memory).
                              </p>
                           </li>
                           <li>
                              <p>GC time: The cumulative time spent on garbage collection and the total number of calls. It may have multiple rows, each of which represents one garbage collector algorithm used in the Java VM.</p>
                           </li>
                        </ul>
                        <p>The bar chart on the lower right-hand side shows the memory consumed by the memory pools in heap and nonheap memory. The bar will turn red when the memory used exceeds the memory usage threshold. You can set the memory usage threshold through an attribute of the <code class="codeph">MemoryMXBean</code>.
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-87E608D9-A384-485B-902E-B4867F132F3F" name="GUID-87E608D9-A384-485B-902E-B4867F132F3F"></a><h6 id="JSMGM-GUID-87E608D9-A384-485B-902E-B4867F132F3F" class="sect6">Heap and Nonheap Memory</h6>
                        <div>
                           <p>The Java VM manages two kinds of memory: heap and nonheap memory, both of which are created when the Java VM starts.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Heap memory: Is the runtime data area from which the Java VM allocates memory for all class instances and arrays. The heap may be of a fixed or variable size. The garbage collector is an automatic memory management system that reclaims heap memory for objects.</p>
                              </li>
                              <li>
                                 <p>Nonheap memory: Includes a method area shared among all threads and memory required for the internal processing or optimization for the Java VM. It stores per-class structures such as a runtime constant pool, field and method data, and the code for methods and constructors. The method area is logically part of the heap but, depending on the implementation, a Java VM may not garbage collect or compact it. Like the heap memory, the method area may be of a fixed or variable size. The memory for the method area does not need to be contiguous.</p>
                              </li>
                           </ul>
                           <p>In addition to the method area, a Java VM may require memory for internal processing or optimization, which also belongs to nonheap memory. For example, the Just-In-Time (JIT) compiler requires memory for storing the native machine code translated from the Java VM code for high performance.</p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832" name="GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832"></a><h6 id="JSMGM-GUID-E1EC7456-6708-4701-8FE4-F030F5D3D832" class="sect6">Memory Pools and Memory Managers</h6>
                        <div>
                           <p>Memory pools and memory managers are key aspects of the Java VM's memory system.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Memory pool: Represents a memory area that the Java VM manages. The Java VM has at least one memory pool and it may create or remove memory pools during execution. A memory pool can belong either to heap or to nonheap memory.</p>
                              </li>
                              <li>
                                 <p>Memory manager: Manages one or more memory pools. The garbage collector is a type of memory manager responsible for reclaiming memory used by unreachable objects. A Java VM may have one or more memory managers. It may add or remove memory managers during execution. A memory pool can be managed by more than one memory manager.</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-A81AE10A-0693-462A-B129-5E292F46523E" name="GUID-A81AE10A-0693-462A-B129-5E292F46523E"></a><h6 id="JSMGM-GUID-A81AE10A-0693-462A-B129-5E292F46523E" class="sect6">Garbage Collection</h6>
                        <div>
                           <p>Garbage collection (GC) is how the Java VM frees memory occupied by objects that are no longer referenced. It is common to think of objects that have active references as being <span class="variable" translate="no">live</span> and nonreferenced (or unreachable) objects as <span class="variable" translate="no">dead</span>. Garbage collection is the process of releasing memory used by the dead objects. The algorithms and parameters used by GC can have dramatic effects on performance.
                           </p>
                           <p>The Java HotSpot VM garbage collector uses generational GC. Generational GC takes advantage of the observation that most programs conform to the following generalizations:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>They create many objects that have short lives, for example, iterators and local variables.</p>
                              </li>
                              <li>
                                 <p>They create some objects that have very long lives, for example, high-level persistent objects.</p>
                              </li>
                           </ul>
                           <p>Generational GC divides memory into several generations, and assigns one or more memory pools to each. When a generation uses up its allotted memory, the VM performs a partial GC (also called a minor collection) on that memory pool to reclaim memory used by dead objects. This partial GC is usually much faster than a full GC.</p>
                           <p>The Java HotSpot VM defines two generations: the young generation (sometimes called the <span class="italic">nursery</span>) and the old generation. The young generation consists of an <span class="italic">Eden space</span> and two <span class="italic">survivor spaces</span>. The VM initially assigns all objects to the Eden space, and most objects die there. When it performs a minor GC, the VM moves any remaining objects from the Eden space to one of the survivor spaces. The VM moves objects that live long enough in the survivor spaces to the <span class="italic">tenured</span> space in the old generation. When the tenured generation fills up, there is a full GC that is often much slower because it involves all live objects. The permanent generation holds all the reflective data of the virtual machine itself, such as class and method objects.
                           </p>
                           <p>The default arrangement of generations looks something like <a href="using-jconsole.html#GUID-A81AE10A-0693-462A-B129-5E292F46523E__FIGURE3-7GENERATIONSOFDATAINGARBAGE-8F135AA1">Figure&nbsp;3-7</a>.
                           </p>
                           <p id="GUID-A81AE10A-0693-462A-B129-5E292F46523E__FIGURE3-7GENERATIONSOFDATAINGARBAGE-8F135AA1"><span class="bold">Figure&nbsp;3-7 Generations of Data in Garbage Collection</span></p><img src="img/generations.gif" height="249" width="450" alt="The different generations of data defined by the Garbage Collector" title="The different generations of data defined by the Garbage Collector"><p>If the garbage collector has become a bottleneck, then you can improve performance by customizing the generation sizes. Using JConsole, you can investigate the sensitivity of your performance metric by experimenting with the garbage collector parameters. See <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/java/javase/11/management&amp;id=JSGCT-GUID-C2CA24AD-DC01-4B31-A868-F7DAC7E3BF4D" target="_blank">Performance Considerations</a> in <span><cite>Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</cite></span>.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3" name="GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3"></a><h6 id="JSMGM-GUID-3A6F4B37-35B8-4883-8D4B-F943D3B3D8F3" class="sect6">Monitoring Thread Use</h6>
                        <div>
                           <p>The Threads tab provides information about thread use.</p>
                           <p><span class="bold">Figure&nbsp;3-8 Threads Tab</span></p><img src="img/threadtab.gif" height="381" width="521" alt="The JConsole Threads tab." title="The JConsole Threads tab."><p>The Threads list in the lower left corner lists all the active threads. If you enter a string in the Filter field, then the Threads list will show only those threads whose name contains the string that you entered. Click the name of a thread in the <span class="bold">Threads</span> list to display information about that thread to the right, including the thread name, state, and stack trace.
                           </p>
                           <p>The chart shows the number of live threads over time. Two lines are shown:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Red: Peak number of threads</p>
                              </li>
                              <li>
                                 <p>Blue: Number of live threads</p>
                              </li>
                           </ul>
                           <p>The Threading MXBean provides several other useful operations that are not covered by the Threads tab.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">findMonitorDeadlockedThreads</code>: Detects if any threads are deadlocked on the object monitor locks. This operation returns an array of deadlocked thread IDs.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">getThreadInfo</code>: Returns the thread information. This includes the name, stack trace, and the monitor lock that the thread is currently blocked on, if any, and which thread is holding that lock, as well as thread contention statistics.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">getThreadCpuTime</code>: Returns the CPU time consumed by a given thread. 
                                 </p>
                              </li>
                           </ul>
                           <p>You can access these additional features through the MBeans tab by selecting <span class="bold">Threading MXBean</span> in the MBeans tree. This MXBean lists all the attributes and operations for accessing threading information in the Java VM being monitored. See <a href="using-jconsole.html#GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87">Monitoring and Managing MBeans</a>.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236" name="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236"></a><h6 id="JSMGM-GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236" class="sect6">Detecting Deadlocked Threads</h6>
                        <div>
                           <p>To check if your application has run into a deadlock (for example, your application seems to be hanging), deadlocked threads can be detected by clicking <span class="bold">Detect Deadlock</span>. If any deadlocked threads are detected, these are displayed in a new tab that appears next to the <span class="bold">Threads</span> tab, as shown in <a href="using-jconsole.html#GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236__FIGURE3-9DEADLOCKEDTHREADS-8F1BA8FE">Figure&nbsp;3-9</a>.
                           </p>
                           <p id="GUID-37EE4D12-5315-4E8B-BBEE-FA63D2C94236__FIGURE3-9DEADLOCKEDTHREADS-8F1BA8FE"><span class="bold">Figure&nbsp;3-9 Deadlocked Threads</span></p><img src="img/deadlock.gif" height="275" width="504" alt="Deadlocked threads detected by JConsole." title="Deadlocked threads detected by JConsole."><p><span class="bold">Detect Deadlock</span> will detect deadlock cycles involving object monitors and <code class="codeph">java.util.concurrent</code> ownable synchronizers (see the API specification documentation for <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/management/LockInfo.html" target="_blank"><span class="apiname"> java.lang.management.LockInfo</span></a>). Monitoring support for <code class="codeph">java.util.concurrent</code> locks has been added in Java SE from version 6.0. If JConsole connects to a Java SE 5.0 VM, then the Detect Deadlock mechanism will find only deadlocks related to object monitors. JConsole will not show any deadlocks related to ownable synchronizers.
                           </p>
                           <p>See the API documentation for <code class="codeph">java.lang.Thread</code> for more information about threads and daemon threads.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C" name="GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C"></a><h5 id="JSMGM-GUID-07AD2B95-D7EC-47B5-A224-325A914D9D7C" class="sect5">Monitoring Class Loading</h5>
                     <div>
                        <p>The Classes tab displays information about class loading.</p>
                        <p><span class="bold">Figure&nbsp;3-10 Classes Tab</span></p><img src="img/classtab.gif" height="383" width="522" alt="The image provides information about the number of classes that are loaded." title="The image provides information about the number of classes that are loaded."><p>The chart plots the number of classes loaded over time.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The red line is the total number of classes loaded (including those subsequently unloaded).</p>
                           </li>
                           <li>
                              <p>The blue line is the current number of classes loaded.</p>
                           </li>
                        </ul>
                        <p>The Details section at the bottom of the tab displays the total number of classes loaded since the Java VM started, the number currently loaded, and the number unloaded. You can set the tracing of class loading to verbose output by selecting the check box in the top right-hand corner.</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2" name="GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2"></a><h5 id="JSMGM-GUID-8E205A07-C881-4F84-A6DE-B760F1A73BA2" class="sect5">Viewing VM Information</h5>
                     <div>
                        <p>The VM Summary tab provides information about the Java VM.</p>
                        <p><span class="bold">Figure&nbsp;3-11 VM Summary Tab</span></p><img src="img/vmtab.gif" height="459" width="487" alt="The JConsole VM Summary tab." title="The JConsole VM Summary tab."><p>The information presented in this tab includes the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Summary</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Uptime: Total amount of time since the Java VM was started.</p>
                                 </li>
                                 <li>
                                    <p>Process CPU Time: Total amount of CPU time that the Java VM has consumed since it was started.</p>
                                 </li>
                                 <li>
                                    <p>Total Compile Time: Total accumulated time spent in JIT compilation. The Java VM determines when JIT compilation occurs. The Hotspot VM uses adaptive compilation, in which the VM launches an application using a standard interpreter, but then analyzes the code as it runs to detect performance bottlenecks, or hot spots.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Threads</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Live threads: Current number of live daemon threads plus nondaemon threads.</p>
                                 </li>
                                 <li>
                                    <p>Peak: Highest number of live threads since Java VM started.</p>
                                 </li>
                                 <li>
                                    <p>Daemon threads: Current number of live daemon threads.</p>
                                 </li>
                                 <li>
                                    <p>Total threads started: Total number of threads started since Java VM started, including daemon, nondaemon, and terminated threads.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Classes</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Current classes loaded: Number of classes currently loaded into memory.</p>
                                 </li>
                                 <li>
                                    <p>Total classes loaded: Total number of classes loaded into memory since the Java VM started, including those that have subsequently been unloaded.</p>
                                 </li>
                                 <li>
                                    <p>Total classes unloaded: Number of classes unloaded from memory since the Java VM started.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Memory</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Current heap size: Number of kilobytes currently occupied by the heap.</p>
                                 </li>
                                 <li>
                                    <p>Committed memory: Total amount of memory allocated for use by the heap.</p>
                                 </li>
                                 <li>
                                    <p>Maximum heap size: Maximum number of kilobytes occupied by the heap.</p>
                                 </li>
                                 <li>
                                    <p>Objects pending for finalization: Number of objects pending for finalization.</p>
                                 </li>
                                 <li>
                                    <p>Garbage collector: Information about garbage collection, including the garbage collector names, number of collections performed, and total time spent performing GC.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Operating System</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Total physical memory: Amount of random access memory (RAM) the operating system has.</p>
                                 </li>
                                 <li>
                                    <p>Free physical memory: Amount of free RAM available to the operating system.</p>
                                 </li>
                                 <li>
                                    <p>Committed virtual memory: Amount of virtual memory guaranteed to be available to the running process.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Other Information</span></p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>VM arguments: The input arguments that the application passed to the Java VM, not including the arguments to the main method.</p>
                                 </li>
                                 <li>
                                    <p>Class path: The class path that is used by the system class loader to search for class files.</p>
                                 </li>
                                 <li>
                                    <p>Library path: The list of paths to search when loading libraries.</p>
                                 </li>
                                 <li>
                                    <p>Boot class path: The path used by the bootstrap class loader to search for class files.</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87" name="GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87"></a><h5 id="JSMGM-GUID-60CF51A0-EDBC-4C60-A15A-DC94D9071E87" class="sect5">Monitoring and Managing MBeans</h5>
                     <div>
                        <p>The MBeans tab displays information about all the MBeans registered with the platform MBean server in a generic way. The MBeans tab allows you to access the full set of the platform MXBean instrumentation, including the ones that are not visible in the other tabs. In addition, you can monitor and manage your application's MBeans using the MBeans tab.</p>
                        <p><span class="bold">Figure&nbsp;3-12 MBeans Tab</span></p><img src="img/mbeantab.gif" height="381" width="520" alt="The JConsole MBeans tab." title="The JConsole MBeans tab."><p>The tree on the left shows all the MBeans currently running. When you select an MBean in the tree, its <code class="codeph">MBeanInfo</code> and its MBean <code class="codeph">Descriptor</code> are both displayed on the right, and any attributes, operations, or notifications appear in the tree below it.
                        </p>
                        <p>All the platform MXBeans and their various operations and attributes are accessible from JConsole's MBeans tab.</p>
                     </div>
                     <div class="sect5"><a id="GUID-83749035-6012-446A-A6BD-6D650A37F076" name="GUID-83749035-6012-446A-A6BD-6D650A37F076"></a><h6 id="JSMGM-GUID-83749035-6012-446A-A6BD-6D650A37F076" class="sect6">Constructing the MBean Tree</h6>
                        <div>
                           <p>By default, the MBeans are displayed in the tree based on their object names. The order of key properties specified when the object names are created is preserved by JConsole when it adds MBeans to the MBean tree. The exact key property list that JConsole will use to build the MBean tree will be the one returned by the method <code class="codeph">ObjectName.getKeyPropertyListString()</code>, with <code class="codeph">type</code> as the first key, and <code class="codeph">j2eeType</code>, if present, as the second key.
                           </p>
                           <p>However, relying on the default order of the <code class="codeph">ObjectName</code> key properties can sometimes lead to unexpected behavior when JConsole renders the MBean tree. For example, if two object names have similar keys but their key order differs, then the corresponding MBeans will not be created under the same node in the MBean tree.
                           </p>
                           <p>For example, suppose you create <code class="codeph">Triangle</code> MBean objects with the following names.
                           </p><pre class="pre codeblock"><code>com.sun.example:type=Triangle,side=isosceles,name=1
com.sun.example:type=Triangle,name=2,side=isosceles
com.sun.example:type=Triangle,side=isosceles,name=3
</code></pre><p>As far as the JMX technology is concerned, these objects will be treated in exactly the same way. The order of the keys in the object name makes no difference to the JMX technology. However, if JConsole connects to these MBeans and the default MBean tree rendering is used, then the object <code class="codeph">com.sun.example:type=Triangle,name=2,side=isosceles</code> will end up being created under the <code class="codeph">Triangle</code> node, in a node called <code class="codeph">2</code>, which in turn will contain a subnode called <code class="codeph">isosceles</code>. The other two isosceles triangles, <code class="codeph">name=1</code> and <code class="codeph">name=3</code>, will be grouped together under <code class="codeph">Triangle</code> in a different node called <code class="codeph">isosceles</code>, as shown in <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5">Figure&nbsp;3-13</a>.
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5"><span class="bold">Figure&nbsp;3-13 Example of Unexpected MBean Tree Rendering</span></p><img src="img/mbeantree1.gif" alt="Example of Unexpected MBean Tree Rendering" title="Example of Unexpected MBean Tree Rendering"><p>To avoid this problem, you can specify the order in which the MBeans are displayed in the tree by supplying an ordered key property list when you start JConsole at the command line. This is achieved by setting the system property <code class="codeph">com.sun.tools.jconsole.mbeans.keyPropertyList</code>, as shown in the following command.
                           </p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=<span class="variable" translate="no">key</span>[,<span class="variable" translate="no">key</span>]*
</code></pre><p>The key property list system property takes a comma-separated list of keys, in the order of your selection, where <code class="codeph"><span class="variable" translate="no">key</span></code> must be a string representing an object name key or an empty string. If a key specified in the list does not apply to a particular MBean, then that key will be discarded. If an MBean has more keys than the ones specified in the key property list, then the key order defined by the value returned by <code class="codeph">ObjectName.getKeyPropertyListString()</code> will be used to complete the key order defined by <code class="codeph">keyPropertyList</code>. Therefore, specifying an empty list of keys means that JConsole will display keys in the order that they appear in the MBean's <code class="codeph">ObjectName</code>.
                           </p>
                           <p>So, returning to the example of the <code class="codeph">Triangle</code> MBeans cited previously, you can start JConsole by specifying the <code class="codeph">keyPropertyList</code> system property, so that all your MBeans will be grouped according to their <code class="codeph">side</code> key property first, and their <code class="codeph">name</code> key property second. To do this, start the JConsole with the following command: 
                           </p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=side,name
</code></pre><p>Starting JConsole with this system property specified will produce the MBean tree as shown in the <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">Figure&nbsp;3-14</a>.
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F"><span class="bold">Figure&nbsp;3-14 Example of MBean Tree Constructed Using keyPropertyList</span></p><img src="img/mbeantree2.gif" alt="Example of MBean Tree Constructed Using keyPropertyList" title="Example of MBean Tree Constructed Using keyPropertyList"><p>In <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">Figure&nbsp;3-14</a>, the <code class="codeph">side</code> key comes first, followed by the <code class="codeph">name</code> key. The <code class="codeph">type</code> key comes at the end because it was not specified in the key property list, so the MBean tree algorithm applied the original key order for the remaining keys. Consequently, the <code class="codeph">type</code> key is appended at the end, after the keys, which were defined by the <code class="codeph">keyPropertyList</code> system property.
                           </p>
                           <p>According to the object name convention defined by the <a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html" target="_blank">JMX Best Practices Guidelines</a>, the <code class="codeph">type</code> key should always come first. You must start JConsole with the following system property:
                           </p><pre class="pre codeblock"><code>% jconsole -J-Dcom.sun.tools.jconsole.mbeans.keyPropertyList=type,side,name
</code></pre><p>The prior command will cause JConsole to render the MBean tree for the Triangle MBeans as shown in the <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-15EXAMPLEOFMBEANTREECONSTRU-8F2064BC">Figure&nbsp;3-15</a>.
                           </p>
                           <p id="GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-15EXAMPLEOFMBEANTREECONSTRU-8F2064BC"><span class="bold">Figure&nbsp;3-15 Example of MBean Tree Constructed Respecting JMX Best Practices</span></p><img src="img/mbeantree3.gif" alt="Example of MBean Tree Constructed Respecting JMX Best Practices" title="Example of MBean Tree Constructed Respecting JMX Best Practices"><p>This is comprehensible than the MBean trees as shown in <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-13EXAMPLEOFUNEXPECTEDMBEANT-8F1F19C5">Figure&nbsp;3-13</a> and <a href="using-jconsole.html#GUID-83749035-6012-446A-A6BD-6D650A37F076__FIGURE3-14EXAMPLEOFMBEANTREECONSTRU-8F1F3B7F">Figure&nbsp;3-14</a>.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428" name="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428"></a><h6 id="JSMGM-GUID-1C3C7299-FBD2-48FC-A940-2622953B4428" class="sect6">MBean Attributes</h6>
                        <div>
                           <p>Selecting the <span class="bold">Attributes</span> node displays all the attributes of an MBean. <a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-16VIEWINGALLMBEANATTRIBUTES-8F220721">Figure&nbsp;3-16</a> shows all the attributes of the Threading platform MXBean.
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-16VIEWINGALLMBEANATTRIBUTES-8F220721"><span class="bold">Figure&nbsp;3-16 Viewing All MBean Attributes</span></p><img src="img/allattributes.gif" height="298" width="481" alt="Viewing the attributes of the Threading MBean." title="Viewing the attributes of the Threading MBean."><p>Selecting an individual MBean attribute from the tree then displays the attribute's value, its <code class="codeph">MBeanAttributeInfo</code>, and the associated Descriptor in the right pane, as you can see in <a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-17VIEWINGANINDIVIDUALMBEANA-8F2218BC">Figure&nbsp;3-17</a>.
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-17VIEWINGANINDIVIDUALMBEANA-8F2218BC"><span class="bold">Figure&nbsp;3-17 Viewing an Individual MBean Attribute</span></p><img src="img/attributes.gif" height="381" width="521" alt="Viewing MBean attributes in the MBeans tab." title="Viewing MBean attributes in the MBeans tab."><p>You can display additional information about an attribute by double-clicking the attribute value, if it appears in bold text. For example, if you click the value of the <code class="codeph">HeapMemoryUsage</code> attribute of the <code class="codeph">java.lang.Memory</code> MBean, then you will see a chart that looks something like <a href="using-jconsole.html#GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-18DISPLAYINGATTRIBUTEVALUES-8F225584">Figure&nbsp;3-18</a>.
                           </p>
                           <p id="GUID-1C3C7299-FBD2-48FC-A940-2622953B4428__FIGURE3-18DISPLAYINGATTRIBUTEVALUES-8F225584"><span class="bold">Figure&nbsp;3-18 Displaying Attribute Values</span></p><img src="img/chart.gif" alt="Viewing the values of MBean attributes." title="Viewing the values of MBean attributes."><p>Double-clicking numeric attribute values will display a chart that plots changes in that numeric value. For example, double-clicking the <span class="bold">CollectionTime</span> attribute of the Garbage Collector MBean <code class="codeph">PS Marksweep</code> will plot the time spent performing garbage collection.
                           </p>
                           <p>You can also use JConsole to set the values of writable attributes. The value of a writable attribute is displayed in blue. Here you can see the Memory MBean's Verbose attribute.</p>
                           <p><span class="bold">Figure&nbsp;3-19 Setting Writable Attribute Values</span></p><img src="img/writeableattrib.gif" alt="Setting an MBean's writable attribute value." title="Setting an MBean's writable attribute value."><p>You can set attributes by clicking them and then editing them. For example, to enable or disable the verbose tracing of the garbage collector in JConsole, select the <span class="bold">Memory MXBean</span> in the <span class="bold">MBeans</span> tab and set the <code class="codeph">Verbose</code> attribute to <code class="codeph">true</code> or <code class="codeph">false</code>. Similarly, the class loading MXBean also has the <code class="codeph">Verbose</code> attribute, which can be set to enable or disable class loading verbose tracing.
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4" name="GUID-1714F49C-7637-41EB-B576-23861C55B8D4"></a><h6 id="JSMGM-GUID-1714F49C-7637-41EB-B576-23861C55B8D4" class="sect6">MBean Operations</h6>
                        <div>
                           <p>Selecting the <span class="bold">Operations</span> node displays all the operations of an MBean. The MBean operations appear as buttons, that you can click to call the operation.<a href="using-jconsole.html#GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-20VIEWINGALLMBEANOPERATIONS-8F228DD0"> Figure&nbsp;3-20</a> shows all the operations of the Threading platform MXBean.
                           </p>
                           <p id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-20VIEWINGALLMBEANOPERATIONS-8F228DD0"><span class="bold">Figure&nbsp;3-20 Viewing All MBean Operations</span></p><img src="img/alloperations.gif" height="437" width="586" alt="Viewing the Threading platform MXBean's operations." title="Viewing the Threading platform MXBean's operations."><p>Selecting an individual MBean operation in the tree displays the button for calling the MBean operation, and the operation's <code class="codeph">MBeanOperationInfo</code> and its Descriptor, as shown in <a href="using-jconsole.html#GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-21VIEWINGINDIVIDUALMBEANOPE-8F22BED4">Figure&nbsp;3-21</a>.
                           </p>
                           <p id="GUID-1714F49C-7637-41EB-B576-23861C55B8D4__FIGURE3-21VIEWINGINDIVIDUALMBEANOPE-8F22BED4"><span class="bold">Figure&nbsp;3-21 Viewing Individual MBean Operations</span></p><img src="img/operations.gif" height="383" width="520" alt="Invoking an MBean's operations." title="Invoking an MBean's operations."></div>
                     </div>
                     <div class="sect5"><a id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7" name="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7"></a><h6 id="JSMGM-GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7" class="sect6">MBean Notifications</h6>
                        <div>
                           <p>You can subscribe to receive notifications by selecting the <span class="bold">Notifications</span> node in the left-hand tree, and clicking the <span class="bold">Subscribe</span> button that appears on the right. The number of notifications received is displayed in brackets, and the Notifications node itself will appear in bold text when new notifications are received. The notifications of the Memory platform MXBean are shown in <a href="using-jconsole.html#GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-22VIEWINGMBEANNOTIFICATIONS-8F237C7D">Figure&nbsp;3-22</a>.
                           </p>
                           <p id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-22VIEWINGMBEANNOTIFICATIONS-8F237C7D"><span class="bold">Figure&nbsp;3-22 Viewing MBean Notifications</span></p><img src="img/allnotifications.gif" height="275" width="612" alt="Viewing an MBean's notifications." title="Viewing an MBean's notifications."><p>Selecting an individual MBean notification displays the <code class="codeph">MBeanNotificationInfo</code> in the right pane, as shown in <a href="using-jconsole.html#GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-23VIEWINGINDIVIDUALMBEANNOT-8F23872C">Figure&nbsp;3-23</a>.
                           </p>
                           <p id="GUID-366C4997-B7DB-423C-942C-5B051DB1F1B7__FIGURE3-23VIEWINGINDIVIDUALMBEANNOT-8F23872C"><span class="bold">Figure&nbsp;3-23 Viewing Individual MBean Notifications</span></p><img src="img/notifications.gif" height="381" width="522" alt="Subscribing to receive MBean Notifications." title="Subscribing to receive MBean Notifications."></div>
                     </div>
                     <div class="sect5"><a id="GUID-A9086B53-310E-45E0-9B67-8DB2806DE009" name="GUID-A9086B53-310E-45E0-9B67-8DB2806DE009"></a><h6 id="JSMGM-GUID-A9086B53-310E-45E0-9B67-8DB2806DE009" class="sect6">HotSpot Diagnostic MXBean</h6>
                        <div>
                           <p>JConsole's MBeans tab also allows you to tell the HotSpot VM to perform a heap dump, and to get or set a VM option using the <code class="codeph">HotSpotDiagnostic</code> MXBean.
                           </p>
                           <p><span class="bold">Figure&nbsp;3-24 Viewing the HotSpot Diagnostic MBean</span></p><img src="img/hotspotdiagnostic.gif" height="382" width="521" alt="Performing heap dumps using the HotSpot VM Diagnostic MBean." title="Performing heap dumps using the HotSpot VM Diagnostic MBean."><p>You can perform a heap dump manually by calling the <code class="codeph">com.sun.management.HotSpotDiagnostic</code> MXBean's <code class="codeph">dumpHeap</code> operation. In addition, you can specify the <code class="codeph">HeapDumpOnOutOfMemoryError</code> Java VM option using the <code class="codeph">setVMOption</code> operation, so that the VM performs a heap dump automatically whenever it receives an <code class="codeph">OutOfMemoryError</code>.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7" name="GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7"></a><h5 id="JSMGM-GUID-AAE9C272-E3FB-440D-AA51-FB0A5C8A4EC7" class="sect5">Creating Custom Tabs</h5>
                     <div>
                        <p>In addition to the existing standard tabs, you can add your own custom tabs to JConsole, to perform your own monitoring activities. The JConsole plug-in API provides a mechanism by which you can, for example, add a tab to access your own application's MBeans. The JConsole plug-in API defines the <code class="codeph">com.sun.tools.jconsole.JConsolePlugin</code> abstract class that you can extend to build your custom plug-in.
                        </p>
                        <p>As stated previously, your plug-in must extend <code class="codeph">JConsolePlugin,</code> and implement the <code class="codeph">JConsolePlugin</code><code class="codeph">getTabs</code> and <code class="codeph">newSwingWorker</code> methods. The <code class="codeph">getTabs</code> method returns either the list of tabs to be added to JConsole, or an empty list. The <code class="codeph">newSwingWorker</code> method returns the <code class="codeph">SwingWorker</code> to be responsible for the plug-in's GUI update.
                        </p>
                        <p>Your plug-in must be provided in a Java archive (JAR) file that contains a file named <code class="codeph">META-INF/services/com.sun.tools.jconsole.JConsolePlugin</code>. This <code class="codeph">JConsolePlugin</code> file itself contains a list of all the fully qualified class names of the plug-ins that you want to add as new JConsole tabs. JConsole uses the service-provider loading facility to look up and load the plug-ins. You can have multiple plug-ins, with one entry per plug-in in the <code class="codeph">JConsolePlugin</code>.
                        </p>
                        <p>To load the new custom plug-ins into JConsole, start JConsole with the following command:</p><pre class="pre codeblock"><code>%  jconsole -pluginpath <span class="variable" translate="no">plugin-path</span>
</code></pre><p>In the previous command, <code class="codeph"><span class="variable" translate="no">plugin-path</span></code> specifies the paths to the JConsole plug-ins to be looked up. These paths can either be to directory names or to JAR files, and multiple paths can be specified, using your platform's standard separator character.
                        </p>
                        <p>An example JConsole plug-in is provided with the Java SE <span>11</span> platform. The <code class="codeph">JTop</code> application is a JDK demonstration (demo) that shows the CPU usage of all threads running in the application. This demo is useful for identifying threads that have high CPU consumption, and it has been updated to be used as a JConsole plug-in as well as a standalone GUI. <code class="codeph">JTop</code> is bundled with the Java SE <span>11</span> platform, as a demo application. You can run JConsole with the JTop plug-in by running the following command:
                        </p><pre class="pre codeblock"><code>
% <span class="variable" translate="no">JDK_HOME</span>/bin/jconsole -pluginpath <span class="variable" translate="no">JDK_HOME</span>/demo/management/JTop/JTop.jar
</code></pre><p>If you connect to this instance of JConsole, then you will see that the <code class="codeph">JTop</code> tab has been added, showing CPU usage of the various threads running.
                        </p>
                        <p><span class="bold">Figure&nbsp;3-25 Viewing a Custom Plug-in Tab</span></p><img src="img/plugin.gif" height="250" width="516" alt="A custom tab showing connected to the JTop example program." title="A custom tab showing connected to the JTop example program."></div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>
