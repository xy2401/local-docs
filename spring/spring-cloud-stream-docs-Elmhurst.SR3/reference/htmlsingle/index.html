<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Sabby Anandan, Marius Bogoevici, Eric Bottard, Mark Fisher, Ilayaperumal Gopinathan, Gunnar Hillert, Mark Pollack, Patrick Peralta, Glenn Renfro, Thomas Risberg, Dave Syer, David Turanski, Janne Valkealahti, Benjamin Klein, Soby Chacko, Vinicius Carvalho, Gary Russell, Oleg Zhurakousky, Jay Bryant">
<title>Spring Cloud Stream Reference Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
  #tocbot a.toc-link.node-name--H1{ font-style: italic }
  @media screen{
    #tocbot > ul.toc-list{ margin-bottom: 0.5em; margin-left: 0.125em }
    #tocbot ul.sectlevel0, #tocbot a.toc-link.node-name--H1 + ul{
      padding-left: 0 }
    #tocbot a.toc-link{ height:100% }
    .is-collapsible{ max-height:3000px; overflow:hidden; }
    .is-collapsed{ max-height:0 }
    .is-active-link{ font-weight:700 }
  }
  @media print{
    #tocbot a.toc-link.node-name--H4{ display:none }
  }
</style>
</head>
<body id="spring-cloud-stream-reference" class="book toc2 toc-left">
<div id="header">
<h1>Spring Cloud Stream Reference Guide</h1>
<div class="details">
<span id="author" class="author">Sabby Anandan</span><br>
<span id="author2" class="author">Marius Bogoevici</span><br>
<span id="author3" class="author">Eric Bottard</span><br>
<span id="author4" class="author">Mark Fisher</span><br>
<span id="author5" class="author">Ilayaperumal Gopinathan</span><br>
<span id="author6" class="author">Gunnar Hillert</span><br>
<span id="author7" class="author">Mark Pollack</span><br>
<span id="author8" class="author">Patrick Peralta</span><br>
<span id="author9" class="author">Glenn Renfro</span><br>
<span id="author10" class="author">Thomas Risberg</span><br>
<span id="author11" class="author">Dave Syer</span><br>
<span id="author12" class="author">David Turanski</span><br>
<span id="author13" class="author">Janne Valkealahti</span><br>
<span id="author14" class="author">Benjamin Klein</span><br>
<span id="author15" class="author">Soby Chacko</span><br>
<span id="author16" class="author">Vinicius Carvalho</span><br>
<span id="author17" class="author">Gary Russell</span><br>
<span id="author18" class="author">Oleg Zhurakousky</span><br>
<span id="author19" class="author">Jay Bryant</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_spring_cloud_stream_core">Spring Cloud Stream Core</a>
<ul class="sectlevel1">
<li><a href="#_quick_start">1. Quick Start</a>
<ul class="sectlevel3">
<li><a href="#spring-cloud-stream-preface-creating-sample-application">1.1. Creating a Sample Application by Using Spring Initializr</a></li>
<li><a href="#spring-cloud-stream-preface-importing-project">1.2. Importing the Project into Your IDE</a></li>
<li><a href="#spring-cloud-stream-preface-adding-message-handler">1.3. Adding a Message Handler, Building, and Running</a></li>
</ul>
</li>
<li><a href="#_what_s_new_in_2_0">2. What&#8217;s New in 2.0?</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-stream-preface-new-features">2.1. New Features and Components</a></li>
<li><a href="#spring-cloud-stream-preface-notable-enhancements">2.2. Notable Enhancements</a>
<ul class="sectlevel3">
<li><a href="#spring-cloud-stream-preface-actuator-web-dependencies">2.2.1. Both Actuator and Web Dependencies Are Now Optional</a></li>
<li><a href="#spring-cloud-stream-preface-content-type-negotiation-improvements">2.2.2. Content-type Negotiation Improvements</a></li>
</ul>
</li>
<li><a href="#spring-cloud-stream-preface-notable-deprecations">2.3. Notable Deprecations</a>
<ul class="sectlevel3">
<li><a href="#spring-cloud-stream-preface-deprecation-java-serialization">2.3.1. Java Serialization (Java Native and Kryo)</a></li>
<li><a href="#spring-cloud-stream-preface-deprecation-classes-methods">2.3.2. Deprecated Classes and Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-cloud-stream-overview-introducing">3. Introducing Spring Cloud Stream</a></li>
<li><a href="#_main_concepts">4. Main Concepts</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-stream-overview-application-model">4.1. Application Model</a>
<ul class="sectlevel3">
<li><a href="#_fat_jar">4.1.1. Fat JAR</a></li>
</ul>
</li>
<li><a href="#spring-cloud-stream-overview-binder-abstraction">4.2. The Binder Abstraction</a></li>
<li><a href="#spring-cloud-stream-overview-persistent-publish-subscribe-support">4.3. Persistent Publish-Subscribe Support</a></li>
<li><a href="#consumer-groups">4.4. Consumer Groups</a></li>
<li><a href="#consumer-types">4.5. Consumer Types</a>
<ul class="sectlevel3">
<li><a href="#durability">4.5.1. Durability</a></li>
</ul>
</li>
<li><a href="#partitioning">4.6. Partitioning Support</a></li>
</ul>
</li>
<li><a href="#_programming_model">5. Programming Model</a>
<ul class="sectlevel2">
<li><a href="#_destination_binders">5.1. Destination Binders</a></li>
<li><a href="#_destination_bindings">5.2. Destination Bindings</a></li>
<li><a href="#spring-cloud-stream-overview-producing-consuming-messages">5.3. Producing and Consuming Messages</a>
<ul class="sectlevel3">
<li><a href="#_spring_integration_support">5.3.1. Spring Integration Support</a></li>
<li><a href="#_using_streamlistener_annotation">5.3.2. Using @StreamListener Annotation</a></li>
<li><a href="#_using_streamlistener_for_content_based_routing">5.3.3. Using @StreamListener for Content-based routing</a></li>
<li><a href="#spring-cloud-streams-overview-using-polled-consumers">5.3.4. Using Polled Consumers</a></li>
</ul>
</li>
<li><a href="#spring-cloud-stream-overview-error-handling">5.4. Error Handling</a>
<ul class="sectlevel4">
<li><a href="#_application_error_handling">Application Error Handling</a></li>
<li><a href="#_system_error_handling">System Error Handling</a></li>
<li><a href="#_retry_template">Retry Template</a></li>
</ul>
</li>
<li><a href="#spring-cloud-stream-overview-reactive-programming-support">5.5. Reactive Programming Support</a>
<ul class="sectlevel4">
<li><a href="#_reactor_based_handlers">Reactor-based Handlers</a></li>
<li><a href="#_reactive_sources">Reactive Sources</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-cloud-stream-overview-binders">6. Binders</a>
<ul class="sectlevel2">
<li><a href="#_producers_and_consumers">6.1. Producers and Consumers</a></li>
<li><a href="#spring-cloud-stream-overview-binder-api">6.2. Binder SPI</a></li>
<li><a href="#_binder_detection">6.3. Binder Detection</a>
<ul class="sectlevel3">
<li><a href="#_classpath_detection">6.3.1. Classpath Detection</a></li>
</ul>
</li>
<li><a href="#multiple-binders">6.4. Multiple Binders on the Classpath</a></li>
<li><a href="#multiple-systems">6.5. Connecting to Multiple Systems</a></li>
<li><a href="#_binding_visualization_and_control">6.6. Binding visualization and control</a></li>
<li><a href="#_binder_configuration_properties">6.7. Binder Configuration Properties</a></li>
</ul>
</li>
<li><a href="#_configuration_options">7. Configuration Options</a>
<ul class="sectlevel2">
<li><a href="#_binding_service_properties">7.1. Binding Service Properties</a></li>
<li><a href="#binding-properties">7.2. Binding Properties</a>
<ul class="sectlevel3">
<li><a href="#_common_binding_properties">7.2.1. Common Binding Properties</a></li>
<li><a href="#_consumer_properties">7.2.2. Consumer Properties</a></li>
<li><a href="#_producer_properties">7.2.3. Producer Properties</a></li>
</ul>
</li>
<li><a href="#dynamicdestination">7.3. Using Dynamically Bound Destinations</a></li>
</ul>
</li>
<li><a href="#content-type-management">8. Content Type Negotiation</a>
<ul class="sectlevel2">
<li><a href="#_mechanics">8.1. Mechanics</a>
<ul class="sectlevel3">
<li><a href="#_content_type_versus_argument_type">8.1.1. Content Type versus Argument Type</a></li>
<li><a href="#_message_converters">8.1.2. Message Converters</a></li>
</ul>
</li>
<li><a href="#_provided_messageconverters">8.2. Provided MessageConverters</a></li>
<li><a href="#spring-cloud-stream-overview-user-defined-message-converters">8.3. User-defined Message Converters</a></li>
</ul>
</li>
<li><a href="#schema-evolution">9. Schema Evolution Support</a>
<ul class="sectlevel2">
<li><a href="#_schema_registry_client">9.1. Schema Registry Client</a>
<ul class="sectlevel3">
<li><a href="#_schema_registry_client_properties">9.1.1. Schema Registry Client Properties</a></li>
</ul>
</li>
<li><a href="#_avro_schema_registry_client_message_converters">9.2. Avro Schema Registry Client Message Converters</a>
<ul class="sectlevel3">
<li><a href="#_avro_schema_registry_message_converter_properties">9.2.1. Avro Schema Registry Message Converter Properties</a></li>
</ul>
</li>
<li><a href="#_apache_avro_message_converters">9.3. Apache Avro Message Converters</a></li>
<li><a href="#_converters_with_schema_support">9.4. Converters with Schema Support</a></li>
<li><a href="#_schema_registry_server">9.5. Schema Registry Server</a>
<ul class="sectlevel3">
<li><a href="#_schema_registry_server_api">9.5.1. Schema Registry Server API</a>
<ul class="sectlevel4">
<li><a href="#spring-cloud-stream-overview-registering-new-schema">Registering a New Schema</a></li>
<li><a href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version">Retrieving an Existing Schema by Subject, Format, and Version</a></li>
<li><a href="#spring-cloud-stream-overview-retrieve-schema-subject-format">Retrieving an Existing Schema by Subject and Format</a></li>
<li><a href="#spring-cloud-stream-overview-retrieve-schema-id">Retrieving an Existing Schema by ID</a></li>
<li><a href="#spring-cloud-stream-overview-deleting-schema-subject-format-version">Deleting a Schema by Subject, Format, and Version</a></li>
<li><a href="#spring-cloud-stream-overview-deleting-schema-id">Deleting a Schema by ID</a></li>
<li><a href="#spring-cloud-stream-overview-deleting-schema-subject">Deleting a Schema by Subject</a></li>
</ul>
</li>
<li><a href="#_using_confluent_s_schema_registry">9.5.2. Using Confluent&#8217;s Schema Registry</a></li>
</ul>
</li>
<li><a href="#_schema_registration_and_resolution">9.6. Schema Registration and Resolution</a>
<ul class="sectlevel3">
<li><a href="#spring-cloud-stream-overview-schema-registration-process">9.6.1. Schema Registration Process (Serialization)</a></li>
<li><a href="#spring-cloud-stream-overview-schema-resolution-process">9.6.2. Schema Resolution Process (Deserialization)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_inter_application_communication">10. Inter-Application Communication</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-stream-overview-connecting-multiple-application-instances">10.1. Connecting Multiple Application Instances</a></li>
<li><a href="#spring-cloud-stream-overview-instance-index-instance-count">10.2. Instance Index and Instance Count</a></li>
<li><a href="#spring-cloud-stream-overview-partitioning">10.3. Partitioning</a>
<ul class="sectlevel3">
<li><a href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning">10.3.1. Configuring Output Bindings for Partitioning</a></li>
<li><a href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning">10.3.2. Configuring Input Bindings for Partitioning</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_testing">11. Testing</a>
<ul class="sectlevel2">
<li><a href="#_disabling_the_test_binder_autoconfiguration">11.1. Disabling the Test Binder Autoconfiguration</a></li>
</ul>
</li>
<li><a href="#_health_indicator">12. Health Indicator</a></li>
<li><a href="#spring-cloud-stream-overview-metrics-emitter">13. Metrics Emitter</a></li>
<li><a href="#_samples">14. Samples</a>
<ul class="sectlevel2">
<li><a href="#_deploying_stream_applications_on_cloudfoundry">14.1. Deploying Stream Applications on CloudFoundry</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_binder_implementations">Binder Implementations</a>
<ul class="sectlevel1">
<li><a href="#_apache_kafka_binder">15. Apache Kafka Binder</a>
<ul class="sectlevel3">
<li><a href="#_usage">15.1. Usage</a></li>
<li><a href="#_apache_kafka_binder_overview">15.2. Apache Kafka Binder Overview</a></li>
<li><a href="#_configuration_options_2">15.3. Configuration Options</a>
<ul class="sectlevel4">
<li><a href="#_kafka_binder_properties">Kafka Binder Properties</a></li>
<li><a href="#kafka-consumer-properties">Kafka Consumer Properties</a></li>
<li><a href="#kafka-producer-properties">Kafka Producer Properties</a></li>
<li><a href="#_usage_examples">Usage examples</a></li>
</ul>
</li>
<li><a href="#kafka-error-channels">15.4. Error Channels</a></li>
<li><a href="#kafka-metrics">15.5. Kafka Metrics</a></li>
<li><a href="#kafka-dlq-processing">15.6. Dead-Letter Topic Processing</a></li>
<li><a href="#_partitioning_with_the_kafka_binder">15.7. Partitioning with the Kafka Binder</a></li>
</ul>
</li>
<li><a href="#_apache_kafka_streams_binder">16. Apache Kafka Streams Binder</a>
<ul class="sectlevel2">
<li><a href="#_usage_2">16.1. Usage</a></li>
<li><a href="#_kafka_streams_binder_overview">16.2. Kafka Streams Binder Overview</a>
<ul class="sectlevel3">
<li><a href="#_streams_dsl">16.2.1. Streams DSL</a></li>
</ul>
</li>
<li><a href="#_configuration_options_3">16.3. Configuration Options</a>
<ul class="sectlevel3">
<li><a href="#_kafka_streams_properties">16.3.1. Kafka Streams Properties</a></li>
<li><a href="#_timewindow_properties">16.3.2. TimeWindow properties:</a></li>
</ul>
</li>
<li><a href="#_multiple_input_bindings">16.4. Multiple Input Bindings</a>
<ul class="sectlevel3">
<li><a href="#_multiple_input_bindings_as_a_sink">16.4.1. Multiple Input Bindings as a Sink</a></li>
<li><a href="#_multiple_input_bindings_as_a_processor">16.4.2. Multiple Input Bindings as a Processor</a></li>
</ul>
</li>
<li><a href="#_multiple_output_bindings_aka_branching">16.5. Multiple Output Bindings (aka Branching)</a></li>
<li><a href="#_message_conversion">16.6. Message Conversion</a>
<ul class="sectlevel4">
<li><a href="#_outbound_serialization">Outbound serialization</a></li>
<li><a href="#_inbound_deserialization">Inbound Deserialization</a></li>
</ul>
</li>
<li><a href="#_error_handling">16.7. Error Handling</a>
<ul class="sectlevel3">
<li><a href="#_handling_deserialization_exceptions">16.7.1. Handling Deserialization Exceptions</a></li>
<li><a href="#_handling_non_deserialization_exceptions">16.7.2. Handling Non-Deserialization Exceptions</a></li>
</ul>
</li>
<li><a href="#_interactive_queries">16.8. Interactive Queries</a></li>
<li><a href="#_accessing_the_underlying_kafkastreams_object">16.9. Accessing the underlying KafkaStreams object</a></li>
</ul>
</li>
<li><a href="#_rabbitmq_binder">17. RabbitMQ Binder</a>
<ul class="sectlevel3">
<li><a href="#_usage_3">17.1. Usage</a></li>
<li><a href="#_rabbitmq_binder_overview">17.2. RabbitMQ Binder Overview</a></li>
<li><a href="#_configuration_options_4">17.3. Configuration Options</a>
<ul class="sectlevel4">
<li><a href="#rabbit-binder-properties">RabbitMQ Binder Properties</a></li>
<li><a href="#_rabbitmq_consumer_properties">RabbitMQ Consumer Properties</a></li>
<li><a href="#_rabbit_producer_properties">Rabbit Producer Properties</a></li>
</ul>
</li>
<li><a href="#_retry_with_the_rabbitmq_binder">17.4. Retry With the RabbitMQ Binder</a>
<ul class="sectlevel4">
<li><a href="#_putting_it_all_together">Putting it All Together</a></li>
</ul>
</li>
<li><a href="#rabbit-error-channels">17.5. Error Channels</a></li>
<li><a href="#rabbit-dlq-processing">17.6. Dead-Letter Queue Processing</a>
<ul class="sectlevel4">
<li><a href="#_non_partitioned_destinations">Non-Partitioned Destinations</a></li>
<li><a href="#_partitioned_destinations">Partitioned Destinations</a></li>
</ul>
</li>
<li><a href="#_partitioning_with_the_rabbitmq_binder">17.7. Partitioning with the RabbitMQ Binder</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_appendices">Appendices</a>
<ul class="sectlevel1">
<li><a href="#building">Appendix A: Building</a>
<ul class="sectlevel2">
<li><a href="#_basic_compile_and_test">A.1. Basic Compile and Test</a></li>
<li><a href="#_documentation">A.2. Documentation</a></li>
<li><a href="#_working_with_the_code">A.3. Working with the code</a>
<ul class="sectlevel3">
<li><a href="#_importing_into_eclipse_with_m2eclipse">A.3.1. Importing into eclipse with m2eclipse</a></li>
<li><a href="#_importing_into_eclipse_without_m2eclipse">A.3.2. Importing into eclipse without m2eclipse</a></li>
</ul>
</li>
<li><a href="#_sign_the_contributor_license_agreement">A.4. Sign the Contributor License Agreement</a></li>
<li><a href="#_code_conventions_and_housekeeping">A.5. Code Conventions and Housekeeping</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<h1 id="_spring_cloud_stream_core" class="sect0">Spring Cloud Stream Core</h1>
<div class="sect1">
<h2 id="_quick_start">1. Quick Start</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can try Spring Cloud Stream in less then 5 min even before you jump into any details by following this three-step guide.</p>
</div>
<div class="paragraph">
<p>We show you how to create a Spring Cloud Stream application that receives messages coming from the messaging middleware of your choice (more on this later) and logs received messages to the console.
We call it <code>LoggingConsumer</code>.
While not very practical, it provides a good introduction to some of the main concepts
and abstractions, making it easier to digest the rest of this user guide.</p>
</div>
<div class="paragraph">
<p>The three steps are as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#spring-cloud-stream-preface-creating-sample-application">Creating a Sample Application by Using Spring Initializr</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-importing-project">Importing the Project into Your IDE</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-adding-message-handler">Adding a Message Handler, Building, and Running</a></p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-creating-sample-application">1.1. Creating a Sample Application by Using Spring Initializr</h4>
<div class="paragraph">
<p>To get started, visit the <a href="https://start.spring.io">Spring Initializr</a>. From there, you can generate our <code>LoggingConsumer</code> application. To do so:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the <strong>Dependencies</strong> section, start typing <code>stream</code>.
When the &#8220;Cloud Stream&#8221; option should appears, select it.</p>
</li>
<li>
<p>Start typing either 'kafka' or 'rabbit'.</p>
</li>
<li>
<p>Select &#8220;Kafka&#8221; or &#8220;RabbitMQ&#8221;.</p>
<div class="paragraph">
<p>Basically, you choose the messaging middleware to which your application binds.
We recommend using the one you have already installed or feel more comfortable with installing and running.
Also, as you can see from the Initilaizer screen, there are a few other options you can choose.
For example, you can choose Gradle as your build tool instead of Maven (the default).</p>
</div>
</li>
<li>
<p>In the <strong>Artifact</strong> field, type 'logging-consumer'.</p>
<div class="paragraph">
<p>The value of the <strong>Artifact</strong> field becomes the application name.
If you chose RabbitMQ for the middleware, your Spring Initializr should now be as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stream-initializr.png" alt="stream initializr">
</div>
</div>
</li>
<li>
<p>Click the <strong>Generate Project</strong> button.</p>
<div class="paragraph">
<p>Doing so downloads the zipped version of the generated project to your hard drive.</p>
</div>
</li>
<li>
<p>Unzip the file into the folder you want to use as your project directory.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We encourage you to explore the many possibilities available in the Spring Initializr.
It lets you create many different kinds of Spring applications.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-importing-project">1.2. Importing the Project into Your IDE</h4>
<div class="paragraph">
<p>Now you can import the project into your IDE.
Keep in mind that, depending on the IDE, you may need to follow a specific import procedure.
For example, depending on how the project was generated (Maven or Gradle), you may need to follow specific import procedure (for example, in Eclipse or STS, you need to use File &#8594; Import &#8594; Maven &#8594; Existing Maven Project).</p>
</div>
<div class="paragraph">
<p>Once imported, the project must have no errors of any kind. Also, <code>src/main/java</code> should contain <code>com.example.loggingconsumer.LoggingConsumerApplication</code>.</p>
</div>
<div class="paragraph">
<p>Technically, at this point, you can run the application&#8217;s main class.
It is already a valid Spring Boot application.
However, it does not do anything, so we want to add some code.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-adding-message-handler">1.3. Adding a Message Handler, Building, and Running</h4>
<div class="paragraph">
<p>Modify the <code>com.example.loggingconsumer.LoggingConsumerApplication</code> class to look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class LoggingConsumerApplication {

	public static void main(String[] args) {
		SpringApplication.run(LoggingConsumerApplication.class, args);
	}

	@StreamListener(Sink.INPUT)
	public void handle(Person person) {
		System.out.println("Received: " + person);
	}

	public static class Person {
		private String name;
		public String getName() {
			return name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public String toString() {
			return this.name;
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see from the preceding listing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We have enabled <code>Sink</code> binding (input-no-output) by using <code>@EnableBinding(Sink.class)</code>.
Doing so signals to the framework to initiate binding to the messaging middleware, where it automatically creates the destination (that is, queue, topic, and others) that are bound to the <code>Sink.INPUT</code> channel.</p>
</li>
<li>
<p>We have added a <code>handler</code> method to receive incoming messages of type <code>Person</code>.
Doing so lets you see one of the core features of the framework: It tries to automatically convert incoming message payloads to type <code>Person</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You now have a fully functional Spring Cloud Stream application that does listens for messages.
From here, for simplicity, we assume you selected RabbitMQ in <a href="#spring-cloud-stream-preface-creating-sample-application">step one</a>.
Assuming you have RabbitMQ installed and running, you can start the application by running its <code>main</code> method in your IDE.</p>
</div>
<div class="paragraph">
<p>You should see following output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>	--- [ main] c.s.b.r.p.RabbitExchangeQueueProvisioner : declaring queue for inbound: input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg, bound to: input
	--- [ main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [localhost:5672]
	--- [ main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#2a3a299:0/SimpleConnection@66c83fc8. . .
	. . .
	--- [ main] o.s.i.a.i.AmqpInboundChannelAdapter      : started inbound.input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg
	. . .
	--- [ main] c.e.l.LoggingConsumerApplication         : Started LoggingConsumerApplication in 2.531 seconds (JVM running for 2.897)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Go to the RabbitMQ management console or any other RabbitMQ client and send a message to <code>input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code>.
The <code>anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code> part represents the group name and is generated, so it is bound to be different in your environment.
For something more predictable, you can use an explicit group name by setting <code>spring.cloud.stream.bindings.input.group=hello</code> (or whatever name you like).</p>
</div>
<div class="paragraph">
<p>The contents of the message should be a JSON representation of the <code>Person</code> class, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{"name":"Sam Spade"}</pre>
</div>
</div>
<div class="paragraph">
<p>Then, in your console, you should see:</p>
</div>
<div class="paragraph">
<p><code>Received: Sam Spade</code></p>
</div>
<div class="paragraph">
<p>You can also build and package your application into a boot jar (by using <code>./mvnw clean install</code>) and run the built JAR by using the <code>java -jar</code> command.</p>
</div>
<div class="paragraph">
<p>Now you have a working (albeit very basic) Spring Cloud Stream application.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_s_new_in_2_0">2. What&#8217;s New in 2.0?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream introduces a number of new features, enhancements, and changes. The following sections outline the most notable ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-new-features">New Features and Components</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-notable-enhancements">Notable Enhancements</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-preface-new-features">2.1. New Features and Components</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Polling Consumers</strong>: Introduction of polled consumers, which lets the application control message processing rates.
See &#8220;<a href="#spring-cloud-streams-overview-using-polled-consumers">Using Polled Consumers</a>&#8221; for more details.
You can also read <a href="https://spring.io/blog/2018/02/27/spring-cloud-stream-2-0-polled-consumers">this blog post</a> for more details.</p>
</li>
<li>
<p><strong>Micrometer Support</strong>: Metrics has been switched to use <a href="https://micrometer.io/">Micrometer</a>.
<code>MeterRegistry</code> is also provided as a bean so that custom applications can autowire it to capture custom metrics.
See &#8220;<a href="#spring-cloud-stream-overview-metrics-emitter">Metrics Emitter</a>&#8221; for more details.</p>
</li>
<li>
<p><strong>New Actuator Binding Controls</strong>: New actuator binding controls let you both visualize and control the Bindings lifecycle.
For more details, see <a href="#_binding_visualization_and_control">Binding visualization and control</a>.</p>
</li>
<li>
<p><strong>Configurable RetryTemplate</strong>: Aside from providing properties to configure <code>RetryTemplate</code>, we now let you provide your own template, effectively overriding the one provided by the framework.
To use it, configure it as a <code>@Bean</code> in your application.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-preface-notable-enhancements">2.2. Notable Enhancements</h3>
<div class="paragraph">
<p>This version includes the following notable enhancements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-actuator-web-dependencies">Both Actuator and Web Dependencies Are Now Optional</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-content-type-negotiation-improvements">Content-type Negotiation Improvements</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-notable-deprecations">Notable Deprecations</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-actuator-web-dependencies">2.2.1. Both Actuator and Web Dependencies Are Now Optional</h4>
<div class="paragraph">
<p>This change slims down the footprint of the deployed application in the event neither actuator nor web dependencies required.
It also lets you switch between the reactive and conventional web paradigms by manually adding one of the following dependencies.</p>
</div>
<div class="paragraph">
<p>The following listing shows how to add the conventional web framework:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows how to add the reactive web framework:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following list shows how to add the actuator dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-content-type-negotiation-improvements">2.2.2. Content-type Negotiation Improvements</h4>
<div class="paragraph">
<p>One of the core themes for verion 2.0 is improvements (in both consistency and performance) around content-type negotiation and message conversion.
The following summary outlines the notable changes and improvements in this area.
See the &#8220;<a href="#content-type-management">Content Type Negotiation</a>&#8221; section for more details.
Also <a href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation">this blog post</a> contains more detail.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All message conversion is now handled <strong>only</strong> by <code>MessageConverter</code> objects.</p>
</li>
<li>
<p>We introduced the <code>@StreamMessageConverter</code> annotation to provide custom <code>MessageConverter</code> objects.</p>
</li>
<li>
<p>We introduced the default <code>Content Type</code> as <code>application/json</code>, which needs to be taken into consideration when migrating 1.3 application or operating in the mixed mode (that is, 1.3 producer &#8594; 2.0 consumer).</p>
</li>
<li>
<p>Messages with textual payloads and a <code>contentType</code> of <code>text/&#8230;&#8203;</code> or <code>&#8230;&#8203;/json</code> are no longer converted to <code>Message&lt;String&gt;</code> for cases where the argument type of the provided <code>MessageHandler</code> can not be determined (that is, <code>public void handle(Message&lt;?&gt; message)</code> or <code>public void handle(Object payload)</code>).
Furthermore, a strong argument type may not be enough to properly convert messages, so the <code>contentType</code> header may be used as a supplement by some <code>MessageConverters</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-preface-notable-deprecations">2.3. Notable Deprecations</h3>
<div class="paragraph">
<p>As of version 2.0, the following items have been deprecated:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-deprecation-java-serialization">Java Serialization (Java Native and Kryo)</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-deprecation-classes-methods">Deprecated Classes and Methods</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-deprecation-java-serialization">2.3.1. Java Serialization (Java Native and Kryo)</h4>
<div class="paragraph">
<p><code>JavaSerializationMessageConverter</code> and <code>KryoMessageConverter</code> remain for now. However, we plan to move them out of the core packages and support in the future.
The main reason for this deprecation is to flag the issue that type-based, language-specific serialization could cause in distributed environments, where Producers and Consumers may depend on different JVM versions or have different versions of supporting libraries (that is, Kryo).
We also wanted to draw the attention to the fact that Consumers and Producers may not even be Java-based, so polyglot style serialization (i.e., JSON) is better suited.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-deprecation-classes-methods">2.3.2. Deprecated Classes and Methods</h4>
<div class="paragraph">
<p>The following is a quick summary of notable deprecations. See the corresponding {spring-cloud-stream-javadoc-current}[javadoc] for more details.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SharedChannelRegistry</code>. Use <code>SharedBindingTargetRegistry</code>.</p>
</li>
<li>
<p><code>Bindings</code>.
Beans qualified by it are already uniquely identified by their type&#8201;&#8212;&#8201;for example, provided <code>Source</code>, <code>Processor</code>, or custom bindings:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>public interface Sample {
	String OUTPUT = "sampleOutput";

	@Output(Sample.OUTPUT)
	MessageChannel output();
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HeaderMode.raw</code>. Use <code>none</code>, <code>headers</code> or <code>embeddedHeaders</code></p>
</li>
<li>
<p><code>ProducerProperties.partitionKeyExtractorClass</code> in favor of <code>partitionKeyExtractorName</code> and <code>ProducerProperties.partitionSelectorClass</code> in favor of <code>partitionSelectorName</code>.
This change ensures that both components are Spring configured and managed and are referenced in a Spring-friendly way.</p>
</li>
<li>
<p><code>BinderAwareRouterBeanPostProcessor</code>. While the component remains, it is no longer a <code>BeanPostProcessor</code> and will be renamed in the future.</p>
</li>
<li>
<p><code>BinderProperties.setEnvironment(Properties environment)</code>. Use <code>BinderProperties.setEnvironment(Map&lt;String, Object&gt; environment)</code>.</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This section goes into more detail about how you can work with Spring Cloud Stream.
It covers topics such as creating and running stream applications.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-stream-overview-introducing">3. Introducing Spring Cloud Stream</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream is a framework for building message-driven microservice applications.
Spring Cloud Stream builds upon Spring Boot to create standalone, production-grade Spring applications and uses Spring Integration to provide connectivity to message brokers.
It provides opinionated configuration of middleware from several vendors, introducing the concepts of persistent publish-subscribe semantics, consumer groups, and partitions.</p>
</div>
<div class="paragraph">
<p>You can add the <code>@EnableBinding</code> annotation to your application to get immediate connectivity to a message broker, and you can add <code>@StreamListener</code> to a method to cause it to receive events for stream processing.
The following example shows a sink application that receives external messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class VoteRecordingSinkApplication {

  public static void main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.class, args);
  }

  @StreamListener(Sink.INPUT)
  public void processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@EnableBinding</code> annotation takes one or more interfaces as parameters (in this case, the parameter is a single <code>Sink</code> interface).
An interface declares input and output channels.
Spring Cloud Stream provides the <code>Source</code>, <code>Sink</code>, and <code>Processor</code> interfaces. You can also define your own interfaces.</p>
</div>
<div class="paragraph">
<p>The following listing shows the definition of the <code>Sink</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Sink {
  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Input</code> annotation identifies an input channel, through which received messages enter the application.
The <code>@Output</code> annotation identifies an output channel, through which published messages leave the application.
The <code>@Input</code> and <code>@Output</code> annotations can take a channel name as a parameter.
If a name is not provided, the name of the annotated method is used.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream creates an implementation of the interface for you.
You can use this in the application by autowiring it, as shown in the following example (from a test case):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = VoteRecordingSinkApplication.class)
@WebAppConfiguration
@DirtiesContext
public class StreamApplicationTests {

  @Autowired
  private Sink sink;

  @Test
  public void contextLoads() {
    assertNotNull(this.sink.input());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_main_concepts">4. Main Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream provides a number of abstractions and primitives that simplify the writing of message-driven microservice applications.
This section gives an overview of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-overview-application-model">Spring Cloud Stream&#8217;s application model</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-binder-abstraction">The Binder Abstraction</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-persistent-publish-subscribe-support">Persistent publish-subscribe support</a></p>
</li>
<li>
<p><a href="#consumer-groups">Consumer group support</a></p>
</li>
<li>
<p><a href="#partitioning">Partitioning support</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-binder-api">A pluggable Binder SPI</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-application-model">4.1. Application Model</h3>
<div class="paragraph">
<p>A Spring Cloud Stream application consists of a middleware-neutral core.
The application communicates with the outside world through input and output channels injected into it by Spring Cloud Stream.
Channels are connected to external brokers through middleware-specific Binder implementations.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/SCSt-with-binder.png" alt="SCSt with binder" width="800">
</div>
<div class="title">Figure 1. Spring Cloud Stream Application</div>
</div>
<div class="sect3">
<h4 id="_fat_jar">4.1.1. Fat JAR</h4>
<div class="paragraph">
<p>Spring Cloud Stream applications can be run in stand-alone mode from your IDE for testing.
To run a Spring Cloud Stream application in production, you can create an executable (or &#8220;fat&#8221;) JAR by using the standard Spring Boot tooling provided for Maven or Gradle. See the  <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-build.html#howto-create-an-executable-jar-with-maven">Spring Boot Reference Guide</a> for more details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-binder-abstraction">4.2. The Binder Abstraction</h3>
<div class="paragraph">
<p>Spring Cloud Stream provides Binder implementations for <a href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-kafka">Kafka</a> and <a href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-rabbit">Rabbit MQ</a>.
Spring Cloud Stream also includes a <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java">TestSupportBinder</a>, which leaves a channel unmodified so that tests can interact with channels directly and reliably assert on what is received.
You can also use the extensible API to write your own Binder.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream uses Spring Boot for configuration, and the Binder abstraction makes it possible for a Spring Cloud Stream application to be flexible in how it connects to middleware.
For example, deployers can dynamically choose, at runtime, the destinations (such as the Kafka topics or RabbitMQ exchanges) to which channels connect.
Such configuration can be provided through external configuration properties and in any form supported by Spring Boot (including application arguments, environment variables, and <code>application.yml</code> or <code>application.properties</code> files).
In the sink example from the <a href="#spring-cloud-stream-overview-introducing">Introducing Spring Cloud Stream</a> section, setting the <code>spring.cloud.stream.bindings.input.destination</code> application property to <code>raw-sensor-data</code> causes it to read from the <code>raw-sensor-data</code> Kafka topic or from a queue bound to the <code>raw-sensor-data</code> RabbitMQ exchange.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream automatically detects and uses a binder found on the classpath.
You can use different types of middleware with the same code.
To do so, include a different binder at build time.
For more complex use cases, you can also package multiple binders with your application and have it choose the binder( and even whether to use different binders for different channels) at runtime.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-persistent-publish-subscribe-support">4.3. Persistent Publish-Subscribe Support</h3>
<div class="paragraph">
<p>Communication between applications follows a publish-subscribe model, where data is broadcast through shared topics.
This can be seen in the following figure, which shows a typical deployment for a set of interacting Spring Cloud Stream applications.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/SCSt-sensors.png" alt="SCSt sensors" width="800">
</div>
<div class="title">Figure 2. Spring Cloud Stream Publish-Subscribe</div>
</div>
<div class="paragraph">
<p>Data reported by sensors to an HTTP endpoint is sent to a common destination named <code>raw-sensor-data</code>.
From the destination, it is independently processed by a microservice application that computes time-windowed averages and by another microservice application that ingests the raw data into HDFS (Hadoop Distributed File System).
In order to process the data, both applications declare the topic as their input at runtime.</p>
</div>
<div class="paragraph">
<p>The publish-subscribe communication model reduces the complexity of both the producer and the consumer and lets new applications be added to the topology without disruption of the existing flow.
For example, downstream from the average-calculating application, you can add an application that calculates the highest temperature values for display and monitoring.
You can then add another application that interprets the same flow of averages for fault detection.
Doing all communication through shared topics rather than point-to-point queues reduces coupling between microservices.</p>
</div>
<div class="paragraph">
<p>While the concept of publish-subscribe messaging is not new, Spring Cloud Stream takes the extra step of making it an opinionated choice for its application model.
By using native middleware support, Spring Cloud Stream also simplifies use of the publish-subscribe model across different platforms.</p>
</div>
</div>
<div class="sect2">
<h3 id="consumer-groups">4.4. Consumer Groups</h3>
<div class="paragraph">
<p>While the publish-subscribe model makes it easy to connect applications through shared topics, the ability to scale up by creating multiple instances of a given application is equally important.
When doing so, different instances of an application are placed in a competing consumer relationship, where only one of the instances is expected to handle a given message.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream models this behavior through the concept of a consumer group.
(Spring Cloud Stream consumer groups are similar to and inspired by Kafka consumer groups.)
Each consumer binding can use the <code>spring.cloud.stream.bindings.&lt;channelName&gt;.group</code> property to specify a group name.
For the consumers shown in the following figure, this property would be set as <code>spring.cloud.stream.bindings.&lt;channelName&gt;.group=hdfsWrite</code> or <code>spring.cloud.stream.bindings.&lt;channelName&gt;.group=average</code>.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/SCSt-groups.png" alt="SCSt groups" width="800">
</div>
<div class="title">Figure 3. Spring Cloud Stream Consumer Groups</div>
</div>
<div class="paragraph">
<p>All groups that subscribe to a given destination receive a copy of published data, but only one member of each group receives a given message from that destination.
By default, when a group is not specified, Spring Cloud Stream assigns the application to an anonymous and independent single-member consumer group that is in a publish-subscribe relationship with all other consumer groups.</p>
</div>
</div>
<div class="sect2">
<h3 id="consumer-types">4.5. Consumer Types</h3>
<div class="paragraph">
<p>Two types of consumer are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Message-driven (sometimes referred to as Asynchronous)</p>
</li>
<li>
<p>Polled (sometimes referred to as Synchronous)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Prior to version 2.0, only asynchronous consumers were supported. A message is delivered as soon as it is available and a thread is available to process it.</p>
</div>
<div class="paragraph">
<p>When you wish to control the rate at which messages are processed, you might want to use a synchronous consumer.</p>
</div>
<div class="sect3">
<h4 id="durability">4.5.1. Durability</h4>
<div class="paragraph">
<p>Consistent with the opinionated application model of Spring Cloud Stream, consumer group subscriptions are durable.
That is, a binder implementation ensures that group subscriptions are persistent and that, once at least one subscription for a group has been created, the group receives messages, even if they are sent while all applications in the group are stopped.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Anonymous subscriptions are non-durable by nature.
For some binder implementations (such as RabbitMQ), it is possible to have non-durable group subscriptions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In general, it is preferable to always specify a consumer group when binding an application to a given destination.
When scaling up a Spring Cloud Stream application, you must specify a consumer group for each of its input bindings.
Doing so prevents the application&#8217;s instances from receiving duplicate messages (unless that behavior is desired, which is unusual).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partitioning">4.6. Partitioning Support</h3>
<div class="paragraph">
<p>Spring Cloud Stream provides support for partitioning data between multiple instances of a given application.
In a partitioned scenario, the physical communication medium (such as the broker topic) is viewed as being structured into multiple partitions.
One or more producer application instances send data to multiple consumer application instances and ensure that data identified by common characteristics are processed by the same consumer instance.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream provides a common abstraction for implementing partitioned processing use cases in a uniform fashion.
Partitioning can thus be used whether the broker itself is naturally partitioned (for example, Kafka) or not (for example, RabbitMQ).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/SCSt-partitioning.png" alt="SCSt partitioning" width="800">
</div>
<div class="title">Figure 4. Spring Cloud Stream Partitioning</div>
</div>
<div class="paragraph">
<p>Partitioning is a critical concept in stateful processing, where it is critical (for either performance or consistency reasons) to ensure that all related data is processed together.
For example, in the time-windowed average calculation example, it is important that all measurements from any given sensor are processed by the same application instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To set up a partitioned processing scenario, you must configure both the data-producing and the data-consuming ends.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programming_model">5. Programming Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To understand the programming model, you should be familiar with the following core concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Destination Binders:</strong> Components responsible to provide integration with the external messaging systems.</p>
</li>
<li>
<p><strong>Destination Bindings:</strong> Bridge between the external messaging systems and application provided <em>Producers</em> and <em>Consumers</em> of messages (created by the Destination Binders).</p>
</li>
<li>
<p><strong>Message:</strong> The canonical data structure used by producers and consumers to communicate with Destination Binders (and thus other applications via external messaging systems).</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/SCSt-overview.png" alt="SCSt overview" width="800">
</div>
</div>
<div class="sect2">
<h3 id="_destination_binders">5.1. Destination Binders</h3>
<div class="paragraph">
<p>Destination Binders are extension components of Spring Cloud Stream responsible for providing the necessary configuration and implementation to facilitate
integration with external messaging systems.
This integration is responsible for connectivity, delegation, and routing of messages to and from producers and consumers, data type conversion,
invocation of the user code, and more.</p>
</div>
<div class="paragraph">
<p>Binders handle a lot of the boiler plate responsibilities that would otherwise fall on your shoulders. However, to accomplish that, the binder still needs
some help in the form of minimalistic yet required set of instructions from the user, which typically come in the form of some type of configuration.</p>
</div>
<div class="paragraph">
<p>While it is out of scope of this section to discuss all of the available binder and binding configuration options (the rest of the manual covers them extensively),
<em>Destination Binding</em> does require special attention. The next section discusses it in detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="_destination_bindings">5.2. Destination Bindings</h3>
<div class="paragraph">
<p>As stated earlier, <em>Destination Bindings</em> provide a bridge between the external messaging system and application-provided <em>Producers</em> and <em>Consumers</em>.</p>
</div>
<div class="paragraph">
<p>Applying the @EnableBinding annotation to one of the applications configuration classes defines a destination binding.
The <code>@EnableBinding</code> annotation itself is meta-annotated with <code>@Configuration</code> and triggers the configuration of the Spring Cloud Stream infrastructure.</p>
</div>
<div class="paragraph">
<p>The following example shows a fully configured and functioning Spring Cloud Stream application that receives the payload of the message from the <code>INPUT</code>
destination as a <code>String</code> type (see <a href="#content-type-management">Content Type Negotiation</a> section), logs it to the console and sends it to the <code>OUTPUT</code> destination after converting it to upper case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Processor.class)
public class MyApplication {

	public static void main(String[] args) {
		SpringApplication.run(MyApplication.class, args);
	}

	@StreamListener(Processor.INPUT)
	@SendTo(Processor.OUTPUT)
	public String handle(String value) {
		System.out.println("Received: " + value);
		return value.toUpperCase();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the <code>@EnableBinding</code> annotation can take one or more interface classes as parameters. The parameters are referred to as <em>bindings</em>,
and they contain methods representing <em>bindable components</em>.
These components are typically message channels (see <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-messaging.html">Spring Messaging</a>)
for channel-based binders (such as Rabbit, Kafka, and others). However other types of bindings can
provide support for the native features of the corresponding technology. For example Kafka Streams binder (formerly known as KStream) allows native bindings directly to Kafka Streams
(see <a href="https://docs.spring.io/autorepo/docs/spring-cloud-stream-binder-kafka-docs/1.1.0.M1/reference/htmlsingle/">Kafka Streams</a> for more details).</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream already provides <em>binding</em> interfaces for typical message exchange contracts, which include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Sink:</strong> Identifies the contract for the message consumer by providing the destination from which the message is consumed.</p>
</li>
<li>
<p><strong>Source:</strong> Identifies the contract for the message producer by providing the destination to which the produced message is sent.</p>
</li>
<li>
<p><strong>Processor:</strong> Encapsulates both the sink and the source contracts by exposing two destinations that allow consumption and production of messages.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Sink {

  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Processor extends Source, Sink {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the preceding example satisfies the majority of cases, you can also define your own contracts by defining your own bindings interfaces and use <code>@Input</code> and <code>@Output</code>
annotations to identify the actual <em>bindable components</em>.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Barista {

    @Input
    SubscribableChannel orders();

    @Output
    MessageChannel hotDrinks();

    @Output
    MessageChannel coldDrinks();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the interface shown in the preceding example as a parameter to <code>@EnableBinding</code> triggers the creation of the three bound channels named <code>orders</code>, <code>hotDrinks</code>, and <code>coldDrinks</code>,
respectively.</p>
</div>
<div class="paragraph">
<p>You can provide as many binding interfaces as you need, as arguments to the <code>@EnableBinding</code> annotation, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(value = { Orders.class, Payment.class })</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Spring Cloud Stream, the bindable <code>MessageChannel</code> components are the Spring Messaging <code>MessageChannel</code> (for outbound) and its extension, <code>SubscribableChannel</code>,
(for inbound).</p>
</div>
<div class="paragraph">
<p><strong>Pollable Destination Binding</strong></p>
</div>
<div class="paragraph">
<p>While the previously described bindings support event-based message consumption, sometimes you need more control, such as rate of consumption.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0, you can now bind a pollable consumer:</p>
</div>
<div class="paragraph">
<p>The following example shows how to bind a pollable consumer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PolledBarista {

    @Input
    PollableMessageSource orders();
	. . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, an implementation of <code>PollableMessageSource</code> is bound to the <code>orders</code> channel. See <a href="#spring-cloud-streams-overview-using-polled-consumers">Using Polled Consumers</a> for more details.</p>
</div>
<div class="paragraph">
<p><strong>Customizing Channel Names</strong></p>
</div>
<div class="paragraph">
<p>By using the <code>@Input</code> and <code>@Output</code> annotations, you can specify a customized channel name for the channel, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Barista {
    @Input("inboundOrders")
    SubscribableChannel orders();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the created bound channel is named <code>inboundOrders</code>.</p>
</div>
<div class="paragraph">
<p>Normally, you need not access individual channels or bindings directly  (other then configuring them via <code>@EnableBinding</code> annotation). However there may be
times, such as testing or other corner cases, when you do.</p>
</div>
<div class="paragraph">
<p>Aside from generating channels for each binding and registering them as Spring beans, for each bound interface, Spring Cloud Stream generates a bean that implements the interface.
That means you can have access to the interfaces representing the bindings or individual channels by auto-wiring either in your application, as shown in the following two examples:</p>
</div>
<div class="paragraph">
<p><em>Autowire Binding interface</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowire
private Source source

public void sayHello(String name) {
    source.output().send(MessageBuilder.withPayload(name).build());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Autowire individual channel</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowire
private MessageChannel output;

public void sayHello(String name) {
    output.send(MessageBuilder.withPayload(name).build());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use standard Spring&#8217;s <code>@Qualifier</code> annotation for cases when channel names are customized or in multiple-channel scenarios that require specifically named channels.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the @Qualifier annotation in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowire
@Qualifier("myChannel")
private MessageChannel output;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-producing-consuming-messages">5.3. Producing and Consuming Messages</h3>
<div class="paragraph">
<p>You can write a Spring Cloud Stream application by using either Spring Integration annotations or Spring Cloud Stream native annotation.</p>
</div>
<div class="sect3">
<h4 id="_spring_integration_support">5.3.1. Spring Integration Support</h4>
<div class="paragraph">
<p>Spring Cloud Stream is built on the concepts and patterns defined by <a href="https://www.enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a> and relies
in its internal implementation on an already established and popular implementation of Enterprise Integration Patterns within the Spring portfolio of projects:
<a href="https://projects.spring.io/spring-integration/">Spring Integration</a> framework.</p>
</div>
<div class="paragraph">
<p>So its only natiural for it to support the foundation, semantics, and configuration options that are already established by Spring Integration</p>
</div>
<div class="paragraph">
<p>For example, you can attach the output channel of a <code>Source</code> to a <code>MessageSource</code> and use the familiar <code>@InboundChannelAdapter</code> annotation, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
public class TimerSource {

  @Bean
  @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "10", maxMessagesPerPoll = "1"))
  public MessageSource&lt;String&gt; timerMessageSource() {
    return () -&gt; new GenericMessage&lt;&gt;("Hello Spring Cloud Stream");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can use @Transformer or @ServiceActivator while providing an implementation of a message handler method for a <em>Processor</em> binding contract, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {
  @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
  public Object transform(String message) {
    return message.toUpperCase();
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While this may be skipping ahead a bit, it is important to understand that, when you consume from the same binding using <code>@StreamListener</code> annotation, a pub-sub model is used.
Each method annotated with <code>@StreamListener</code> receives its own copy of a message, and each one has its own consumer group.
However, if you consume from the same binding by using one of the Spring Integration annotation (such as <code>@Aggregator</code>, <code>@Transformer</code>, or <code>@ServiceActivator</code>), those consume in a competing model.
No individual consumer group is created for each subscription.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_streamlistener_annotation">5.3.2. Using @StreamListener Annotation</h4>
<div class="paragraph">
<p>Complementary to its Spring Integration support, Spring Cloud Stream provides its own <code>@StreamListener</code> annotation, modeled after other Spring Messaging annotations
(<code>@MessageMapping</code>, <code>@JmsListener</code>, <code>@RabbitListener</code>, and others) and provides conviniences, such as content-based routing and others.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
public class VoteHandler {

  @Autowired
  VotingService votingService;

  @StreamListener(Sink.INPUT)
  public void handle(Vote vote) {
    votingService.record(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with other Spring Messaging methods, method arguments can be annotated with <code>@Payload</code>, <code>@Headers</code>, and <code>@Header</code>.</p>
</div>
<div class="paragraph">
<p>For methods that return data, you must use the <code>@SendTo</code> annotation to specify the output binding destination for data returned by the method, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {

  @Autowired
  VotingService votingService;

  @StreamListener(Processor.INPUT)
  @SendTo(Processor.OUTPUT)
  public VoteResult handle(Vote vote) {
    return votingService.record(vote);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_streamlistener_for_content_based_routing">5.3.3. Using @StreamListener for Content-based routing</h4>
<div class="paragraph">
<p>Spring Cloud Stream supports dispatching messages to multiple handler methods annotated with <code>@StreamListener</code> based on conditions.</p>
</div>
<div class="paragraph">
<p>In order to be eligible to support conditional dispatching, a method must satisfy the follow conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It must not return a value.</p>
</li>
<li>
<p>It must be an individual message handling method (reactive API methods are not supported).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The condition is specified by a SpEL expression in the <code>condition</code> argument of the annotation and is evaluated for each message.
All the handlers that match the condition are invoked in the same thread, and no assumption must be made about the order in which the invocations take place.</p>
</div>
<div class="paragraph">
<p>In the following example of a <code>@StreamListener</code> with dispatching conditions, all the messages bearing a header <code>type</code> with the value <code>bogey</code> are dispatched to the
<code>receiveBogey</code> method, and all the messages bearing a header <code>type</code> with the value <code>bacall</code> are dispatched to the <code>receiveBacall</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class TestPojoWithAnnotatedArguments {

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bogey'")
    public void receiveBogey(@Payload BogeyPojo bogeyPojo) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bacall'")
    public void receiveBacall(@Payload BacallPojo bacallPojo) {
       // handle the message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Content Type Negotiation in the Context of <code>condition</code></strong></p>
</div>
<div class="paragraph">
<p>It is important to understand some of the mechanics behind content-based routing using the <code>condition</code> argument of <code>@StreamListener</code>, especially in the context of the type of the message as a whole.
It may also help if you familiarize yourself with the <a href="#content-type-management">Content Type Negotiation</a>  before you proceed.</p>
</div>
<div class="paragraph">
<p>Consider the following scenario:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class CatsAndDogs {

    @StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Dog'")
    public void bark(Dog dog) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Cat'")
    public void purr(Cat cat) {
       // handle the message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code is perfectly valid. It compiles and deploys without any issues, yet it never produces the result you expect.</p>
</div>
<div class="paragraph">
<p>That is because you are testing something that does not yet exist in a state you expect. That is becouse the payload of the message is not yet converted from the
wire format (<code>byte[]</code>) to the desired type.
In other words, it has not yet gone through the type conversion process described in the <a href="#content-type-management">Content Type Negotiation</a>.</p>
</div>
<div class="paragraph">
<p>So, unless you use a SPeL expression that evaluates raw data (for example, the value of the first byte in the byte array), use message header-based expressions
(such as <code>condition = "headers['type']=='dog'"</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
At the moment, dispatching through <code>@StreamListener</code> conditions is supported only for channel-based binders (not for reactive programming)
support.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-streams-overview-using-polled-consumers">5.3.4. Using Polled Consumers</h4>
<div class="paragraph">
<p>When using polled consumers, you poll the <code>PollableMessageSource</code> on demand.
Consider the following example of a polled consumer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PolledConsumer {

    @Input
    PollableMessageSource destIn();

    @Output
    MessageChannel destOut();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given the polled consumer in the preceding example, you might use it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ApplicationRunner poller(PollableMessageSource destIn, MessageChannel destOut) {
    return args -&gt; {
        while (someCondition()) {
            try {
                if (!destIn.poll(m -&gt; {
                    String newPayload = ((String) m.getPayload()).toUpperCase();
                    destOut.send(new GenericMessage&lt;&gt;(newPayload));
                })) {
                    Thread.sleep(1000);
                }
            }
            catch (Exception e) {
                // handle failure (throw an exception to reject the message);
            }
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PollableMessageSource.poll()</code> method takes a <code>MessageHandler</code> argument (often a lambda expression, as shown here).
It returns <code>true</code> if the message was received and successfully processed.</p>
</div>
<div class="paragraph">
<p>As with message-driven consumers, if the <code>MessageHandler</code> throws an exception, messages are published to error channels, as discussed in &#8220;<a href="#binder-error-channels">[binder-error-channels]</a>&#8221;.</p>
</div>
<div class="paragraph">
<p>Normally, the <code>poll()</code> method acknowledges the message when the <code>MessageHandler</code> exits.
If the method exits abnormally, the message is rejected (not re-queued).
You can override that behavior by taking responsibility for the acknowledgment, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ApplicationRunner poller(PollableMessageSource dest1In, MessageChannel dest2Out) {
    return args -&gt; {
        while (someCondition()) {
            if (!dest1In.poll(m -&gt; {
                StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).noAutoAck();
                // e.g. hand off to another thread which can perform the ack
                // or acknowledge(Status.REQUEUE)

            })) {
                Thread.sleep(1000);
            }
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You must <code>ack</code> (or <code>nack</code>) the message at some point, to avoid resource leaks.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Some messaging systems (such as Apache Kafka) maintain a simple offset in a log. If a delivery fails and is re-queued with  <code>StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).acknowledge(Status.REQUEUE);</code>, any later successfully ack&#8217;d messages are redelivered.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There is also an overloaded <code>poll</code> method, for which the definition is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">poll(MessageHandler handler, ParameterizedTypeReference&lt;?&gt; type)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>type</code> is a conversion hint that allows the incoming message payload to be converted, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean result = pollableSource.poll(received -&gt; {
			Map&lt;String, Foo&gt; payload = (Map&lt;String, Foo&gt;) received.getPayload();
            ...

		}, new ParameterizedTypeReference&lt;Map&lt;String, Foo&gt;&gt;() {});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-error-handling">5.4. Error Handling</h3>
<div class="paragraph">
<p>Errors happen, and Spring Cloud Stream provides several flexible mechanisms to handle them.
The error handling comes in two flavors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>application:</strong> The error handling is done within the application (custom error handler).</p>
</li>
<li>
<p><strong>system:</strong> The error handling is delegated to the binder (re-queue, DL, and others). Note that the techniques are dependent on binder implementation and the
capability of the underlying messaging middleware.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Stream uses the <a href="https://github.com/spring-projects/spring-retry">Spring Retry</a> library to facilitate successful message processing. See <a href="#_retry_template">Retry Template</a> for more details.
However, when all fails, the exceptions thrown by the message handlers are propagated back to the binder. At that point, binder invokes custom error handler or communicates
the error back to the messaging system (re-queue, DLQ, and others).</p>
</div>
<div class="sect4">
<h5 id="_application_error_handling">Application Error Handling</h5>
<div class="paragraph">
<p>There are two types of application-level error handling. Errors can be handled at each binding subscription or a global handler can handle all the binding subscription errors. Let&#8217;s review the details.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/custom_vs_global_error_channels.png" alt="custom vs global error channels" width="800">
</div>
<div class="title">Figure 5. A Spring Cloud Stream Sink Application with Custom and Global Error Handlers</div>
</div>
<div class="paragraph">
<p>For each input binding, Spring Cloud Stream creates a dedicated error channel with the following semantics <code>&lt;destinationName&gt;.errors</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>&lt;destinationName&gt;</code> consists of the name of the binding (such as <code>input</code>) and the name of the group (such as <code>myGroup</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.bindings.input.group=myGroup</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@StreamListener(Sink.INPUT) // destination name 'input.myGroup'
public void handle(Person value) {
	throw new RuntimeException("BOOM!");
}

@ServiceActivator(inputChannel = Processor.INPUT + ".myGroup.errors") //channel name 'input.myGroup.errors'
public void error(Message&lt;?&gt; message) {
	System.out.println("Handling ERROR: " + message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example the destination name is <code>input.myGroup</code> and the dedicated error channel name is <code>input.myGroup.errors</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The use of @StreamListener annotation is intended specifically to define bindings that bridge internal channels and external destinations. Given that the destination
specific error channel does NOT have an associated external destination, such channel is a prerogative of Spring Integration (SI). This means that the handler
for such destination must be defined using one of the SI handler annotations (i.e., @ServiceActivator, @Transformer etc.).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If <code>group</code> is not specified anonymous group is used (something like <code>input.anonymous.2K37rb06Q6m2r51-SPIDDQ</code>), which is not suitable for error
handling scenarious, since you don&#8217;t know what it&#8217;s going to be until the destination is created.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, in the event you are binding to the existing destination such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.bindings.input.destination=myFooDestination
spring.cloud.stream.bindings.input.group=myGroup</code></pre>
</div>
</div>
<div class="paragraph">
<p>the full destination name is <code>myFooDestination.myGroup</code> and then the dedicated error channel name is <code>myFooDestination.myGroup.errors</code>.</p>
</div>
<div class="paragraph">
<p>Back to the example&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The <code>handle(..)</code> method, which subscribes to the channel named <code>input</code>, throws an exception.  Given there is also a subscriber to the error channel <code>input.myGroup.errors</code>
all error messages are handled by this subscriber.</p>
</div>
<div class="paragraph">
<p>If you have multiple bindings, you may want to have a single error handler. Spring Cloud Stream automatically provides support for
a <em>global error channel</em> by bridging each individual error channel to the channel named <code>errorChannel</code>, allowing a single subscriber to handle all errors,
as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@StreamListener("errorChannel")
public void error(Message&lt;?&gt; message) {
	System.out.println("Handling ERROR: " + message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This may be a convenient option if error handling logic is the same regardless of which handler produced the error.</p>
</div>
<div class="paragraph">
<p>Also, error messages sent to the <code>errorChannel</code> can be published to the specific destination at the broker by configuring a binding named <code>error</code> for the outbound target.
This option provides a mechanism to automatically send error messages to another application bound to that destination or for later retrieval (for example, audit).
For example, to publish error messages to a broker destination named <code>myErrors</code>, set the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.bindings.error.destination=myErrors.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The ability to bridge global error channel to a broker destination essentially provides a mechanism which connects
the <em>application-level</em> error handling with the <em>system-level</em> error handling.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_system_error_handling">System Error Handling</h5>
<div class="paragraph">
<p>System-level error handling implies that the errors are communicated back to the messaging system and, given that not every messaging system
is the same, the capabilities may differ from binder to binder.</p>
</div>
<div class="paragraph">
<p>That said, in this section we explain the general idea behind system level error handling and use Rabbit binder as an example. NOTE: Kafka binder provides similar
support, although some configuration properties do differ. Also, for more details and configuration options, see the individual binder&#8217;s documentation.</p>
</div>
<div class="paragraph">
<p>If no internal error handlers are configured, the errors propagate to the binders, and the binders subsequently propagate those errors back to the messaging system.
Depending on the capabilities of the messaging system such a system may <em>drop</em> the message, <em>re-queue</em> the message for re-processing or <em>send the failed message to DLQ</em>.
Both Rabbit and Kafka support these concepts. However, other binders may not, so refer to your individual binders documentation for details on supported system-level
error-handling options.</p>
</div>
<div class="sect5">
<h6 id="_drop_failed_messages">Drop Failed Messages</h6>
<div class="paragraph">
<p>By default, if no additional system-level configuration is provided, the messaging system drops the failed message.
While acceptable in some cases, for most cases, it is not, and we need some recovery mechanism to avoid message loss.</p>
</div>
</div>
<div class="sect5">
<h6 id="_dlq_dead_letter_queue">DLQ - Dead Letter Queue</h6>
<div class="paragraph">
<p>DLQ allows failed messages to be sent to a special destination: - <em>Dead Letter Queue</em>.</p>
</div>
<div class="paragraph">
<p>When configured, failed messages are sent to this destination for subsequent re-processing or auditing and reconciliation.</p>
</div>
<div class="paragraph">
<p>For example, continuing on the previous example and to set up the DLQ with Rabbit binder, you need to set the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that, in the above property, <code>input</code> corresponds to the name of the input destination binding.
The <code>consumer</code> indicates that it is a consumer property and <code>auto-bind-dlq</code> instructs the binder to configure DLQ for <code>input</code>
destination, which results in an additional Rabbit queue named <code>input.myGroup.dlq</code>.</p>
</div>
<div class="paragraph">
<p>Once configured, all failed messages are routed to this queue with an error message similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">delivery_mode:	1
headers:
x-death:
count:	1
reason:	rejected
queue:	input.hello
time:	1522328151
exchange:
routing-keys:	input.myGroup
Payload {"name:"Bob"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see from the above, your original message is preserved for further actions.</p>
</div>
<div class="paragraph">
<p>However, one thing you may have noticed is that there is limited information on the original issue with the message processing. For example, you do not see a stack
trace corresponding to the original error.
To get more relevant information about the original error, you must set an additional property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.rabbit.bindings.input.consumer.republish-to-dlq=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing so forces the internal error handler to intercept the error message and add additional information to it before publishing it to DLQ.
Once configured, you can see that the error message contains more information relevant to the original error, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">delivery_mode:	2
headers:
x-original-exchange:
x-exception-message:	has an error
x-original-routingKey:	input.myGroup
x-exception-stacktrace:	org.springframework.messaging.MessageHandlingException: nested exception is
      org.springframework.messaging.MessagingException: has an error, failedMessage=GenericMessage [payload=byte[15],
      headers={amqp_receivedDeliveryMode=NON_PERSISTENT, amqp_receivedRoutingKey=input.hello, amqp_deliveryTag=1,
      deliveryAttempt=3, amqp_consumerQueue=input.hello, amqp_redelivered=false, id=a15231e6-3f80-677b-5ad7-d4b1e61e486e,
      amqp_consumerTag=amq.ctag-skBFapilvtZhDsn0k3ZmQg, contentType=application/json, timestamp=1522327846136}]
      at org.spring...integ...han...MethodInvokingMessageProcessor.processMessage(MethodInvokingMessageProcessor.java:107)
      at. . . . .
Payload {"name:"Bob"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This effectively combines application-level and system-level error handling to further assist with downstream troubleshooting mechanics.</p>
</div>
</div>
<div class="sect5">
<h6 id="_re_queue_failed_messages">Re-queue Failed Messages</h6>
<div class="paragraph">
<p>As mentioned earlier, the currently supported binders (Rabbit and Kafka) rely on <code>RetryTemplate</code> to facilitate successful message processing. See <a href="#_retry_template">Retry Template</a> for details.
However, for cases when <code>max-attempts</code> property is set to 1, internal reprocessing of the message is disabled. At this point, you can facilitate message re-processing (re-tries)
by instructing the messaging system to re-queue the failed message. Once re-queued, the failed message is sent back to the original handler, essentially creating a retry loop.</p>
</div>
<div class="paragraph">
<p>This option may be feasible for cases where the nature of the error is related to some sporadic yet short-term unavailability of some resource.</p>
</div>
<div class="paragraph">
<p>To accomplish that, you must set the following properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">spring.cloud.stream.bindings.input.consumer.max-attempts=1
spring.cloud.stream.rabbit.bindings.input.consumer.requeue-rejected=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>max-attempts</code> set to 1 essentially disabling internal re-tries and <code>requeue-rejected</code> (short for <em>requeue rejected messages</em>) is set to <code>true</code>.
Once set, the failed message is resubmitted to the same handler and loops continuously or until the handler throws <code>AmqpRejectAndDontRequeueException</code>
essentially allowing you to build your own re-try logic within the handler itself.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_retry_template">Retry Template</h5>
<div class="paragraph">
<p>The <code>RetryTemplate</code> is part of the <a href="https://github.com/spring-projects/spring-retry">Spring Retry</a> library.
While it is out of scope of this document to cover all of the capabilities of the <code>RetryTemplate</code>, we will mention the following consumer properties that are specifically related to
the <code>RetryTemplate</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">maxAttempts</dt>
<dd>
<p>The number of attempts to process the message.</p>
<div class="paragraph">
<p>Default: 3.</p>
</div>
</dd>
<dt class="hdlist1">backOffInitialInterval</dt>
<dd>
<p>The backoff initial interval on retry.</p>
<div class="paragraph">
<p>Default 1000 milliseconds.</p>
</div>
</dd>
<dt class="hdlist1">backOffMaxInterval</dt>
<dd>
<p>The maximum backoff interval.</p>
<div class="paragraph">
<p>Default 10000 milliseconds.</p>
</div>
</dd>
<dt class="hdlist1">backOffMultiplier</dt>
<dd>
<p>The backoff multiplier.</p>
<div class="paragraph">
<p>Default 2.0.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>While the preceding settings are sufficient for majority of the customization requirements, they may not satisfy certain complex requirements at, which
point you may want to provide your own instance of the <code>RetryTemplate</code>. To do so configure it as a bean in your application configuration. The application provided
instance will override the one provided by the framework. Also, to avoid conflicts you must qualify the instance of the <code>RetryTemplate</code> you want to be used by the binder
as <code>@StreamRetryTemplate</code>. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@StreamRetryTemplate
public RetryTemplate myRetryTemplate() {
    return new RetryTemplate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see from the above example you don&#8217;t need to annotate it with <code>@Bean</code> since <code>@StreamRetryTemplate</code> is a qualified <code>@Bean</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-reactive-programming-support">5.5. Reactive Programming Support</h3>
<div class="paragraph">
<p>Spring Cloud Stream also supports the use of reactive APIs where incoming and outgoing data is handled as continuous data flows.
Support for reactive APIs is available through <code>spring-cloud-stream-reactive</code>, which needs to be added explicitly to your project.</p>
</div>
<div class="paragraph">
<p>The programming model with reactive APIs is declarative. Instead of specifying how each individual message should be handled, you can use operators that describe functional transformations from inbound to outbound data flows.</p>
</div>
<div class="paragraph">
<p>At present Spring Cloud Stream supports the only the <a href="https://projectreactor.io/">Reactor API</a>.
In the future, we intend to support a more generic model based on Reactive Streams.</p>
</div>
<div class="paragraph">
<p>The reactive programming model also uses the <code>@StreamListener</code> annotation for setting up reactive handlers.
The differences are that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>@StreamListener</code> annotation must not specify an input or output, as they are provided as arguments and return values from the method.</p>
</li>
<li>
<p>The arguments of the method must be annotated with <code>@Input</code> and <code>@Output</code>, indicating which input or output the incoming and outgoing data flows connect to, respectively.</p>
</li>
<li>
<p>The return value of the method, if any, is annotated with <code>@Output</code>, indicating the input where data should be sent.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Reactive programming support requires Java 1.8.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring Cloud Stream 1.1.1 and later (starting with release train Brooklyn.SR2), reactive programming support requires the use of Reactor 3.0.4.RELEASE and higher.
Earlier Reactor versions (including 3.0.1.RELEASE, 3.0.2.RELEASE and 3.0.3.RELEASE) are not supported.
<code>spring-cloud-stream-reactive</code> transitively retrieves the proper version, but it is possible for the project structure to manage the version of the <code>io.projectreactor:reactor-core</code> to an earlier release, especially when using Maven.
This is the case for projects generated by using Spring Initializr with Spring Boot 1.x, which overrides the Reactor version to <code>2.0.8.RELEASE</code>.
In such cases, you must ensure that the proper version of the artifact is released.
You can do so by adding a direct dependency on <code>io.projectreactor:reactor-core</code> with a version of <code>3.0.4.RELEASE</code> or later to your project.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The use of term, &#8220;reactive&#8221;, currently refers to the reactive APIs being used and not to the execution model being reactive (that is, the bound endpoints still use a 'push' rather than a 'pull' model). While some backpressure support is provided by the use of Reactor, we do intend, in a future release, to support entirely reactive pipelines by the use of native reactive clients for the connected middleware.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_reactor_based_handlers">Reactor-based Handlers</h5>
<div class="paragraph">
<p>A Reactor-based handler can have the following argument types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For arguments annotated with <code>@Input</code>, it supports the  Reactor <code>Flux</code> type.
The parameterization of the inbound Flux follows the same rules as in the case of individual message handling: It can be the entire <code>Message</code>, a POJO that can be the <code>Message</code> payload, or a POJO that is the result of a transformation based on the <code>Message</code> content-type header. Multiple inputs are provided.</p>
</li>
<li>
<p>For arguments annotated with <code>Output</code>, it supports the <code>FluxSender</code> type, which connects a <code>Flux</code> produced by the method with an output. Generally speaking, specifying outputs as arguments is only recommended when the method can have multiple outputs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A Reactor-based handler supports a return type of <code>Flux</code>. In that case, it must be annotated with <code>@Output</code>. We recommend using the return value of the method when a single output <code>Flux</code> is available.</p>
</div>
<div class="paragraph">
<p>The following example shows a Reactor-based <code>Processor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Flux&lt;String&gt; receive(@Input(Processor.INPUT) Flux&lt;String&gt; input) {
    return input.map(s -&gt; s.toUpperCase());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same processor using output arguments looks like the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Flux&lt;String&gt; input,
     @Output(Processor.OUTPUT) FluxSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_reactive_sources">Reactive Sources</h5>
<div class="paragraph">
<p>Spring Cloud Stream reactive support also provides the ability for creating reactive sources through the <code>@StreamEmitter</code> annotation.
By using the <code>@StreamEmitter</code> annotation, a regular source may be converted to a reactive one.
<code>@StreamEmitter</code> is a method level annotation that marks a method to be an emitter to outputs declared with <code>@EnableBinding</code>.
You cannot use the <code>@Input</code> annotation along with <code>@StreamEmitter</code>, as the methods marked with this annotation are not listening for any input. Rather, methods marked with <code>@StreamEmitter</code> generate output.
Following the same programming model used in <code>@StreamListener</code>, <code>@StreamEmitter</code> also allows flexible ways of using the <code>@Output</code> annotation, depending on whether the method has any arguments, a return type, and other considerations.</p>
</div>
<div class="paragraph">
<p>The remainder of this section contains examples of using the <code>@StreamEmitter</code> annotation in various styles.</p>
</div>
<div class="paragraph">
<p>The following example emits the <code>Hello, World</code> message every millisecond and publishes to a Reactor <code>Flux</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public Flux&lt;String&gt; emit() {
    return Flux.intervalMillis(1)
            .map(l -&gt; "Hello World");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the resulting messages in the <code>Flux</code> are sent to the output channel of the <code>Source</code>.</p>
</div>
<div class="paragraph">
<p>The next example is another flavor of an <code>@StreamEmmitter</code> that sends a Reactor <code>Flux</code>.
Instead of returning a <code>Flux</code>, the following method uses a <code>FluxSender</code> to programmatically send a <code>Flux</code> from a source:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public void emit(FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -&gt; "Hello World"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example is exactly same as the above snippet in functionality and style.
However, instead of using an explicit <code>@Output</code> annotation on the method, it uses the annotation on the method parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  public void emit(@Output(Source.OUTPUT) FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -&gt; "Hello World"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last example in this section is yet another flavor of writing reacting sources by using the Reactive Streams Publisher API and taking advantage of the support for it in <a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">Spring Integration Java DSL</a>.
The <code>Publisher</code> in the following example still uses Reactor <code>Flux</code> under the hood, but, from an application perspective, that is transparent to the user and only needs Reactive Streams and Java DSL for Spring Integration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  @Bean
  public Publisher&lt;Message&lt;String&gt;&gt; emit() {
    return IntegrationFlows.from(() -&gt;
                new GenericMessage&lt;&gt;("Hello World"),
        e -&gt; e.poller(p -&gt; p.fixedDelay(1)))
        .toReactivePublisher();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-stream-overview-binders">6. Binders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream provides a Binder abstraction for use in connecting to physical destinations at the external middleware.
This section provides information about the main concepts behind the Binder SPI, its main components, and implementation-specific details.</p>
</div>
<div class="sect2">
<h3 id="_producers_and_consumers">6.1. Producers and Consumers</h3>
<div class="paragraph">
<p>The following image shows the general relationship of producers and consumers:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/producers-consumers.png" alt="producers consumers" width="800">
</div>
<div class="title">Figure 6. Producers and Consumers</div>
</div>
<div class="paragraph">
<p>A producer is any component that sends messages to a channel.
The channel can be bound to an external message broker with a <code>Binder</code> implementation for that broker.
When invoking the <code>bindProducer()</code> method, the first parameter is the name of the destination within the broker, the second parameter is the local channel instance to which the producer sends messages, and the third parameter contains properties (such as a partition key expression) to be used within the adapter that is created for that channel.</p>
</div>
<div class="paragraph">
<p>A consumer is any component that receives messages from a channel.
As with a producer, the consumer&#8217;s channel can be bound to an external message broker.
When invoking the <code>bindConsumer()</code> method, the first parameter is the destination name, and a second parameter provides the name of a logical group of consumers.
Each group that is represented by consumer bindings for a given destination receives a copy of each message that a producer sends to that destination (that is, it follows normal publish-subscribe semantics).
If there are multiple consumer instances bound with the same group name, then messages are load-balanced across those consumer instances so that each message sent by a producer is consumed by only a single consumer instance within each group (that is, it follows normal queueing semantics).</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-binder-api">6.2. Binder SPI</h3>
<div class="paragraph">
<p>The Binder SPI consists of a number of interfaces, out-of-the box utility classes, and discovery strategies that provide a pluggable mechanism for connecting to external middleware.</p>
</div>
<div class="paragraph">
<p>The key point of the SPI is the <code>Binder</code> interface, which is a strategy for connecting inputs and outputs to external middleware. The following listing shows the definnition of the <code>Binder</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Binder&lt;T, C extends ConsumerProperties, P extends ProducerProperties&gt; {
    Binding&lt;T&gt; bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

    Binding&lt;T&gt; bindProducer(String name, T outboundBindTarget, P producerProperties);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface is parameterized, offering a number of extension points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Input and output bind targets. As of version 1.0, only <code>MessageChannel</code> is supported, but this is intended to be used as an extension point in the future.</p>
</li>
<li>
<p>Extended consumer and producer properties, allowing specific Binder implementations to add supplemental properties that can be supported in a type-safe manner.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A typical binder implementation consists of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A class that implements the <code>Binder</code> interface;</p>
</li>
<li>
<p>A Spring <code>@Configuration</code> class that creates a bean of type <code>Binder</code> along with the middleware connection infrastructure.</p>
</li>
<li>
<p>A <code>META-INF/spring.binders</code> file found on the classpath containing one or more binder definitions, as shown in the following example:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>kafka:\
org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_binder_detection">6.3. Binder Detection</h3>
<div class="paragraph">
<p>Spring Cloud Stream relies on implementations of the Binder SPI to perform the task of connecting channels to message brokers.
Each Binder implementation typically connects to one type of messaging system.</p>
</div>
<div class="sect3">
<h4 id="_classpath_detection">6.3.1. Classpath Detection</h4>
<div class="paragraph">
<p>By default, Spring Cloud Stream relies on Spring Boot&#8217;s auto-configuration to configure the binding process.
If a single Binder implementation is found on the classpath, Spring Cloud Stream automatically uses it.
For example, a Spring Cloud Stream project that aims to bind only to RabbitMQ can add the following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the specific Maven coordinates of other binder dependencies, see the documentation of that binder implementation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multiple-binders">6.4. Multiple Binders on the Classpath</h3>
<div class="paragraph">
<p>When multiple binders are present on the classpath, the application must indicate which binder is to be used for each channel binding.
Each binder configuration contains a <code>META-INF/spring.binders</code> file, which is a simple properties file, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>rabbit:\
org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar files exist for the other provided binder implementations (such as Kafka), and custom binder implementations are expected to provide them as well.
The key represents an identifying name for the binder implementation, whereas the value is a comma-separated list of configuration classes that each contain one and only one bean definition of type <code>org.springframework.cloud.stream.binder.Binder</code>.</p>
</div>
<div class="paragraph">
<p>Binder selection can either be performed globally, using the <code>spring.cloud.stream.defaultBinder</code> property (for example, <code>spring.cloud.stream.defaultBinder=rabbit</code>) or individually, by configuring the binder on each channel binding.
For instance, a processor application (that has channels named <code>input</code> and <code>output</code> for read and write respectively) that reads from Kafka and writes to RabbitMQ can specify the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multiple-systems">6.5. Connecting to Multiple Systems</h3>
<div class="paragraph">
<p>By default, binders share the application&#8217;s Spring Boot auto-configuration, so that one instance of each binder found on the classpath is created.
If your application should connect to more than one broker of the same type, you can specify multiple binder configurations, each with different environment settings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Turning on explicit binder configuration disables the default binder configuration process altogether.
If you do so, all binders in use must be included in the configuration.
Frameworks that intend to use Spring Cloud Stream transparently may create binder configurations that can be referenced by name, but they do not affect the default binder configuration.
In order to do so, a binder configuration may have its <code>defaultCandidate</code> flag set to false (for example, <code>spring.cloud.stream.binders.&lt;configurationName&gt;.defaultCandidate=false</code>).
This denotes a configuration that exists independently of the default binder configuration process.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a typical configuration for a processor application that connects to two RabbitMQ broker instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: thing1
          binder: rabbit1
        output:
          destination: thing2
          binder: rabbit2
      binders:
        rabbit1:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host1&gt;
        rabbit2:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host2&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_binding_visualization_and_control">6.6. Binding visualization and control</h3>
<div class="paragraph">
<p>Since version 2.0, Spring Cloud Stream supports visualization and control of the Bindings through Actuator endpoints.</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0 actuator and web are optional, you must first add one of the web dependencies as well as add the actuator dependency manually.
The following example shows how to add the dependency for the Web framework:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add the dependency for the WebFlux framework:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add the Actuator dependency as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To run Spring Cloud Stream 2.0 apps in Cloud Foundry, you must add <code>spring-boot-starter-web</code> and <code>spring-boot-starter-actuator</code> to the classpath. Otherwise, the
application will not start due to health check failures.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You must also enable the <code>bindings</code> actuator endpoints by setting the following property: <code>--management.endpoints.web.exposure.include=bindings</code>.</p>
</div>
<div class="paragraph">
<p>Once those prerequisites are satisfied. you should see the following in the logs when application start:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>: Mapped "{[/actuator/bindings/{name}],methods=[POST]. . .
: Mapped "{[/actuator/bindings],methods=[GET]. . .
: Mapped "{[/actuator/bindings/{name}],methods=[GET]. . .</pre>
</div>
</div>
<div class="paragraph">
<p>To visualize the current bindings, access the following URL:
<code><a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings</a></code></p>
</div>
<div class="paragraph">
<p>Alternative, to see a single binding, access one of the URLs similar to the following:
<code><a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName</a></code></p>
</div>
<div class="paragraph">
<p>You can also stop, start, pause, and resume individual bindings by posting to the same URL while providing a <code>state</code> argument as JSON, as shown in the following examples:</p>
</div>
<div class="paragraph">
<p>curl -d '{"state":"STOPPED"}' -H "Content-Type: application/json" -X POST <a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName</a>
curl -d '{"state":"STARTED"}' -H "Content-Type: application/json" -X POST <a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName</a>
curl -d '{"state":"PAUSED"}' -H "Content-Type: application/json" -X POST <a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName</a>
curl -d '{"state":"RESUMED"}' -H "Content-Type: application/json" -X POST <a href="http://&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName" class="bare">&lt;host&gt;:&lt;port&gt;/actuator/bindings/myBindingName</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>PAUSED</code> and <code>RESUMED</code> work only when the corresponding binder and its underlying technology supports it. Otherwise, you see the warning message in the logs.
Currently, only Kafka binder supports the <code>PAUSED</code> and <code>RESUMED</code> states.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_binder_configuration_properties">6.7. Binder Configuration Properties</h3>
<div class="paragraph">
<p>The following properties are available when customizing binder configurations. These properties exposed via <code>org.springframework.cloud.stream.config.BinderProperties</code></p>
</div>
<div class="paragraph">
<p>They must be prefixed with <code>spring.cloud.stream.binders.&lt;configurationName&gt;</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">type</dt>
<dd>
<p>The binder type.
It typically references one of the binders found on the classpath&#8201;&#8212;&#8201;in particular, a key in a <code>META-INF/spring.binders</code> file.</p>
<div class="paragraph">
<p>By default, it has the same value as the configuration name.</p>
</div>
</dd>
<dt class="hdlist1">inheritEnvironment</dt>
<dd>
<p>Whether the configuration inherits the environment of the application itself.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">environment</dt>
<dd>
<p>Root for a set of properties that can be used to customize the environment of the binder.
When this property is set, the context in which the binder is being created is not a child of the application context.
This setting allows for complete separation between the binder components and the application components.</p>
<div class="paragraph">
<p>Default: <code>empty</code>.</p>
</div>
</dd>
<dt class="hdlist1">defaultCandidate</dt>
<dd>
<p>Whether the binder configuration is a candidate for being considered a default binder or can be used only when explicitly referenced.
This setting allows adding binder configurations without interfering with the default processing.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration_options">7. Configuration Options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream supports general configuration options as well as configuration for bindings and binders.
Some binders let additional binding properties support middleware-specific features.</p>
</div>
<div class="paragraph">
<p>Configuration options can be provided to Spring Cloud Stream applications through any mechanism supported by Spring Boot.
This includes application arguments, environment variables, and YAML or .properties files.</p>
</div>
<div class="sect2">
<h3 id="_binding_service_properties">7.1. Binding Service Properties</h3>
<div class="paragraph">
<p>These properties are exposed via <code>org.springframework.cloud.stream.config.BindingServiceProperties</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.instanceCount</dt>
<dd>
<p>The number of deployed instances of an application.
Must be set for partitioning on the producer side. Must be set on the consumer side when using RabbitMQ and with Kafka if <code>autoRebalanceEnabled=false</code>.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.instanceIndex</dt>
<dd>
<p>The instance index of the application: A number from <code>0</code> to <code>instanceCount - 1</code>.
Used for partitioning with RabbitMQ and with Kafka if <code>autoRebalanceEnabled=false</code>.
Automatically set in Cloud Foundry to match the application&#8217;s instance index.</p>
</dd>
<dt class="hdlist1">spring.cloud.stream.dynamicDestinations</dt>
<dd>
<p>A list of destinations that can be bound dynamically (for example, in a dynamic routing scenario).
If set, only listed destinations can be bound.</p>
<div class="paragraph">
<p>Default: empty (letting any destination be bound).</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.defaultBinder</dt>
<dd>
<p>The default binder to use, if multiple binders are configured.
See <a href="#multiple-binders">Multiple Binders on the Classpath</a>.</p>
<div class="paragraph">
<p>Default: empty.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.overrideCloudConnectors</dt>
<dd>
<p>This property is only applicable when the <code>cloud</code> profile is active and Spring Cloud Connectors are provided with the application.
If the property is <code>false</code> (the default), the binder detects a suitable bound service (for example, a RabbitMQ service bound in Cloud Foundry for the RabbitMQ binder) and uses it for creating connections (usually through Spring Cloud Connectors).
When set to <code>true</code>, this property instructs binders to completely ignore the bound services and rely on Spring Boot properties (for example, relying on the <code>spring.rabbitmq.*</code> properties provided in the environment for the RabbitMQ binder).
The typical usage of this property is to be nested in a customized environment <a href="#multiple-systems">when connecting to multiple systems</a>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.bindingRetryInterval</dt>
<dd>
<p>The interval (in seconds) between retrying binding creation when, for example, the binder does not support late binding and the broker (for example, Apache Kafka) is down.
Set it to zero to treat such conditions as fatal, preventing the application from starting.</p>
<div class="paragraph">
<p>Default: <code>30</code></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="binding-properties">7.2. Binding Properties</h3>
<div class="paragraph">
<p>Binding properties are supplied by using the format of <code>spring.cloud.stream.bindings.&lt;channelName&gt;.&lt;property&gt;=&lt;value&gt;</code>.
The <code>&lt;channelName&gt;</code> represents the name of the channel being configured (for example, <code>output</code> for a <code>Source</code>).</p>
</div>
<div class="paragraph">
<p>To avoid repetition, Spring Cloud Stream supports setting values for all channels, in the format of <code>spring.cloud.stream.default.&lt;property&gt;=&lt;value&gt;</code>.</p>
</div>
<div class="paragraph">
<p>In what follows, we indicate where we have omitted the <code>spring.cloud.stream.bindings.&lt;channelName&gt;.</code> prefix and focus just on the property name, with the understanding that the prefix ise included at runtime.</p>
</div>
<div class="sect3">
<h4 id="_common_binding_properties">7.2.1. Common Binding Properties</h4>
<div class="paragraph">
<p>These properties are exposed via <code>org.springframework.cloud.stream.config.BindingProperties</code></p>
</div>
<div class="paragraph">
<p>The following binding properties are available for both input and output bindings and must be prefixed with <code>spring.cloud.stream.bindings.&lt;channelName&gt;.</code> (for example, <code>spring.cloud.stream.bindings.input.destination=ticktock</code>).</p>
</div>
<div class="paragraph">
<p>Default values can be set by using the <code>spring.cloud.stream.default</code> prefix (for example`spring.cloud.stream.default.contentType=application/json`).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">destination</dt>
<dd>
<p>The target destination of a channel on the bound middleware (for example, the RabbitMQ exchange or Kafka topic).
If the channel is bound as a consumer, it could be bound to multiple destinations, and the destination names can be specified as comma-separated <code>String</code> values.
If not set, the channel name is used instead.
The default value of this property cannot be overridden.</p>
</dd>
<dt class="hdlist1">group</dt>
<dd>
<p>The consumer group of the channel.
Applies only to inbound bindings.
See <a href="#consumer-groups">Consumer Groups</a>.</p>
<div class="paragraph">
<p>Default: <code>null</code> (indicating an anonymous consumer).</p>
</div>
</dd>
<dt class="hdlist1">contentType</dt>
<dd>
<p>The content type of the channel.
See &#8220;<a href="#content-type-management">Content Type Negotiation</a>&#8221;.</p>
<div class="paragraph">
<p>Default: <code>application/json</code>.</p>
</div>
</dd>
<dt class="hdlist1">binder</dt>
<dd>
<p>The binder used by this binding.
See &#8220;<a href="#multiple-binders">Multiple Binders on the Classpath</a>&#8221; for details.</p>
<div class="paragraph">
<p>Default: <code>null</code> (the default binder is used, if it exists).</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_properties">7.2.2. Consumer Properties</h4>
<div class="paragraph">
<p>These properties are exposed via <code>org.springframework.cloud.stream.binder.ConsumerProperties</code></p>
</div>
<div class="paragraph">
<p>The following binding properties are available for input bindings only and must be prefixed with <code>spring.cloud.stream.bindings.&lt;channelName&gt;.consumer.</code> (for example, <code>spring.cloud.stream.bindings.input.consumer.concurrency=3</code>).</p>
</div>
<div class="paragraph">
<p>Default values can be set by using the <code>spring.cloud.stream.default.consumer</code> prefix (for example, <code>spring.cloud.stream.default.consumer.headerMode=none</code>).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">concurrency</dt>
<dd>
<p>The concurrency of the inbound consumer.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">partitioned</dt>
<dd>
<p>Whether the consumer receives data from a partitioned producer.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">headerMode</dt>
<dd>
<p>When set to <code>none</code>, disables header parsing on input.
Effective only for messaging middleware that does not support message headers natively and requires header embedding.
This option is useful when consuming data from non-Spring Cloud Stream applications when native headers are not supported.
When set to <code>headers</code>, it uses the middleware&#8217;s native header mechanism.
When set to <code>embeddedHeaders</code>, it embeds headers into the message payload.</p>
<div class="paragraph">
<p>Default: depends on the binder implementation.</p>
</div>
</dd>
<dt class="hdlist1">maxAttempts</dt>
<dd>
<p>If processing fails, the number of attempts to process the message (including the first).
Set to <code>1</code> to disable retry.</p>
<div class="paragraph">
<p>Default: <code>3</code>.</p>
</div>
</dd>
<dt class="hdlist1">backOffInitialInterval</dt>
<dd>
<p>The backoff initial interval on retry.</p>
<div class="paragraph">
<p>Default: <code>1000</code>.</p>
</div>
</dd>
<dt class="hdlist1">backOffMaxInterval</dt>
<dd>
<p>The maximum backoff interval.</p>
<div class="paragraph">
<p>Default: <code>10000</code>.</p>
</div>
</dd>
<dt class="hdlist1">backOffMultiplier</dt>
<dd>
<p>The backoff multiplier.</p>
<div class="paragraph">
<p>Default: <code>2.0</code>.</p>
</div>
</dd>
<dt class="hdlist1">instanceIndex</dt>
<dd>
<p>When set to a value greater than equal to zero, it allows customizing the instance index of this consumer (if different from <code>spring.cloud.stream.instanceIndex</code>).
When set to a negative value, it defaults to <code>spring.cloud.stream.instanceIndex</code>.
See &#8220;<a href="#spring-cloud-stream-overview-instance-index-instance-count">Instance Index and Instance Count</a>&#8221; for more information.</p>
<div class="paragraph">
<p>Default: <code>-1</code>.</p>
</div>
</dd>
<dt class="hdlist1">instanceCount</dt>
<dd>
<p>When set to a value greater than equal to zero, it allows customizing the instance count of this consumer (if different from <code>spring.cloud.stream.instanceCount</code>).
When set to a negative value, it defaults to <code>spring.cloud.stream.instanceCount</code>.
See &#8220;<a href="#spring-cloud-stream-overview-instance-index-instance-count">Instance Index and Instance Count</a>&#8221; for more information.</p>
<div class="paragraph">
<p>Default: <code>-1</code>.</p>
</div>
</dd>
<dt class="hdlist1">useNativeDecoding</dt>
<dd>
<p>When set to <code>true</code>, the inbound message is deserialized directly by the client library, which must be configured correspondingly (for example, setting an appropriate Kafka producer value deserializer).
When this configuration is being used, the inbound message unmarshalling is not based on the <code>contentType</code> of the binding.
When native decoding is used, it is the responsibility of the producer to use an appropriate encoder (for example, the Kafka producer value serializer) to serialize the outbound message.
Also, when native encoding and decoding is used, the <code>headerMode=embeddedHeaders</code> property is ignored and headers are not embedded in the message.
See the producer property <code>useNativeEncoding</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_producer_properties">7.2.3. Producer Properties</h4>
<div class="paragraph">
<p>These properties are exposed via <code>org.springframework.cloud.stream.binder.ProducerProperties</code></p>
</div>
<div class="paragraph">
<p>The following binding properties are available for output bindings only and must be prefixed with <code>spring.cloud.stream.bindings.&lt;channelName&gt;.producer.</code> (for example, <code>spring.cloud.stream.bindings.input.producer.partitionKeyExpression=payload.id</code>).</p>
</div>
<div class="paragraph">
<p>Default values can be set by using the prefix <code>spring.cloud.stream.default.producer</code> (for example, <code>spring.cloud.stream.default.producer.partitionKeyExpression=payload.id</code>).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">partitionKeyExpression</dt>
<dd>
<p>A SpEL expression that determines how to partition outbound data.
If set, or if <code>partitionKeyExtractorClass</code> is set, outbound data on this channel is partitioned. <code>partitionCount</code> must be set to a value greater than 1 to be effective.
Mutually exclusive with <code>partitionKeyExtractorClass</code>.
See &#8220;<a href="#partitioning">Partitioning Support</a>&#8221;.</p>
<div class="paragraph">
<p>Default: null.</p>
</div>
</dd>
<dt class="hdlist1">partitionKeyExtractorClass</dt>
<dd>
<p>A <code>PartitionKeyExtractorStrategy</code> implementation.
If set, or if <code>partitionKeyExpression</code> is set, outbound data on this channel is partitioned. <code>partitionCount</code> must be set to a value greater than 1 to be effective.
Mutually exclusive with <code>partitionKeyExpression</code>.
See &#8220;<a href="#partitioning">Partitioning Support</a>&#8221;.</p>
<div class="paragraph">
<p>Default: <code>null</code>.</p>
</div>
</dd>
<dt class="hdlist1">partitionSelectorClass</dt>
<dd>
<p>  A <code>PartitionSelectorStrategy</code> implementation.
Mutually exclusive with <code>partitionSelectorExpression</code>.
If neither is set, the partition is selected as the <code>hashCode(key) % partitionCount</code>, where <code>key</code> is computed through either <code>partitionKeyExpression</code> or <code>partitionKeyExtractorClass</code>.</p>
<div class="paragraph">
<p>Default: <code>null</code>.</p>
</div>
</dd>
<dt class="hdlist1">partitionSelectorExpression</dt>
<dd>
<p>A SpEL expression for customizing partition selection.
Mutually exclusive with <code>partitionSelectorClass</code>.
If neither is set, the partition is selected as the <code>hashCode(key) % partitionCount</code>, where <code>key</code> is computed through either <code>partitionKeyExpression</code> or <code>partitionKeyExtractorClass</code>.</p>
<div class="paragraph">
<p>Default: <code>null</code>.</p>
</div>
</dd>
<dt class="hdlist1">partitionCount</dt>
<dd>
<p>The number of target partitions for the data, if partitioning is enabled.
Must be set to a value greater than 1 if the producer is partitioned.
On Kafka, it is interpreted as a hint. The larger of this and the partition count of the target topic is used instead.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">requiredGroups</dt>
<dd>
<p>A comma-separated list of groups to which the producer must ensure message delivery even if they start after it has been created (for example, by pre-creating durable queues in RabbitMQ).</p>
</dd>
<dt class="hdlist1">headerMode</dt>
<dd>
<p>When set to <code>none</code>, it disables header embedding on output.
It is effective only for messaging middleware that does not support message headers natively and requires header embedding.
This option is useful when producing data for non-Spring Cloud Stream applications when native headers are not supported.
When set to <code>headers</code>, it uses the middleware&#8217;s native header mechanism.
When set to <code>embeddedHeaders</code>, it embeds headers into the message payload.</p>
<div class="paragraph">
<p>Default: Depends on the binder implementation.</p>
</div>
</dd>
<dt class="hdlist1">useNativeEncoding</dt>
<dd>
<p>When set to <code>true</code>, the outbound message is serialized directly by the client library, which must be configured correspondingly (for example, setting an appropriate Kafka producer value serializer).
When this configuration is being used, the outbound message marshalling is not based on the <code>contentType</code> of the binding.
When native encoding is used, it is the responsibility of the consumer to use an appropriate decoder (for example, the Kafka consumer value de-serializer) to deserialize the inbound message.
Also, when native encoding and decoding is used, the <code>headerMode=embeddedHeaders</code> property is ignored and headers are not embedded in the message.
See the consumer property <code>useNativeDecoding</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">errorChannelEnabled</dt>
<dd>
<p>When set to <code>true</code>, if the binder supports asynchroous send results, send failures are sent to an error channel for the destination.
See &#8220;<a href="#binder-error-channels">[binder-error-channels]</a>&#8221; for more information.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamicdestination">7.3. Using Dynamically Bound Destinations</h3>
<div class="paragraph">
<p>Besides the channels defined by using <code>@EnableBinding</code>, Spring Cloud Stream lets applications send messages to dynamically bound destinations.
This is useful, for example, when the target destination needs to be determined at runtime.
Applications can do so by using the <code>BinderAwareChannelResolver</code> bean, registered automatically by the <code>@EnableBinding</code> annotation.</p>
</div>
<div class="paragraph">
<p>The 'spring.cloud.stream.dynamicDestinations' property can be used for restricting the dynamic destination names to a known set (whitelisting).
If this property is not set, any destination can be bound dynamically.</p>
</div>
<div class="paragraph">
<p>The <code>BinderAwareChannelResolver</code> can be used directly, as shown in the following example of a REST controller using a path variable to decide the target channel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

    @Autowired
    private BinderAwareChannelResolver resolver;

    @RequestMapping(path = "/{target}", method = POST, consumes = "*/*")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void handleRequest(@RequestBody String body, @PathVariable("target") target,
           @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
        sendMessage(body, target, contentType);
    }

    private void sendMessage(String body, String target, Object contentType) {
        resolver.resolveDestination(target).send(MessageBuilder.createMessage(body,
                new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now consider what happens when we start the application on the default port (8080) and make the following requests with CURL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -H "Content-Type: application/json" -X POST -d "customer-1" http://localhost:8080/customers

curl -H "Content-Type: application/json" -X POST -d "order-1" http://localhost:8080/orders</pre>
</div>
</div>
<div class="paragraph">
<p>The destinations, 'customers' and 'orders', are created in the broker (in the exchange for Rabbit or in the topic for Kafka) with names of 'customers' and 'orders', and the data is published to the appropriate destinations.</p>
</div>
<div class="paragraph">
<p>The <code>BinderAwareChannelResolver</code> is a general-purpose Spring Integration <code>DestinationResolver</code> and can be injected in other components&#8201;&#8212;&#8201;for example, in a router using a SpEL expression based on the <code>target</code> field of an incoming JSON message. The following example includes a router that reads SpEL expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

    @Autowired
    private BinderAwareChannelResolver resolver;


    @RequestMapping(path = "/", method = POST, consumes = "application/json")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void handleRequest(@RequestBody String body, @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
        sendMessage(body, contentType);
    }

    private void sendMessage(Object body, Object contentType) {
        routerChannel().send(MessageBuilder.createMessage(body,
                new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }

    @Bean(name = "routerChannel")
    public MessageChannel routerChannel() {
        return new DirectChannel();
    }

    @Bean
    @ServiceActivator(inputChannel = "routerChannel")
    public ExpressionEvaluatingRouter router() {
        ExpressionEvaluatingRouter router =
            new ExpressionEvaluatingRouter(new SpelExpressionParser().parseExpression("payload.target"));
        router.setDefaultOutputChannelName("default-output");
        router.setChannelResolver(resolver);
        return router;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/spring-cloud-stream-app-starters/router">Router Sink Application</a> uses this technique to create the destinations on-demand.</p>
</div>
<div class="paragraph">
<p>If the channel names are known in advance, you can configure the producer properties as with any other destination.
Alternatively, if you register a <code>NewBindingCallback&lt;&gt;</code> bean, it is invoked just before the binding is created.
The callback takes the generic type of the extended producer properties used by the binder.
It has one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void configure(String channelName, MessageChannel channel, ProducerProperties producerProperties,
        T extendedProducerProperties);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the RabbitMQ binder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public NewBindingCallback&lt;RabbitProducerProperties&gt; dynamicConfigurer() {
    return (name, channel, props, extended) -&gt; {
        props.setRequiredGroups("bindThisQueue");
        extended.setQueueNameGroupOnly(true);
        extended.setAutoBindDlq(true);
        extended.setDeadLetterQueueName("myDLQ");
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need to support dynamic destinations with multiple binder types, use <code>Object</code> for the generic type and cast the <code>extended</code> argument as needed.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="content-type-management">8. Content Type Negotiation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data transformation is one of the core features of any message-driven microservice architecture. Given that, in Spring Cloud Stream, such data
is represented as a Spring <code>Message</code>, a message may have to be transformed to a desired shape or size before reaching its destination. This is required for two reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To convert the contents of the incoming message to match the signature of the application-provided handler.</p>
</li>
<li>
<p>To convert the contents of the outgoing message to the wire format.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The wire format is typically <code>byte[]</code> (that is true for the Kafka and Rabbit binders), but it is governed by the binder implementation.</p>
</div>
<div class="paragraph">
<p>In Spring Cloud Stream, message transformation is accomplished with an <code>org.springframework.messaging.converter.MessageConverter</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As a supplement to the details to follow, you may also want to read the following <a href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation">blog post</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_mechanics">8.1. Mechanics</h3>
<div class="paragraph">
<p>To better understand the mechanics and the necessity behind content-type negotiation, we take a look at a very simple use case by using the following message handler as an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@StreamListener(Processor.INPUT)
@SendTo(Processor.OUTPUT)
public String handle(Person person) {..}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For simplicity, we assume that this is the only handler in the application (we assume there is no internal pipeline).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The handler shown in the preceding example expects a <code>Person</code> object as an argument and produces a <code>String</code> type as an output.
In order for the framework to succeed in passing the incoming <code>Message</code> as an argument to this handler, it has to somehow transform the payload of the <code>Message</code> type from the wire format to a <code>Person</code> type.
In other words, the framework must locate and apply the appropriate <code>MessageConverter</code>.
To accomplish that, the framework needs some instructions from the user.
One of these instructions is already provided by the signature of the handler method itself (<code>Person</code> type).
Consequently, in theory, that should be (and, in some cases, is) enough.
However, for the majority of use cases, in order to select the appropriate <code>MessageConverter</code>, the framework needs an additional piece of information.
That missing piece is <code>contentType</code>.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream provides three mechanisms to define <code>contentType</code> (in order of precedence):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>HEADER</strong>: The <code>contentType</code> can be communicated through the Message itself. By providing a <code>contentType</code> header, you declare the content type to use to locate and apply the appropriate <code>MessageConverter</code>.</p>
</li>
<li>
<p><strong>BINDING</strong>: The <code>contentType</code> can be set per destination binding by setting the <code>spring.cloud.stream.bindings.input.content-type</code> property.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>input</code> segment in the property name corresponds to the actual name of the destination (which is input in our case). This approach lets you declare, on a per-binding basis, the content type to use to locate and apply the appropriate <code>MessageConverter</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><strong>DEFAULT</strong>: If <code>contentType</code> is not present in the <code>Message</code> header or the binding, the default <code>application/json</code> content type is used to
locate and apply the appropriate <code>MessageConverter</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As mentioned earlier, the preceding list also demonstrates the order of precedence in case of a tie. For example, a header-provided content type takes precedence over any other content type.
The same applies for a content type set on a per-binding basis, which essentially lets you override the default content type.
However, it also provides a sensible default (which was determined from community feedback).</p>
</div>
<div class="paragraph">
<p>Another reason for making <code>application/json</code> the default stems from the interoperability requirements driven by distributed microservices architectures, where producer and consumer not only run in different JVMs but can also run on different non-JVM platforms.</p>
</div>
<div class="paragraph">
<p>When the non-void handler method returns, if the the return value is already a <code>Message</code>, that <code>Message</code> becomes the payload. However, when the return value is not a <code>Message</code>, the new <code>Message</code> is constructed with the return value as the payload while inheriting
headers from the input <code>Message</code> minus the headers defined or filtered by <code>SpringIntegrationProperties.messageHandlerNotPropagatedHeaders</code>.
By default, there is only one header set there: <code>contentType</code>. This means that the new <code>Message</code> does not have <code>contentType</code> header set, thus ensuring that the <code>contentType</code> can evolve.
You can always opt out of returning a <code>Message</code> from the handler method where you can inject any header you wish.</p>
</div>
<div class="paragraph">
<p>If there is an internal pipeline, the <code>Message</code> is sent to the next handler by going through the same process of conversion. However, if there is no internal pipeline or you have reached the end of it, the <code>Message</code> is sent back to the output destination.</p>
</div>
<div class="sect3">
<h4 id="_content_type_versus_argument_type">8.1.1. Content Type versus Argument Type</h4>
<div class="paragraph">
<p>As mentioned earlier, for the framework to select the appropriate <code>MessageConverter</code>, it requires argument type and, optionally, content type information.
The logic for selecting the appropriate <code>MessageConverter</code> resides with the argument resolvers (<code>HandlerMethodArgumentResolvers</code>), which trigger right before the invocation of the user-defined handler method (which is when the actual argument type is known to the framework).
If the argument type does not match the type of the current payload, the framework delegates to the stack of the
pre-configured <code>MessageConverters</code> to see if any one of them can convert the payload.
As you can see, the  <code>Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);</code>
operation of the MessageConverter takes <code>targetClass</code> as one of its arguments.
The framework also ensures that the provided <code>Message</code> always contains a <code>contentType</code> header.
When no contentType header was already present, it injects either the per-binding <code>contentType</code> header or the default <code>contentType</code> header.
The combination of <code>contentType</code> argument type is the mechanism by which framework determines if message can be converted to a target type.
If no appropriate <code>MessageConverter</code> is found, an exception is thrown, which you can handle by adding a custom <code>MessageConverter</code> (see &#8220;<a href="#spring-cloud-stream-overview-user-defined-message-converters">User-defined Message Converters</a>&#8221;).</p>
</div>
<div class="paragraph">
<p>But what if the payload type matches the target type declared by the handler method? In this case, there is nothing to convert, and the
payload is passed unmodified. While this sounds pretty straightforward and logical, keep in mind handler methods that take a <code>Message&lt;?&gt;</code> or <code>Object</code> as an argument.
By declaring the target type to be <code>Object</code> (which is an <code>instanceof</code> everything in Java), you essentially forfeit the conversion process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not expect <code>Message</code> to be converted into some other type based only on the <code>contentType</code>.
Remember that the <code>contentType</code> is complementary to the target type.
If you wish, you can provide a hint, which <code>MessageConverter</code> may or may not take into consideration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_message_converters">8.1.2. Message Converters</h4>
<div class="paragraph">
<p><code>MessageConverters</code> define two methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;?&gt; toMessage(Object payload, @Nullable MessageHeaders headers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important to understand the contract of these methods and their usage, specifically in the context of Spring Cloud Stream.</p>
</div>
<div class="paragraph">
<p>The <code>fromMessage</code> method converts an incoming <code>Message</code> to an argument type.
The payload of the <code>Message</code> could be any type, and it is
up to the actual implementation of the <code>MessageConverter</code> to support multiple types.
For example, some JSON converter may support the payload type as <code>byte[]</code>, <code>String</code>, and others.
This is important when the application contains an internal pipeline (that is, input &#8594; handler1 &#8594; handler2 &#8594;. . . &#8594; output) and the output of the upstream handler results in a <code>Message</code> which may not be in the initial wire format.</p>
</div>
<div class="paragraph">
<p>However, the <code>toMessage</code> method has a more strict contract and must always convert <code>Message</code> to the wire format: <code>byte[]</code>.</p>
</div>
<div class="paragraph">
<p>So, for all intents and purposes (and especially when implementing your own converter) you regard the two methods as having the following signatures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;byte[]&gt; toMessage(Object payload, @Nullable MessageHeaders headers);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_provided_messageconverters">8.2. Provided MessageConverters</h3>
<div class="paragraph">
<p>As mentioned earlier, the framework already provides a stack of <code>MessageConverters</code> to handle most common use cases.
The following list describes the provided <code>MessageConverters</code>, in order of precedence (the first <code>MessageConverter</code> that works is used):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ApplicationJsonMessageMarshallingConverter</code>: Variation of the <code>org.springframework.messaging.converter.MappingJackson2MessageConverter</code>. Supports conversion of the payload of the <code>Message</code> to/from POJO for cases when <code>contentType</code> is <code>application/json</code> (DEFAULT).</p>
</li>
<li>
<p><code>TupleJsonMessageConverter</code>: <strong>DEPRECATED</strong> Supports conversion of the payload of the <code>Message</code> to/from <code>org.springframework.tuple.Tuple</code>.</p>
</li>
<li>
<p><code>ByteArrayMessageConverter</code>: Supports conversion of the payload of the <code>Message</code> from <code>byte[]</code> to <code>byte[]</code> for cases when <code>contentType</code> is <code>application/octet-stream</code>. It is essentially a pass through and exists primarily for backward compatibility.</p>
</li>
<li>
<p><code>ObjectStringMessageConverter</code>: Supports conversion of any type to a <code>String</code> when <code>contentType</code> is <code>text/plain</code>.
It invokes Objects <code>toString()</code> method or, if the payload is <code>byte[]</code>, a new <code>String(byte[])</code>.</p>
</li>
<li>
<p><code>JavaSerializationMessageConverter</code>: <strong>DEPRECATED</strong> Supports conversion based on java serialization when <code>contentType</code> is <code>application/x-java-serialized-object</code>.</p>
</li>
<li>
<p><code>KryoMessageConverter</code>: <strong>DEPRECATED</strong> Supports conversion based on Kryo serialization when <code>contentType</code> is <code>application/x-java-object</code>.</p>
</li>
<li>
<p><code>JsonUnmarshallingConverter</code>: Similar to the <code>ApplicationJsonMessageMarshallingConverter</code>. It supports conversion of any type when <code>contentType</code> is <code>application/x-java-object</code>.
It expects the actual type information to be embedded in the <code>contentType</code> as an attribute (for example, <code>application/x-java-object;type=foo.bar.Cat</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When no appropriate converter is found, the framework throws an exception. When that happens, you should check your code and configuration and ensure you did not miss anything (that is, ensure that you provided a <code>contentType</code> by using a binding or a header).
However, most likely, you found some uncommon case (such as a custom <code>contentType</code> perhaps) and the current stack of provided <code>MessageConverters</code>
does not know how to convert. If that is the case, you can add custom <code>MessageConverter</code>. See <a href="#spring-cloud-stream-overview-user-defined-message-converters">User-defined Message Converters</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-user-defined-message-converters">8.3. User-defined Message Converters</h3>
<div class="paragraph">
<p>Spring Cloud Stream exposes a mechanism to define and register additional <code>MessageConverters</code>.
To use it, implement <code>org.springframework.messaging.converter.MessageConverter</code>, configure it as a <code>@Bean</code>, and annotate it with <code>@StreamMessageConverter</code>.
It is then apended to the existing stack of `MessageConverter`s.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that custom <code>MessageConverter</code> implementations are added to the head of the existing stack.
Consequently, custom <code>MessageConverter</code> implementations take precedence over the existing ones, which lets you override as well as add to the existing converters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to create a message converter bean to support a new content type called <code>application/bar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

    ...

    @Bean
    @StreamMessageConverter
    public MessageConverter customMessageConverter() {
        return new MyCustomMessageConverter();
    }
}

public class MyCustomMessageConverter extends AbstractMessageConverter {

    public MyCustomMessageConverter() {
        super(new MimeType("application", "bar"));
    }

    @Override
    protected boolean supports(Class&lt;?&gt; clazz) {
        return (Bar.class.equals(clazz));
    }

    @Override
    protected Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
        Object payload = message.getPayload();
        return (payload instanceof Bar ? payload : new Bar((byte[]) payload));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Stream also provides support for Avro-based converters and schema evolution.
See &#8220;<a href="#schema-evolution">Schema Evolution Support</a>&#8221; for details.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schema-evolution">9. Schema Evolution Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream provides support for schema evolution so that the data can be evolved over time and still work with older or newer producers and consumers and vice versa.
Most serialization models, especially the ones that aim for portability across different platforms and languages, rely on a schema that describes how the data is serialized in the binary payload.
In order to serialize the data and then to interpret it, both the sending and receiving sides must have access to a schema that describes the binary format.
In certain cases, the schema can be inferred from the payload type on serialization or from the target type on deserialization.
However, many applications benefit from having access to an explicit schema that describes the binary data format.
A schema registry lets you store schema information in a textual format (typically JSON) and makes that information accessible to various applications that need it to receive and send data in binary format.
A schema is referenceable as a tuple consisting of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A subject that is the logical name of the schema</p>
</li>
<li>
<p>The schema version</p>
</li>
<li>
<p>The schema format, which describes the binary format of the data</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This following sections goes through the details of various components involved in schema evolution process.</p>
</div>
<div class="sect2">
<h3 id="_schema_registry_client">9.1. Schema Registry Client</h3>
<div class="paragraph">
<p>The client-side abstraction for interacting with schema registry servers is the <code>SchemaRegistryClient</code> interface, which has the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface SchemaRegistryClient {

    SchemaRegistrationResponse register(String subject, String format, String schema);

    String fetch(SchemaReference schemaReference);

    String fetch(Integer id);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Stream provides out-of-the-box implementations for interacting with its own schema server and for interacting with the Confluent Schema Registry.</p>
</div>
<div class="paragraph">
<p>A client for the Spring Cloud Stream schema registry can be configured by using the <code>@EnableSchemaRegistryClient</code>, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">  @EnableBinding(Sink.class)
  @SpringBootApplication
  @EnableSchemaRegistryClient
  public static class AvroSinkApplication {
    ...
  }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default converter is optimized to cache not only the schemas from the remote server but also the <code>parse()</code> and <code>toString()</code> methods, which are quite expensive.
Because of this, it uses a <code>DefaultSchemaRegistryClient</code> that does not cache responses.
If you intend to change the default behavior, you can use the client directly on your code and override it to the desired outcome.
To do so, you have to add the property <code>spring.cloud.stream.schemaRegistryClient.cached=true</code> to your application properties.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_schema_registry_client_properties">9.1.1. Schema Registry Client Properties</h4>
<div class="paragraph">
<p>The Schema Registry Client supports the following properties:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>spring.cloud.stream.schemaRegistryClient.endpoint</code></dt>
<dd>
<p>The location of the schema-server.
When setting this, use a full URL, including protocol (<code>http</code> or <code>https</code>) , port, and context path.</p>
</dd>
<dt class="hdlist1">Default</dt>
<dd>
<p><code><a href="http://localhost:8990/" class="bare">localhost:8990/</a></code></p>
</dd>
<dt class="hdlist1"><code>spring.cloud.stream.schemaRegistryClient.cached</code></dt>
<dd>
<p>Whether the client should cache schema server responses.
Normally set to <code>false</code>, as the caching happens in the message converter.
Clients using the schema registry client should set this to <code>true</code>.</p>
</dd>
<dt class="hdlist1">Default</dt>
<dd>
<p><code>true</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avro_schema_registry_client_message_converters">9.2. Avro Schema Registry Client Message Converters</h3>
<div class="paragraph">
<p>For applications that have a SchemaRegistryClient bean registered with the application context, Spring Cloud Stream auto configures an Apache Avro message converter for schema management.
This eases schema evolution, as applications that receive messages can get easy access to a writer schema that can be reconciled with their own reader schema.</p>
</div>
<div class="paragraph">
<p>For outbound messages, if the content type of the channel is set to <code>application/*+avro</code>, the <code>MessageConverter</code> is activated, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">spring.cloud.stream.bindings.output.contentType=application/*+avro</code></pre>
</div>
</div>
<div class="paragraph">
<p>During the outbound conversion, the message converter tries to infer the schema of each outbound messages (based on its type) and register it to a subject (based on the payload type) by using the <code>SchemaRegistryClient</code>.
If an identical schema is already found, then a reference to it is retrieved.
If not, the schema is registered, and a new version number is provided.
The message is sent with a <code>contentType</code> header by using the following scheme: <code>application/[prefix].[subject].v[version]+avro</code>, where <code>prefix</code> is configurable and <code>subject</code> is deduced from the payload type.</p>
</div>
<div class="paragraph">
<p>For example, a message of the type <code>User</code> might be sent as a binary payload with a content type of <code>application/vnd.user.v2+avro</code>, where <code>user</code> is the subject and <code>2</code> is the version number.</p>
</div>
<div class="paragraph">
<p>When receiving messages, the converter infers the schema reference from the header of the incoming message and tries to retrieve it. The schema is used as the writer schema in the deserialization process.</p>
</div>
<div class="sect3">
<h4 id="_avro_schema_registry_message_converter_properties">9.2.1. Avro Schema Registry Message Converter Properties</h4>
<div class="paragraph">
<p>If you have enabled Avro based schema registry client by setting <code>spring.cloud.stream.bindings.output.contentType=application/*+avro</code>, you can customize the behavior of the registration by setting the following properties.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</dt>
<dd>
<p>Enable if you want the converter to use reflection to infer a Schema from a POJO.</p>
<div class="paragraph">
<p>Default: <code>false</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.readerSchema</dt>
<dd>
<p>Avro compares schema versions by looking at a writer schema (origin payload) and a reader schema (your application payload). See the <a href="https://avro.apache.org/docs/1.7.6/spec.html">Avro documentation</a> for more information. If set, this overrides any lookups at the schema server and uses the local schema as the reader schema.
Default: <code>null</code></p>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.schemaLocations</dt>
<dd>
<p>Registers any <code>.avsc</code> files listed in this property with the Schema Server.</p>
<div class="paragraph">
<p>Default: <code>empty</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.prefix</dt>
<dd>
<p>The prefix to be used on the Content-Type header.</p>
<div class="paragraph">
<p>Default: <code>vnd</code></p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apache_avro_message_converters">9.3. Apache Avro Message Converters</h3>
<div class="paragraph">
<p>Spring Cloud Stream provides support for schema-based message converters through its <code>spring-cloud-stream-schema</code> module.
Currently, the only serialization format supported out of the box for schema-based message converters is Apache Avro, with more formats to be added in future versions.</p>
</div>
<div class="paragraph">
<p>The <code>spring-cloud-stream-schema</code> module contains two types of message converters that can be used for Apache Avro serialization:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Converters that use the class information of the serialized or deserialized objects or a schema with a location known at startup.</p>
</li>
<li>
<p>Converters that use a schema registry. They locate the schemas at runtime and dynamically register new schemas as domain objects evolve.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_converters_with_schema_support">9.4. Converters with Schema Support</h3>
<div class="paragraph">
<p>The <code>AvroSchemaMessageConverter</code> supports serializing and deserializing messages either by using a predefined schema or by using the schema information available in the class (either reflectively or contained in the <code>SpecificRecord</code>).
If you provide a custom converter, then the default AvroSchemaMessageConverter bean is not created. The following example shows a custom converter:</p>
</div>
<div class="paragraph">
<p>To use custom converters, you can simply add it to the application context, optionally specifying one or more <code>MimeTypes</code> with which to associate it.
The default <code>MimeType</code> is <code>application/avro</code>.</p>
</div>
<div class="paragraph">
<p>If the target type of the conversion is a <code>GenericRecord</code>, a schema must be set.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a converter in a sink application by registering the Apache Avro <code>MessageConverter</code> without a predefined schema.
In this example, note that the mime type value is <code>avro/bytes</code>, not the default <code>application/avro</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      return new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Conversely, the following application registers a converter with a predefined schema (found on the classpath):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
      converter.setSchemaLocation(new ClassPathResource("schemas/User.avro"));
      return converter;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registry_server">9.5. Schema Registry Server</h3>
<div class="paragraph">
<p>Spring Cloud Stream provides a schema registry server implementation.
To use it, you can add the <code>spring-cloud-stream-schema-server</code> artifact to your project and use the <code>@EnableSchemaRegistryServer</code> annotation, which adds the schema registry server REST controller to your application.
This annotation is intended to be used with Spring Boot web applications, and the listening port of the server is controlled by the <code>server.port</code> property.
The <code>spring.cloud.stream.schema.server.path</code> property can be used to control the root path of the schema server (especially when it is embedded in other applications).
The <code>spring.cloud.stream.schema.server.allowSchemaDeletion</code> boolean property enables the deletion of a schema. By default, this is disabled.</p>
</div>
<div class="paragraph">
<p>The schema registry server uses a relational database to store the schemas.
By default, it uses an embedded database.
You can customize the schema storage by using the <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql">Spring Boot SQL database and JDBC configuration options</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows a Spring Boot application that enables the schema registry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableSchemaRegistryServer
public class SchemaRegistryServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchemaRegistryServerApplication.class, args);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_schema_registry_server_api">9.5.1. Schema Registry Server API</h4>
<div class="paragraph">
<p>The Schema Registry Server API consists of the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>POST /</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-registering-new-schema">Registering a New Schema</a>&#8221;</p>
</li>
<li>
<p>'GET /{subject}/{format}/{version}'&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version">Retrieving an Existing Schema by Subject, Format, and Version</a>&#8221;</p>
</li>
<li>
<p><code>GET /{subject}/{format}</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-retrieve-schema-subject-format">Retrieving an Existing Schema by Subject and Format</a>&#8221;</p>
</li>
<li>
<p><code>GET /schemas/{id}</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-retrieve-schema-id">Retrieving an Existing Schema by ID</a>&#8221;</p>
</li>
<li>
<p><code>DELETE /{subject}/{format}/{version}</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-deleting-schema-subject-format-version">Deleting a Schema by Subject, Format, and Version</a>&#8221;</p>
</li>
<li>
<p><code>DELETE /schemas/{id}</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-deleting-schema-id">Deleting a Schema by ID</a>&#8221;</p>
</li>
<li>
<p><code>DELETE /{subject}</code>&#8201;&#8212;&#8201;see &#8220;<a href="#spring-cloud-stream-overview-deleting-schema-subject">Deleting a Schema by Subject</a>&#8221;</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-registering-new-schema">Registering a New Schema</h5>
<div class="paragraph">
<p>To register a new schema, send a <code>POST</code> request to the <code>/</code> endpoint.</p>
</div>
<div class="paragraph">
<p>The <code>/</code> accepts a JSON payload  with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject</code>: The schema subject</p>
</li>
<li>
<p><code>format</code>: The schema format</p>
</li>
<li>
<p><code>definition</code>: The schema definition</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Its response is a schema object in JSON, with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code>: The schema ID</p>
</li>
<li>
<p><code>subject</code>: The schema subject</p>
</li>
<li>
<p><code>format</code>: The schema format</p>
</li>
<li>
<p><code>version</code>: The schema version</p>
</li>
<li>
<p><code>definition</code>: The schema definition</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-retrieve-schema-subject-format-version">Retrieving an Existing Schema by Subject, Format, and Version</h5>
<div class="paragraph">
<p>To retrieve an existing schema by subject, format, and version, send <code>GET</code> request to the <code>/{subject}/{format}/{version}</code> endpoint.</p>
</div>
<div class="paragraph">
<p>Its response is a schema object in JSON, with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code>: The schema ID</p>
</li>
<li>
<p><code>subject</code>: The schema subject</p>
</li>
<li>
<p><code>format</code>: The schema format</p>
</li>
<li>
<p><code>version</code>: The schema version</p>
</li>
<li>
<p><code>definition</code>: The schema definition</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-retrieve-schema-subject-format">Retrieving an Existing Schema by Subject and Format</h5>
<div class="paragraph">
<p>To retrieve an existing schema by subject and format, send a <code>GET</code> request to the <code>/subject/format</code> endpoint.</p>
</div>
<div class="paragraph">
<p>Its response is a list of schemas with each schema object in JSON, with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code>: The schema ID</p>
</li>
<li>
<p><code>subject</code>: The schema subject</p>
</li>
<li>
<p><code>format</code>: The schema format</p>
</li>
<li>
<p><code>version</code>: The schema version</p>
</li>
<li>
<p><code>definition</code>: The schema definition</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-retrieve-schema-id">Retrieving an Existing Schema by ID</h5>
<div class="paragraph">
<p>To retrieve a schema by its ID, send a <code>GET</code> request to the <code>/schemas/{id}</code> endpoint.</p>
</div>
<div class="paragraph">
<p>Its response is a schema object in JSON, with the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code>: The schema ID</p>
</li>
<li>
<p><code>subject</code>: The schema subject</p>
</li>
<li>
<p><code>format</code>: The schema format</p>
</li>
<li>
<p><code>version</code>: The schema version</p>
</li>
<li>
<p><code>definition</code>: The schema definition</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-deleting-schema-subject-format-version">Deleting a Schema by Subject, Format, and Version</h5>
<div class="paragraph">
<p>To delete a schema identified by its subject, format, and version, send a <code>DELETE</code> request to the <code>/{subject}/{format}/{version}</code> endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-deleting-schema-id">Deleting a Schema by ID</h5>
<div class="paragraph">
<p>To delete a schema by its ID, send a <code>DELETE</code> request to the <code>/schemas/{id}</code> endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-deleting-schema-subject">Deleting a Schema by Subject</h5>
<div class="paragraph">
<p><code>DELETE /{subject}</code></p>
</div>
<div class="paragraph">
<p>Delete existing schemas by their subject.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This note applies to users of Spring Cloud Stream 1.1.0.RELEASE only.
Spring Cloud Stream 1.1.0.RELEASE used the table name, <code>schema</code>, for storing <code>Schema</code> objects. <code>Schema</code> is a keyword in a number of database implementations.
To avoid any conflicts in the future, starting with 1.1.1.RELEASE, we have opted for the name <code>SCHEMA_REPOSITORY</code> for the storage table.
Any Spring Cloud Stream 1.1.0.RELEASE users who upgrade should migrate their existing schemas to the new table before upgrading.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_confluent_s_schema_registry">9.5.2. Using Confluent&#8217;s Schema Registry</h4>
<div class="paragraph">
<p>The default configuration creates a <code>DefaultSchemaRegistryClient</code> bean.
If you want to use the Confluent schema registry, you need to create a bean of type <code>ConfluentSchemaRegistryClient</code>, which supersedes the one configured by default by the framework. The following example shows how to create such a bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SchemaRegistryClient schemaRegistryClient(@Value("${spring.cloud.stream.schemaRegistryClient.endpoint}") String endpoint){
  ConfluentSchemaRegistryClient client = new ConfluentSchemaRegistryClient();
  client.setEndpoint(endpoint);
  return client;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The ConfluentSchemaRegistryClient is tested against Confluent platform version 4.0.0.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registration_and_resolution">9.6. Schema Registration and Resolution</h3>
<div class="paragraph">
<p>To better understand how Spring Cloud Stream registers and resolves new schemas and its use of Avro schema comparison features, we provide two separate subsections:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-schema-registration-process">Schema Registration Process (Serialization)</a>&#8221;</p>
</li>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-schema-resolution-process">Schema Resolution Process (Deserialization)</a>&#8221;</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-schema-registration-process">9.6.1. Schema Registration Process (Serialization)</h4>
<div class="paragraph">
<p>The first part of the registration process is extracting a schema from the payload that is being sent over a channel.
Avro types such as <code>SpecificRecord</code> or <code>GenericRecord</code> already contain a schema, which can be retrieved immediately from the instance.
In the case of POJOs, a schema is inferred if the <code>spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</code> property is set to <code>true</code> (the default).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/schema_resolution.png" alt="schema resolution" width="800">
</div>
<div class="title">Figure 7. Schema Writer Resolution Process</div>
</div>
<div class="paragraph">
<p>Ones a schema is obtained, the converter loads its metadata (version) from the remote server.
First, it queries a local cache. If no result is found, it submits the data to the server, which replies with versioning information.
The converter always caches the results to avoid the overhead of querying the Schema Server for every new message that needs to be serialized.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/registration.png" alt="registration" width="800">
</div>
<div class="title">Figure 8. Schema Registration Process</div>
</div>
<div class="paragraph">
<p>With the schema version information, the converter sets the <code>contentType</code> header of the message to carry the version information&#8201;&#8212;&#8201;for example: <code>application/vnd.user.v1+avro</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-schema-resolution-process">9.6.2. Schema Resolution Process (Deserialization)</h4>
<div class="paragraph">
<p>When reading messages that contain version information (that is, a <code>contentType</code> header with a scheme like the one described under &#8220;<a href="#spring-cloud-stream-overview-schema-registration-process">Schema Registration Process (Serialization)</a>&#8221;), the converter queries the Schema server to fetch the writer schema of the message.
Once it has found the correct schema of the incoming message, it retrieves the reader schema and, by using Avro&#8217;s schema resolution support, reads it into the reader definition (setting defaults and any missing properties).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/schema_reading.png" alt="schema reading" width="800">
</div>
<div class="title">Figure 9. Schema Reading Resolution Process</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should understand the difference between a writer schema (the application that wrote the message) and a reader schema (the receiving application).
We suggest taking a moment to read <a href="https://avro.apache.org/docs/1.7.6/spec.html">the Avro terminology</a> and understand the process.
Spring Cloud Stream always fetches the writer schema to determine how to read a message.
If you want to get Avro&#8217;s schema evolution support working, you need to make sure that a <code>readerSchema</code> was properly set for your application.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inter_application_communication">10. Inter-Application Communication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream enables communication between applications. Inter-application communication is a complex issue spanning several concerns, as described in the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-connecting-multiple-application-instances">Connecting Multiple Application Instances</a>&#8221;</p>
</li>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-instance-index-instance-count">Instance Index and Instance Count</a>&#8221;</p>
</li>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-partitioning">Partitioning</a>&#8221;</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-connecting-multiple-application-instances">10.1. Connecting Multiple Application Instances</h3>
<div class="paragraph">
<p>While Spring Cloud Stream makes it easy for individual Spring Boot applications to connect to messaging systems, the typical scenario for Spring Cloud Stream is the creation of multi-application pipelines, where microservice applications send data to each other.
You can achieve this scenario by correlating the input and output destinations of &#8220;adjacent&#8221; applications.</p>
</div>
<div class="paragraph">
<p>Suppose a design calls for the Time Source application to send data to the Log Sink application. You could use a common destination named <code>ticktock</code> for bindings within both applications.</p>
</div>
<div class="paragraph">
<p>Time Source (that has the channel name <code>output</code>) would set the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.output.destination=ticktock</pre>
</div>
</div>
<div class="paragraph">
<p>Log Sink (that has the channel name <code>input</code>) would set the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.input.destination=ticktock</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-instance-index-instance-count">10.2. Instance Index and Instance Count</h3>
<div class="paragraph">
<p>When scaling up Spring Cloud Stream applications, each instance can receive information about how many other instances of the same application exist and what its own instance index is.
Spring Cloud Stream does this through the <code>spring.cloud.stream.instanceCount</code> and <code>spring.cloud.stream.instanceIndex</code> properties.
For example, if there are three instances of a HDFS sink application, all three instances have <code>spring.cloud.stream.instanceCount</code> set to <code>3</code>, and the individual applications have <code>spring.cloud.stream.instanceIndex</code> set to <code>0</code>, <code>1</code>, and <code>2</code>, respectively.</p>
</div>
<div class="paragraph">
<p>When Spring Cloud Stream applications are deployed through Spring Cloud Data Flow, these properties are configured automatically; when Spring Cloud Stream applications are launched independently, these properties must be set correctly.
By default, <code>spring.cloud.stream.instanceCount</code> is <code>1</code>, and <code>spring.cloud.stream.instanceIndex</code> is <code>0</code>.</p>
</div>
<div class="paragraph">
<p>In a scaled-up scenario, correct configuration of these two properties is important for addressing partitioning behavior (see below) in general, and the two properties are always required by certain binders (for example, the Kafka binder) in order to ensure that data are split correctly across multiple consumer instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-partitioning">10.3. Partitioning</h3>
<div class="paragraph">
<p>Partitioning in Spring Cloud Stream consists of two tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning">Configuring Output Bindings for Partitioning</a>&#8221;</p>
</li>
<li>
<p>&#8220;<a href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning">Configuring Input Bindings for Partitioning</a>&#8221;</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-configuring-output-bindings-partitioning">10.3.1. Configuring Output Bindings for Partitioning</h4>
<div class="paragraph">
<p>You can configure an output binding to send partitioned data by setting one and only one of its <code>partitionKeyExpression</code> or <code>partitionKeyExtractorName</code> properties, as well as its <code>partitionCount</code> property.</p>
</div>
<div class="paragraph">
<p>For example, the following is a valid and typical configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre>
</div>
</div>
<div class="paragraph">
<p>Based on that example configuration, data is sent to the target partition by using the following logic.</p>
</div>
<div class="paragraph">
<p>A partition key&#8217;s value is calculated for each message sent to a partitioned output channel based on the <code>partitionKeyExpression</code>.
The <code>partitionKeyExpression</code> is a SpEL expression that is evaluated against the outbound message for extracting the partitioning key.</p>
</div>
<div class="paragraph">
<p>If a SpEL expression is not sufficient for your needs, you can instead calculate the partition key value by providing an implementation of <code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code> and configuring it as a bean (by using the <code>@Bean</code> annotation).
If you have more then one bean of type <code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code> available in the Application Context, you can further filter it by specifying its name with the <code>partitionKeyExtractorName</code> property, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>--spring.cloud.stream.bindings.output.producer.partitionKeyExtractorName=customPartitionKeyExtractor
--spring.cloud.stream.bindings.output.producer.partitionCount=5
. . .
@Bean
public CustomPartitionKeyExtractorClass customPartitionKeyExtractor() {
    return new CustomPartitionKeyExtractorClass();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In previous versions of Spring Cloud Stream, you could specify the implementation of <code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code> by setting the  <code>spring.cloud.stream.bindings.output.producer.partitionKeyExtractorClass</code> property.
Since version 2.0, this property is deprecated, and support for it will be removed in a future version.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the message key is calculated, the partition selection process determines the target partition as a value between <code>0</code> and <code>partitionCount - 1</code>.
The default calculation, applicable in most scenarios, is based on the following formula: <code>key.hashCode() % partitionCount</code>.
This can be customized on the binding, either by setting a SpEL expression to be evaluated against the 'key' (through the <code>partitionSelectorExpression</code> property) or by configuring an implementation of <code>org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code> as a bean (by using the @Bean annotation).
Similar to the <code>PartitionKeyExtractorStrategy</code>, you can further filter it by using the <code>spring.cloud.stream.bindings.output.producer.partitionSelectorName</code> property when more than one bean of this type is available in the Application Context, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>--spring.cloud.stream.bindings.output.producer.partitionSelectorName=customPartitionSelector
. . .
@Bean
public CustomPartitionSelectorClass customPartitionSelector() {
    return new CustomPartitionSelectorClass();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In previous versions of Spring Cloud Stream you could specify the implementation of <code>org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code> by setting the <code>spring.cloud.stream.bindings.output.producer.partitionSelectorClass</code> property.
Since version 2.0, this property is deprecated and support for it will be removed in a future version.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-configuring-input-bindings-partitioning">10.3.2. Configuring Input Bindings for Partitioning</h4>
<div class="paragraph">
<p>An input binding (with the channel name <code>input</code>) is configured to receive partitioned data by setting its <code>partitioned</code> property, as well as the <code>instanceIndex</code> and <code>instanceCount</code> properties on the application itself, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>instanceCount</code> value represents the total number of application instances between which the data should be partitioned.
The <code>instanceIndex</code> must be a unique value across the multiple instances, with a value between <code>0</code> and <code>instanceCount - 1</code>.
The instance index helps each application instance to identify the unique partition(s) from which it receives data.
It is required by binders using technology that does not support partitioning natively.
For example, with RabbitMQ, there is a queue for each partition, with the queue name containing the instance index.
With Kafka, if <code>autoRebalanceEnabled</code> is <code>true</code> (default), Kafka takes care of distributing partitions across instances, and these properties are not required.
If <code>autoRebalanceEnabled</code> is set to false, the <code>instanceCount</code> and <code>instanceIndex</code> are used by the binder to determine which partition(s) the instance subscribes to (you must have at least as many partitions as there are instances).
The binder allocates the partitions instead of Kafka.
This might be useful if you want messages for a particular partition to always go to the same instance.
When a binder configuration requires them, it is important to set both values correctly in order to ensure that all of the data is consumed and that the application instances receive mutually exclusive datasets.</p>
</div>
<div class="paragraph">
<p>While a scenario in which using multiple instances for partitioned data processing may be complex to set up in a standalone case, Spring Cloud Dataflow can simplify the process significantly by populating both the input and output values correctly and by letting you rely on the runtime infrastructure to provide information about the instance index and instance count.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing">11. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream provides support for testing your microservice applications without connecting to a messaging system.
You can do that by using the <code>TestSupportBinder</code> provided by the <code>spring-cloud-stream-test-support</code> library, which can be added as a test dependency to the application, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
       &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>TestSupportBinder</code> uses the Spring Boot autoconfiguration mechanism to supersede the other binders found on the classpath.
Therefore, when adding a binder as a dependency, you must make sure that the <code>test</code> scope is being used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>TestSupportBinder</code> lets you interact with the bound channels and inspect any messages sent and received by the application.</p>
</div>
<div class="paragraph">
<p>For outbound message channels, the <code>TestSupportBinder</code> registers a single subscriber and retains the messages emitted by the application in a <code>MessageCollector</code>.
They can be retrieved during tests and have assertions made against them.</p>
</div>
<div class="paragraph">
<p>You can also send messages to inbound message channels so that the consumer application can consume the messages.
The following example shows how to test both input and output channels on a processor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message&lt;String&gt; message = new GenericMessage&lt;&gt;("hello");
    processor.input().send(message);
    Message&lt;String&gt; received = (Message&lt;String&gt;) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we create an application that has an input channel and an output channel, both bound through the <code>Processor</code> interface.
The bound interface is injected into the test so that we can have access to both channels.
We send a message on the input channel, and we use the <code>MessageCollector</code> provided by Spring Cloud Stream&#8217;s test support to capture that the message has been sent to the output channel as a result.
Once we have received the message, we can validate that the component functions correctly.</p>
</div>
<div class="sect2">
<h3 id="_disabling_the_test_binder_autoconfiguration">11.1. Disabling the Test Binder Autoconfiguration</h3>
<div class="paragraph">
<p>The intent behind the test binder superseding all the other binders on the classpath is to make it easy to test your applications without making changes to your production dependencies.
In some cases (for example, integration tests) it is useful to use the actual production binders instead, and that requires disabling the test binder autoconfiguration.
To do so, you can exclude the <code>org.springframework.cloud.stream.test.binder.TestSupportBinderAutoConfiguration</code> class by using one of the Spring Boot autoconfiguration exclusion mechanisms, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @SpringBootApplication(exclude = TestSupportBinderAutoConfiguration.class)
    @EnableBinding(Processor.class)
    public static class MyProcessor {

        @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
        public String transform(String in) {
            return in + " world";
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When autoconfiguration is disabled, the test binder is available on the classpath, and its <code>defaultCandidate</code> property is set to <code>false</code> so that it does not interfere with the regular user configuration. It can be referenced under the name, <code>test</code>, as shown in the following example:</p>
</div>
<div class="paragraph">
<p><code>spring.cloud.stream.defaultBinder=test</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_health_indicator">12. Health Indicator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Stream provides a health indicator for binders.
It is registered under the name <code>binders</code> and can be enabled or disabled by setting the <code>management.health.binders.enabled</code> property.</p>
</div>
<div class="paragraph">
<p>By default <code>management.health.binders.enabled</code> is set to 	<code>false</code>.
Setting <code>management.health.binders.enabled</code> to <code>true</code> enables the health indicator, allowing you to access the <code>/health</code> endpoint to retrieve the binder health indicators.</p>
</div>
<div class="paragraph">
<p>Health indicators are binder-specific and certain binder implementations may not necessarily provide a health indicator.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-stream-overview-metrics-emitter">13. Metrics Emitter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot Actuator provides dependency management and auto-configuration for <a href="https://micrometer.io/">Micrometer</a>, an application metrics
facade that supports numerous <a href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#production-ready-metrics">monitoring systems</a>.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream provides support for emitting any available micrometer-based metrics to a binding destination, allowing for periodic
collection of metric data from stream applications without relying on polling individual endpoints.</p>
</div>
<div class="paragraph">
<p>Metrics Emitter is activated by defining the <code>spring.cloud.stream.bindings.applicationMetrics.destination</code> property,
which specifies the name of the binding destination used by the current binder to publish metric messages.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">spring.cloud.stream.bindings.applicationMetrics.destination=myMetricDestination</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example instructs the binder to bind to <code>myMetricDestination</code> (that is, Rabbit exchange, Kafka topic, and others).</p>
</div>
<div class="paragraph">
<p>The following properties can be used for customizing the emission of metrics:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.metrics.key</dt>
<dd>
<p>The name of the metric being emitted. Should be a unique value per application.</p>
<div class="paragraph">
<p>Default: <code>${spring.application.name:${vcap.application.name:${spring.config.name:application}}}</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.properties</dt>
<dd>
<p>Allows white listing application properties that are added to the metrics payload</p>
<div class="paragraph">
<p>Default: null.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.meter-filter</dt>
<dd>
<p>Pattern to control the 'meters' one wants to capture.
For example, specifying <code>spring.integration.*</code> captures metric information for meters whose name starts with <code>spring.integration.</code></p>
<div class="paragraph">
<p>Default: all 'meters' are captured.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.schedule-interval</dt>
<dd>
<p>Interval to control the rate of publishing metric data.</p>
<div class="paragraph">
<p>Default: 1 min</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">java -jar time-source.jar \
    --spring.cloud.stream.bindings.applicationMetrics.destination=someMetrics \
    --spring.cloud.stream.metrics.properties=spring.application** \
    --spring.cloud.stream.metrics.meter-filter=spring.integration.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the payload of the data published to the binding destination as a result of the preceding command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
	"name": "application",
	"createdTime": "2018-03-23T14:48:12.700Z",
	"properties": {
	},
	"metrics": [
		{
			"id": {
				"name": "spring.integration.send",
				"tags": [
					{
						"key": "exception",
						"value": "none"
					},
					{
						"key": "name",
						"value": "input"
					},
					{
						"key": "result",
						"value": "success"
					},
					{
						"key": "type",
						"value": "channel"
					}
				],
				"type": "TIMER",
				"description": "Send processing time",
				"baseUnit": "milliseconds"
			},
			"timestamp": "2018-03-23T14:48:12.697Z",
			"sum": 130.340546,
			"count": 6,
			"mean": 21.72342433333333,
			"upper": 116.176299,
			"total": 130.340546
		}
	]
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Given that the format of the Metric message has slightly changed after migrating to Micrometer, the published message will also have
a <code>STREAM_CLOUD_STREAM_VERSION</code> header set to <code>2.x</code> to help distinguish between Metric messages from the older versions of the Spring Cloud Stream.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_samples">14. Samples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For Spring Cloud Stream samples, see the <a href="https://github.com/spring-cloud/spring-cloud-stream-samples">spring-cloud-stream-samples</a> repository on GitHub.</p>
</div>
<div class="sect2">
<h3 id="_deploying_stream_applications_on_cloudfoundry">14.1. Deploying Stream Applications on CloudFoundry</h3>
<div class="paragraph">
<p>On CloudFoundry, services are usually exposed through a special environment variable called <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES">VCAP_SERVICES</a>.</p>
</div>
<div class="paragraph">
<p>When configuring your binder connections, you can use the values from an environment variable as explained on the <a href="https://docs.spring.io/spring-cloud-dataflow-server-cloudfoundry/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-ups">dataflow Cloud Foundry Server</a> docs.</p>
</div>
</div>
</div>
</div>
<h1 id="_binder_implementations" class="sect0">Binder Implementations</h1>
<div class="sect1">
<h2 id="_apache_kafka_binder">15. Apache Kafka Binder</h2>
<div class="sectionbody">

<div class="sect3">
<h4 id="_usage">15.1. Usage</h4>
<div class="paragraph">
<p>To use Apache Kafka binder, you need to add <code>spring-cloud-stream-binder-kafka</code> as a dependency to your Spring Cloud Stream application, as shown in the following example for Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can also use the Spring Cloud Stream Kafka Starter, as shown inn the following example for Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_apache_kafka_binder_overview">15.2. Apache Kafka Binder Overview</h4>
<div class="paragraph">
<p>The following image shows a simplified diagram of how the Apache Kafka binder operates:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/images/kafka-binder.png" alt="kafka binder" width="300">
</div>
<div class="title">Figure 10. Kafka Binder</div>
</div>
<div class="paragraph">
<p>The Apache Kafka Binder implementation maps each destination to an Apache Kafka topic.
The consumer group maps directly to the same Apache Kafka concept.
Partitioning also maps directly to Apache Kafka partitions as well.</p>
</div>
<div class="paragraph">
<p>The binder currently uses the Apache Kafka <code>kafka-clients</code> 1.0.0 jar and is designed to be used with a broker of at least that version.
This client can communicate with older brokers (see the Kafka documentation), but certain features may not be available.
For example, with versions earlier than 0.11.x.x, native headers are not supported.
Also, 0.11.x.x does not support the <code>autoAddPartitions</code> property.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuration_options_2">15.3. Configuration Options</h4>
<div class="paragraph">
<p>This section contains the configuration options used by the Apache Kafka binder.</p>
</div>
<div class="paragraph">
<p>For common configuration options and properties pertaining to binder, see the <a href="#binding-properties">core documentation</a>.</p>
</div>
<div class="sect4">
<h5 id="_kafka_binder_properties">Kafka Binder Properties</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.brokers</dt>
<dd>
<p>A list of brokers to which the Kafka binder connects.</p>
<div class="paragraph">
<p>Default: <code>localhost</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.defaultBrokerPort</dt>
<dd>
<p><code>brokers</code> allows hosts specified with or without port information (for example, <code>host1,host2:port2</code>).
This sets the default port when no port is configured in the broker list.</p>
<div class="paragraph">
<p>Default: <code>9092</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.configuration</dt>
<dd>
<p>Key/Value map of client properties (both producers and consumer) passed to all clients created by the binder.
Due to the fact that these properties are used by both producers and consumers, usage should be restricted to common properties&#8201;&#8212;&#8201;for example, security settings.</p>
<div class="paragraph">
<p>Default: Empty map.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.headers</dt>
<dd>
<p>The list of custom headers that are transported by the binder.
Only required when communicating with older applications (&#8656; 1.3.x) with a <code>kafka-clients</code> version &lt; 0.11.0.0. Newer versions support headers natively.</p>
<div class="paragraph">
<p>Default: empty.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.healthTimeout</dt>
<dd>
<p>The time to wait to get partition information, in seconds.
Health reports as down if this timer expires.</p>
<div class="paragraph">
<p>Default: 10.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.requiredAcks</dt>
<dd>
<p>The number of required acks on the broker.
See the Kafka documentation for the producer <code>acks</code> property.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.minPartitionCount</dt>
<dd>
<p>Effective only if <code>autoCreateTopics</code> or <code>autoAddPartitions</code> is set.
The global minimum number of partitions that the binder configures on topics on which it produces or consumes data.
It can be superseded by the <code>partitionCount</code> setting of the producer or by the value of <code>instanceCount * concurrency</code> settings of the producer (if either is larger).</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.replicationFactor</dt>
<dd>
<p>The replication factor of auto-created topics if <code>autoCreateTopics</code> is active.
Can be overridden on each binding.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoCreateTopics</dt>
<dd>
<p>If set to <code>true</code>, the binder creates new topics automatically.
If set to <code>false</code>, the binder relies on the topics being already configured.
In the latter case, if the topics do not exist, the binder fails to start.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This setting is independent of the <code>auto.topic.create.enable</code> setting of the broker and does not influence it.
If the server is set to auto-create topics, they may be created as part of the metadata retrieval request, with default broker settings.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoAddPartitions</dt>
<dd>
<p>If set to <code>true</code>, the binder creates new partitions if required.
If set to <code>false</code>, the binder relies on the partition size of the topic being already configured.
If the partition count of the target topic is smaller than the expected value, the binder fails to start.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</dt>
<dd>
<p>Enables transactions in the binder. See <code>transaction.id</code> in the Kafka documentation and <a href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#transactions">Transactions</a> in the <code>spring-kafka</code> documentation.
When transactions are enabled, individual <code>producer</code> properties are ignored and all producers use the <code>spring.cloud.stream.kafka.binder.transaction.producer.*</code> properties.</p>
<div class="paragraph">
<p>Default <code>null</code> (no transactions)</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.transaction.producer.*</dt>
<dd>
<p>Global producer properties for producers in a transactional binder.
See <code>spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</code> and <a href="#kafka-producer-properties">Kafka Producer Properties</a> and the general producer properties supported by all binders.</p>
<div class="paragraph">
<p>Default: See individual producer properties.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.headerMapperBeanName</dt>
<dd>
<p>The bean name of a <code>KafkaHeaderMapper</code> used for mapping <code>spring-messaging</code> headers to and from Kafka headers.
Use this, for example, if you wish to customize the trusted packages in a <code>DefaultKafkaHeaderMapper</code> that uses JSON deserialization for the headers.</p>
<div class="paragraph">
<p>Default: none.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="kafka-consumer-properties">Kafka Consumer Properties</h5>
<div class="paragraph">
<p>The following properties are available for Kafka consumers only and
must be prefixed with <code>spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.consumer.</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">admin.configuration</dt>
<dd>
<p>A <code>Map</code> of Kafka topic properties used when provisioning topics&#8201;&#8212;&#8201;for example, <code>spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p>
<div class="paragraph">
<p>Default: none.</p>
</div>
</dd>
<dt class="hdlist1">admin.replicas-assignment</dt>
<dd>
<p>A Map&lt;Integer, List&lt;Integer&gt;&gt; of replica assignments, with the key being the partition and the value being the assignments.
Used when provisioning new topics.
See the <code>NewTopic</code> Javadocs in the <code>kafka-clients</code> jar.</p>
<div class="paragraph">
<p>Default: none.</p>
</div>
</dd>
<dt class="hdlist1">admin.replication-factor</dt>
<dd>
<p>The replication factor to use when provisioning topics. Overrides the binder-wide setting.
Ignored if <code>replicas-assignments</code> is present.</p>
<div class="paragraph">
<p>Default: none (the binder-wide default of 1 is used).</p>
</div>
</dd>
<dt class="hdlist1">autoRebalanceEnabled</dt>
<dd>
<p>When <code>true</code>, topic partitions is automatically rebalanced between the members of a consumer group.
When <code>false</code>, each consumer is assigned a fixed set of partitions based on <code>spring.cloud.stream.instanceCount</code> and <code>spring.cloud.stream.instanceIndex</code>.
This requires both the <code>spring.cloud.stream.instanceCount</code> and <code>spring.cloud.stream.instanceIndex</code> properties to be set appropriately on each launched instance.
The value of the <code>spring.cloud.stream.instanceCount</code> property must typically be greater than 1 in this case.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">ackEachRecord</dt>
<dd>
<p>When <code>autoCommitOffset</code> is <code>true</code>, this setting dictates whether to commit the offset after each record is processed.
By default, offsets are committed after all records in the batch of records returned by <code>consumer.poll()</code> have been processed.
The number of records returned by a poll can be controlled with the <code>max.poll.records</code> Kafka property, which is set through the consumer <code>configuration</code> property.
Setting this to <code>true</code> may cause a degradation in performance, but doing so reduces the likelihood of redelivered records when a failure occurs.
Also, see the binder <code>requiredAcks</code> property, which also affects the performance of committing offsets.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">autoCommitOffset</dt>
<dd>
<p>Whether to autocommit offsets when a message has been processed.
If set to <code>false</code>, a header with the key <code>kafka_acknowledgment</code> of the type <code>org.springframework.kafka.support.Acknowledgment</code> header is present in the inbound message.
Applications may use this header for acknowledging messages.
See the examples section for details.
When this property is set to <code>false</code>, Kafka binder sets the ack mode to <code>org.springframework.kafka.listener.AbstractMessageListenerContainer.AckMode.MANUAL</code> and the application is responsible for acknowledging records.
Also see <code>ackEachRecord</code>.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">autoCommitOnError</dt>
<dd>
<p>Effective only if <code>autoCommitOffset</code> is set to <code>true</code>.
If set to <code>false</code>, it suppresses auto-commits for messages that result in errors and commits only for successful messages. It allows a stream to automatically replay from the last successfully processed message, in case of persistent failures.
If set to <code>true</code>, it always auto-commits (if auto-commit is enabled).
If not set (the default), it effectively has the same value as <code>enableDlq</code>, auto-committing erroneous messages if they are sent to a DLQ and not committing them otherwise.</p>
<div class="paragraph">
<p>Default: not set.</p>
</div>
</dd>
<dt class="hdlist1">resetOffsets</dt>
<dd>
<p>Whether to reset offsets on the consumer to the value provided by startOffset.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">startOffset</dt>
<dd>
<p>The starting offset for new groups.
Allowed values: <code>earliest</code> and <code>latest</code>.
If the consumer group is set explicitly for the consumer 'binding' (through <code>spring.cloud.stream.bindings.&lt;channelName&gt;.group</code>), 'startOffset' is set to <code>earliest</code>. Otherwise, it is set to <code>latest</code> for the <code>anonymous</code> consumer group.
Also see <code>resetOffsets</code> (earlier in this list).</p>
<div class="paragraph">
<p>Default: null (equivalent to <code>earliest</code>).</p>
</div>
</dd>
<dt class="hdlist1">enableDlq</dt>
<dd>
<p>When set to true, it enables DLQ behavior for the consumer.
By default, messages that result in errors are forwarded to a topic named <code>error.&lt;destination&gt;.&lt;group&gt;</code>.
The DLQ topic name can be configurable by setting the <code>dlqName</code> property.
This provides an alternative option to the more common Kafka replay scenario for the case when the number of errors is relatively small and replaying the entire original topic may be too cumbersome.
See <a href="#kafka-dlq-processing">Dead-Letter Topic Processing</a> processing for more information.
Starting with version 2.0, messages sent to the DLQ topic are enhanced with the following headers: <code>x-original-topic</code>, <code>x-exception-message</code>, and <code>x-exception-stacktrace</code> as <code>byte[]</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">configuration</dt>
<dd>
<p>Map with a key/value pair containing generic Kafka consumer properties.</p>
<div class="paragraph">
<p>Default: Empty map.</p>
</div>
</dd>
<dt class="hdlist1">dlqName</dt>
<dd>
<p>The name of the DLQ topic to receive the error messages.</p>
<div class="paragraph">
<p>Default: null (If not specified, messages that result in errors are forwarded to a topic named <code>error.&lt;destination&gt;.&lt;group&gt;</code>).</p>
</div>
</dd>
<dt class="hdlist1">dlqProducerProperties</dt>
<dd>
<p>Using this, DLQ-specific producer properties can be set.
All the properties available through kafka producer properties can be set through this property.</p>
<div class="paragraph">
<p>Default: Default Kafka producer properties.</p>
</div>
</dd>
<dt class="hdlist1">standardHeaders</dt>
<dd>
<p>Indicates which standard headers are populated by the inbound channel adapter.
Allowed values: <code>none</code>, <code>id</code>, <code>timestamp</code>, or <code>both</code>.
Useful if using native deserialization and the first component to receive a message needs an <code>id</code> (such as an aggregator that is configured to use a JDBC message store).</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">converterBeanName</dt>
<dd>
<p>The name of a bean that implements <code>RecordMessageConverter</code>. Used in the inbound channel adapter to replace the default <code>MessagingMessageConverter</code>.</p>
<div class="paragraph">
<p>Default: <code>null</code></p>
</div>
</dd>
<dt class="hdlist1">idleEventInterval</dt>
<dd>
<p>The interval, in milliseconds, between events indicating that no messages have recently been received.
Use an <code>ApplicationListener&lt;ListenerContainerIdleEvent&gt;</code> to receive these events.
See <a href="#pause-resume">Example: Pausing and Resuming the Consumer</a> for a usage example.</p>
<div class="paragraph">
<p>Default: <code>30000</code></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="kafka-producer-properties">Kafka Producer Properties</h5>
<div class="paragraph">
<p>The following properties are available for Kafka producers only and
must be prefixed with <code>spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.producer.</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">admin.configuration</dt>
<dd>
<p>A <code>Map</code> of Kafka topic properties used when provisioning new topics&#8201;&#8212;&#8201;for example, <code>spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p>
<div class="paragraph">
<p>Default: none.</p>
</div>
</dd>
<dt class="hdlist1">admin.replicas-assignment</dt>
<dd>
<p>A Map&lt;Integer, List&lt;Integer&gt;&gt; of replica assignments, with the key being the partition and the value being the assignments.
Used when provisioning new topics.
See <code>NewTopic</code> javadocs in the <code>kafka-clients</code> jar.</p>
<div class="paragraph">
<p>Default: none.</p>
</div>
</dd>
<dt class="hdlist1">admin.replication-factor</dt>
<dd>
<p>The replication factor to use when provisioning new topics. Overrides the binder-wide setting.
Ignored if <code>replicas-assignments</code> is present.</p>
<div class="paragraph">
<p>Default: none (the binder-wide default of 1 is used).</p>
</div>
</dd>
<dt class="hdlist1">bufferSize</dt>
<dd>
<p>Upper limit, in bytes, of how much data the Kafka producer attempts to batch before sending.</p>
<div class="paragraph">
<p>Default: <code>16384</code>.</p>
</div>
</dd>
<dt class="hdlist1">sync</dt>
<dd>
<p>Whether the producer is synchronous.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">batchTimeout</dt>
<dd>
<p>How long the producer waits to allow more messages to accumulate in the same batch before sending the messages.
(Normally, the producer does not wait at all and simply sends all the messages that accumulated while the previous send was in progress.) A non-zero value may increase throughput at the expense of latency.</p>
<div class="paragraph">
<p>Default: <code>0</code>.</p>
</div>
</dd>
<dt class="hdlist1">messageKeyExpression</dt>
<dd>
<p>A SpEL expression evaluated against the outgoing message used to populate the key of the produced Kafka message&#8201;&#8212;&#8201;for example, <code>headers['myKey']</code>.
The payload cannot be used because, by the time this expression is evaluated, the payload is already in the form of a <code>byte[]</code>.</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>A comma-delimited list of simple patterns to match Spring messaging headers to be mapped to the Kafka <code>Headers</code> in the <code>ProducerRecord</code>.
Patterns can begin or end with the wildcard character (asterisk).
Patterns can be negated by prefixing with <code>!</code>.
Matching stops after the first match (positive or negative).
For example <code>!ask,as*</code> will pass <code>ash</code> but not <code>ask</code>.
<code>id</code> and <code>timestamp</code> are never mapped.</p>
<div class="paragraph">
<p>Default: <code>*</code> (all headers - except the <code>id</code> and <code>timestamp</code>)</p>
</div>
</dd>
<dt class="hdlist1">configuration</dt>
<dd>
<p>Map with a key/value pair containing generic Kafka producer properties.</p>
<div class="paragraph">
<p>Default: Empty map.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Kafka binder uses the <code>partitionCount</code> setting of the producer as a hint to create a topic with the given partition count (in conjunction with the <code>minPartitionCount</code>, the maximum of the two being the value being used).
Exercise caution when configuring both <code>minPartitionCount</code> for a binder and <code>partitionCount</code> for an application, as the larger value is used.
If a topic already exists with a smaller partition count and <code>autoAddPartitions</code> is disabled (the default), the binder fails to start.
If a topic already exists with a smaller partition count and <code>autoAddPartitions</code> is enabled, new partitions are added.
If a topic already exists with a larger number of partitions than the maximum of (<code>minPartitionCount</code> or <code>partitionCount</code>), the existing partition count is used.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_usage_examples">Usage examples</h5>
<div class="paragraph">
<p>In this section, we show the use of the preceding properties for specific scenarios.</p>
</div>
<div class="sect5">
<h6 id="_example_setting_code_autocommitoffset_code_to_code_false_code_and_relying_on_manual_acking">Example: Setting <code>autoCommitOffset</code> to <code>false</code> and Relying on Manual Acking</h6>
<div class="paragraph">
<p>This example illustrates how one may manually acknowledge offsets in a consumer application.</p>
</div>
<div class="paragraph">
<p>This example requires that <code>spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</code> be set to <code>false</code>.
Use the corresponding input channel name for your example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@SpringBootApplication
@EnableBinding(Sink.class)
public class ManuallyAcknowdledgingConsumer {

 public static void main(String[] args) {
     SpringApplication.run(ManuallyAcknowdledgingConsumer.class, args);
 }

 @StreamListener(Sink.INPUT)
 public void process(Message&lt;?&gt; message) {
     Acknowledgment acknowledgment = message.getHeaders().get(KafkaHeaders.ACKNOWLEDGMENT, Acknowledgment.class);
     if (acknowledgment != null) {
         System.out.println("Acknowledgment provided");
         acknowledgment.acknowledge();
     }
 }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_example_security_configuration">Example: Security Configuration</h6>
<div class="paragraph">
<p>Apache Kafka 0.9 supports secure connections between client and brokers.
To take advantage of this feature, follow the guidelines in the <a href="https://kafka.apache.org/090/documentation.html#security_configclients">Apache Kafka Documentation</a> as well as the Kafka 0.9 <a href="https://docs.confluent.io/2.0.0/kafka/security.html">security guidelines from the Confluent documentation</a>.
Use the <code>spring.cloud.stream.kafka.binder.configuration</code> option to set security properties for all clients created by the binder.</p>
</div>
<div class="paragraph">
<p>For example, to set <code>security.protocol</code> to <code>SASL_SSL</code>, set the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_SSL</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the other security properties can be set in a similar manner.</p>
</div>
<div class="paragraph">
<p>When using Kerberos, follow the instructions in the <a href="https://kafka.apache.org/090/documentation.html#security_sasl_clientconfig">reference documentation</a> for creating and referencing the JAAS configuration.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream supports passing JAAS configuration information to the application by using a JAAS configuration file and using Spring Boot properties.</p>
</div>
<div class="sect6">
<h7 id="_using_jaas_configuration_files">Using JAAS Configuration Files</h7>
<div class="paragraph">
<p>The JAAS and (optionally) krb5 file locations can be set for Spring Cloud Stream applications by using system properties.
The following example shows how to launch a Spring Cloud Stream application with SASL and Kerberos by using a JAAS configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> java -Djava.security.auth.login.config=/path.to/kafka_client_jaas.conf -jar log.jar \
   --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="_using_spring_boot_properties">Using Spring Boot Properties</h7>
<div class="paragraph">
<p>As an alternative to having a JAAS configuration file, Spring Cloud Stream provides a mechanism for setting up the JAAS configuration for Spring Cloud Stream applications by using Spring Boot properties.</p>
</div>
<div class="paragraph">
<p>The following properties can be used to configure the login context of the Kafka client:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.loginModule</dt>
<dd>
<p>The login module name. Not necessary to be set in normal cases.</p>
<div class="paragraph">
<p>Default: <code>com.sun.security.auth.module.Krb5LoginModule</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.controlFlag</dt>
<dd>
<p>The control flag of the login module.</p>
<div class="paragraph">
<p>Default: <code>required</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.options</dt>
<dd>
<p>Map with a key/value pair containing the login module options.</p>
<div class="paragraph">
<p>Default: Empty map.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following example shows how to launch a Spring Cloud Stream application with SASL and Kerberos by using Spring Boot configuration properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> java --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.autoCreateTopics=false \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT \
   --spring.cloud.stream.kafka.binder.jaas.options.useKeyTab=true \
   --spring.cloud.stream.kafka.binder.jaas.options.storeKey=true \
   --spring.cloud.stream.kafka.binder.jaas.options.keyTab=/etc/security/keytabs/kafka_client.keytab \
   --spring.cloud.stream.kafka.binder.jaas.options.principal=kafka-client-1@EXAMPLE.COM</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example represents the equivalent of the following JAAS file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>KafkaClient {
    com.sun.security.auth.module.Krb5LoginModule required
    useKeyTab=true
    storeKey=true
    keyTab="/etc/security/keytabs/kafka_client.keytab"
    principal="kafka-client-1@EXAMPLE.COM";
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the topics required already exist on the broker or will be created by an administrator, autocreation can be turned off and only client JAAS properties need to be sent.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not mix JAAS configuration files and Spring Boot properties in the same application.
If the <code>-Djava.security.auth.login.config</code> system property is already present, Spring Cloud Stream ignores the Spring Boot properties.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Be careful when using the <code>autoCreateTopics</code> and <code>autoAddPartitions</code> with Kerberos.
Usually, applications may use principals that do not have administrative rights in Kafka and Zookeeper.
Consequently, relying on Spring Cloud Stream to create/modify topics may fail.
In secure environments, we strongly recommend creating topics and managing ACLs administratively by using Kafka tooling.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pause-resume">Example: Pausing and Resuming the Consumer</h6>
<div class="paragraph">
<p>If you wish to suspend consumption but not cause a partition rebalance, you can pause and resume the consumer.
This is facilitated by adding the <code>Consumer</code> as a parameter to your <code>@StreamListener</code>.
To resume, you need an <code>ApplicationListener</code> for <code>ListenerContainerIdleEvent</code> instances.
The frequency at which events are published is controlled by the <code>idleEventInterval</code> property.
Since the consumer is not thread-safe, you must call these methods on the calling thread.</p>
</div>
<div class="paragraph">
<p>The following simple application shows how to pause and resume:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

	@StreamListener(Sink.INPUT)
	public void in(String in, @Header(KafkaHeaders.CONSUMER) Consumer&lt;?, ?&gt; consumer) {
		System.out.println(in);
		consumer.pause(Collections.singleton(new TopicPartition("myTopic", 0)));
	}

	@Bean
	public ApplicationListener&lt;ListenerContainerIdleEvent&gt; idleListener() {
		return event -&gt; {
			System.out.println(event);
			if (event.getConsumer().paused().size() &gt; 0) {
				event.getConsumer().resume(event.getConsumer().paused());
			}
		};
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kafka-error-channels">15.4. Error Channels</h4>
<div class="paragraph">
<p>Starting with version 1.3, the binder unconditionally sends exceptions to an error channel for each consumer destination and can also be configured to send async producer send failures to an error channel.
See <a href="#spring-cloud-stream-overview-error-handling">Error Handling</a> for more information.</p>
</div>
<div class="paragraph">
<p>The payload of the <code>ErrorMessage</code> for a send failure is a <code>KafkaSendFailureException</code> with properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code>: The Spring Messaging <code>Message&lt;?&gt;</code> that failed to be sent.</p>
</li>
<li>
<p><code>record</code>: The raw <code>ProducerRecord</code> that was created from the <code>failedMessage</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is no automatic handling of producer exceptions (such as sending to a <a href="#kafka-dlq-processing">Dead-Letter queue</a>).
You can consume these exceptions with your own Spring Integration flow.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafka-metrics">15.5. Kafka Metrics</h4>
<div class="paragraph">
<p>Kafka binder module exposes the following metrics:</p>
</div>
<div class="paragraph">
<p><code>spring.cloud.stream.binder.kafka.offset</code>: This metric indicates how many messages have not been yet consumed from a given binder&#8217;s topic by a given consumer group.
The metrics provided are based on the Mircometer metrics library. The metric contains the consumer group information, topic and the actual lag in committed offset from the latest offset on the topic.
This metric is particularly useful for providing auto-scaling feedback to a PaaS platform.</p>
</div>
</div>
<div class="sect3">
<h4 id="kafka-dlq-processing">15.6. Dead-Letter Topic Processing</h4>
<div class="paragraph">
<p>Because you cannot anticipate how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.
If the reason for the dead-lettering is transient, you may wish to route the messages back to the original topic.
However, if the problem is a permanent issue, that could cause an infinite loop.
The sample Spring Boot application within this topic is an example of how to route those messages back to the original topic, but it moves them to a &#8220;parking lot&#8221; topic after three attempts.
The application is another spring-cloud-stream application that reads from the dead-letter topic.
It terminates when no messages are received for 5 seconds.</p>
</div>
<div class="paragraph">
<p>The examples assume the original destination is <code>so8400out</code> and the consumer group is <code>so8400</code>.</p>
</div>
<div class="paragraph">
<p>There are a couple of strategies to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consider running the rerouting only when the main application is not running.
Otherwise, the retries for transient errors are used up very quickly.</p>
</li>
<li>
<p>Alternatively, use a two-stage approach: Use this application to route to a third topic and another to route from there back to the main topic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code listings show the sample application:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.input.group=so8400replay
spring.cloud.stream.bindings.input.destination=error.so8400out.so8400

spring.cloud.stream.bindings.output.destination=so8400out
spring.cloud.stream.bindings.output.producer.partitioned=true

spring.cloud.stream.bindings.parkingLot.destination=so8400in.parkingLot
spring.cloud.stream.bindings.parkingLot.producer.partitioned=true

spring.cloud.stream.kafka.binder.configuration.auto.offset.reset=earliest

spring.cloud.stream.kafka.binder.headers=x-retries</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Application</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(TwoOutputProcessor.class)
public class ReRouteDlqKApplication implements CommandLineRunner {

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) {
        SpringApplication.run(ReRouteDlqKApplication.class, args).close();
    }

    private final AtomicInteger processed = new AtomicInteger();

    @Autowired
    private MessageChannel parkingLot;

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public Message&lt;?&gt; reRoute(Message&lt;?&gt; failed) {
        processed.incrementAndGet();
        Integer retries = failed.getHeaders().get(X_RETRIES_HEADER, Integer.class);
        if (retries == null) {
            System.out.println("First retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else if (retries.intValue() &lt; 3) {
            System.out.println("Another retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(retries.intValue() + 1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else {
            System.out.println("Retries exhausted for " + failed);
            parkingLot.send(MessageBuilder.fromMessage(failed)
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build());
        }
        return null;
    }

    @Override
    public void run(String... args) throws Exception {
        while (true) {
            int count = this.processed.get();
            Thread.sleep(5000);
            if (count == this.processed.get()) {
                System.out.println("Idle, terminating");
                return;
            }
        }
    }

    public interface TwoOutputProcessor extends Processor {

        @Output("parkingLot")
        MessageChannel parkingLot();

    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_partitioning_with_the_kafka_binder">15.7. Partitioning with the Kafka Binder</h4>
<div class="paragraph">
<p>Apache Kafka supports topic partitioning natively.</p>
</div>
<div class="paragraph">
<p>Sometimes it is advantageous to send data to specific partitions&#8201;&#8212;&#8201;for example, when you want to strictly order message processing (all messages for a particular customer should go to the same partition).</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure the producer and consumer side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Source.class)
public class KafkaPartitionProducerApplication {

    private static final Random RANDOM = new Random(System.currentTimeMillis());

    private static final String[] data = new String[] {
            "foo1", "bar1", "qux1",
            "foo2", "bar2", "qux2",
            "foo3", "bar3", "qux3",
            "foo4", "bar4", "qux4",
            };

    public static void main(String[] args) {
        new SpringApplicationBuilder(KafkaPartitionProducerApplication.class)
            .web(false)
            .run(args);
    }

    @InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))
    public Message&lt;?&gt; generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println("Sending: " + value);
        return MessageBuilder.withPayload(value)
                .setHeader("partitionKey", value)
                .build();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    stream:
      bindings:
        output:
          destination: partitioned.topic
          producer:
            partitioned: true
            partition-key-expression: headers['partitionKey']
            partition-count: 12</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The topic must be provisioned to have enough partitions to achieve the desired concurrency for all consumer groups.
The above configuration supports up to 12 consumer instances (6 if their <code>concurrency</code> is 2, 4 if their concurrency is 3, and so on).
It is generally best to &#8220;over-provision&#8221; the partitions to allow for future increases in consumers or concurrency.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The preceding configuration uses the default partitioning (<code>key.hashCode() % partitionCount</code>).
This may or may not provide a suitably balanced algorithm, depending on the key values.
You can override this default by using the <code>partitionSelectorExpression</code> or <code>partitionSelectorClass</code> properties.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since partitions are natively handled by Kafka, no special configuration is needed on the consumer side.
Kafka allocates partitions across the instances.</p>
</div>
<div class="paragraph">
<p>The following Spring Boot application listens to a Kafka stream and prints (to the console) the partition ID to which each message goes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class KafkaPartitionConsumerApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(KafkaPartitionConsumerApplication.class)
            .web(false)
            .run(args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(@Payload String in, @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition) {
        System.out.println(in + " received from partition " + partition);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: partitioned.topic
          group: myGroup</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add instances as needed.
Kafka rebalances the partition allocations.
If the instance count (or <code>instance count * concurrency</code>) exceeds the number of partitions, some consumers are idle.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_apache_kafka_streams_binder">16. Apache Kafka Streams Binder</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_usage_2">16.1. Usage</h3>
<div class="paragraph">
<p>For using the Kafka Streams binder, you just need to add it to your Spring Cloud Stream application, using the following
Maven coordinates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-kafka-streams&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kafka_streams_binder_overview">16.2. Kafka Streams Binder Overview</h3>
<div class="paragraph">
<p>Spring Cloud Stream&#8217;s Apache Kafka support also includes a binder implementation designed explicitly for Apache Kafka
Streams binding. With this native integration, a Spring Cloud Stream "processor" application can directly use the
<a href="https://kafka.apache.org/documentation/streams/developer-guide">Apache Kafka Streams</a> APIs in the core business logic.</p>
</div>
<div class="paragraph">
<p>Kafka Streams binder implementation builds on the foundation provided by the <a href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams">Kafka Streams in Spring Kafka</a>
project.</p>
</div>
<div class="paragraph">
<p>As part of this native integration, the high-level <a href="https://docs.confluent.io/current/streams/developer-guide/dsl-api.html">Streams DSL</a>
provided by the Kafka Streams API is available for use in the business logic, too.</p>
</div>
<div class="paragraph">
<p>An early version of the <a href="https://docs.confluent.io/current/streams/developer-guide/processor-api.html">Processor API</a>
support is available as well.</p>
</div>
<div class="paragraph">
<p>As noted early-on, Kafka Streams support in Spring Cloud Stream strictly only available for use in the Processor model.
A model in which the messages read from an inbound topic, business processing can be applied, and the transformed messages
can be written to an outbound topic. It can also be used in Processor applications with a no-outbound destination.</p>
</div>
<div class="sect3">
<h4 id="_streams_dsl">16.2.1. Streams DSL</h4>
<div class="paragraph">
<p>This application consumes data from a Kafka topic (e.g., <code>words</code>), computes word count for each unique word in a 5 seconds
time window, and the computed results are sent to a downstream topic (e.g., <code>counts</code>) for further processing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@SpringBootApplication
@EnableBinding(KStreamProcessor.class)
public class WordCountProcessorApplication {

	@StreamListener("input")
	@SendTo("output")
	public KStream&lt;?, WordCount&gt; process(KStream&lt;?, String&gt; input) {
		return input
                .flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
                .groupBy((key, value) -&gt; value)
                .windowedBy(TimeWindows.of(5000))
                .count(Materialized.as("WordCounts-multi"))
                .toStream()
                .map((key, value) -&gt; new KeyValue&lt;&gt;(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))));
    }

	public static void main(String[] args) {
		SpringApplication.run(WordCountProcessorApplication.class, args);
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once built as a uber-jar (e.g., <code>wordcount-processor.jar</code>), you can run the above example like the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>java -jar wordcount-processor.jar  --spring.cloud.stream.bindings.input.destination=words --spring.cloud.stream.bindings.output.destination=counts</code></pre>
</div>
</div>
<div class="paragraph">
<p>This application will consume messages from the Kafka topic <code>words</code> and the computed results are published to an output
topic <code>counts</code>.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream will ensure that the messages from both the incoming and outgoing topics are automatically bound as
KStream objects. As a developer, you can exclusively focus on the business aspects of the code, i.e. writing the logic
required in the processor. Setting up the Streams DSL specific configuration required by the Kafka Streams infrastructure
is automatically handled by the framework.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_options_3">16.3. Configuration Options</h3>
<div class="paragraph">
<p>This section contains the configuration options used by the Kafka Streams binder.</p>
</div>
<div class="paragraph">
<p>For common configuration options and properties pertaining to binder, refer to the <a href="#binding-properties">core documentation</a>.</p>
</div>
<div class="sect3">
<h4 id="_kafka_streams_properties">16.3.1. Kafka Streams Properties</h4>
<div class="paragraph">
<p>The following properties are available at the binder level and must be prefixed with <code>spring.cloud.stream.kafka.streams.binder.</code>
literal.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">configuration</dt>
<dd>
<p> Map with a key/value pair containing properties pertaining to Apache Kafka Streams API.
 This property must be prefixed with <code>spring.cloud.stream.kafka.streams.binder.</code>.
Following are some examples of using this property.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms=1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about all the properties that may go into streams configuration, see StreamsConfig JavaDocs in
Apache Kafka Streams docs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">brokers</dt>
<dd>
<p>Broker URL</p>
<div class="paragraph">
<p>Default: <code>localhost</code></p>
</div>
</dd>
<dt class="hdlist1">zkNodes</dt>
<dd>
<p>Zookeeper URL</p>
<div class="paragraph">
<p>Default: <code>localhost</code></p>
</div>
</dd>
<dt class="hdlist1">serdeError</dt>
<dd>
<p>Deserialization error handler type.
Possible values are - <code>logAndContinue</code>, <code>logAndFail</code> or <code>sendToDlq</code></p>
<div class="paragraph">
<p>Default: <code>logAndFail</code></p>
</div>
</dd>
<dt class="hdlist1">applicationId</dt>
<dd>
<p>Application ID for all the stream configurations in the current application context.
You can override the application id for an individual <code>StreamListener</code> method using the <code>group</code> property on the binding.
You have to ensure that you are using the same group name for all input bindings in the case of multiple inputs on the same methods.</p>
<div class="paragraph">
<p>Default: <code>default</code></p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following properties are <em>only</em> available for Kafka Streams producers and must be prefixed with <code>spring.cloud.stream.kafka.streams.bindings.&lt;binding name&gt;.producer.</code>
literal.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">keySerde</dt>
<dd>
<p>key serde to use</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">valueSerde</dt>
<dd>
<p>value serde to use</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">useNativeEncoding</dt>
<dd>
<p>flag to enable native encoding</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following properties are <em>only</em> available for Kafka Streams consumers and must be prefixed with <code>spring.cloud.stream.kafka.streams.bindings.&lt;binding name&gt;.consumer.</code>
literal.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">keySerde</dt>
<dd>
<p>key serde to use</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">valueSerde</dt>
<dd>
<p>value serde to use</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">materializedAs</dt>
<dd>
<p>state store to materialize when using incoming KTable types</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">useNativeDecoding</dt>
<dd>
<p>flag to enable native decoding</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">dlqName</dt>
<dd>
<p>DLQ topic name.</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_timewindow_properties">16.3.2. TimeWindow properties:</h4>
<div class="paragraph">
<p>Windowing is an important concept in stream processing applications. Following properties are available to configure
time-window computations.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.streams.timeWindow.length</dt>
<dd>
<p>When this property is given, you can autowire a <code>TimeWindows</code> bean into the application.
The value is expressed in milliseconds.</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.streams.timeWindow.advanceBy</dt>
<dd>
<p>Value is given in milliseconds.</p>
<div class="paragraph">
<p>Default: <code>none</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_input_bindings">16.4. Multiple Input Bindings</h3>
<div class="paragraph">
<p>For use cases that requires multiple incoming KStream objects or a combination of KStream and KTable objects, the Kafka
Streams binder provides multiple bindings support.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see it in action.</p>
</div>
<div class="sect3">
<h4 id="_multiple_input_bindings_as_a_sink">16.4.1. Multiple Input Bindings as a Sink</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@EnableBinding(KStreamKTableBinding.class)
.....
.....
@StreamListener
public void process(@Input("inputStream") KStream&lt;String, PlayEvent&gt; playEvents,
                    @Input("inputTable") KTable&lt;Long, Song&gt; songTable) {
                    ....
                    ....
}

interface KStreamKTableBinding {

    @Input("inputStream")
    KStream&lt;?, ?&gt; inputStream();

    @Input("inputTable")
    KTable&lt;?, ?&gt; inputTable();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the application is written as a sink, i.e. there are no output bindings and the application has to
decide concerning downstream processing. When you write applications in this style, you might want to send the information
downstream or store them in a state store (See below for Queryable State Stores).</p>
</div>
<div class="paragraph">
<p>In the case of incoming KTable, if you want to materialize the computations to a state store, you have to express it
through the following property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.inputTable.consumer.materializedAs: all-songs</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_input_bindings_as_a_processor">16.4.2. Multiple Input Bindings as a Processor</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@EnableBinding(KStreamKTableBinding.class)
....
....

@StreamListener
@SendTo("output")
public KStream&lt;String, Long&gt; process(@Input("input") KStream&lt;String, Long&gt; userClicksStream,
                                     @Input("inputTable") KTable&lt;String, String&gt; userRegionsTable) {
....
....
}

interface KStreamKTableBinding extends KafkaStreamsProcessor {

    @Input("inputX")
    KTable&lt;?, ?&gt; inputTable();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_output_bindings_aka_branching">16.5. Multiple Output Bindings (aka Branching)</h3>
<div class="paragraph">
<p>Kafka Streams allow outbound data to be split into multiple topics based on some predicates. The Kafka Streams binder provides
support for this feature without compromising the programming model exposed through <code>StreamListener</code> in the end user application.</p>
</div>
<div class="paragraph">
<p>You can write the application in the usual way as demonstrated above in the word count example. However, when using the
branching feature, you are required to do a few things. First, you need to make sure that your return type is <code>KStream[]</code>
instead of a regular <code>KStream</code>. Second, you need to use the <code>SendTo</code> annotation containing the output bindings in the order
(see example below). For each of these output bindings, you need to configure destination, content-type etc., complying with
the standard Spring Cloud Stream expectations.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@EnableBinding(KStreamProcessorWithBranches.class)
@EnableAutoConfiguration
public static class WordCountProcessorApplication {

    @Autowired
    private TimeWindows timeWindows;

    @StreamListener("input")
    @SendTo({"output1","output2","output3})
    public KStream&lt;?, WordCount&gt;[] process(KStream&lt;Object, String&gt; input) {

			Predicate&lt;Object, WordCount&gt; isEnglish = (k, v) -&gt; v.word.equals("english");
			Predicate&lt;Object, WordCount&gt; isFrench =  (k, v) -&gt; v.word.equals("french");
			Predicate&lt;Object, WordCount&gt; isSpanish = (k, v) -&gt; v.word.equals("spanish");

			return input
					.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
					.groupBy((key, value) -&gt; value)
					.windowedBy(timeWindows)
					.count(Materialized.as("WordCounts-1"))
					.toStream()
					.map((key, value) -&gt; new KeyValue&lt;&gt;(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))))
					.branch(isEnglish, isFrench, isSpanish);
    }

    interface KStreamProcessorWithBranches {

    		@Input("input")
    		KStream&lt;?, ?&gt; input();

    		@Output("output1")
    		KStream&lt;?, ?&gt; output1();

    		@Output("output2")
    		KStream&lt;?, ?&gt; output2();

    		@Output("output3")
    		KStream&lt;?, ?&gt; output3();
    	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/json
spring.cloud.stream.bindings.output3.contentType: application/json
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms: 1000
spring.cloud.stream.kafka.streams.binder.configuration:
  default.key.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
  default.value.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.bindings.output1:
  destination: foo
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output2:
  destination: bar
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output3:
  destination: fox
  producer:
    headerMode: raw
spring.cloud.stream.bindings.input:
  destination: words
  consumer:
    headerMode: raw</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_message_conversion">16.6. Message Conversion</h3>
<div class="paragraph">
<p>Similar to message-channel based binder applications, the Kafka Streams binder adapts to the out-of-the-box content-type
conversions without any compromise.</p>
</div>
<div class="paragraph">
<p>It is typical for Kafka Streams operations to know the type of SerDes used to transform the key and value correctly.
Therefore, it may be more natural to rely on the SerDe facilities provided by the Apache Kafka Streams library itself at
the inbound and outbound conversions rather than using the content-type conversions offered by the framework.
On the other hand, you might be already familiar with the content-type conversion patterns provided by the framework, and
that, you&#8217;d like to continue using for inbound and outbound conversions.</p>
</div>
<div class="paragraph">
<p>Both the options are supported in the Kafka Streams binder implementation.</p>
</div>
<div class="sect4">
<h5 id="_outbound_serialization">Outbound serialization</h5>
<div class="paragraph">
<p>If native encoding is disabled (which is the default), then the framework will convert the message using the contentType
set by the user (otherwise, the default <code>application/json</code> will be applied). It will ignore any SerDe set on the outbound
in this case for outbound serialization.</p>
</div>
<div class="paragraph">
<p>Here is the property to set the contentType on the outbound.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.output.contentType: application/json</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the property to enable native encoding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.output.nativeEncoding: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native encoding is enabled on the output binding (user has to enable it as above explicitly), then the framework will
skip any form of automatic message conversion on the outbound. In that case, it will switch to the Serde set by the user.
The <code>valueSerde</code> property set on the actual output binding will be used. Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.output.producer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this property is not set, then it will use the "default" SerDe: <code>spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code>.</p>
</div>
<div class="paragraph">
<p>It is worth to mention that Kafka Streams binder does not serialize the keys on outbound - it simply relies on Kafka itself.
Therefore, you either have to specify the <code>keySerde</code> property on the binding or it will default to the application-wide common
<code>keySerde</code>.</p>
</div>
<div class="paragraph">
<p>Binding level key serde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.output.producer.keySerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>Common Key serde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</code></pre>
</div>
</div>
<div class="paragraph">
<p>If branching is used, then you need to use multiple output bindings. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface KStreamProcessorWithBranches {

    		@Input("input")
    		KStream&lt;?, ?&gt; input();

    		@Output("output1")
    		KStream&lt;?, ?&gt; output1();

    		@Output("output2")
    		KStream&lt;?, ?&gt; output2();

    		@Output("output3")
    		KStream&lt;?, ?&gt; output3();
    	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nativeEncoding</code> is set, then you can set different SerDe&#8217;s on individual output bindings as below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.output1.producer.valueSerde=IntegerSerde
spring.cloud.stream.kafka.streams.bindings.output2.producer.valueSerde=StringSerde
spring.cloud.stream.kafka.streams.bindings.output3.producer.valueSerde=JsonSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then if you have <code>SendTo</code> like this, @SendTo({"output1", "output2", "output3"}), the <code>KStream[]</code> from the branches are
applied with proper SerDe objects as defined above. If you are not enabling <code>nativeEncoding</code>, you can then set different
contentType values on the output bindings as below. In that case, the framework will use the appropriate message converter
to convert the messages before sending to Kafka.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/java-serialzied-object
spring.cloud.stream.bindings.output3.contentType: application/octet-stream</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_inbound_deserialization">Inbound Deserialization</h5>
<div class="paragraph">
<p>Similar rules apply to data deserialization on the inbound.</p>
</div>
<div class="paragraph">
<p>If native decoding is disabled (which is the default), then the framework will convert the message using the contentType
set by the user (otherwise, the default <code>application/json</code> will be applied). It will ignore any SerDe set on the inbound
in this case for inbound deserialization.</p>
</div>
<div class="paragraph">
<p>Here is the property to set the contentType on the inbound.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.input.contentType: application/json</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the property to enable native decoding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.bindings.input.nativeDecoding: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native decoding is enabled on the input binding (user has to enable it as above explicitly), then the framework will
skip doing any message conversion on the inbound. In that case, it will switch to the SerDe set by the user. The <code>valueSerde</code>
property set on the actual output binding will be used. Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this property is not set, it will use the default SerDe: <code>spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code>.</p>
</div>
<div class="paragraph">
<p>It is worth to mention that Kafka Streams binder does not deserialize the keys on inbound - it simply relies on Kafka itself.
Therefore, you either have to specify the <code>keySerde</code> property on the binding or it will default to the application-wide common
<code>keySerde</code>.</p>
</div>
<div class="paragraph">
<p>Binding level key serde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.keySerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>Common Key serde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in the case of KStream branching on the outbound, the benefit of setting value SerDe per binding is that if you have
multiple input bindings (multiple KStreams object) and they all require separate value SerDe&#8217;s, then you can configure
them individually. If you use the common configuration approach, then this feature won&#8217;t be applicable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling">16.7. Error Handling</h3>
<div class="paragraph">
<p>Apache Kafka Streams provide the capability for natively handling exceptions from deserialization errors.
For details on this support, please see <a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-161%3A+streams+deserialization+exception+handlers">this</a>
Out of the box, Apache Kafka Streams provide two kinds of deserialization exception handlers - <code>logAndContinue</code> and <code>logAndFail</code>.
As the name indicates, the former will log the error and continue processing the next records and the latter will log the
error and fail. <code>LogAndFail</code> is the default deserialization exception handler.</p>
</div>
<div class="sect3">
<h4 id="_handling_deserialization_exceptions">16.7.1. Handling Deserialization Exceptions</h4>
<div class="paragraph">
<p>Kafka Streams binder supports a selection of exception handlers through the following properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.binder.serdeError: logAndContinue</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the above two deserialization exception handlers, the binder also provides a third one for sending the erroneous
records (poison pills) to a DLQ topic. Here is how you enable this DLQ exception handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.binder.serdeError: sendToDlq</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the above property is set, all the deserialization error records are automatically sent to the DLQ topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.dlqName: foo-dlq</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this is set, then the error records are sent to the topic <code>foo-dlq</code>. If this is not set, then it will create a DLQ
topic with the name <code>error.&lt;input-topic-name&gt;.&lt;group-name&gt;</code>.</p>
</div>
<div class="paragraph">
<p>A couple of things to keep in mind when using the exception handling feature in Kafka Streams binder.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The property <code>spring.cloud.stream.kafka.streams.binder.serdeError</code> is applicable for the entire application. This implies
that if there are multiple <code>StreamListener</code> methods in the same application, this property is applied to all of them.</p>
</li>
<li>
<p>The exception handling for deserialization works consistently with native deserialization and framework provided message
conversion.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_handling_non_deserialization_exceptions">16.7.2. Handling Non-Deserialization Exceptions</h4>
<div class="paragraph">
<p>For general error handling in Kafka Streams binder, it is up to the end user applications to handle application level errors.
As a side effect of providing a DLQ for deserialization exception handlers, Kafka Streams binder provides a way to get
access to the DLQ sending bean directly from your application.
Once you get access to that bean, you can programmatically send any exception records from your application to the DLQ.</p>
</div>
<div class="paragraph">
<p>It continues to remain hard to robust error handling using the high-level DSL; Kafka Streams doesn&#8217;t natively support error
handling yet.</p>
</div>
<div class="paragraph">
<p>However, when you use the low-level Processor API in your application, there are options to control this behavior. See
below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Autowired
private SendToDlqAndContinue dlqHandler;

@StreamListener("input")
@SendTo("output")
public KStream&lt;?, WordCount&gt; process(KStream&lt;Object, String&gt; input) {

    input.process(() -&gt; new Processor() {
    			ProcessorContext context;

    			@Override
    			public void init(ProcessorContext context) {
    				this.context = context;
    			}

    			@Override
    			public void process(Object o, Object o2) {

    			    try {
    			        .....
    			        .....
    			    }
    			    catch(Exception e) {
    			        //explicitly provide the kafka topic corresponding to the input binding as the first argument.
                        //DLQ handler will correctly map to the dlq topic from the actual incoming destination.
                        dlqHandler.sendToDlq("topic-name", (byte[]) o1, (byte[]) o2, context.partition());
    			    }
    			}

    			.....
    			.....
    });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interactive_queries">16.8. Interactive Queries</h3>
<div class="paragraph">
<p>As part of the public Kafka Streams binder API, we expose a class called <code>QueryableStoreRegistry</code>. You can access this
as a Spring bean in your application. An easy way to get access to this bean from your application is to "autowire" the bean
in your application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Autowired
private QueryableStoreRegistry queryableStoreRegistry;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you gain access to this bean, then you can query for the particular state-store that you are interested. See below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ReadOnlyKeyValueStore&lt;Object, Object&gt; keyValueStore =
						queryableStoreRegistry.getQueryableStoreType("my-store", QueryableStoreTypes.keyValueStore());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_accessing_the_underlying_kafkastreams_object">16.9. Accessing the underlying KafkaStreams object</h3>
<div class="paragraph">
<p><code>StreamBuilderFactoryBean</code> from spring-kafka that is responsible for constructing the <code>KafkaStreams</code> object can be accessed programmatically.
Each <code>StreamBuilderFactoryBean</code> is registered as <code>stream-builder</code> and appended with the <code>StreamListener</code> method name.
If your <code>StreamListener</code> method is named as <code>process</code> for example, the stream builder bean is named as <code>stream-builder-process</code>.
Since this is a factory bean, it should be accessed by prepending an ampersand (<code>&amp;</code>) when accessing it programmatically.
Following is an example and it assumes the <code>StreamListener</code> method is named as <code>process</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean("&amp;stream-builder-process", StreamsBuilderFactoryBean.class);
			KafkaStreams kafkaStreams = streamsBuilderFactoryBean.getKafkaStreams();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rabbitmq_binder">17. RabbitMQ Binder</h2>
<div class="sectionbody">

<div class="sect3">
<h4 id="_usage_3">17.1. Usage</h4>
<div class="paragraph">
<p>To use the RabbitMQ binder, you can add it to your Spring Cloud Stream application, by using the following Maven coordinates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use the Spring Cloud Stream RabbitMQ Starter, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rabbitmq_binder_overview">17.2. RabbitMQ Binder Overview</h4>
<div class="paragraph">
<p>The following simplified diagram shows how the RabbitMQ binder operates:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/rabbit-binder.png" alt="rabbit binder" width="300">
</div>
<div class="title">Figure 11. RabbitMQ Binder</div>
</div>
<div class="paragraph">
<p>By default, the RabbitMQ Binder implementation maps each destination to a <code>TopicExchange</code>.
For each consumer group, a <code>Queue</code> is bound to that <code>TopicExchange</code>.
Each consumer instance has a corresponding RabbitMQ <code>Consumer</code> instance for its group&#8217;s <code>Queue</code>.
For partitioned producers and consumers, the queues are suffixed with the partition index and use the partition index as the routing key.
For anonymous consumers (those with no <code>group</code> property), an auto-delete queue (with a randomized unique name) is used.</p>
</div>
<div class="paragraph">
<p>By using the optional <code>autoBindDlq</code> option, you can configure the binder to create and configure dead-letter queues (DLQs) (and a dead-letter exchange <code>DLX</code>, as well as routing infrastructure).
By default, the dead letter queue has the name of the destination, appended with <code>.dlq</code>.
If retry is enabled (<code>maxAttempts &gt; 1</code>), failed messages are delivered to the DLQ after retries are exhausted.
If retry is disabled (<code>maxAttempts = 1</code>), you should set <code>requeueRejected</code> to <code>false</code> (the default) so that failed messages are routed to the DLQ, instead of being re-queued.
In addition, <code>republishToDlq</code> causes the binder to publish a failed message to the DLQ (instead of rejecting it).
This feature lets additional information (such as the stack trace in the <code>x-exception-stacktrace</code> header) be added to the message in headers.
This option does not need retry enabled.
You can republish a failed message after just one attempt.
Starting with version 1.2, you can configure the delivery mode of republished messages.
See the <a href="#spring-cloud-stream-rabbit-republish-delivery-mode"><code>republishDeliveryMode</code> property</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Setting <code>requeueRejected</code> to <code>true</code> (with <code>republishToDlq=false</code> ) causes the message to be re-queued and redelivered continually, which is likely not what you want unless the reason for the failure is transient.
In general, you should enable retry within the binder by setting <code>maxAttempts</code> to greater than one or by setting <code>republishToDlq</code> to <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#rabbit-binder-properties">RabbitMQ Binder Properties</a> for more information about these properties.</p>
</div>
<div class="paragraph">
<p>The framework does not provide any standard mechanism to consume dead-letter messages (or to re-route them back to the primary queue).
Some options are described in <a href="#rabbit-dlq-processing">Dead-Letter Queue Processing</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When multiple RabbitMQ binders are used in a Spring Cloud Stream application, it is important to disable 'RabbitAutoConfiguration' to avoid the same configuration from <code>RabbitAutoConfiguration</code> being applied to the two binders.
You can exclude the class by using the <code>@SpringBootApplication</code> annotation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 2.0, the <code>RabbitMessageChannelBinder</code> sets the <code>RabbitTemplate.userPublisherConnection</code> property to <code>true</code> so that the non-transactional producers avoid deadlocks on consumers, which can happen if cached connections are blocked because of a <a href="https://www.rabbitmq.com/memory.html">memory alarm</a> on the broker.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuration_options_4">17.3. Configuration Options</h4>
<div class="paragraph">
<p>This section contains settings specific to the RabbitMQ Binder and bound channels.</p>
</div>
<div class="paragraph">
<p>For general binding configuration options and properties, see the <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-core-docs/src/main/asciidoc/spring-cloud-stream-overview.adoc#configuration-options">Spring Cloud Stream core documentation</a>.</p>
</div>
<div class="sect4">
<h5 id="rabbit-binder-properties">RabbitMQ Binder Properties</h5>
<div class="paragraph">
<p>By default, the RabbitMQ binder uses Spring Boot&#8217;s <code>ConnectionFactory</code>.
Conseuqently, it supports all Spring Boot configuration options for RabbitMQ.
(For reference, see the <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties">Spring Boot documentation</a>).
RabbitMQ configuration options use the <code>spring.rabbitmq</code> prefix.</p>
</div>
<div class="paragraph">
<p>In addition to Spring Boot options, the RabbitMQ binder supports the following properties:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.adminAddresses</dt>
<dd>
<p>A comma-separated list of RabbitMQ management plugin URLs.
Only used when <code>nodes</code> contains more than one entry.
Each entry in this list must have a corresponding entry in <code>spring.rabbitmq.addresses</code>.
Only needed if you use a RabbitMQ cluster and wish to consume from the node that hosts the queue.
See <a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity">Queue Affinity and the LocalizedQueueConnectionFactory</a> for more information.</p>
<div class="paragraph">
<p>Default: empty.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.nodes</dt>
<dd>
<p>A comma-separated list of RabbitMQ node names.
When more than one entry, used to locate the server address where a queue is located.
Each entry in this list must have a corresponding entry in <code>spring.rabbitmq.addresses</code>.
Only needed if you use a RabbitMQ cluster and wish to consume from the node that hosts the queue.
See <a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity">Queue Affinity and the LocalizedQueueConnectionFactory</a> for more information.</p>
<div class="paragraph">
<p>Default: empty.</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.compressionLevel</dt>
<dd>
<p>The compression level for compressed bindings.
See <code>java.util.zip.Deflater</code>.</p>
<div class="paragraph">
<p>Default: <code>1</code> (BEST_LEVEL).</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.binder.connection-name-prefix</dt>
<dd>
<p>A connection name prefix used to name the connection(s) created by this binder.
The name is this prefix followed by <code>#n</code>, where <code>n</code> increments each time a new connection is opened.</p>
<div class="paragraph">
<p>Default: none (Spring AMQP default).</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_rabbitmq_consumer_properties">RabbitMQ Consumer Properties</h5>
<div class="paragraph">
<p>The following properties are available for Rabbit consumers only and must be prefixed with <code>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">acknowledgeMode</dt>
<dd>
<p>The acknowledge mode.</p>
<div class="paragraph">
<p>Default: <code>AUTO</code>.</p>
</div>
</dd>
<dt class="hdlist1">autoBindDlq</dt>
<dd>
<p>Whether to automatically declare the DLQ and bind it to the binder DLX.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">bindingRoutingKey</dt>
<dd>
<p>The routing key with which to bind the queue to the exchange (if <code>bindQueue</code> is <code>true</code>).
For partitioned destinations, <code>-&lt;instanceIndex&gt;</code> is appended.</p>
<div class="paragraph">
<p>Default: <code>#</code>.</p>
</div>
</dd>
<dt class="hdlist1">bindQueue</dt>
<dd>
<p>Whether to bind the queue to the destination exchange.
Set it to <code>false</code> if you have set up your own infrastructure and have previously created and bound the queue.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">deadLetterQueueName</dt>
<dd>
<p>The name of the DLQ</p>
<div class="paragraph">
<p>Default: <code>prefix+destination.dlq</code></p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchange</dt>
<dd>
<p>A DLX to assign to the queue.
Relevant only if <code>autoBindDlq</code> is <code>true</code>.</p>
<div class="paragraph">
<p>Default: 'prefix+DLX'</p>
</div>
</dd>
<dt class="hdlist1">deadLetterRoutingKey</dt>
<dd>
<p>A dead letter routing key to assign to the queue.
Relevant only if <code>autoBindDlq</code> is <code>true</code>.</p>
<div class="paragraph">
<p>Default: <code>destination</code></p>
</div>
</dd>
<dt class="hdlist1">declareExchange</dt>
<dd>
<p>Whether to declare the exchange for the destination.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">delayedExchange</dt>
<dd>
<p>Whether to declare the exchange as a <code>Delayed Message Exchange</code>.
Requires the delayed message exchange plugin on the broker.
The <code>x-delayed-type</code> argument is set to the <code>exchangeType</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterExchange</dt>
<dd>
<p>If a DLQ is declared, a DLX to assign to that queue.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterRoutingKey</dt>
<dd>
<p>If a DLQ is declared, a dead letter routing key to assign to that queue.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqExpires</dt>
<dd>
<p>How long before an unused dead letter queue is deleted (in milliseconds).</p>
<div class="paragraph">
<p>Default: <code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">dlqLazy</dt>
<dd>
<p>Declare the dead letter queue with the <code>x-queue-mode=lazy</code> argument.
See <a href="https://www.rabbitmq.com/lazy-queues.html">&#8220;Lazy Queues&#8221;</a>.
Consider using a policy instead of this setting, because using a policy allows changing the setting without deleting the queue.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLength</dt>
<dd>
<p>Maximum number of messages in the dead letter queue.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLengthBytes</dt>
<dd>
<p>Maximum number of total bytes in the dead letter queue from all messages.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxPriority</dt>
<dd>
<p>Maximum priority of messages in the dead letter queue (0-255).</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqTtl</dt>
<dd>
<p>Default time to live to apply to the dead letter queue when declared (in milliseconds).</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">durableSubscription</dt>
<dd>
<p>Whether the subscription should be durable.
Only effective if <code>group</code> is also set.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">exchangeAutoDelete</dt>
<dd>
<p>If <code>declareExchange</code> is true, whether the exchange should be auto-deleted (that is, removed after the last queue is removed).</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">exchangeDurable</dt>
<dd>
<p>If <code>declareExchange</code> is true, whether the exchange should be durable (that is, it survives broker restart).</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">exchangeType</dt>
<dd>
<p>The exchange type: <code>direct</code>, <code>fanout</code> or <code>topic</code> for non-partitioned destinations and <code>direct</code> or <code>topic</code> for partitioned destinations.</p>
<div class="paragraph">
<p>Default: <code>topic</code>.</p>
</div>
</dd>
<dt class="hdlist1">exclusive</dt>
<dd>
<p>Whether to create an exclusive consumer.
Concurrency should be 1 when this is <code>true</code>.
Often used when strict ordering is required but enabling a hot standby instance to take over after a failure.
See <code>recoveryInterval</code>, which controls how often a standby instance attempts to consume.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">expires</dt>
<dd>
<p>How long before an unused queue is deleted (in milliseconds).</p>
<div class="paragraph">
<p>Default: <code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">failedDeclarationRetryInterval</dt>
<dd>
<p>The interval (in milliseconds) between attempts to consume from a queue if it is missing.</p>
<div class="paragraph">
<p>Default: 5000</p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>Patterns for headers to be mapped from inbound messages.</p>
<div class="paragraph">
<p>Default: <code>['*']</code> (all headers).</p>
</div>
</dd>
<dt class="hdlist1">lazy</dt>
<dd>
<p>Declare the queue with the <code>x-queue-mode=lazy</code> argument.
See <a href="https://www.rabbitmq.com/lazy-queues.html">&#8220;Lazy Queues&#8221;</a>.
Consider using a policy instead of this setting, because using a policy allows changing the setting without deleting the queue.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">maxConcurrency</dt>
<dd>
<p>The maximum number of consumers.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">maxLength</dt>
<dd>
<p>The maximum number of messages in the queue.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxLengthBytes</dt>
<dd>
<p>The maximum number of total bytes in the queue from all messages.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxPriority</dt>
<dd>
<p>The maximum priority of messages in the queue (0-255).</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">missingQueuesFatal</dt>
<dd>
<p>When the queue cannot be found, whether to treat the condition as fatal and stop the listener container.
Defaults to <code>false</code> so that the container keeps trying to consume from the queue&#8201;&#8212;&#8201;for example, when using a cluster and the node hosting a non-HA queue is down.</p>
<div class="paragraph">
<p>Default: <code>false</code></p>
</div>
</dd>
<dt class="hdlist1">prefetch</dt>
<dd>
<p>Prefetch count.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
<dt class="hdlist1">prefix</dt>
<dd>
<p>A prefix to be added to the name of the <code>destination</code> and queues.</p>
<div class="paragraph">
<p>Default: "".</p>
</div>
</dd>
<dt class="hdlist1">queueDeclarationRetries</dt>
<dd>
<p>The number of times to retry consuming from a queue if it is missing.
Relevant only when <code>missingQueuesFatal</code> is <code>true</code>.
Otherwise, the container keeps retrying indefinitely.</p>
<div class="paragraph">
<p>Default: <code>3</code></p>
</div>
</dd>
<dt class="hdlist1">queueNameGroupOnly</dt>
<dd>
<p>When true, consume from a queue with a name equal to the <code>group</code>.
Otherwise the queue name is <code>destination.group</code>.
This is useful, for example, when using Spring Cloud Stream to consume from an existing RabbitMQ queue.</p>
<div class="paragraph">
<p>Default: false.</p>
</div>
</dd>
<dt class="hdlist1">recoveryInterval</dt>
<dd>
<p>The interval between connection recovery attempts, in milliseconds.</p>
<div class="paragraph">
<p>Default: <code>5000</code>.</p>
</div>
</dd>
<dt class="hdlist1">requeueRejected</dt>
<dd>
<p>Whether delivery failures should be re-queued when retry is disabled or <code>republishToDlq</code> is <code>false</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
</dl>
</div>
<div id="spring-cloud-stream-rabbit-republish-delivery-mode" class="dlist">
<dl>
<dt class="hdlist1">republishDeliveryMode</dt>
<dd>
<p>When <code>republishToDlq</code> is <code>true</code>, specifies the delivery mode of the republished message.</p>
<div class="paragraph">
<p>Default: <code>DeliveryMode.PERSISTENT</code></p>
</div>
</dd>
<dt class="hdlist1">republishToDlq</dt>
<dd>
<p>By default, messages that fail after retries are exhausted are rejected.
If a dead-letter queue (DLQ) is configured, RabbitMQ routes the failed message (unchanged) to the DLQ.
If set to <code>true</code>, the binder republishs failed messages to the DLQ with additional headers, including the exception message and stack trace from the cause of the final failure.</p>
<div class="paragraph">
<p>Default: false</p>
</div>
</dd>
<dt class="hdlist1">transacted</dt>
<dd>
<p>Whether to use transacted channels.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">ttl</dt>
<dd>
<p>Default time to live to apply to the queue when declared (in milliseconds).</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">txSize</dt>
<dd>
<p>The number of deliveries between acks.</p>
<div class="paragraph">
<p>Default: <code>1</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_rabbit_producer_properties">Rabbit Producer Properties</h5>
<div class="paragraph">
<p>The following properties are available for Rabbit producers only and
must be prefixed with <code>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.producer.</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">autoBindDlq</dt>
<dd>
<p>Whether to automatically declare the DLQ and bind it to the binder DLX.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">batchingEnabled</dt>
<dd>
<p>Whether to enable message batching by producers.
Messages are batched into one message according to the following properties (described in the next three entries in this list): 'batchSize', <code>batchBufferLimit</code>, and <code>batchTimeout</code>.
See <a href="https://docs.spring.io/spring-amqp//reference/html/_reference.html#template-batching">Batching</a> for more information.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">batchSize</dt>
<dd>
<p>The number of messages to buffer when batching is enabled.</p>
<div class="paragraph">
<p>Default: <code>100</code>.</p>
</div>
</dd>
<dt class="hdlist1">batchBufferLimit</dt>
<dd>
<p>The maximum buffer size when batching is enabled.</p>
<div class="paragraph">
<p>Default: <code>10000</code>.</p>
</div>
</dd>
<dt class="hdlist1">batchTimeout</dt>
<dd>
<p>The batch timeout when batching is enabled.</p>
<div class="paragraph">
<p>Default: <code>5000</code>.</p>
</div>
</dd>
<dt class="hdlist1">bindingRoutingKey</dt>
<dd>
<p>The routing key with which to bind the queue to the exchange (if <code>bindQueue</code> is <code>true</code>).
Only applies to non-partitioned destinations.
Only applies if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>#</code>.</p>
</div>
</dd>
<dt class="hdlist1">bindQueue</dt>
<dd>
<p>Whether to bind the queue to the destination exchange.
Set it to <code>false</code> if you have set up your own infrastructure and have previously created and bound the queue.
Only applies if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">compress</dt>
<dd>
<p>Whether data should be compressed when sent.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">deadLetterQueueName</dt>
<dd>
<p>The name of the DLQ
Only applies if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>prefix+destination.dlq</code></p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchange</dt>
<dd>
<p>A DLX to assign to the queue.
Relevant only when <code>autoBindDlq</code> is <code>true</code>.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: 'prefix+DLX'</p>
</div>
</dd>
<dt class="hdlist1">deadLetterRoutingKey</dt>
<dd>
<p>A dead letter routing key to assign to the queue.
Relevant only when <code>autoBindDlq</code> is <code>true</code>.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>destination</code></p>
</div>
</dd>
<dt class="hdlist1">declareExchange</dt>
<dd>
<p>Whether to declare the exchange for the destination.</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">delayExpression</dt>
<dd>
<p>A SpEL expression to evaluate the delay to apply to the message (<code>x-delay</code> header).
It has no effect if the exchange is not a delayed message exchange.</p>
<div class="paragraph">
<p>Default: No <code>x-delay</code> header is set.</p>
</div>
</dd>
<dt class="hdlist1">delayedExchange</dt>
<dd>
<p>Whether to declare the exchange as a <code>Delayed Message Exchange</code>.
Requires the delayed message exchange plugin on the broker.
The <code>x-delayed-type</code> argument is set to the <code>exchangeType</code>.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">deliveryMode</dt>
<dd>
<p>The delivery mode.</p>
<div class="paragraph">
<p>Default: <code>PERSISTENT</code>.</p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterExchange</dt>
<dd>
<p>When a DLQ is declared, a DLX to assign to that queue.
Applies only if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterRoutingKey</dt>
<dd>
<p>When a DLQ is declared, a dead letter routing key to assign to that queue.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqExpires</dt>
<dd>
<p>How long (in milliseconds) before an unused dead letter queue is deleted.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">dlqLazy</dt>
<dd>
<p>Declare the dead letter queue with the <code>x-queue-mode=lazy</code> argument.
See <a href="https://www.rabbitmq.com/lazy-queues.html">&#8220;Lazy Queues&#8221;</a>.
Consider using a policy instead of this setting, because using a policy allows changing the setting without deleting the queue.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
</dd>
<dt class="hdlist1">dlqMaxLength</dt>
<dd>
<p>Maximum number of messages in the dead letter queue.
Applies only if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLengthBytes</dt>
<dd>
<p>Maximum number of total bytes in the dead letter queue from all messages.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxPriority</dt>
<dd>
<p>Maximum priority of messages in the dead letter queue (0-255)
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqTtl</dt>
<dd>
<p>Default time (in milliseconds) to live to apply to the dead letter queue when declared.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">exchangeAutoDelete</dt>
<dd>
<p>If <code>declareExchange</code> is <code>true</code>, whether the exchange should be auto-delete (it is removed after the last queue is removed).</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">exchangeDurable</dt>
<dd>
<p>If <code>declareExchange</code> is <code>true</code>, whether the exchange should be durable (survives broker restart).</p>
<div class="paragraph">
<p>Default: <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1">exchangeType</dt>
<dd>
<p>The exchange type: <code>direct</code>, <code>fanout</code> or <code>topic</code> for non-partitioned destinations and <code>direct</code> or <code>topic</code> for partitioned destinations.</p>
<div class="paragraph">
<p>Default: <code>topic</code>.</p>
</div>
</dd>
<dt class="hdlist1">expires</dt>
<dd>
<p>How long (in milliseconds) before an unused queue is deleted.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>Patterns for headers to be mapped to outbound messages.</p>
<div class="paragraph">
<p>Default: <code>['*']</code> (all headers).</p>
</div>
</dd>
<dt class="hdlist1">lazy</dt>
<dd>
<p>Declare the queue with the <code>x-queue-mode=lazy</code> argument.
See <a href="https://www.rabbitmq.com/lazy-queues.html">&#8220;Lazy Queues&#8221;</a>.
Consider using a policy instead of this setting, because using a policy allows changing the setting without deleting the queue.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">maxLength</dt>
<dd>
<p>Maximum number of messages in the queue.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxLengthBytes</dt>
<dd>
<p>Maximum number of total bytes in the queue from all messages.
Only applies if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxPriority</dt>
<dd>
<p>Maximum priority of messages in the queue (0-255).
Only applies if <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>none</code></p>
</div>
</dd>
<dt class="hdlist1">prefix</dt>
<dd>
<p>A prefix to be added to the name of the <code>destination</code> exchange.</p>
<div class="paragraph">
<p>Default: "".</p>
</div>
</dd>
<dt class="hdlist1">queueNameGroupOnly</dt>
<dd>
<p>When <code>true</code>, consume from a queue with a name equal to the <code>group</code>.
Otherwise the queue name is <code>destination.group</code>.
This is useful, for example, when using Spring Cloud Stream to consume from an existing RabbitMQ queue.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: false.</p>
</div>
</dd>
<dt class="hdlist1">routingKeyExpression</dt>
<dd>
<p>A SpEL expression to determine the routing key to use when publishing messages.
For a fixed routing key, use a literal expression, such as <code>routingKeyExpression='my.routingKey'</code> in a properties file or <code>routingKeyExpression: '''my.routingKey'''</code> in a YAML file.</p>
<div class="paragraph">
<p>Default: <code>destination</code> or <code>destination-&lt;partition&gt;</code> for partitioned destinations.</p>
</div>
</dd>
<dt class="hdlist1">transacted</dt>
<dd>
<p>Whether to use transacted channels.</p>
<div class="paragraph">
<p>Default: <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">ttl</dt>
<dd>
<p>Default time (in milliseconds) to live to apply to the queue when declared.
Applies only when <code>requiredGroups</code> are provided and then only to those groups.</p>
<div class="paragraph">
<p>Default: <code>no limit</code></p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the case of RabbitMQ, content type headers can be set by external applications.
Spring Cloud Stream supports them as part of an extended internal protocol used for any type of transport&#8201;&#8212;&#8201;including transports, such as Kafka (prior to 0.11), that do not natively support headers.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retry_with_the_rabbitmq_binder">17.4. Retry With the RabbitMQ Binder</h4>
<div class="paragraph">
<p>When retry is enabled within the binder, the listener container thread is suspended for any back off periods that are configured.
This might be important when strict ordering is required with a single consumer. However, for other use cases, it prevents other messages from being processed on that thread.
An alternative to using binder retry is to set up dead lettering with time to live on the dead-letter queue (DLQ) as well as dead-letter configuration on the DLQ itself.
See &#8220;<a href="#rabbit-binder-properties">RabbitMQ Binder Properties</a>&#8221; for more information about the properties discussed here.
You can use the following example configuration to enable this feature:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set <code>autoBindDlq</code> to <code>true</code>.
The binder create a DLQ.
Optionally, you can specify a name in <code>deadLetterQueueName</code>.</p>
</li>
<li>
<p>Set <code>dlqTtl</code> to the back off time you want to wait between redeliveries.</p>
</li>
<li>
<p>Set the <code>dlqDeadLetterExchange</code> to the default exchange.
Expired messages from the DLQ are routed to the original queue, because the default <code>deadLetterRoutingKey</code> is the queue name (<code>destination.group</code>).
Setting to the default exchange is achieved by setting the property with no value, as shown in the next example.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To force a message to be dead-lettered, either throw an <code>AmqpRejectAndDontRequeueException</code> or set <code>requeueRejected</code> to <code>true</code> (the default) and throw any exception.</p>
</div>
<div class="paragraph">
<p>The loop continue without end, which is fine for transient problems, but you may want to give up after some number of attempts.
Fortunately, RabbitMQ provides the <code>x-death</code> header, which lets you determine how many cycles have occurred.</p>
</div>
<div class="paragraph">
<p>To acknowledge a message after giving up, throw an <code>ImmediateAcknowledgeAmqpException</code>.</p>
</div>
<div class="sect4">
<h5 id="_putting_it_all_together">Putting it All Together</h5>
<div class="paragraph">
<p>The following configuration creates an exchange <code>myDestination</code> with queue <code>myDestination.consumerGroup</code> bound to a topic exchange with a wildcard routing key <code>#</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>---
spring.cloud.stream.bindings.input.destination=myDestination
spring.cloud.stream.bindings.input.group=consumerGroup
#disable binder retries
spring.cloud.stream.bindings.input.consumer.max-attempts=1
#dlx/dlq setup
spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-ttl=5000
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-dead-letter-exchange=
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration creates a DLQ bound to a direct exchange (<code>DLX</code>) with a routing key of <code>myDestination.consumerGroup</code>.
When messages are rejected, they are routed to the DLQ.
After 5 seconds, the message expires and is routed to the original queue by using the queue name as the routing key, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="title">Spring Boot application</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class XDeathApplication {

    public static void main(String[] args) {
        SpringApplication.run(XDeathApplication.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(String in, @Header(name = "x-death", required = false) Map&lt;?,?&gt; death) {
        if (death != null &amp;&amp; death.get("count").equals(3L)) {
            // giving up - don't send to DLX
            throw new ImmediateAcknowledgeAmqpException("Failed after 4 attempts");
        }
        throw new AmqpRejectAndDontRequeueException("failed");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the count property in the <code>x-death</code> header is a <code>Long</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rabbit-error-channels">17.5. Error Channels</h4>
<div class="paragraph">
<p>Starting with version 1.3, the binder unconditionally sends exceptions to an error channel for each consumer destination and can also be configured to send async producer send failures to an error channel.
See &#8220;<a href="#binder-error-channels">[binder-error-channels]</a>&#8221; for more information.</p>
</div>
<div class="paragraph">
<p>RabbitMQ has two types of send failures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Returned messages,</p>
</li>
<li>
<p>Negatively acknowledged <a href="https://www.rabbitmq.com/confirms.html">Publisher Confirms</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The latter is rare.
According to the RabbitMQ documentation "[A nack] will only be delivered if an internal error occurs in the Erlang process responsible for a queue.".</p>
</div>
<div class="paragraph">
<p>As well as enabling producer error channels (as described in &#8220;<a href="#binder-error-channels">[binder-error-channels]</a>&#8221;), the RabbitMQ binder only sends messages to the channels if the connection factory is appropriately configured, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ccf.setPublisherConfirms(true);</code></p>
</li>
<li>
<p><code>ccf.setPublisherReturns(true);</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using Spring Boot configuration for the connection factory, set the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.rabbitmq.publisher-confirms</code></p>
</li>
<li>
<p><code>spring.rabbitmq.publisher-returns</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The payload of the <code>ErrorMessage</code> for a returned message is a <code>ReturnedAmqpMessageException</code> with the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code>: The spring-messaging <code>Message&lt;?&gt;</code> that failed to be sent.</p>
</li>
<li>
<p><code>amqpMessage</code>: The raw spring-amqp <code>Message</code>.</p>
</li>
<li>
<p><code>replyCode</code>: An integer value indicating the reason for the failure (for example, 312 - No route).</p>
</li>
<li>
<p><code>replyText</code>: A text value indicating the reason for the failure (for example, <code>NO_ROUTE</code>).</p>
</li>
<li>
<p><code>exchange</code>: The exchange to which the message was published.</p>
</li>
<li>
<p><code>routingKey</code>: The routing key used when the message was published.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For negatively acknowledged confirmations, the payload is a <code>NackedAmqpMessageException</code> with the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code>: The spring-messaging <code>Message&lt;?&gt;</code> that failed to be sent.</p>
</li>
<li>
<p><code>nackReason</code>: A reason (if available&#8201;&#8212;&#8201;you may need to examine the broker logs for more information).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is no automatic handling of these exceptions (such as sending to a <a href="#rabbit-dlq-processing">dead-letter queue</a>).
You can consume these exceptions with your own Spring Integration flow.</p>
</div>
</div>
<div class="sect3">
<h4 id="rabbit-dlq-processing">17.6. Dead-Letter Queue Processing</h4>
<div class="paragraph">
<p>Because you cannot anticipate how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.
If the reason for the dead-lettering is transient, you may wish to route the messages back to the original queue.
However, if the problem is a permanent issue, that could cause an infinite loop.
The following Spring Boot application shows an example of how to route those messages back to the original queue but moves them to a third &#8220;parking lot&#8221; queue after three attempts.
The second example uses the <a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/">RabbitMQ Delayed Message Exchange</a> to introduce a delay to the re-queued message.
In this example, the delay increases for each attempt.
These examples use a <code>@RabbitListener</code> to receive messages from the DLQ.
You could also use <code>RabbitTemplate.receive()</code> in a batch process.</p>
</div>
<div class="paragraph">
<p>The examples assume the original destination is <code>so8400in</code> and the consumer group is <code>so8400</code>.</p>
</div>
<div class="sect4">
<h5 id="_non_partitioned_destinations">Non-Partitioned Destinations</h5>
<div class="paragraph">
<p>The first two examples are for when the destination is <strong>not</strong> partitioned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Integer retriesHeader = (Integer) failedMessage.getMessageProperties().getHeaders().get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            failedMessage.getMessageProperties().getHeaders().put(X_RETRIES_HEADER, retriesHeader + 1);
            this.rabbitTemplate.send(ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    private static final String DELAY_EXCHANGE = "dlqReRouter";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            headers.put("x-delay", 5000 * retriesHeader);
            this.rabbitTemplate.send(DELAY_EXCHANGE, ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public DirectExchange delayExchange() {
        DirectExchange exchange = new DirectExchange(DELAY_EXCHANGE);
        exchange.setDelayed(true);
        return exchange;
    }

    @Bean
    public Binding bindOriginalToDelay() {
        return BindingBuilder.bind(new Queue(ORIGINAL_QUEUE)).to(delayExchange()).with(ORIGINAL_QUEUE);
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_partitioned_destinations">Partitioned Destinations</h5>
<div class="paragraph">
<p>With partitioned destinations, there is one DLQ for all partitions. We determine the original queue from the headers.</p>
</div>
<div class="sect5">
<h6 id="__code_republishtodlq_false_code"><code>republishToDlq=false</code></h6>
<div class="paragraph">
<p>When <code>republishToDlq</code> is <code>false</code>, RabbitMQ publishes the message to the DLX/DLQ with an <code>x-death</code> header containing information about the original destination, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_DEATH_HEADER = "x-death";

	private static final String X_RETRIES_HEADER = "x-retries";

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@SuppressWarnings("unchecked")
	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			List&lt;Map&lt;String, ?&gt;&gt; xDeath = (List&lt;Map&lt;String, ?&gt;&gt;) headers.get(X_DEATH_HEADER);
			String exchange = (String) xDeath.get(0).get("exchange");
			List&lt;String&gt; routingKeys = (List&lt;String&gt;) xDeath.get(0).get("routing-keys");
			this.rabbitTemplate.send(exchange, routingKeys.get(0), failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="__code_republishtodlq_true_code"><code>republishToDlq=true</code></h6>
<div class="paragraph">
<p>When <code>republishToDlq</code> is <code>true</code>, the republishing recoverer adds the original exchange and routing key to headers, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_RETRIES_HEADER = "x-retries";

	private static final String X_ORIGINAL_EXCHANGE_HEADER = RepublishMessageRecoverer.X_ORIGINAL_EXCHANGE;

	private static final String X_ORIGINAL_ROUTING_KEY_HEADER = RepublishMessageRecoverer.X_ORIGINAL_ROUTING_KEY;

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			String exchange = (String) headers.get(X_ORIGINAL_EXCHANGE_HEADER);
			String originalRoutingKey = (String) headers.get(X_ORIGINAL_ROUTING_KEY_HEADER);
			this.rabbitTemplate.send(exchange, originalRoutingKey, failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_partitioning_with_the_rabbitmq_binder">17.7. Partitioning with the RabbitMQ Binder</h4>
<div class="paragraph">
<p>RabbitMQ does not support partitioning natively.</p>
</div>
<div class="paragraph">
<p>Sometimes, it is advantageous to send data to specific partitions&#8201;&#8212;&#8201;for example, when you want to strictly order message processing, all messages for a particular customer should go to the same partition.</p>
</div>
<div class="paragraph">
<p>The <code>RabbitMessageChannelBinder</code> provides partitioning by binding a queue for each partition to the destination exchange.</p>
</div>
<div class="paragraph">
<p>The following Java and YAML examples show how to configure the producer:</p>
</div>
<div class="listingblock">
<div class="title">Producer</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Source.class)
public class RabbitPartitionProducerApplication {

    private static final Random RANDOM = new Random(System.currentTimeMillis());

    private static final String[] data = new String[] {
            "abc1", "def1", "qux1",
            "abc2", "def2", "qux2",
            "abc3", "def3", "qux3",
            "abc4", "def4", "qux4",
            };

    public static void main(String[] args) {
        new SpringApplicationBuilder(RabbitPartitionProducerApplication.class)
            .web(false)
            .run(args);
    }

    @InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))
    public Message&lt;?&gt; generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println("Sending: " + value);
        return MessageBuilder.withPayload(value)
                .setHeader("partitionKey", value)
                .build();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">    spring:
      cloud:
        stream:
          bindings:
            output:
              destination: partitioned.destination
              producer:
                partitioned: true
                partition-key-expression: headers['partitionKey']
                partition-count: 2
                required-groups:
                - myGroup</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The configuration in the prececing example uses the default partitioning (<code>key.hashCode() % partitionCount</code>).
This may or may not provide a suitably balanced algorithm, depending on the key values.
You can override this default by using the <code>partitionSelectorExpression</code> or <code>partitionSelectorClass</code> properties.</p>
</div>
<div class="paragraph">
<p>The <code>required-groups</code> property is required only if you need the consumer queues to be provisioned when the producer is deployed.
Otherwise, any messages sent to a partition are lost until the corresponding consumer is deployed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following configuration provisions a topic exchange:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/part-exchange.png" alt="part exchange">
</div>
</div>
<div class="paragraph">
<p>The following queues are bound to that exchange:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/part-queues.png" alt="part queues">
</div>
</div>
<div class="paragraph">
<p>The following bindings associate the queues to the exchange:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/part-bindings.png" alt="part bindings">
</div>
</div>
<div class="paragraph">
<p>The following Java and YAML examples continue the previous examples and show how to configure the consumer:</p>
</div>
<div class="listingblock">
<div class="title">Consumer</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class RabbitPartitionConsumerApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(RabbitPartitionConsumerApplication.class)
            .web(false)
            .run(args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(@Payload String in, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {
        System.out.println(in + " received from queue " + queue);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">    spring:
      cloud:
        stream:
          bindings:
            input:
              destination: partitioned.destination
              group: myGroup
              consumer:
                partitioned: true
                instance-index: 0</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>RabbitMessageChannelBinder</code> does not support dynamic scaling.
There must be at least one consumer per partition.
The consumer&#8217;s <code>instanceIndex</code> is used to indicate which partition is consumed.
Platforms such as Cloud Foundry can have only one instance with an <code>instanceIndex</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="_appendices" class="sect0">Appendices</h1>
<div class="sect1">
<h2 id="building">Appendix A: Building</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_basic_compile_and_test">A.1. Basic Compile and Test</h3>
<div class="paragraph">
<p>To build the source you will need to install JDK 1.7.</p>
</div>
<div class="paragraph">
<p>The build uses the Maven wrapper so you don&#8217;t have to install a specific
version of Maven.  To enable the tests for Redis, Rabbit, and Kafka bindings you
should have those servers running before building. See below for more
information on running the servers.</p>
</div>
<div class="paragraph">
<p>The main build command is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw clean install</pre>
</div>
</div>
<div class="paragraph">
<p>You can also add '-DskipTests' if you like, to avoid running the tests.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also install Maven (&gt;=3.3.3) yourself and run the <code>mvn</code> command
in place of <code>./mvnw</code> in the examples below. If you do that you also
might need to add <code>-P spring</code> if your local Maven settings do not
contain repository declarations for spring pre-release artifacts.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Be aware that you might need to increase the amount of memory
available to Maven by setting a <code>MAVEN_OPTS</code> environment variable with
a value like <code>-Xmx512m -XX:MaxPermSize=128m</code>. We try to cover this in
the <code>.mvn</code> configuration, so if you find you have to do it to make a
build succeed, please raise a ticket to get the settings added to
source control.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The projects that require middleware generally include a
<code>docker-compose.yml</code>, so consider using
<a href="http://compose.docker.io/">Docker Compose</a> to run the middeware servers
in Docker containers. See the README in the
<a href="https://github.com/spring-cloud-samples/scripts">scripts demo
repository</a> for specific instructions about the common cases of mongo,
rabbit and redis.</p>
</div>
</div>
<div class="sect2">
<h3 id="_documentation">A.2. Documentation</h3>
<div class="paragraph">
<p>There is a "full" profile that will generate documentation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_the_code">A.3. Working with the code</h3>
<div class="paragraph">
<p>If you don&#8217;t have an IDE preference we would recommend that you use
<a href="http://www.springsource.com/developer/sts">Spring Tools Suite</a> or
<a href="http://eclipse.org">Eclipse</a> when working with the code. We use the
<a href="http://eclipse.org/m2e/">m2eclipe</a> eclipse plugin for maven support. Other IDEs and tools
should also work without issue.</p>
</div>
<div class="sect3">
<h4 id="_importing_into_eclipse_with_m2eclipse">A.3.1. Importing into eclipse with m2eclipse</h4>
<div class="paragraph">
<p>We recommend the <a href="http://eclipse.org/m2e/">m2eclipe</a> eclipse plugin when working with
eclipse. If you don&#8217;t already have m2eclipse installed it is available from the "eclipse
marketplace".</p>
</div>
<div class="paragraph">
<p>Unfortunately m2e does not yet support Maven 3.3, so once the projects
are imported into Eclipse you will also need to tell m2eclipse to use
the <code>.settings.xml</code> file for the projects.  If you do not do this you
may see many different errors related to the POMs in the
projects.  Open your Eclipse preferences, expand the Maven
preferences, and select User Settings.  In the User Settings field
click Browse and navigate to the Spring Cloud project you imported
selecting the <code>.settings.xml</code> file in that project.  Click Apply and
then OK to save the preference changes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Alternatively you can copy the repository settings from <a href="https://github.com/spring-cloud/spring-cloud-build/blob/master/.settings.xml"><code>.settings.xml</code></a> into your own <code>~/.m2/settings.xml</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_importing_into_eclipse_without_m2eclipse">A.3.2. Importing into eclipse without m2eclipse</h4>
<div class="paragraph">
<p>If you prefer not to use m2eclipse you can generate eclipse project metadata using the
following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw eclipse:eclipse</pre>
</div>
</div>
<div class="paragraph">
<p>The generated eclipse projects can be imported by selecting <code>import existing projects</code>
from the <code>file</code> menu.
[[contributing]
== Contributing</p>
</div>
<div class="paragraph">
<p>Spring Cloud is released under the non-restrictive Apache 2.0 license,
and follows a very standard Github development process, using Github
tracker for issues and merging pull requests into master. If you want
to contribute even something trivial please do not hesitate, but
follow the guidelines below.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sign_the_contributor_license_agreement">A.4. Sign the Contributor License Agreement</h3>
<div class="paragraph">
<p>Before we accept a non-trivial patch or pull request we will need you to sign the
<a href="https://support.springsource.com/spring_committer_signup">contributor&#8217;s agreement</a>.
Signing the contributor&#8217;s agreement does not grant anyone commit rights to the main
repository, but it does mean that we can accept your contributions, and you will get an
author credit if we do.  Active contributors might be asked to join the core team, and
given the ability to merge pull requests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_code_conventions_and_housekeeping">A.5. Code Conventions and Housekeeping</h3>
<div class="paragraph">
<p>None of these is essential for a pull request, but they will all help.  They can also be
added after the original pull request but before a merge.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the Spring Framework code format conventions. If you use Eclipse
you can import formatter settings using the
<code>eclipse-code-formatter.xml</code> file from the
<a href="https://github.com/spring-cloud/build/tree/master/eclipse-coding-conventions.xml">Spring
Cloud Build</a> project. If using IntelliJ, you can use the
<a href="http://plugins.jetbrains.com/plugin/6546">Eclipse Code Formatter
Plugin</a> to import the same file.</p>
</li>
<li>
<p>Make sure all new <code>.java</code> files to have a simple Javadoc class comment with at least an
<code>@author</code> tag identifying you, and preferably at least a paragraph on what the class is
for.</p>
</li>
<li>
<p>Add the ASF license header comment to all new <code>.java</code> files (copy from existing files
in the project)</p>
</li>
<li>
<p>Add yourself as an <code>@author</code> to the .java files that you modify substantially (more
than cosmetic changes).</p>
</li>
<li>
<p>Add some Javadocs and, if you change the namespace, some XSD doc elements.</p>
</li>
<li>
<p>A few unit tests would help a lot as well&#8201;&#8212;&#8201;someone has to do it.</p>
</li>
<li>
<p>If no-one else is using your branch, please rebase it against the current master (or
other target branch in the main project).</p>
</li>
<li>
<p>When writing a commit message please follow <a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">these conventions</a>,
if you are fixing an existing issue please add <code>Fixes gh-XXXX</code> at the end of the commit
message (where XXXX is the issue number).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-04 00:58:46 UTC
</div>
</div>
<script type="text/javascript" src="tocbot-3.0.2/tocbot.js"></script>
<script type="text/javascript" >

    // Tocbot dynamic TOC, works with tocbot 3.0.2
    // Source: https://github.com/asciidoctor/asciidoctor/issues/699#issuecomment-321066006

    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({ contentSelector: '#content',
        headingSelector: 'h1, h2, h3, h4, h5',
        smoothScroll: false });
    var handleTocRefresh = function() {
        tocbot.refresh();
    }
    var handleTocOnResize = function() {
        var width = window.innerWidth
                    || document.documentElement.clientWidth
                    || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false });
        }
        else {
            tocbot.refresh({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    window.addEventListener('tocRefresh', handleTocRefresh);
    handleTocOnResize();

</script>
</body>
</html>