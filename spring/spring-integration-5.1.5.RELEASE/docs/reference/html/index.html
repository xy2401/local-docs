<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Mark Fisher, Marius Bogoevici, Iwein Fuld, Jonas Partner, Oleg Zhurakousky, Gary Russell, Dave Syer, Josh Long, David Turanski, Gunnar Hillert, Artem Bilan, Amol Nayak, Jay Bryant">
<title>Spring Integration</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body id="spring-integration-reference" class="book toc2 toc-left">
<div id="header">
<h1>Spring Integration</h1>
<div class="details">
<span id="author" class="author">Mark Fisher</span><br>
<span id="author2" class="author">Marius Bogoevici</span><br>
<span id="author3" class="author">Iwein Fuld</span><br>
<span id="author4" class="author">Jonas Partner</span><br>
<span id="author5" class="author">Oleg Zhurakousky</span><br>
<span id="author6" class="author">Gary Russell</span><br>
<span id="author7" class="author">Dave Syer</span><br>
<span id="author8" class="author">Josh Long</span><br>
<span id="author9" class="author">David Turanski</span><br>
<span id="author10" class="author">Gunnar Hillert</span><br>
<span id="author11" class="author">Artem Bilan</span><br>
<span id="author12" class="author">Amol Nayak</span><br>
<span id="author13" class="author">Jay Bryant</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#preface">Preface</a>
<ul class="sectlevel1">
<li><a href="#system-requirements">1. Requirements</a>
<ul class="sectlevel2">
<li><a href="#supported-java-versions">1.1. Compatible Java Versions</a></li>
<li><a href="#supported-spring-versions">1.2. Compatible Versions of the Spring Framework</a></li>
</ul>
</li>
<li><a href="#code-conventions">2. Code Conventions</a></li>
<li><a href="#guide-conventions">3. Conventions in This Guide</a></li>
</ul>
</li>
<li><a href="#whats-new-part">What&#8217;s New?</a>
<ul class="sectlevel1">
<li><a href="#whats-new">4. What&#8217;s New in Spring Integration 5.1?</a>
<ul class="sectlevel2">
<li><a href="#x5.1-new-components">4.1. New Components</a>
<ul class="sectlevel3">
<li><a href="#x5.1-AmqpDedicatedChannelAdvice">4.1.1. <code>AmqpDedicatedChannelAdvice</code></a></li>
<li><a href="#x5.1-Functions">4.1.2. Improved Function Support</a></li>
<li><a href="#x5.1-LongRunningTest">4.1.3. <code>@LongRunningTest</code></a></li>
</ul>
</li>
<li><a href="#x5.1-general">4.2. General Changes</a>
<ul class="sectlevel3">
<li><a href="#x5.1-java-dsl">4.2.1. Java DSL</a></li>
<li><a href="#x5.1-dispatcher-exceptions">4.2.2. Dispatcher Exceptions</a></li>
<li><a href="#x5.1-global-channel-interceptors">4.2.3. Global Channel Interceptors</a></li>
<li><a href="#x5.1-channel-interceptors">4.2.4. Channel Interceptors</a></li>
<li><a href="#x5.1-object-to-json-transformer">4.2.5. <code>ObjectToJsonTransformer</code></a></li>
<li><a href="#x5.1-integration-flows-generated-bean-names">4.2.6. Integration Flows: Generated Bean Names</a></li>
<li><a href="#x5.1-aggregator">4.2.7. Aggregator Changes</a></li>
<li><a href="#x5.1-publisher">4.2.8. @Publisher annotation changes</a></li>
</ul>
</li>
<li><a href="#x5.1-files">4.3. Files Changes</a></li>
<li><a href="#x5.1-amqp">4.4. AMQP Changes</a></li>
<li><a href="#x5.1-jdbc">4.5. JDBC Changes</a></li>
<li><a href="#x5.1-ftp-sftp">4.6. FTP and SFTP Changes</a></li>
<li><a href="#x51.-tcp">4.7. TCP Support</a></li>
<li><a href="#x5.1-twitter">4.8. Twitter Support</a></li>
<li><a href="#x51.-jms">4.9. JMS Support</a></li>
<li><a href="#x51.-http">4.10. HTTP/WebFlux Support</a></li>
<li><a href="#x51.-jmx">4.11. JMX Changes</a></li>
<li><a href="#x51.-micrometer">4.12. Micrometer Support Changes</a></li>
<li><a href="#x51.-integration-graph">4.13. Integration Graph Customization</a></li>
<li><a href="#x51.-global-properties">4.14. Integration Global Properties</a></li>
<li><a href="#x51.-poller-annotation">4.15. The <code>receiveTimeout</code> for <code>@Poller</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-integration-introduction">Overview of Spring Integration Framework</a>
<ul class="sectlevel1">
<li><a href="#overview">5. Spring Integration Overview</a>
<ul class="sectlevel2">
<li><a href="#overview-background">5.1. Background</a></li>
<li><a href="#overview-goalsandprinciples">5.2. Goals and Principles</a></li>
<li><a href="#overview-components">5.3. Main Components</a>
<ul class="sectlevel3">
<li><a href="#overview-components-message">5.3.1. Message</a></li>
<li><a href="#overview-components-channel">5.3.2. Message Channel</a></li>
<li><a href="#overview-components-endpoint">5.3.3. Message Endpoint</a></li>
</ul>
</li>
<li><a href="#overview-endpoints">5.4. Message Endpoints</a>
<ul class="sectlevel3">
<li><a href="#overview-endpoints-transformer">5.4.1. Message Transformer</a></li>
<li><a href="#overview-endpoints-filter">5.4.2. Message Filter</a></li>
<li><a href="#overview-endpoints-router">5.4.3. Message Router</a></li>
<li><a href="#overview-endpoints-splitter">5.4.4. Splitter</a></li>
<li><a href="#overview-endpoints-aggregator">5.4.5. Aggregator</a></li>
<li><a href="#overview-endpoints-service-activator">5.4.6. Service Activator</a></li>
<li><a href="#overview-endpoints-channeladapter">5.4.7. Channel Adapter</a></li>
<li><a href="#endpoint-bean-names">5.4.8. Endpoint Bean Names</a></li>
</ul>
</li>
<li><a href="#configuration-enable-integration">5.5. Configuration and <code>@EnableIntegration</code></a></li>
<li><a href="#programming-considerations">5.6. Programming Considerations</a>
<ul class="sectlevel3">
<li><a href="#shaded">5.6.1. Considerations When Using Packaged (for example, Shaded) Jars</a></li>
</ul>
</li>
<li><a href="#programming-tips">5.7. Programming Tips and Tricks</a>
<ul class="sectlevel3">
<li><a href="#xml-schemas">5.7.1. XML Schemas</a></li>
<li><a href="#finding-class-names-for-java-and-dsl-configuration">5.7.2. Finding Class Names for Java and DSL Configuration</a></li>
</ul>
</li>
<li><a href="#pojo-invocation">5.8. POJO Method invocation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-integration-core-messaging">Core Messaging</a>
<ul class="sectlevel1">
<li><a href="#messaging-channels-section">6. Messaging Channels</a>
<ul class="sectlevel2">
<li><a href="#channel">6.1. Message Channels</a>
<ul class="sectlevel3">
<li><a href="#channel-interfaces">6.1.1. The MessageChannel Interface</a>
<ul class="sectlevel4">
<li><a href="#channel-interfaces-pollablechannel"><code>PollableChannel</code></a></li>
<li><a href="#channel-interfaces-subscribablechannel"><code>SubscribableChannel</code></a></li>
</ul>
</li>
<li><a href="#channel-implementations">6.1.2. Message Channel Implementations</a>
<ul class="sectlevel4">
<li><a href="#channel-implementations-publishsubscribechannel"><code>PublishSubscribeChannel</code></a></li>
<li><a href="#channel-implementations-queuechannel"><code>QueueChannel</code></a></li>
<li><a href="#channel-implementations-prioritychannel"><code>PriorityChannel</code></a></li>
<li><a href="#channel-implementations-rendezvouschannel"><code>RendezvousChannel</code></a></li>
<li><a href="#channel-implementations-directchannel"><code>DirectChannel</code></a></li>
<li><a href="#executor-channel"><code>ExecutorChannel</code></a></li>
<li><a href="#channel-implementations-threadlocalchannel">Scoped Channel</a></li>
</ul>
</li>
<li><a href="#channel-interceptors">6.1.3. Channel Interceptors</a></li>
<li><a href="#channel-template">6.1.4. <code>MessagingTemplate</code></a></li>
<li><a href="#channel-configuration">6.1.5. Configuring Message Channels</a>
<ul class="sectlevel4">
<li><a href="#channel-configuration-directchannel"><code>DirectChannel</code> Configuration</a></li>
<li><a href="#channel-datatype-channel">Datatype Channel Configuration</a></li>
<li><a href="#channel-configuration-queuechannel"><code>QueueChannel</code> Configuration</a></li>
<li><a href="#channel-configuration-pubsubchannel"><code>PublishSubscribeChannel</code> Configuration</a></li>
<li><a href="#channel-configuration-executorchannel"><code>ExecutorChannel</code></a></li>
<li><a href="#channel-configuration-prioritychannel"><code>PriorityChannel</code> Configuration</a></li>
<li><a href="#channel-configuration-rendezvouschannel"><code>RendezvousChannel</code> Configuration</a></li>
<li><a href="#channel-configuration-threadlocalchannel">Scoped Channel Configuration</a></li>
<li><a href="#channel-configuration-interceptors">Channel Interceptor Configuration</a></li>
<li><a href="#global-channel-configuration-interceptors">Global Channel Interceptor Configuration</a></li>
<li><a href="#channel-wiretap">Wire Tap</a></li>
<li><a href="#conditional-wiretap">Conditional Wire Taps</a></li>
<li><a href="#channel-global-wiretap">Global Wire Tap Configuration</a></li>
</ul>
</li>
<li><a href="#channel-special-channels">6.1.6. Special Channels</a></li>
</ul>
</li>
<li><a href="#polling-consumer">6.2. Poller</a>
<ul class="sectlevel3">
<li><a href="#polling-consumer-2">6.2.1. Polling Consumer</a></li>
<li><a href="#pollable-message-source">6.2.2. Pollable Message Source</a></li>
<li><a href="#deferred-acks-message-source">6.2.3. Deferred Acknowledgment Pollable Message Source</a></li>
<li><a href="#conditional-pollers">6.2.4. Conditional Pollers for Message Sources</a>
<ul class="sectlevel4">
<li><a href="#background">Background</a></li>
<li><a href="#smart-polling">&#8220;Smart&#8221; Polling</a></li>
<li><a href="#simpleactiveidlemessagesourceadvice"><code>SimpleActiveIdleMessageSourceAdvice</code></a></li>
<li><a href="#compoundtriggeradvice"><code>CompoundTriggerAdvice</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#channel-adapter">6.3. Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#channel-adapter-namespace-inbound">6.3.1. Configuring An Inbound Channel Adapter</a></li>
<li><a href="#channel-adapter-namespace-outbound">6.3.2. Configuring An Outbound Channel Adapter</a></li>
<li><a href="#channel-adapter-expressions-and-scripts">6.3.3. Channel Adapter Expressions and Scripts</a></li>
</ul>
</li>
<li><a href="#bridge">6.4. Messaging Bridge</a>
<ul class="sectlevel3">
<li><a href="#bridge-namespace">6.4.1. Configuring a Bridge with XML</a></li>
<li><a href="#bridge-annot">6.4.2. Configuring a Bridge with Java Configuration</a></li>
<li><a href="#bridge-dsl">6.4.3. Configuring a Bridge with the Java DSL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#message">7. Message</a>
<ul class="sectlevel2">
<li><a href="#message-interface">7.1. The <code>Message</code> Interface</a></li>
<li><a href="#message-headers">7.2. Message Headers</a>
<ul class="sectlevel3">
<li><a href="#message-header-accessor">7.2.1. <code>MessageHeaderAccessor</code> API</a></li>
<li><a href="#message-id-generation">7.2.2. Message ID Generation</a></li>
<li><a href="#read-only-headers">7.2.3. Read-only Headers</a></li>
<li><a href="#header-propagation">7.2.4. Header Propagation</a></li>
</ul>
</li>
<li><a href="#message-implementations">7.3. Message Implementations</a></li>
<li><a href="#message-builder">7.4. The <code>MessageBuilder</code> Helper Class</a></li>
</ul>
</li>
<li><a href="#messaging-routing-chapter">8. Message Routing</a>
<ul class="sectlevel2">
<li><a href="#router">8.1. Routers</a>
<ul class="sectlevel3">
<li><a href="#router-overview">8.1.1. Overview</a></li>
<li><a href="#router-common-parameters">8.1.2. Common Router Parameters</a>
<ul class="sectlevel4">
<li><a href="#router-common-parameters-all">Inside and Outside of a Chain</a></li>
<li><a href="#router-common-parameters-top">Top-Level (Outside of a Chain)</a></li>
</ul>
</li>
<li><a href="#router-implementations">8.1.3. Router Implementations</a>
<ul class="sectlevel4">
<li><a href="#router-implementations-payloadtyperouter"><code>PayloadTypeRouter</code></a></li>
<li><a href="#router-implementations-headervaluerouter"><code>HeaderValueRouter</code></a></li>
<li><a href="#router-implementations-recipientlistrouter"><code>RecipientListRouter</code></a></li>
<li><a href="#recipient-list-router-management"><code>RecipientListRouterManagement</code></a></li>
<li><a href="#router-implementations-xpath-router">XPath Router</a></li>
<li><a href="#router-implementations-exception-router">Routing and Error Handling</a></li>
</ul>
</li>
<li><a href="#router-namespace">8.1.4. Configuring a Generic Router</a>
<ul class="sectlevel4">
<li><a href="#configuring-a-content-based-router-with-xml">Configuring a Content-based Router with XML</a></li>
</ul>
</li>
<li><a href="#router-spel">8.1.5. Routers and the Spring Expression Language (SpEL)</a>
<ul class="sectlevel4">
<li><a href="#router-annotation">Configuring a Router with Annotations</a></li>
</ul>
</li>
<li><a href="#dynamic-routers">8.1.6. Dynamic Routers</a>
<ul class="sectlevel4">
<li><a href="#dynamic-routers-control-bus">Manage Router Mappings using the Control Bus</a></li>
<li><a href="#dynamic-routers-jmx">Manage Router Mappings by Using JMX</a></li>
<li><a href="#routing-slip">Routing Slip</a></li>
<li><a href="#process-manager">Process Manager Enterprise Integration Pattern</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#filter">8.2. Filter</a>
<ul class="sectlevel3">
<li><a href="#filter-xml">8.2.1. Configuring a Filter with XML</a></li>
<li><a href="#filter-annotations">8.2.2. Configuring a Filter with Annotations</a></li>
</ul>
</li>
<li><a href="#splitter">8.3. Splitter</a>
<ul class="sectlevel3">
<li><a href="#programming-model">8.3.1. Programming Model</a>
<ul class="sectlevel4">
<li><a href="#iterators">Iterators</a></li>
<li><a href="#stream-and-flux">Stream and Flux</a></li>
</ul>
</li>
<li><a href="#configuring-a-splitter-with-xml">8.3.2. Configuring a Splitter with XML</a></li>
<li><a href="#configuring-a-splitter-with-annotations">8.3.3. Configuring a Splitter with Annotations</a></li>
</ul>
</li>
<li><a href="#aggregator">8.4. Aggregator</a>
<ul class="sectlevel3">
<li><a href="#aggregator-functionality">8.4.1. Functionality</a></li>
<li><a href="#aggregator-api">8.4.2. Programming Model</a>
<ul class="sectlevel4">
<li><a href="#aggregatingmessagehandler"><code>AggregatingMessageHandler</code></a></li>
<li><a href="#releasestrategy"><code>ReleaseStrategy</code></a></li>
<li><a href="#aggregating-large-groups">Aggregating Large Groups</a></li>
<li><a href="#correlation-strategy">Correlation Strategy</a></li>
<li><a href="#lock-registry">Lock Registry</a></li>
<li><a href="#aggregator-deadlocks">Avoiding Deadlocks</a></li>
</ul>
</li>
<li><a href="#aggregator-java-dsl">8.4.3. Configuring an Aggregator in Java DSL</a>
<ul class="sectlevel4">
<li><a href="#aggregator-xml">Configuring an Aggregator with XML</a></li>
<li><a href="#aggregator-annotations">Configuring an Aggregator with Annotations</a></li>
</ul>
</li>
<li><a href="#reaper">8.4.4. Managing State in an Aggregator: <code>MessageGroupStore</code></a></li>
</ul>
</li>
<li><a href="#resequencer">8.5. Resequencer</a>
<ul class="sectlevel3">
<li><a href="#resequencer-functionality">8.5.1. Functionality</a></li>
<li><a href="#configuring-a-resequencer">8.5.2. Configuring a Resequencer</a></li>
</ul>
</li>
<li><a href="#chain">8.6. Message Handler Chain</a>
<ul class="sectlevel3">
<li><a href="#chain-namespace">8.6.1. Configuring a Chain</a></li>
<li><a href="#using-the-id-attribute">8.6.2. Using the 'id' Attribute</a></li>
<li><a href="#calling-a-chain-from-within-a-chain">8.6.3. Calling a Chain from within a Chain</a></li>
</ul>
</li>
<li><a href="#scatter-gather">8.7. Scatter-Gather</a>
<ul class="sectlevel3">
<li><a href="#scatter-gather-functionality">8.7.1. Functionality</a>
<ul class="sectlevel4">
<li><a href="#auction">Auction</a></li>
<li><a href="#distribution">Distribution</a></li>
</ul>
</li>
<li><a href="#scatter-gather-namespace">8.7.2. Configuring a Scatter-Gather Endpoint</a></li>
<li><a href="#scatter-gather-error-handling">8.7.3. Error Handling</a></li>
</ul>
</li>
<li><a href="#barrier">8.8. Thread Barrier</a></li>
</ul>
</li>
<li><a href="#messaging-transformation-chapter">9. Message Transformation</a>
<ul class="sectlevel2">
<li><a href="#transformer">9.1. Transformer</a>
<ul class="sectlevel3">
<li><a href="#transformer-namespace">9.1.1. Configuring a Transformer with XML</a></li>
<li><a href="#transformers-and-spring-expression-language-spel">9.1.2. Transformers and Spring Expression Language (SpEL)</a></li>
<li><a href="#common-transformers">9.1.3. Common Transformers</a>
<ul class="sectlevel4">
<li><a href="#object-to-string-transformer">Object-to-String Transformer</a></li>
<li><a href="#object-to-map-and-map-to-object-transformers"><code>Object</code>-to-<code>Map</code> and <code>Map</code>-to-<code>Object</code> Transformers</a></li>
<li><a href="#stream-transformer">Stream Transformer</a></li>
<li><a href="#json-transformers">JSON Transformers</a></li>
</ul>
</li>
<li><a href="#transformer-annotation">9.1.4. Configuring a Transformer with Annotations</a></li>
<li><a href="#header-filter">9.1.5. Header Filter</a></li>
<li><a href="#codec-based-transformers">9.1.6. Codec-Based Transformers</a></li>
</ul>
</li>
<li><a href="#content-enricher">9.2. Content Enricher</a>
<ul class="sectlevel3">
<li><a href="#header-enricher">9.2.1. Header Enricher</a>
<ul class="sectlevel4">
<li><a href="#pojo-support">POJO Support</a></li>
<li><a href="#spel-support">SpEL Support</a></li>
<li><a href="#configuring-a-header-enricher-with-java-configuration">Configuring a Header Enricher with Java Configuration</a></li>
<li><a href="#configuring-a-header-enricher-with-the-java-dsl">Configuring a Header Enricher with the Java DSL</a></li>
<li><a href="#header-channel-registry">Header Channel Registry</a></li>
</ul>
</li>
<li><a href="#payload-enricher">9.2.2. Payload Enricher</a>
<ul class="sectlevel4">
<li><a href="#payload-enricher-configuration">Configuration</a></li>
<li><a href="#payload-enricher-examples">Examples</a></li>
<li><a href="#how-do-i-pass-only-a-subset-of-data-to-the-request-channel">How Do I Pass Only a Subset of Data to the Request Channel?</a></li>
<li><a href="#how-can-i-enrich-payloads-with-static-information-without-using-a-request-channel">How Can I Enrich Payloads with Static Information without Using a Request Channel?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#claim-check">9.3. Claim Check</a>
<ul class="sectlevel3">
<li><a href="#claim-check-in">9.3.1. Incoming Claim Check Transformer</a></li>
<li><a href="#claim-check-out">9.3.2. Outgoing Claim Check Transformer</a></li>
<li><a href="#claim-once">9.3.3. Claim Once</a></li>
<li><a href="#a-word-on-message-store">9.3.4. A Word on Message Store</a></li>
</ul>
</li>
<li><a href="#codec">9.4. Codec</a>
<ul class="sectlevel3">
<li><a href="#encodingpayloadtransformer">9.4.1. <code>EncodingPayloadTransformer</code></a></li>
<li><a href="#decodingtransformer">9.4.2. <code>DecodingTransformer</code></a></li>
<li><a href="#codecmessageconverter">9.4.3. <code>CodecMessageConverter</code></a></li>
<li><a href="#kryo">9.4.4. Kryo</a>
<ul class="sectlevel4">
<li><a href="#customizing-kryo">Customizing Kryo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#messaging-endpoints-chapter">10. Messaging Endpoints</a>
<ul class="sectlevel2">
<li><a href="#endpoint">10.1. Message Endpoints</a>
<ul class="sectlevel3">
<li><a href="#endpoint-handler">10.1.1. Message Handler</a></li>
<li><a href="#endpoint-eventdrivenconsumer">10.1.2. Event-driven Consumer</a></li>
<li><a href="#endpoint-pollingconsumer">10.1.3. Polling Consumer</a></li>
<li><a href="#endpoint-namespace">10.1.4. Endpoint Namespace Support</a>
<ul class="sectlevel4">
<li><a href="#examples">Examples</a></li>
<li><a href="#aop-advice-chains">AOP Advice chains</a></li>
</ul>
</li>
<li><a href="#polling-consumer-change-polling-rate">10.1.5. Changing Polling Rate at Runtime</a></li>
<li><a href="#payload-type-conversion">10.1.6. Payload Type Conversion</a></li>
<li><a href="#content-type-conversion">10.1.7. Content Type Conversion</a></li>
<li><a href="#async-polling">10.1.8. Asynchronous Polling</a></li>
<li><a href="#endpoint-inner">10.1.9. Endpoint Inner Beans</a></li>
</ul>
</li>
<li><a href="#endpoint-roles">10.2. Endpoint Roles</a></li>
<li><a href="#leadership-event-handling">10.3. Leadership Event Handling</a></li>
<li><a href="#gateway">10.4. Messaging Gateways</a>
<ul class="sectlevel3">
<li><a href="#gateway-proxy">10.4.1. Enter the <code>GatewayProxyFactoryBean</code></a></li>
<li><a href="#gateway-namespace">10.4.2. Gateway XML Namespace Support</a></li>
<li><a href="#gateway-default-reply-channel">10.4.3. Setting the Default Reply Channel</a></li>
<li><a href="#gateway-configuration-annotations">10.4.4. Gateway Configuration with Annotations and XML</a>
<ul class="sectlevel4">
<li><a href="#expressions-and-global-headers">Expressions and &#8220;Global&#8221; Headers</a></li>
</ul>
</li>
<li><a href="#gateway-mapping">10.4.5. Mapping Method Arguments to a Message</a>
<ul class="sectlevel4">
<li><a href="#mapping-method-arguments">Mapping Method Arguments</a></li>
</ul>
</li>
<li><a href="#messaging-gateway-annotation">10.4.6. <code>@MessagingGateway</code> Annotation</a></li>
<li><a href="#gateway-calling-no-argument-methods">10.4.7. Invoking No-Argument Methods</a></li>
<li><a href="#gateway-error-handling">10.4.8. Error Handling</a></li>
<li><a href="#gateway-timeouts">10.4.9. Gateway Timeouts</a></li>
<li><a href="#async-gateway">10.4.10. Asynchronous Gateway</a>
<ul class="sectlevel4">
<li><a href="#listenablefuture"><code>ListenableFuture</code></a></li>
<li><a href="#gateway-asynctaskexecutor"><code>AsyncTaskExecutor</code></a></li>
<li><a href="#gw-completable-future"><code>CompletableFuture</code></a></li>
<li><a href="#reactor-mono">Reactor <code>Mono</code></a></li>
<li><a href="#downstream-flows-returning-an-asynchronous-type">Downstream Flows Returning an Asynchronous Type</a></li>
<li><a href="#void-return-type"><code>void</code> Return Type</a></li>
</ul>
</li>
<li><a href="#gateway-no-response">10.4.11. Gateway Behavior When No response Arrives</a>
<ul class="sectlevel4">
<li><a href="#long-running-process-downstream">Long-running Process Downstream</a></li>
<li><a href="#downstream-component-returns-null">Downstream Component Returns 'null'</a></li>
<li><a href="#downstream-component-return-signature-is-void-while-gateway-method-signature-is-non-void">Downstream Component Return Signature is 'void' While Gateway Method Signature Is Non-void</a></li>
<li><a href="#downstream-component-results-in-runtime-exception">Downstream Component Results in Runtime Exception</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#service-activator">10.5. Service Activator</a>
<ul class="sectlevel3">
<li><a href="#service-activator-namespace">10.5.1. Configuring Service Activator</a>
<ul class="sectlevel4">
<li><a href="#service-activators-and-the-spring-expression-language-spel">Service Activators and the Spring Expression Language (SpEL)</a></li>
</ul>
</li>
<li><a href="#async-service-activator">10.5.2. Asynchronous Service Activator</a></li>
<li><a href="#service-activator-return-type">10.5.3. Service Activator and Method Return Type</a></li>
</ul>
</li>
<li><a href="#delayer">10.6. Delayer</a>
<ul class="sectlevel3">
<li><a href="#delayer-namespace">10.6.1. Configuring a Delayer</a></li>
<li><a href="#delayer-message-store">10.6.2. Delayer and a Message Store</a></li>
<li><a href="#delayer-release-failures">10.6.3. Release Failures</a></li>
</ul>
</li>
<li><a href="#scripting">10.7. Scripting Support</a>
<ul class="sectlevel3">
<li><a href="#scripting-config">10.7.1. Script Configuration</a>
<ul class="sectlevel4">
<li><a href="#scripting-script-variable-bindings">Script Variable Bindings</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#groovy">10.8. Groovy support</a>
<ul class="sectlevel3">
<li><a href="#groovy-config">10.8.1. Groovy Configuration</a></li>
<li><a href="#groovy-object-customization">10.8.2. Groovy Object Customization</a></li>
<li><a href="#groovy-script-compiler-customization">10.8.3. Groovy Script Compiler Customization</a></li>
<li><a href="#groovy-control-bus">10.8.4. Control Bus</a></li>
</ul>
</li>
<li><a href="#message-handler-advice-chain">10.9. Adding Behavior to Endpoints</a>
<ul class="sectlevel3">
<li><a href="#advice-classes">10.9.1. Provided Advice Classes</a>
<ul class="sectlevel4">
<li><a href="#retry-advice">Retry Advice</a></li>
<li><a href="#circuit-breaker-advice">Circuit Breaker Advice</a></li>
<li><a href="#expression-advice">Expression Evaluating Advice</a></li>
</ul>
</li>
<li><a href="#custom-advice">10.9.2. Custom Advice Classes</a></li>
<li><a href="#other-advice">10.9.3. Other Advice Chain Elements</a></li>
<li><a href="#handle-message-advice">10.9.4. Handling Message Advice</a></li>
<li><a href="#tx-handle-message-advice">10.9.5. Transaction Support</a></li>
<li><a href="#advising-filters">10.9.6. Advising Filters</a></li>
<li><a href="#advising-with-annotations">10.9.7. Advising Endpoints Using Annotations</a></li>
<li><a href="#advice-order">10.9.8. Ordering Advices within an Advice Chain</a></li>
<li><a href="#advised-handler-properties">10.9.9. Advised Handler Properties</a></li>
<li><a href="#idempotent-receiver">10.9.10. Idempotent Receiver Enterprise Integration Pattern</a></li>
</ul>
</li>
<li><a href="#logging-channel-adapter">10.10. Logging Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#using-java-configuration">10.10.1. Using Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl">10.10.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#functions-support">10.11. <code>java.util.function</code> Interfaces Support</a>
<ul class="sectlevel3">
<li><a href="#kotlin-functions-support">10.11.1. Kotlin Lambdas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#java-dsl">11. Java DSL</a>
<ul class="sectlevel2">
<li><a href="#java-dsl-basics">11.1. DSL Basics</a></li>
<li><a href="#java-dsl-channels">11.2. Message Channels</a></li>
<li><a href="#java-dsl-pollers">11.3. Pollers</a></li>
<li><a href="#java-dsl-endpoints">11.4. DSL and Endpoint Configuration</a></li>
<li><a href="#java-dsl-transformers">11.5. Transformers</a></li>
<li><a href="#java-dsl-inbound-adapters">11.6. Inbound Channel Adapters</a></li>
<li><a href="#java-dsl-routers">11.7. Message Routers</a></li>
<li><a href="#java-dsl-splitters">11.8. Splitters</a></li>
<li><a href="#java-dsl-aggregators">11.9. Aggregators and Resequencers</a></li>
<li><a href="#java-dsl-handle">11.10. Service Activators and the <code>.handle()</code> method</a></li>
<li><a href="#java-dsl-log">11.11. Operator log()</a></li>
<li><a href="#java-dsl-wiretap">11.12. <code>MessageChannelSpec.wireTap()</code></a></li>
<li><a href="#java-dsl-flows">11.13. Working With Message Flows</a></li>
<li><a href="#java-dsl-function-expression">11.14. <code>FunctionExpression</code></a></li>
<li><a href="#java-dsl-subflows">11.15. Sub-flows support</a></li>
<li><a href="#java-dsl-protocol-adapters">11.16. Using Protocol Adapters</a></li>
<li><a href="#java-dsl-flow-adapter">11.17. <code>IntegrationFlowAdapter</code></a></li>
<li><a href="#java-dsl-runtime-flows">11.18. Dynamic and Runtime Integration Flows</a></li>
<li><a href="#java-dsl-gateway">11.19. <code>IntegrationFlow</code> as Gateway</a></li>
</ul>
</li>
<li><a href="#system-management-chapter">12. System Management</a>
<ul class="sectlevel2">
<li><a href="#metrics-management">12.1. Metrics and Management</a>
<ul class="sectlevel3">
<li><a href="#configuring-metrics-capture">12.1.1. Configuring Metrics Capture</a></li>
<li><a href="#micrometer-integration">12.1.2. Micrometer Integration</a></li>
<li><a href="#mgmt-channel-features">12.1.3. <code>MessageChannel</code> Metric Features</a></li>
<li><a href="#mgmt-handler-features">12.1.4. MessageHandler Metric Features</a></li>
<li><a href="#mgmt-statistics">12.1.5. Time-Based Average Estimates</a></li>
<li><a href="#mgmt-metrics-factory">12.1.6. Metrics Factory</a>
<ul class="sectlevel4">
<li><a href="#customizing-the-default-channel-and-handler-statistics">Customizing the Default Channel and Handler Statistics</a></li>
<li><a href="#advanced-customization">Advanced Customization</a></li>
<li><a href="#performance-improvement">Performance Improvement</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jmx">12.2. JMX Support</a>
<ul class="sectlevel3">
<li><a href="#jmx-notification-listening-channel-adapter">12.2.1. Notification-listening Channel Adapter</a></li>
<li><a href="#jmx-notification-publishing-channel-adapter">12.2.2. Notification-publishing Channel Adapter</a></li>
<li><a href="#jmx-attribute-polling-channel-adapter">12.2.3. Attribute-polling Channel Adapter</a></li>
<li><a href="#tree-polling-channel-adapter">12.2.4. Tree-polling Channel Adapter</a></li>
<li><a href="#jmx-operation-invoking-channel-adapter">12.2.5. Operation-invoking Channel Adapter</a></li>
<li><a href="#jmx-operation-invoking-outbound-gateway">12.2.6. Operation-invoking Outbound Gateway</a></li>
<li><a href="#jmx-mbean-exporter">12.2.7. MBean Exporter</a>
<ul class="sectlevel4">
<li><a href="#jmx-mbean-features">MBean Object Names</a></li>
<li><a href="#jmx-42-improvements">JMX Improvements</a></li>
<li><a href="#jmx-mbean-shutdown">Orderly Shutdown Managed Operation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#message-history">12.3. Message History</a>
<ul class="sectlevel3">
<li><a href="#message-history-config">12.3.1. Message History Configuration</a></li>
</ul>
</li>
<li><a href="#message-store">12.4. Message Store</a>
<ul class="sectlevel3">
<li><a href="#message-group-factory">12.4.1. Using <code>MessageGroupFactory</code></a></li>
<li><a href="#lazy-load-message-group">12.4.2. Persistent <code>MessageGroupStore</code> and Lazy-load</a></li>
</ul>
</li>
<li><a href="#metadata-store">12.5. Metadata Store</a>
<ul class="sectlevel3">
<li><a href="#idempotent-receiver-pattern">12.5.1. Idempotent Receiver and Metadata Store</a></li>
<li><a href="#metadatastore-listener">12.5.2. <code>MetadataStoreListener</code></a></li>
</ul>
</li>
<li><a href="#control-bus">12.6. Control Bus</a></li>
<li><a href="#jmx-shutdown">12.7. Orderly Shutdown</a></li>
<li><a href="#integration-graph">12.8. Integration Graph</a>
<ul class="sectlevel3">
<li><a href="#graph-runtime-model">12.8.1. Graph Runtime Model</a></li>
</ul>
</li>
<li><a href="#integration-graph-controller">12.9. Integration Graph Controller</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-integration-endpoints">Integration Endpoints</a>
<ul class="sectlevel1">
<li><a href="#endpoint-summary">13. Endpoint Quick Reference Table</a></li>
<li><a href="#amqp">14. AMQP Support</a>
<ul class="sectlevel2">
<li><a href="#amqp-inbound-channel-adapter">14.1. Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration">14.1.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-2">14.1.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#polled-inbound-channel-adapter">14.2. Polled Inbound Channel Adapter</a></li>
<li><a href="#amqp-inbound-gateway">14.3. Inbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-2">14.3.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-3">14.3.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#amqp-inbound-ack">14.4. Inbound Endpoint Acknowledge Mode</a></li>
<li><a href="#amqp-outbound-channel-adapter">14.5. Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-3">14.5.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-4">14.5.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#amqp-outbound-gateway">14.6. Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-4">14.6.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-5">14.6.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#amqp-async-outbound-gateway">14.7. Asynchronous Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-5">14.7.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-6">14.7.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#amqp-conversion-inbound">14.8. Inbound Message Conversion</a></li>
<li><a href="#content-type-conversion-outbound">14.9. Outbound Message Conversion</a></li>
<li><a href="#amqp-user-id">14.10. Outbound User ID</a></li>
<li><a href="#amqp-delay">14.11. Delayed Message Exchange</a></li>
<li><a href="#amqp-channels">14.12. AMQP-backed Message Channels</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-6">14.12.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-7">14.12.2. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#amqp-message-headers">14.13. AMQP Message Headers</a>
<ul class="sectlevel3">
<li><a href="#overview-2">14.13.1. Overview</a></li>
<li><a href="#amqp-content-type">14.13.2. contentType Header</a></li>
</ul>
</li>
<li><a href="#amqp-strict-ordering">14.14. Strict Message Ordering</a>
<ul class="sectlevel3">
<li><a href="#inbound">14.14.1. Inbound</a></li>
<li><a href="#outbound">14.14.2. Outbound</a></li>
</ul>
</li>
<li><a href="#amqp-samples">14.15. AMQP Samples</a></li>
</ul>
</li>
<li><a href="#applicationevent">15. Spring <code>ApplicationEvent</code> Support</a>
<ul class="sectlevel2">
<li><a href="#appevent-inbound">15.1. Receiving Spring Application Events</a></li>
<li><a href="#appevent-outbound">15.2. Sending Spring Application Events</a></li>
</ul>
</li>
<li><a href="#feed">16. Feed Adapter</a>
<ul class="sectlevel2">
<li><a href="#feed-inbound-channel-adapter">16.1. Feed Inbound Channel Adapter</a></li>
<li><a href="#duplicate-entries">16.2. Duplicate Entries</a></li>
<li><a href="#other-options">16.3. Other Options</a></li>
<li><a href="#feed-java-configuration">16.4. Java DSL Configuration</a></li>
</ul>
</li>
<li><a href="#files">17. File Support</a>
<ul class="sectlevel2">
<li><a href="#file-reading">17.1. Reading Files</a>
<ul class="sectlevel3">
<li><a href="#message-headers-2">17.1.1. Message Headers</a></li>
<li><a href="#directory-scanning-and-polling">17.1.2. Directory Scanning and Polling</a></li>
<li><a href="#file-namespace-support">17.1.3. Namespace Support</a></li>
<li><a href="#watch-service-directory-scanner">17.1.4. <code>WatchServiceDirectoryScanner</code></a></li>
<li><a href="#limiting-memory-consumption">17.1.5. Limiting Memory Consumption</a></li>
<li><a href="#configuring-with-java-configuration-7">17.1.6. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-8">17.1.7. Configuring with the Java DSL</a></li>
<li><a href="#file-tailing">17.1.8. 'tail&#8217;ing Files</a></li>
<li><a href="#file-incomplete">17.1.9. Dealing With Incomplete Data</a></li>
</ul>
</li>
<li><a href="#file-writing">17.2. Writing files</a>
<ul class="sectlevel3">
<li><a href="#file-writing-file-names">17.2.1. Generating File Names</a></li>
<li><a href="#file-writing-output-directory">17.2.2. Specifying the Output Directory</a>
<ul class="sectlevel4">
<li><a href="#using-the-directory-attribute">Using the <code>directory</code> Attribute</a></li>
<li><a href="#using-the-directory-expression-attribute">Using the <code>directory-expression</code> Attribute</a></li>
<li><a href="#using-the-auto-create-directory-attribute">Using the <code>auto-create-directory</code> Attribute</a></li>
</ul>
</li>
<li><a href="#file-writing-destination-exists">17.2.3. Dealing with Existing Destination Files</a></li>
<li><a href="#file-flushing">17.2.4. Flushing Files When Using <code>APPEND_NO_FLUSH</code></a></li>
<li><a href="#file-timestamps">17.2.5. File Timestamps</a></li>
<li><a href="#file-permissions">17.2.6. File Permissions</a></li>
<li><a href="#file-outbound-channel-adapter">17.2.7. File Outbound Channel Adapter</a></li>
<li><a href="#file-writing-output-gateway">17.2.8. Outbound Gateway</a></li>
<li><a href="#configuring-with-java-configuration-8">17.2.9. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-9">17.2.10. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#file-transforming">17.3. File Transformers</a></li>
<li><a href="#file-splitter">17.4. File Splitter</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-9">17.4.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-10">17.4.2. Configuring with the Java DSL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ftp">18. FTP/FTPS Adapters</a>
<ul class="sectlevel2">
<li><a href="#ftp-session-factory">18.1. FTP Session Factory</a>
<ul class="sectlevel3">
<li><a href="#default-factories">18.1.1. Default Factories</a></li>
</ul>
</li>
<li><a href="#advanced-configuration">18.2. Advanced Configuration</a>
<ul class="sectlevel3">
<li><a href="#ftps-and-shared-sslsession">18.2.1. FTPS and Shared SSLSession</a></li>
</ul>
</li>
<li><a href="#ftp-dsf">18.3. Delegating Session Factory</a></li>
<li><a href="#ftp-inbound">18.4. FTP Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#more-on-file-filtering-and-incomplete-files">18.4.1. More on File Filtering and Incomplete Files</a></li>
<li><a href="#poller-configuration-notes-for-the-inbound-ftp-adapter">18.4.2. Poller Configuration Notes for the Inbound FTP Adapter</a></li>
<li><a href="#recovering-from-failures">18.4.3. Recovering from Failures</a></li>
<li><a href="#configuring-with-java-configuration-10">18.4.4. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-11">18.4.5. Configuring with the Java DSL</a></li>
<li><a href="#ftp-incomplete">18.4.6. Dealing With Incomplete Data</a></li>
</ul>
</li>
<li><a href="#ftp-streaming">18.5. FTP Streaming Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#ftp-streaming-java">18.5.1. Configuring with Java Configuration</a></li>
</ul>
</li>
<li><a href="#ftp-rotating-server-advice">18.6. Inbound Channel Adapters: Polling Multiple Servers and Directories</a></li>
<li><a href="#ftp-max-fetch">18.7. Inbound Channel Adapters: Controlling Remote File Fetching</a></li>
<li><a href="#ftp-outbound">18.8. FTP Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#avoiding-partially-written-files">18.8.1. Avoiding Partially Written Files</a></li>
<li><a href="#configuring-with-java-configuration-11">18.8.2. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-12">18.8.3. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#ftp-outbound-gateway">18.9. FTP Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#ftp-using-ls">18.9.1. Using the <code>ls</code> Command</a></li>
<li><a href="#using-the-nlst-command">18.9.2. Using the <code>nlst</code> Command</a></li>
<li><a href="#using-the-get-command">18.9.3. Using the <code>get</code> Command</a></li>
<li><a href="#using-the-mget-command">18.9.4. Using the <code>mget</code> Command</a></li>
<li><a href="#ftp-put-command">18.9.5. Using the <code>put</code> Command</a></li>
<li><a href="#using-the-rm-command">18.9.6. Using the <code>rm</code> Command</a></li>
<li><a href="#using-the-mv-command">18.9.7. Using the <code>mv</code> Command</a></li>
<li><a href="#additional-information-about-ftp-outbound-gateway-commands">18.9.8. Additional Information about FTP Outbound Gateway Commands</a></li>
<li><a href="#configuring-with-java-configuration-12">18.9.9. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-13">18.9.10. Configuring with the Java DSL</a></li>
<li><a href="#ftp-partial">18.9.11. Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a></li>
</ul>
</li>
<li><a href="#ftp-session-caching">18.10. FTP Session Caching</a></li>
<li><a href="#ftp-rft">18.11. Using <code>RemoteFileTemplate</code></a></li>
<li><a href="#ftp-session-callback">18.12. Using <code>MessageSessionCallback</code></a></li>
</ul>
</li>
<li><a href="#gemfire">19. Pivotal GemFire and Apache Geode Support</a>
<ul class="sectlevel2">
<li><a href="#gemfire-inbound">19.1. Inbound Channel Adapter</a></li>
<li><a href="#gemfire-cq">19.2. Continuous Query Inbound Channel Adapter</a></li>
<li><a href="#gemfire-outbound">19.3. Outbound Channel Adapter</a></li>
<li><a href="#gemfire-message-store">19.4. Gemfire Message Store</a></li>
<li><a href="#gemfire-lock-registry">19.5. Gemfire Lock Registry</a></li>
<li><a href="#gemfire-metadata-store">19.6. Gemfire Metadata Store</a></li>
</ul>
</li>
<li><a href="#http">20. HTTP Support</a>
<ul class="sectlevel2">
<li><a href="#http-inbound">20.1. Http Inbound Components</a></li>
<li><a href="#http-outbound">20.2. HTTP Outbound Components</a>
<ul class="sectlevel3">
<li><a href="#using-httprequestexecutingmessagehandler">20.2.1. Using <code>HttpRequestExecutingMessageHandler</code></a></li>
<li><a href="#using-cookies">20.2.2. Using Cookies</a></li>
</ul>
</li>
<li><a href="#http-namespace">20.3. HTTP Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#inbound-2">20.3.1. Inbound</a></li>
<li><a href="#http-request-mapping">20.3.2. Request Mapping Support</a></li>
<li><a href="#http-cors">20.3.3. Cross-origin Resource Sharing (CORS) Support</a></li>
<li><a href="#http-response-statuscode">20.3.4. Response Status Code</a></li>
<li><a href="#uri-template-variables-and-expressions">20.3.5. URI Template Variables and Expressions</a></li>
<li><a href="#outbound-2">20.3.6. Outbound</a></li>
<li><a href="#mapping-uri-variables">20.3.7. Mapping URI Variables</a></li>
<li><a href="#controlling-uri-encoding">20.3.8. Controlling URI Encoding</a></li>
</ul>
</li>
<li><a href="#http-java-config">20.4. Configuring HTTP Endpoints with Java</a></li>
<li><a href="#http-timeout">20.5. Timeout Handling</a>
<ul class="sectlevel3">
<li><a href="#http-inbound-gateway">20.5.1. HTTP Inbound Gateway</a></li>
</ul>
</li>
<li><a href="#http-proxy">20.6. HTTP Proxy configuration</a>
<ul class="sectlevel3">
<li><a href="#standard-java-proxy-configuration">20.6.1. Standard Java Proxy configuration</a></li>
<li><a href="#springs-simpleclienthttprequestfactory">20.6.2. Spring&#8217;s <code>SimpleClientHttpRequestFactory</code></a></li>
</ul>
</li>
<li><a href="#http-header-mapping">20.7. HTTP Header Mappings</a></li>
<li><a href="#int-graph-controller">20.8. Integration Graph Controller</a></li>
<li><a href="#http-samples">20.9. HTTP Samples</a>
<ul class="sectlevel3">
<li><a href="#multipart-rest-inbound">20.9.1. Multipart HTTP Request&#8201;&#8212;&#8201;RestTemplate (Client) and Http Inbound Gateway (Server)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jdbc">21. JDBC Support</a>
<ul class="sectlevel2">
<li><a href="#jdbc-inbound-channel-adapter">21.1. Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jdbc-polling-transactions">21.1.1. Polling and Transactions</a></li>
<li><a href="#jdbc-max-rows-versus-max-messages-per-poll">21.1.2. <code>max-rows</code> Versus <code>max-messages-per-poll</code></a></li>
</ul>
</li>
<li><a href="#jdbc-outbound-channel-adapter">21.2. Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#passing-parameters-by-using-spel-expressions">21.2.1. Passing Parameters by Using SpEL Expressions</a></li>
<li><a href="#using-the-preparedstatement-callback">21.2.2. Using the <code>PreparedStatement</code> Callback</a></li>
<li><a href="#batch-update">21.2.3. Batch Update</a></li>
</ul>
</li>
<li><a href="#jdbc-outbound-gateway">21.3. Outbound Gateway</a></li>
<li><a href="#jdbc-message-store">21.4. JDBC Message Store</a>
<ul class="sectlevel3">
<li><a href="#initializing-the-database">21.4.1. Initializing the Database</a></li>
<li><a href="#jdbc-message-store-generic">21.4.2. The Generic JDBC Message Store</a></li>
<li><a href="#jdbc-message-store-channels">21.4.3. Backing Message Channels</a>
<ul class="sectlevel4">
<li><a href="#supported-databases">Supported Databases</a></li>
<li><a href="#custom-message-insertion">Custom Message Insertion</a></li>
<li><a href="#concurrent-polling">Concurrent Polling</a></li>
<li><a href="#priority-channel">Priority Channel</a></li>
</ul>
</li>
<li><a href="#partitioning-a-message-store">21.4.4. Partitioning a Message Store</a></li>
</ul>
</li>
<li><a href="#stored-procedures">21.5. Stored Procedures</a>
<ul class="sectlevel3">
<li><a href="#sp-supported-databases">21.5.1. Supported Databases</a></li>
<li><a href="#sp-configuration">21.5.2. Configuration</a></li>
<li><a href="#sp-common-config-params">21.5.3. Common Configuration Attributes</a></li>
<li><a href="#sp-common-config-subelements">21.5.4. Common Configuration Sub-Elements</a></li>
<li><a href="#sp-defining-parameter-sources">21.5.5. Defining Parameter Sources</a></li>
<li><a href="#stored-procedure-inbound-channel-adapter">21.5.6. Stored Procedure Inbound Channel Adapter</a></li>
<li><a href="#stored-procedure-outbound-channel-adapter">21.5.7. Stored Procedure Outbound Channel Adapter</a></li>
<li><a href="#stored-procedure-outbound-gateway">21.5.8. Stored Procedure Outbound Gateway</a></li>
<li><a href="#sp-examples">21.5.9. Examples</a></li>
</ul>
</li>
<li><a href="#jdbc-lock-registry">21.6. JDBC Lock Registry</a></li>
<li><a href="#jdbc-metadata-store">21.7. JDBC Metadata Store</a></li>
</ul>
</li>
<li><a href="#jpa">22. JPA Support</a>
<ul class="sectlevel2">
<li><a href="#functionality">22.1. Functionality</a></li>
<li><a href="#jpa-supported-persistence-providers">22.2. Supported Persistence Providers</a></li>
<li><a href="#jpa-java-implementation">22.3. Java Implementation</a></li>
<li><a href="#jpa-namespace-support">22.4. Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#jpa-namespace-support-common-attributes">22.4.1. Common XML Namespace Configuration Attributes</a></li>
<li><a href="#jpa-parameters">22.4.2. Providing JPA Query Parameters</a></li>
<li><a href="#jpa-transactions">22.4.3. Transaction Handling</a></li>
</ul>
</li>
<li><a href="#jpa-inbound-channel-adapter">22.5. Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jpaInboundChannelAdapterParameters">22.5.1. Configuration Parameter Reference</a></li>
<li><a href="#configuring-with-java-configuration-13">22.5.2. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-14">22.5.3. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#jpa-outbound-channel-adapter">22.6. Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jpa-outbound-channel-adapter-entity-class">22.6.1. Using an Entity Class</a></li>
<li><a href="#jpa-using-jpaql">22.6.2. Using JPA Query Language (JPA QL)</a></li>
<li><a href="#jpa-using-native-queries">22.6.3. Using Native Queries</a></li>
<li><a href="#using-named-queries">22.6.4. Using Named Queries</a></li>
<li><a href="#jpaOutboundChannelAdapterParameters">22.6.5. Configuration Parameter Reference</a></li>
<li><a href="#configuring-with-java-configuration-14">22.6.6. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-15">22.6.7. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#jpa-outbound-gateways">22.7. Outbound Gateways</a>
<ul class="sectlevel3">
<li><a href="#jpa-outbound-gateway-common-parameters">22.7.1. Common Configuration Parameters</a></li>
<li><a href="#jpa-updating-outbound-gateway">22.7.2. Updating Outbound Gateway</a></li>
<li><a href="#configuring-with-java-configuration-15">22.7.3. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-16">22.7.4. Configuring with the Java DSL</a></li>
<li><a href="#jpa-retrieving-outbound-gateway">22.7.5. Retrieving Outbound Gateway</a></li>
<li><a href="#configuring-with-java-configuration-16">22.7.6. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-17">22.7.7. Configuring with the Java DSL</a></li>
<li><a href="#outboundGatewaySamples">22.7.8. JPA Outbound Gateway Samples</a>
<ul class="sectlevel4">
<li><a href="#update-by-using-an-entity-class">Update by Using an Entity Class</a></li>
<li><a href="#update-using-jpql">Update using JPQL</a></li>
<li><a href="#retrieving-an-entity-using-jpql">Retrieving an Entity using JPQL</a></li>
<li><a href="#retrieving-an-entity-by-using-id-expression">Retrieving an Entity by Using <code>id-expression</code></a></li>
<li><a href="#update-using-a-named-query">Update using a Named Query</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#jms">23. JMS Support</a>
<ul class="sectlevel2">
<li><a href="#jms-inbound-channel-adapter">23.1. Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jms-ib-transactions">23.1.1. Transactions</a></li>
</ul>
</li>
<li><a href="#jms-message-driven-channel-adapter">23.2. Message-driven Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jms-md-conversion-errors">23.2.1. Inbound Conversion Errors</a></li>
</ul>
</li>
<li><a href="#jms-outbound-channel-adapter">23.3. Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#jms-ob-transactions">23.3.1. Transactions</a></li>
</ul>
</li>
<li><a href="#jms-inbound-gateway">23.4. Inbound Gateway</a></li>
<li><a href="#jms-outbound-gateway">23.5. Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#jms-outbound-gateway-reply-listener">23.5.1. Using a <code>&lt;reply-listener/&gt;</code></a></li>
<li><a href="#idle-reply-listeners">23.5.2. Idle Reply Listeners</a></li>
<li><a href="#gateway-reply-correlation">23.5.3. Gateway Reply Correlation</a></li>
<li><a href="#jms-async-gateway">23.5.4. Async Gateway</a></li>
<li><a href="#jms-og-attributes">23.5.5. Attribute Reference</a></li>
</ul>
</li>
<li><a href="#jms-header-mapping">23.6. Mapping Message Headers to and from JMS Message</a></li>
<li><a href="#jms-conversion-and-marshalling">23.7. Message Conversion, Marshalling, and Unmarshalling</a></li>
<li><a href="#jms-channel">23.8. JMS-backed Message Channels</a></li>
<li><a href="#jms-selectors">23.9. Using JMS Message Selectors</a></li>
<li><a href="#jms-samples">23.10. JMS Samples</a></li>
</ul>
</li>
<li><a href="#mail">24. Mail Support</a>
<ul class="sectlevel2">
<li><a href="#mail-outbound">24.1. Mail-sending Channel Adapter</a></li>
<li><a href="#mail-inbound">24.2. Mail-receiving Channel Adapter</a></li>
<li><a href="#mail-mapping">24.3. Inbound Mail Message Mapping</a></li>
<li><a href="#mail-namespace">24.4. Mail Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#imap-idle-and-lost-connections">24.4.1. IMAP <code>idle</code> and Lost Connections</a></li>
</ul>
</li>
<li><a href="#imap-seen">24.5. Marking IMAP Messages When <code>\Recent</code> Is Not Supported</a></li>
<li><a href="#mail-filtering">24.6. Email Message Filtering</a></li>
<li><a href="#mail-tx-sync">24.7. Transaction Synchronization</a></li>
<li><a href="#java-dsl-configuration">24.8. Configuring channel adapters with the Java DSL</a></li>
</ul>
</li>
<li><a href="#mongodb">25. MongoDb Support</a>
<ul class="sectlevel2">
<li><a href="#mongodb-connection">25.1. Connecting to MongoDb</a>
<ul class="sectlevel3">
<li><a href="#using-mongodbfactory">25.1.1. Using <code>MongoDbFactory</code></a></li>
</ul>
</li>
<li><a href="#mongodb-message-store">25.2. MongoDB Message Store</a>
<ul class="sectlevel3">
<li><a href="#mongodb-priority-channel-message-store">25.2.1. MongoDB Channel Message Store</a></li>
<li><a href="#mongodb-metadata-store">25.2.2. MongoDB Metadata Store</a></li>
</ul>
</li>
<li><a href="#mongodb-inbound-channel-adapter">25.3. MongoDB Inbound Channel Adapter</a></li>
<li><a href="#mongodb-outbound-channel-adapter">25.4. MongoDB Outbound Channel Adapter</a></li>
<li><a href="#mongodb-outbound-gateway">25.5. MongoDB Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-17">25.5.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-18">25.5.2. Configuring with the Java DSL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mqtt">26. MQTT Support</a>
<ul class="sectlevel2">
<li><a href="#mqtt-inbound">26.1. Inbound (Message-driven) Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#adding-and-removing-topics-at-runtime">26.1.1. Adding and Removing Topics at Runtime</a></li>
<li><a href="#configuring-with-java-configuration-18">26.1.2. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-19">26.1.3. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#mqtt-outbound">26.2. Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#configuring-with-java-configuration-19">26.2.1. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-20">26.2.2. Configuring with the Java DSL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis">27. Redis Support</a>
<ul class="sectlevel2">
<li><a href="#redis-connection">27.1. Connecting to Redis</a>
<ul class="sectlevel3">
<li><a href="#using-redisconnectionfactory">27.1.1. Using <code>RedisConnectionFactory</code></a></li>
<li><a href="#using-redistemplate">27.1.2. Using <code>RedisTemplate</code></a></li>
</ul>
</li>
<li><a href="#redis-messages">27.2. Messaging with Redis</a>
<ul class="sectlevel3">
<li><a href="#redis-pub-sub-channel">27.2.1. Redis Publish/Subscribe channel</a></li>
<li><a href="#redis-inbound-channel-adapter">27.2.2. Redis Inbound Channel Adapter</a></li>
<li><a href="#redis-outbound-channel-adapter">27.2.3. Redis Outbound Channel Adapter</a></li>
<li><a href="#redis-queue-inbound-channel-adapter">27.2.4. Redis Queue Inbound Channel Adapter</a></li>
<li><a href="#redis-queue-outbound-channel-adapter">27.2.5. Redis Queue Outbound Channel Adapter</a></li>
<li><a href="#redis-application-events">27.2.6. Redis Application Events</a></li>
</ul>
</li>
<li><a href="#redis-message-store">27.3. Redis Message Store</a>
<ul class="sectlevel3">
<li><a href="#redis-cms">27.3.1. Redis Channel Message Stores</a></li>
</ul>
</li>
<li><a href="#redis-metadata-store">27.4. Redis Metadata Store</a></li>
<li><a href="#redis-store-inbound-channel-adapter">27.5. Redis Store Inbound Channel Adapter</a></li>
<li><a href="#redis-store-outbound-channel-adapter">27.6. RedisStore Outbound Channel Adapter</a></li>
<li><a href="#redis-outbound-gateway">27.7. Redis Outbound Command Gateway</a></li>
<li><a href="#redis-queue-outbound-gateway">27.8. Redis Queue Outbound Gateway</a></li>
<li><a href="#redis-queue-inbound-gateway">27.9. Redis Queue Inbound Gateway</a></li>
<li><a href="#redis-lock-registry">27.10. Redis Lock Registry</a></li>
</ul>
</li>
<li><a href="#resource">28. Resource Support</a>
<ul class="sectlevel2">
<li><a href="#resource-inbound-channel-adapter">28.1. Resource Inbound Channel Adapter</a></li>
</ul>
</li>
<li><a href="#rmi">29. RMI Support</a>
<ul class="sectlevel2">
<li><a href="#rmi-outbound">29.1. Outbound RMI</a></li>
<li><a href="#rmi-inbound">29.2. Inbound RMI</a></li>
<li><a href="#rmi-namespace">29.3. RMI namespace support</a></li>
<li><a href="#configuring-with-java-configuration-20">29.4. Configuring with Java Configuration</a></li>
</ul>
</li>
<li><a href="#sftp">30. SFTP Adapters</a>
<ul class="sectlevel2">
<li><a href="#sftp-session-factory">30.1. SFTP Session Factory</a>
<ul class="sectlevel3">
<li><a href="#sftp-session-factory-properties">30.1.1. Configuration Properties</a></li>
</ul>
</li>
<li><a href="#sftp-proxy-factory-bean">30.2. Proxy Factory Bean</a></li>
<li><a href="#sftp-dsf">30.3. Delegating Session Factory</a></li>
<li><a href="#sftp-session-caching">30.4. SFTP Session Caching</a></li>
<li><a href="#sftp-rft">30.5. Using <code>RemoteFileTemplate</code></a></li>
<li><a href="#sftp-inbound">30.6. SFTP Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#more-on-file-filtering-and-large-files">30.6.1. More on File Filtering and Large Files</a></li>
<li><a href="#recovering-from-failures-2">30.6.2. Recovering from Failures</a></li>
<li><a href="#configuring-with-java-configuration-21">30.6.3. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-21">30.6.4. Configuring with the Java DSL</a></li>
<li><a href="#sftp-incomplete">30.6.5. Dealing With Incomplete Data</a></li>
</ul>
</li>
<li><a href="#sftp-streaming">30.7. SFTP Streaming Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#sftp-streaming-java-config">30.7.1. Configuring with Java Configuration</a></li>
</ul>
</li>
<li><a href="#sftp-rotating-server-advice">30.8. Inbound Channel Adapters: Polling Multiple Servers and Directories</a></li>
<li><a href="#sftp-max-fetch">30.9. Inbound Channel Adapters: Controlling Remote File Fetching</a></li>
<li><a href="#sftp-outbound">30.10. SFTP Outbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#spel-and-the-sftp-outbound-adapter">30.10.1. SpEL and the SFTP Outbound Adapter</a></li>
<li><a href="#avoiding-partially-written-files-2">30.10.2. Avoiding Partially Written Files</a></li>
<li><a href="#configuring-with-java-configuration-22">30.10.3. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-22">30.10.4. Configuring with the Java DSL</a></li>
</ul>
</li>
<li><a href="#sftp-outbound-gateway">30.11. SFTP Outbound Gateway</a>
<ul class="sectlevel3">
<li><a href="#using-the-ls-command">30.11.1. Using the <code>ls</code> Command</a></li>
<li><a href="#using-the-get-command-2">30.11.2. Using the <code>get</code> Command</a></li>
<li><a href="#using-the-mget-command-2">30.11.3. Using the <code>mget</code> Command</a></li>
<li><a href="#sftp-put-command">30.11.4. Using the <code>put</code> Command</a></li>
<li><a href="#using-the-mput-command">30.11.5. Using the <code>mput</code> Command</a></li>
<li><a href="#using-the-mv-command-2">30.11.6. Using the <code>mv</code> Command</a></li>
<li><a href="#additional-command-information">30.11.7. Additional Command Information</a></li>
<li><a href="#configuring-with-java-configuration-23">30.11.8. Configuring with Java Configuration</a></li>
<li><a href="#configuring-with-the-java-dsl-23">30.11.9. Configuring with the Java DSL</a></li>
<li><a href="#sftp-partial">30.11.10. Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a></li>
</ul>
</li>
<li><a href="#sftp-jsch-logging">30.12. SFTP/JSCH Logging</a></li>
<li><a href="#sftp-session-callback">30.13. MessageSessionCallback</a></li>
</ul>
</li>
<li><a href="#stomp">31. STOMP Support</a>
<ul class="sectlevel2">
<li><a href="#stomp-overview">31.1. Overview</a></li>
<li><a href="#stomp-inbound-adapter">31.2. STOMP Inbound Channel Adapter</a></li>
<li><a href="#stomp-outbound-adapter">31.3. STOMP Outbound Channel Adapter</a></li>
<li><a href="#stomp-headers">31.4. STOMP Headers Mapping</a></li>
<li><a href="#stomp-events">31.5. STOMP Integration Events</a></li>
<li><a href="#stomp-java-config">31.6. STOMP Adapters Java Configuration</a></li>
<li><a href="#stomp-namespace">31.7. STOMP Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#stomp-outbound-channel-adapter">31.7.1. Understanding the <code>&lt;int-stomp:outbound-channel-adapter&gt;</code> Element</a></li>
<li><a href="#understanding-the-int-stompinbound-channel-adapter-element">31.7.2. Understanding the <code>&lt;int-stomp:inbound-channel-adapter&gt;</code> Element</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stream">32. Stream Support</a>
<ul class="sectlevel2">
<li><a href="#stream-reading">32.1. Reading from Streams</a></li>
<li><a href="#stream-writing">32.2. Writing to Streams</a></li>
<li><a href="#stream-namespace">32.3. Stream Namespace Support</a></li>
</ul>
</li>
<li><a href="#syslog">33. Syslog Support</a>
<ul class="sectlevel2">
<li><a href="#syslog-inbound-adapter">33.1. Syslog Inbound Channel Adapter</a>
<ul class="sectlevel3">
<li><a href="#syslog-inbound-examplers">33.1.1. Example Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ip">34. TCP and UDP Support</a>
<ul class="sectlevel2">
<li><a href="#ip-intro">34.1. Introduction</a></li>
<li><a href="#udp-adapters">34.2. UDP Adapters</a>
<ul class="sectlevel3">
<li><a href="#outbound-udp-adapters-xml-configuration">34.2.1. Outbound UDP Adapters (XML Configuration)</a></li>
<li><a href="#outbound-udp-adapters-java-configuration">34.2.2. Outbound UDP Adapters (Java Configuration)</a></li>
<li><a href="#outbound-udp-adapters-java-dsl-configuration">34.2.3. Outbound UDP Adapters (Java DSL Configuration)</a></li>
<li><a href="#inbound-udp-adapters-xml-configuration">34.2.4. Inbound UDP Adapters (XML Configuration)</a></li>
<li><a href="#inbound-udp-adapters-java-configuration">34.2.5. Inbound UDP Adapters (Java Configuration)</a></li>
<li><a href="#inbound-udp-adapters-java-dsl-configuration">34.2.6. Inbound UDP Adapters (Java DSL Configuration)</a></li>
<li><a href="#server-listening-events">34.2.7. Server Listening Events</a></li>
<li><a href="#advanced-outbound-configuration">34.2.8. Advanced Outbound Configuration</a></li>
</ul>
</li>
<li><a href="#tcp-connection-factories">34.3. TCP Connection Factories</a>
<ul class="sectlevel3">
<li><a href="#overview-3">34.3.1. Overview</a></li>
<li><a href="#message-demarcation-serializers-and-deserializers">34.3.2. Message Demarcation (Serializers and Deserializers)</a></li>
<li><a href="#custom-serializers-and-deserializers">34.3.3. Custom Serializers and Deserializers</a></li>
<li><a href="#caching-cf">34.3.4. TCP Caching Client Connection Factory</a></li>
<li><a href="#failover-cf">34.3.5. TCP Failover Client Connection Factory</a></li>
<li><a href="#tcp-affinity-cf">34.3.6. TCP Thread Affinity Connection Factory</a></li>
</ul>
</li>
<li><a href="#ip-interceptors">34.4. TCP Connection Interceptors</a></li>
<li><a href="#tcp-events">34.5. TCP Connection Events</a></li>
<li><a href="#tcp-adapters">34.6. TCP Adapters</a></li>
<li><a href="#tcp-gateways">34.7. TCP Gateways</a></li>
<li><a href="#ip-correlation">34.8. TCP Message Correlation</a>
<ul class="sectlevel3">
<li><a href="#ip-gateways">34.8.1. Gateways</a></li>
<li><a href="#ip-collaborating-adapters">34.8.2. Collaborating Outbound and Inbound Channel Adapters</a></li>
<li><a href="#ip-headers">34.8.3. Transferring Headers</a></li>
</ul>
</li>
<li><a href="#note_nio">34.9. About Non-blocking I/O (NIO)</a>
<ul class="sectlevel3">
<li><a href="#pool-size">34.9.1. Pool Size</a></li>
<li><a href="#io-thread-pool-task-executor-caller-runs">34.9.2. Thread Pool Task Executor with <code>CALLER_RUNS</code> Policy</a></li>
</ul>
</li>
<li><a href="#ssl-tls">34.10. SSL/TLS Support</a>
<ul class="sectlevel3">
<li><a href="#ip-ssl-tls-getting-started">34.10.1. Getting Started</a></li>
<li><a href="#tcp-ssl-host-verification">34.10.2. Host Verification</a></li>
</ul>
</li>
<li><a href="#tcp-advanced-techniques">34.11. Advanced Techniques</a>
<ul class="sectlevel3">
<li><a href="#strategy-interfaces">34.11.1. Strategy Interfaces</a>
<ul class="sectlevel4">
<li><a href="#the-tcpsslcontextsupport-strategy-interface">The <code>TcpSSLContextSupport</code> Strategy Interface</a></li>
<li><a href="#the-tcpsocketfactorysupport-strategy-interface">The <code>TcpSocketFactorySupport</code> Strategy Interface</a></li>
<li><a href="#the-tcpsocketsupport-strategy-interface">The <code>TcpSocketSupport</code> Strategy Interface</a></li>
<li><a href="#the-tcpnetconnectionsupport-strategy-interface">The <code>TcpNetConnectionSupport</code> Strategy Interface</a></li>
<li><a href="#the-tcpnioconnectionsupport-strategy-interface">The <code>TcpNioConnectionSupport</code> Strategy Interface</a></li>
</ul>
</li>
<li><a href="#ssl-client-authentication-example">34.11.2. Example: Enabling SSL Client Authentication</a></li>
</ul>
</li>
<li><a href="#ip-endpoint-reference">34.12. IP Configuration Attributes</a></li>
<li><a href="#ip-msg-headers">34.13. IP Message Headers</a></li>
<li><a href="#ip-annotation">34.14. Annotation-Based Configuration</a></li>
</ul>
</li>
<li><a href="#webflux">35. WebFlux Support</a>
<ul class="sectlevel2">
<li><a href="#webflux-inbound">35.1. WebFlux Inbound Components</a></li>
<li><a href="#webflux-outbound">35.2. WebFlux Outbound Components</a></li>
<li><a href="#webflux-namespace">35.3. WebFlux Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#inbound-3">35.3.1. Inbound</a></li>
<li><a href="#outbound-3">35.3.2. Outbound</a></li>
</ul>
</li>
<li><a href="#webflux-java-config">35.4. Configuring WebFlux Endpoints with Java</a></li>
<li><a href="#webflux-header-mapping">35.5. WebFlux Header Mappings</a></li>
</ul>
</li>
<li><a href="#web-sockets">36. WebSockets Support</a>
<ul class="sectlevel2">
<li><a href="#web-socket-overview">36.1. Overview</a></li>
<li><a href="#web-socket-inbound-adapter">36.2. WebSocket Inbound Channel Adapter</a></li>
<li><a href="#web-socket-outbound-adapter">36.3. WebSocket Outbound Channel Adapter</a></li>
<li><a href="#web-sockets-namespace">36.4. WebSockets Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#websocket-client-container-attributes">36.4.1. <code>&lt;int-websocket:client-container&gt;</code> Attributes</a></li>
<li><a href="#int-websocketserver-container-attributes">36.4.2. <code>&lt;int-websocket:server-container&gt;</code> Attributes</a></li>
<li><a href="#websocket-outbound-channel-adapter-attributes">36.4.3. <code>&lt;int-websocket:outbound-channel-adapter&gt;</code> Attributes</a></li>
<li><a href="#int-websocketinbound-channel-adapter-attributes">36.4.4. <code>&lt;int-websocket:inbound-channel-adapter&gt;</code> Attributes</a></li>
</ul>
</li>
<li><a href="#client-stomp-encoder">36.5. Using <code>ClientStompEncoder</code></a></li>
</ul>
</li>
<li><a href="#ws">37. Web Services Support</a>
<ul class="sectlevel2">
<li><a href="#webservices-outbound">37.1. Outbound Web Service Gateways</a></li>
<li><a href="#webservices-inbound">37.2. Inbound Web Service Gateways</a></li>
<li><a href="#webservices-namespace">37.3. Web Service Namespace Support</a></li>
<li><a href="#outbound-uri">37.4. Outbound URI Configuration</a>
<ul class="sectlevel3">
<li><a href="#controlling-uri-encoding-2">37.4.1. Controlling URI Encoding</a></li>
</ul>
</li>
<li><a href="#ws-message-headers">37.5. WS Message Headers</a></li>
<li><a href="#mtom-support">37.6. MTOM Support</a></li>
</ul>
</li>
<li><a href="#xml">38. XML Support - Dealing with XML Payloads</a>
<ul class="sectlevel2">
<li><a href="#xpath-namespace-support">38.1. Namespace Support</a>
<ul class="sectlevel3">
<li><a href="#xml-xpath-expressions">38.1.1. XPath Expressions</a>
<ul class="sectlevel4">
<li><a href="#providing-namespaces-optional-to-xpath-expressions">Providing Namespaces (Optional) to XPath Expressions</a></li>
<li><a href="#using-xpath-expressions-with-default-namespaces">Using XPath Expressions with Default Namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xml-transformation">38.2. Transforming XML Payloads</a>
<ul class="sectlevel3">
<li><a href="#xml-transformation-beans">38.2.1. Configuring Transformers as Beans</a>
<ul class="sectlevel4">
<li><a href="#xml-unmarshalling-transformer">UnmarshallingTransformer</a></li>
<li><a href="#xml-marshalling-transformer">Using <code>MarshallingTransformer</code></a></li>
<li><a href="#xml-xslt-payload-transformers">XsltPayloadTransformer</a></li>
<li><a href="#xml-using-result-transformers">Using <code>ResultTransformer</code> Implementations</a></li>
</ul>
</li>
<li><a href="#xml-transformer-namespace">38.2.2. Namespace Support for XML Transformers</a>
<ul class="sectlevel4">
<li><a href="#using-an-unmarshallingtransformer">Using an <code>UnmarshallingTransformer</code></a></li>
<li><a href="#using-a-marshallingtransformer">Using a <code>MarshallingTransformer</code></a></li>
<li><a href="#using-an-xsltpayloadtransformer">Using an <code>XsltPayloadTransformer</code></a></li>
</ul>
</li>
<li><a href="#xml-using-result-transformers-namespace">38.2.3. Namespace Configuration and Result Transformers</a>
<ul class="sectlevel4">
<li><a href="#xsltpayloadtransformer-and-xsloutput-methodtext"><code>XsltPayloadTransformer</code> and <code>&lt;xsl:output method="text"/&gt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xml-xpath-transformer">38.3. Transforming XML Messages with XPath</a>
<ul class="sectlevel3">
<li><a href="#simple-xpath-transformation">38.3.1. Simple XPath Transformation</a></li>
<li><a href="#node-mappers">38.3.2. Node Mappers</a></li>
<li><a href="#xml-payload-converter">38.3.3. XML Payload Converter</a></li>
</ul>
</li>
<li><a href="#xml-xpath-splitting">38.4. Splitting XML Messages</a></li>
<li><a href="#xml-xpath-routing">38.5. Routing XML Messages with XPath</a>
<ul class="sectlevel3">
<li><a href="#xpath-routing-converter">38.5.1. XML Payload Converter</a></li>
</ul>
</li>
<li><a href="#xml-xpath-header-enricher">38.6. XPath Header Enricher</a></li>
<li><a href="#xml-xpath-filter">38.7. Using the XPath Filter</a></li>
<li><a href="#xpath-spel-function">38.8. #xpath SpEL Function</a></li>
<li><a href="#xml-validating-filter">38.9. XML Validating Filter</a></li>
</ul>
</li>
<li><a href="#xmpp">39. XMPP Support</a>
<ul class="sectlevel2">
<li><a href="#xmpp-connection">39.1. XMPP Connection</a></li>
<li><a href="#xmpp-messages">39.2. XMPP Messages</a>
<ul class="sectlevel3">
<li><a href="#xmpp-message-inbound-channel-adapter">39.2.1. Inbound Message Channel Adapter</a></li>
<li><a href="#xmpp-message-outbound-channel-adapter">39.2.2. Outbound Message Channel Adapter</a></li>
</ul>
</li>
<li><a href="#xmpp-presence">39.3. XMPP Presence</a>
<ul class="sectlevel3">
<li><a href="#xmpp-roster-inbound-channel-adapter">39.3.1. Inbound Presence Message Channel Adapter</a></li>
<li><a href="#xmpp-roster-outbound-channel-adapter">39.3.2. Outbound Presence Message Channel Adapter</a></li>
</ul>
</li>
<li><a href="#xmpp-advanced">39.4. Advanced Configuration</a></li>
<li><a href="#xmpp-message-headers">39.5. XMPP Message Headers</a></li>
<li><a href="#xmpp-extensions">39.6. XMPP Extensions</a></li>
</ul>
</li>
<li><a href="#zookeeper">40. Zookeeper Support</a>
<ul class="sectlevel2">
<li><a href="#zk-metadata-store">40.1. Zookeeper Metadata Store</a></li>
<li><a href="#zk-lock-registry">40.2. Zookeeper Lock Registry</a></li>
<li><a href="#zk-leadership">40.3. Zookeeper Leadership Event Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-integration-appendices">Appendices</a>
<ul class="sectlevel1">
<li><a href="#spel">Appendix A: Spring Expression Language (SpEL)</a>
<ul class="sectlevel2">
<li><a href="#spel-customization">A.1. SpEL Evaluation Context Customization</a></li>
<li><a href="#spel-functions">A.2. SpEL Functions</a>
<ul class="sectlevel3">
<li><a href="#built-in-spel-functions">A.2.1. Built-in SpEL Functions</a></li>
</ul>
</li>
<li><a href="#spel-property-accessors">A.3. Property Accessors</a></li>
</ul>
</li>
<li><a href="#message-publishing">Appendix B: Message Publishing</a>
<ul class="sectlevel2">
<li><a href="#message-publishing-config">B.1. Message Publishing Configuration</a>
<ul class="sectlevel3">
<li><a href="#publisher-annotation">B.1.1. Annotation-driven Configuration with the <code>@Publisher</code> Annotation</a></li>
<li><a href="#aop-based-interceptor">B.1.2. XML-based Approach with the <code>&lt;publishing-interceptor&gt;</code> element</a>
<ul class="sectlevel4">
<li><a href="#asynchronous-publishing">Asynchronous Publishing</a></li>
</ul>
</li>
<li><a href="#scheduled-producer">B.1.3. Producing and Publishing Messages Based on a Scheduled Trigger</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#transactions">Appendix C: Transaction Support</a>
<ul class="sectlevel2">
<li><a href="#understanding-transaction">C.1. Understanding Transactions in Message flows</a>
<ul class="sectlevel3">
<li><a href="#transaction-poller">C.1.1. Poller Transaction Support</a></li>
</ul>
</li>
<li><a href="#transaction-boundaries">C.2. Transaction Boundaries</a></li>
<li><a href="#transaction-synchronization">C.3. Transaction Synchronization</a></li>
<li><a href="#pseudo-transactions">C.4. Pseudo Transactions</a></li>
</ul>
</li>
<li><a href="#security">Appendix D: Security in Spring Integration</a>
<ul class="sectlevel2">
<li><a href="#securing-channels">D.1. Securing channels</a></li>
<li><a href="#security-context-propagation">D.2. Security Context Propagation</a></li>
</ul>
</li>
<li><a href="#configuration">Appendix E: Configuration</a>
<ul class="sectlevel2">
<li><a href="#configuration-namespace">E.1. Namespace Support</a></li>
<li><a href="#namespace-taskscheduler">E.2. Configuring the Task Scheduler</a></li>
<li><a href="#namespace-errorhandler">E.3. Error Handling</a></li>
<li><a href="#global-properties">E.4. Global Properties</a></li>
<li><a href="#annotations">E.5. Annotation Support</a>
<ul class="sectlevel3">
<li><a href="#configuration-using-poller-annotation">E.5.1. Using the <code>@Poller</code> Annotation</a></li>
<li><a href="#using-the-inboundchanneladapter-annotation">E.5.2. Using the <code>@InboundChannelAdapter</code> Annotation</a></li>
<li><a href="#using-the-integrationcomponentscan-annotation">E.5.3. Using the <code>@IntegrationComponentScan</code> Annotation</a></li>
</ul>
</li>
<li><a href="#meta-annotations">E.6. Messaging Meta-Annotations</a>
<ul class="sectlevel3">
<li><a href="#annotations_on_beans">E.6.1. Annotations on <code>@Bean</code> Methods</a></li>
<li><a href="#creating-a-bridge-with-annotations">E.6.2. Creating a Bridge with Annotations</a></li>
<li><a href="#advising-annotated-endpoints">E.6.3. Advising Annotated Endpoints</a></li>
</ul>
</li>
<li><a href="#message-mapping-rules">E.7. Message Mapping Rules and Conventions</a>
<ul class="sectlevel3">
<li><a href="#sample-scenarios">E.7.1. Sample Scenarios</a></li>
<li><a href="#annotation-based-mapping">E.7.2. Annotation-based Mapping</a></li>
<li><a href="#complex-scenarios">E.7.3. Complex Scenarios</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing">Appendix F: Testing support</a>
<ul class="sectlevel2">
<li><a href="#testing-utilities">F.1. Testing Utilities</a>
<ul class="sectlevel3">
<li><a href="#testutils">F.1.1. TestUtils</a></li>
<li><a href="#using-the-socketutils-class">F.1.2. Using the <code>SocketUtils</code> Class</a></li>
<li><a href="#using-onlyoncetrigger">F.1.3. Using <code>OnlyOnceTrigger</code></a></li>
<li><a href="#support-components">F.1.4. Support Components</a></li>
<li><a href="#test-junit-rules">F.1.5. JUnit Rules and Conditions</a></li>
<li><a href="#hamcrest-and-mockito-matchers">F.1.6. Hamcrest and Mockito Matchers</a></li>
</ul>
</li>
<li><a href="#test-context">F.2. Spring Integration and the Test Context</a></li>
<li><a href="#testing-mocks">F.3. Integration Mocks</a>
<ul class="sectlevel3">
<li><a href="#mockintegration">F.3.1. MockIntegration</a></li>
</ul>
</li>
<li><a href="#testing-other-resources">F.4. Other Resources</a></li>
</ul>
</li>
<li><a href="#samples">Appendix G: Spring Integration Samples</a>
<ul class="sectlevel2">
<li><a href="#samples-get">G.1. Where to Get Samples</a></li>
<li><a href="#submitting-samples-or-sample-requests">G.2. Submitting Samples or Sample Requests</a>
<ul class="sectlevel3">
<li><a href="#samples-how-can-i-contribute">G.2.1. How Can I Contribute My Own Samples?</a></li>
<li><a href="#code-contribution-process">G.2.2. Code Contribution Process</a></li>
<li><a href="#sample-requests">G.2.3. Sample Requests</a></li>
</ul>
</li>
<li><a href="#samples-structure">G.3. Samples Structure</a></li>
<li><a href="#samples-impl">G.4. Samples</a>
<ul class="sectlevel3">
<li><a href="#samples-loan-broker">G.4.1. Loan Broker</a>
<ul class="sectlevel4">
<li><a href="#design">Design</a></li>
<li><a href="#composed-message-processor">Composed Message Processor</a></li>
</ul>
</li>
<li><a href="#samples-cafe">G.4.2. The Cafe Sample</a></li>
<li><a href="#samples-xml-messaging">G.4.3. The XML Messaging Sample</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">Appendix H: Additional Resources</a></li>
<li><a href="#history">Appendix I: Change History</a>
<ul class="sectlevel2">
<li><a href="#migration-4.3-5.0">I.1. Changes between 4.3 and 5.0</a></li>
<li><a href="#x5.0-new-components">I.2. New Components</a>
<ul class="sectlevel3">
<li><a href="#java-dsl-2">I.2.1. Java DSL</a></li>
<li><a href="#testing-support">I.2.2. Testing Support</a></li>
<li><a href="#mongodb-outbound-gateway-2">I.2.3. MongoDB Outbound Gateway</a></li>
<li><a href="#webflux-gateways-and-channel-adapters">I.2.4. WebFlux Gateways and Channel Adapters</a></li>
<li><a href="#content-type-conversion-2">I.2.5. Content Type Conversion</a></li>
<li><a href="#errormessagepublisher-and-errormessagestrategy">I.2.6. <code>ErrorMessagePublisher</code> and <code>ErrorMessageStrategy</code></a></li>
<li><a href="#jdbc-metadata-store-2">I.2.7. JDBC Metadata Store</a></li>
</ul>
</li>
<li><a href="#x5.0-general">I.3. General Changes</a>
<ul class="sectlevel3">
<li><a href="#core-changes">I.3.1. Core Changes</a></li>
<li><a href="#gateway-changes">I.3.2. Gateway Changes</a></li>
<li><a href="#aggregator-performance-changes">I.3.3. Aggregator Performance Changes</a></li>
<li><a href="#splitter-changes">I.3.4. Splitter Changes</a></li>
<li><a href="#jms-changes">I.3.5. JMS Changes</a></li>
<li><a href="#mail-changes">I.3.6. Mail Changes</a></li>
<li><a href="#feed-changes">I.3.7. Feed Changes</a></li>
<li><a href="#file-changes">I.3.8. File Changes</a></li>
<li><a href="#ftp-and-sftp-changes">I.3.9. FTP and SFTP Changes</a></li>
<li><a href="#integration-properties">I.3.10. Integration Properties</a></li>
<li><a href="#stream-changes">I.3.11. Stream Changes</a></li>
<li><a href="#barrier-changes">I.3.12. Barrier Changes</a></li>
<li><a href="#amqp-changes">I.3.13. AMQP Changes</a></li>
<li><a href="#http-changes">I.3.14. HTTP Changes</a></li>
<li><a href="#mqtt-changes">I.3.15. MQTT Changes</a></li>
<li><a href="#stomp-changes">I.3.16. STOMP Changes</a></li>
<li><a href="#web-services-changes">I.3.17. Web Services Changes</a></li>
<li><a href="#redis-changes">I.3.18. Redis Changes</a></li>
<li><a href="#tcp-changes">I.3.19. TCP Changes</a></li>
<li><a href="#gemfire-changes">I.3.20. Gemfire Changes</a></li>
<li><a href="#jdbc-changes">I.3.21. JDBC Changes</a></li>
<li><a href="#metrics-changes">I.3.22. Metrics Changes</a></li>
<li><a href="#endpointid-annotations">I.3.23. <code>@EndpointId</code> Annotations</a></li>
</ul>
</li>
<li><a href="#migration-4.2-4.3">I.4. Changes between 4.2 and 4.3</a></li>
<li><a href="#x4.3-new-components">I.5. New Components</a>
<ul class="sectlevel3">
<li><a href="#amqp-async-outbound-gateway-2">I.5.1. AMQP Async Outbound Gateway</a></li>
<li><a href="#messagegroupfactory">I.5.2. <code>MessageGroupFactory</code></a></li>
<li><a href="#persistentmessagegroup">I.5.3. <code>PersistentMessageGroup</code></a></li>
<li><a href="#ftp-and-sftp-streaming-inbound-channel-adapters">I.5.4. FTP and SFTP Streaming Inbound Channel Adapters</a></li>
<li><a href="#streamtransformer">I.5.5. <code>StreamTransformer</code></a></li>
<li><a href="#integration-graph-2">I.5.6. Integration Graph</a></li>
<li><a href="#jdbc-lock-registry-2">I.5.7. JDBC Lock Registry</a></li>
<li><a href="#leaderinitiator-for-lockregistry">I.5.8. <code>LeaderInitiator</code> for <code>LockRegistry</code></a></li>
</ul>
</li>
<li><a href="#x4.3-general">I.6. General Changes</a>
<ul class="sectlevel3">
<li><a href="#core-changes-2">I.6.1. Core Changes</a>
<ul class="sectlevel4">
<li><a href="#outbound-gateway-within-a-chain">Outbound Gateway within a Chain</a></li>
<li><a href="#asynchronous-service-activator">Asynchronous Service Activator</a></li>
<li><a href="#messaging-annotation-support-changes">Messaging Annotation Support changes</a></li>
</ul>
</li>
<li><a href="#mail-changes-2">I.6.2. Mail Changes</a>
<ul class="sectlevel4">
<li><a href="#customizable-user-flag">Customizable User Flag</a></li>
<li><a href="#mail-message-mapping">Mail Message Mapping</a></li>
</ul>
</li>
<li><a href="#jms-changes-2">I.6.3. JMS Changes</a>
<ul class="sectlevel4">
<li><a href="#header-mapper">Header Mapper</a></li>
<li><a href="#asynchronous-gateway">Asynchronous Gateway</a></li>
</ul>
</li>
<li><a href="#aggregator-changes">I.6.4. Aggregator Changes</a></li>
<li><a href="#tcpudp-changes">I.6.5. TCP/UDP Changes</a>
<ul class="sectlevel4">
<li><a href="#events">Events</a></li>
<li><a href="#stream-deserializers">Stream Deserializers</a></li>
<li><a href="#tcp-message-mapper">TCP Message Mapper</a></li>
</ul>
</li>
<li><a href="#file-changes-2">I.6.6. File Changes</a>
<ul class="sectlevel4">
<li><a href="#destination-directory-creation">Destination Directory Creation</a></li>
<li><a href="#buffer-size">Buffer Size</a></li>
<li><a href="#appending-and-flushing">Appending and Flushing</a></li>
<li><a href="#preserving-timestamps">Preserving Timestamps</a></li>
<li><a href="#splitter-changes-2">Splitter Changes</a></li>
<li><a href="#file-filters">File Filters</a></li>
</ul>
</li>
<li><a href="#amqp-changes-2">I.6.7. AMQP Changes</a>
<ul class="sectlevel4">
<li><a href="#content-type-message-converter">Content Type Message Converter</a></li>
<li><a href="#headers-for-delayed-message-handling">Headers for Delayed Message Handling</a></li>
<li><a href="#amqp-backed-channels">AMQP-Backed Channels</a></li>
</ul>
</li>
<li><a href="#redis-changes-2">I.6.8. Redis Changes</a>
<ul class="sectlevel4">
<li><a href="#list-pushpop-direction">List Push/Pop Direction</a></li>
<li><a href="#queue-inbound-gateway-default-serializer">Queue Inbound Gateway Default Serializer</a></li>
</ul>
</li>
<li><a href="#http-changes-2">I.6.9. HTTP Changes</a></li>
<li><a href="#sftp-changes">I.6.10. SFTP Changes</a>
<ul class="sectlevel4">
<li><a href="#factory-bean">Factory Bean</a></li>
<li><a href="#chmod-changes"><code>chmod</code> Changes</a></li>
</ul>
</li>
<li><a href="#ftp-changes">I.6.11. FTP Changes</a>
<ul class="sectlevel4">
<li><a href="#session-changes">Session Changes</a></li>
</ul>
</li>
<li><a href="#router-changes">I.6.12. Router Changes</a></li>
<li><a href="#header-mapping">I.6.13. Header Mapping</a>
<ul class="sectlevel4">
<li><a href="#general">General</a></li>
<li><a href="#amqp-header-mapping">AMQP Header Mapping</a></li>
</ul>
</li>
<li><a href="#groovy-scripts">I.6.14. Groovy Scripts</a></li>
<li><a href="#inboundchanneladapter-changes">I.6.15. <code>@InboundChannelAdapter</code> Changes</a></li>
<li><a href="#xmpp-changes">I.6.16. XMPP Changes</a></li>
<li><a href="#wiretap-late-binding">I.6.17. WireTap Late Binding</a></li>
<li><a href="#channelmessagestorequeryprovider-changes">I.6.18. <code>ChannelMessageStoreQueryProvider</code> Changes</a></li>
<li><a href="#websocket-changes">I.6.19. WebSocket Changes</a></li>
</ul>
</li>
<li><a href="#migration-4.1-4.2">I.7. Changes between 4.1 and 4.2</a></li>
<li><a href="#x4.2-new-components">I.8. New Components</a>
<ul class="sectlevel3">
<li><a href="#x4.2-JMX">I.8.1. Major Management/JMX Rework</a></li>
<li><a href="#x4.2-mongodb-metadata-store">I.8.2. MongoDB Metadata Store</a></li>
<li><a href="#x4.2-secured-channel-annotation">I.8.3. SecuredChannel Annotation</a></li>
<li><a href="#x4.2-security-context-propagation">I.8.4. <code>SecurityContext</code> Propagation</a></li>
<li><a href="#x4.2-file-splitter">I.8.5. FileSplitter</a></li>
<li><a href="#x4.2-zk">I.8.6. Zookeeper Support</a></li>
<li><a href="#x4.2-barrier">I.8.7. Thread Barrier</a></li>
<li><a href="#x4.2-stomp">I.8.8. STOMP Support</a></li>
<li><a href="#x4.2-codec">I.8.9. Codec</a></li>
<li><a href="#x4.2-prepared-statement-setter">I.8.10. Message PreparedStatement Setter</a></li>
</ul>
</li>
<li><a href="#x4.2-general">I.9. General Changes</a>
<ul class="sectlevel3">
<li><a href="#x4.2-wire-tap">I.9.1. WireTap</a></li>
<li><a href="#x4.2-file-changes">I.9.2. File Changes</a>
<ul class="sectlevel4">
<li><a href="#appending-new-lines">Appending New Lines</a></li>
<li><a href="#ignoring-hidden-files">Ignoring Hidden Files</a></li>
<li><a href="#writing-inputstream-payloads">Writing <code>InputStream</code> Payloads</a></li>
<li><a href="#headdirectoryscanner"><code>HeadDirectoryScanner</code></a></li>
<li><a href="#last-modified-filter">Last Modified Filter</a></li>
<li><a href="#watch-service-directory-scanner-2">Watch Service Directory Scanner</a></li>
<li><a href="#persistent-file-list-filter-changes">Persistent File List Filter Changes</a></li>
</ul>
</li>
<li><a href="#x4.2-class-package-change">I.9.3. Class Package Change</a></li>
<li><a href="#tcp-changes-2">I.9.4. TCP Changes</a>
<ul class="sectlevel4">
<li><a href="#x4.2-tcp-serializers">TCP Serializers</a></li>
<li><a href="#x4.2-tcp-server-exceptions">Server Socket Exceptions</a></li>
<li><a href="#x4.2-tcp-server-port">TCP Server Port</a></li>
<li><a href="#x4.2-tcp-gw-rto">TCP Gateway Remote Timeout</a></li>
<li><a href="#x4.2-tcp-ssl">TCP SSLSession Available for Header Mapping</a></li>
<li><a href="#x4.2-tcp-events">TCP Events</a></li>
</ul>
</li>
<li><a href="#x4.2-inbound-channel-adapter-annotation">I.9.5. <code>@InboundChannelAdapter</code> Changes</a></li>
<li><a href="#x4.2-api-changes">I.9.6. API Changes</a></li>
<li><a href="#x4.2-jms-changes">I.9.7. JMS Changes</a>
<ul class="sectlevel4">
<li><a href="#reply-listener-lazy-initialization">Reply Listener Lazy Initialization</a></li>
<li><a href="#conversion-errors-in-message-driven-endpoints">Conversion Errors in Message-Driven Endpoints</a></li>
<li><a href="#default-acknowledge-mode">Default Acknowledge Mode</a></li>
<li><a href="#shared-subscriptions">Shared Subscriptions</a></li>
</ul>
</li>
<li><a href="#x4.2-conditional-pollers">I.9.8. Conditional Pollers</a></li>
<li><a href="#x4.2-amqp-changes">I.9.9. AMQP Changes</a>
<ul class="sectlevel4">
<li><a href="#publisher-confirmations">Publisher Confirmations</a></li>
<li><a href="#correlation-data">Correlation Data</a></li>
<li><a href="#inbound-gateway-properties">Inbound Gateway Properties</a></li>
</ul>
</li>
<li><a href="#x4.2-xpath-splitter">I.9.10. XPath Splitter Improvements</a></li>
<li><a href="#x4.2-http-changes">I.9.11. HTTP Changes</a>
<ul class="sectlevel4">
<li><a href="#cors">CORS</a></li>
<li><a href="#inbound-gateway-timeout">Inbound Gateway Timeout</a></li>
<li><a href="#form-data">Form Data</a></li>
</ul>
</li>
<li><a href="#x4.2-gw">I.9.12. Gateway Changes</a>
<ul class="sectlevel4">
<li><a href="#gateway-methods-can-return-completablefuture">Gateway Methods can Return <code>CompletableFuture&lt;?&gt;</code></a></li>
<li><a href="#messaginggateway-annotation">MessagingGateway Annotation</a></li>
</ul>
</li>
<li><a href="#x4.2-aggregator-changes">I.9.13. Aggregator Changes</a>
<ul class="sectlevel4">
<li><a href="#aggregator-performance">Aggregator Performance</a></li>
<li><a href="#output-message-group-processor">Output Message Group Processor</a></li>
</ul>
</li>
<li><a href="#ftp-and-sftp-changes-2">I.9.14. FTP and SFTP Changes</a>
<ul class="sectlevel4">
<li><a href="#inbound-channel-adapters">Inbound Channel Adapters</a></li>
<li><a href="#gateway-partial-results">Gateway Partial Results</a></li>
<li><a href="#delegating-session-factory">Delegating Session Factory</a></li>
<li><a href="#default-sftp-session-factory">Default Sftp Session Factory</a></li>
<li><a href="#message-session-callback">Message Session Callback</a></li>
</ul>
</li>
<li><a href="#websocket-changes-2">I.9.15. Websocket Changes</a></li>
<li><a href="#application-event-adapters-changes">I.9.16. Application Event Adapters changes</a></li>
</ul>
</li>
<li><a href="#migration-4.0-4.1">I.10. Changes between 4.0 and 4.1</a>
<ul class="sectlevel3">
<li><a href="#new-components">I.10.1. New Components</a>
<ul class="sectlevel4">
<li><a href="#x4.1-promise-gateway">Promise&lt;?&gt; Gateway</a></li>
<li><a href="#x4.1-web-socket-adapters">WebSocket support</a></li>
<li><a href="#x4.1-scatter-gather">Scatter-Gather Enterprise Integration Pattern</a></li>
<li><a href="#x4.1-Routing-Slip">Routing Slip Pattern</a></li>
<li><a href="#x4.1-idempotent-receiver">Idempotent Receiver Pattern</a></li>
<li><a href="#x4.1-BoonJsonObjectMapper">Boon <code>JsonObjectMapper</code></a></li>
<li><a href="#x4.1-redis-queue-gateways">Redis Queue Gateways</a></li>
<li><a href="#x4.1-PollSkipAdvice"><code>PollSkipAdvice</code></a></li>
</ul>
</li>
<li><a href="#x4.1-general">I.10.2. General Changes</a>
<ul class="sectlevel4">
<li><a href="#x4.1-amqp-inbound-missing-queues">AMQP Inbound Endpoints, Channel</a></li>
<li><a href="#x4.1-amqp-outbound-lazy-connect">AMQP Outbound Endpoints</a></li>
<li><a href="#x4.1-sms-copy-on-get">SimpleMessageStore</a></li>
<li><a href="#x4.1-ws-encode-uri">Web Service Outbound Gateway: <code>encode-uri</code></a></li>
<li><a href="#x4.1-http-status-code">Http Inbound Channel Adapter and Status Code</a></li>
<li><a href="#x4.1-mqtt">MQTT Adapter Changes</a></li>
<li><a href="#x4.1-sftp">FTP and SFTP Adapter Changes</a></li>
<li><a href="#x4.1-splitter-iterator">Splitter and Iterator</a></li>
<li><a href="#x4.1-aggregator">Aggregator</a></li>
<li><a href="#x4.1-content-enricher-improvement">Content Enricher Improvements</a></li>
<li><a href="#x4.1-header-channel-registry">Header Channel Registry</a></li>
<li><a href="#x4.1-orderly-shutdown">Orderly Shutdown</a></li>
<li><a href="#x4.1-recipientListRouter">Management for <code>RecipientListRouter</code></a></li>
<li><a href="#x4.1-AbstractHeaderMapper-changes">AbstractHeaderMapper: NON_STANDARD_HEADERS token</a></li>
<li><a href="#x4.1-amqp-channels">AMQP Channels: <code>template-channel-transacted</code></a></li>
<li><a href="#x4.1-syslog">Syslog Adapter</a></li>
<li><a href="#x4.1-async-gateway">Asynchronous Gateway</a></li>
<li><a href="#x4.1-aggregator-advice-chain">Aggregator Advice Chain</a></li>
<li><a href="#x4.1-script-outbound-channel-adapter">Outbound Channel Adapter and Scripts</a></li>
<li><a href="#x4.1-reseq">Resequencer Changes</a></li>
<li><a href="#x4.1-Optional-Parameter">Optional POJO method parameter</a></li>
<li><a href="#x4.1-queue-channel-queue.typ"><code>QueueChannel</code> backed Queue type</a></li>
<li><a href="#x4.1-channel-interceptor"><code>ChannelInterceptor</code> Changes</a></li>
<li><a href="#x4.1-mail-peek">IMAP PEEK</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migration-3.0-4.0">I.11. Changes between 3.0 and 4.0</a>
<ul class="sectlevel3">
<li><a href="#x4.0-new-components">I.11.1. New Components</a>
<ul class="sectlevel4">
<li><a href="#x4.0-mqtt">MQTT Channel Adapters</a></li>
<li><a href="#x4.0-enable-configuration"><code>@EnableIntegration</code></a></li>
<li><a href="#x4.0-component-scan"><code>@IntegrationComponentScan</code></a></li>
<li><a href="#x4.0-message-history">&#8220;@EnableMessageHistory&#8221;</a></li>
<li><a href="#x4.0-messaging-gateway"><code>@MessagingGateway</code></a></li>
<li><a href="#x4.0-boot">Spring Boot <code>@EnableAutoConfiguration</code></a></li>
<li><a href="#x4.0-global-channel-interceptor"><code>@GlobalChannelInterceptor</code></a></li>
<li><a href="#x4.0-integration-converter"><code>@IntegrationConverter</code></a></li>
<li><a href="#x4.0-enable-publisher"><code>@EnablePublisher</code></a></li>
<li><a href="#x4.0-redis-cms">Redis Channel Message Stores</a></li>
<li><a href="#x4.0-priority-channel-mondodb">MongodDB Channel Message Store</a></li>
<li><a href="#x4.0-MBeanExport-annotation"><code>@EnableIntegrationMBeanExport</code></a></li>
<li><a href="#x4.0-channel-security-interceptor"><code>ChannelSecurityInterceptorFactoryBean</code></a></li>
<li><a href="#x4.0-redis-outbound-gateway">Redis Command Gateway</a></li>
<li><a href="#x4.0-redis-gemfire-lock-registry"><code>RedisLockRegistry</code> and <code>GemfireLockRegistry</code></a></li>
<li><a href="#x4.0-poller-annotation"><code>@Poller</code></a></li>
<li><a href="#x4.0-inbound-channel-adapter-annotation"><code>@InboundChannelAdapter</code> and <code>SmartLifecycle</code> for Annotated Endpoints</a></li>
<li><a href="#x4.0-twitter-sog">Twitter Search Outbound Gateway</a></li>
<li><a href="#x4.0-gemfire-metadata">Gemfire Metadata Store</a></li>
<li><a href="#x4.0-bridge-annotations"><code>@BridgeFrom</code> and <code>@BridgeTo</code> Annotations</a></li>
<li><a href="#x4.0-meta-messaging-annotations">Meta-messaging Annotations</a></li>
</ul>
</li>
<li><a href="#x4.0-general">I.11.2. General Changes</a>
<ul class="sectlevel4">
<li><a href="#requires-spring-framework-4-0">Requires Spring Framework 4.0</a></li>
<li><a href="#x4.0-xpath-header-enricher-header-type">Header Type for XPath Header Enricher</a></li>
<li><a href="#x4.0-object-to-json-transformer-result-type">Object To JSON Transformer: Node Result</a></li>
<li><a href="#x4.0-jms-header-mapping">JMS Header Mapping</a></li>
<li><a href="#x4.0-jms-ob">JMS Outbound Channel Adapter</a></li>
<li><a href="#x4.0-jms-ib">JMS Inbound Channel Adapter</a></li>
<li><a href="#x4.0-datatype-channel">Datatype Channels</a></li>
<li><a href="#x4.0-retry-config">Simpler Retry Advice Configuration</a></li>
<li><a href="#x4.0-release-strategy-group-timeout">Correlation Endpoint: Time-based Release Strategy</a></li>
<li><a href="#x4.0-redis-metadata">Redis Metadata Store</a></li>
<li><a href="#x4.0-jdbc-cs"><code>JdbcChannelMessageStore</code> and <code>PriorityChannel</code></a></li>
<li><a href="#x4.0-amqp">AMQP Endpoints Delivery Mode</a></li>
<li><a href="#x4.0-ftp">FTP Timeouts</a></li>
<li><a href="#x4.0-twitter-status-updating">Twitter: <code>StatusUpdatingMessageHandler</code></a></li>
<li><a href="#x4.0-jpa-id-expression">JPA Retrieving Gateway: <code>id-expression</code></a></li>
<li><a href="#x4.0-tcp-deserializer-events">TCP Deserialization Events</a></li>
<li><a href="#x4.0-bean-messaging-annotations">Messaging Annotations on <code>@Bean</code> Definitions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migration-2.2-3.0">I.12. Changes Between 2.2 and 3.0</a>
<ul class="sectlevel3">
<li><a href="#x3.0-new-components">I.12.1. New Components</a>
<ul class="sectlevel4">
<li><a href="#x3.0-request-mapping">HTTP Request Mapping</a></li>
<li><a href="#x3.0-spel-customization">Spring Expression Language (SpEL) Configuration</a></li>
<li><a href="#x3.0-spel-functions">SpEL Functions Support</a></li>
<li><a href="#x3.0-spel-property-accessors">SpEL PropertyAccessors Support</a></li>
<li><a href="#x3.0-redis-new-components">Redis: New Components</a></li>
<li><a href="#x3.0-hcr">Header Channel Registry</a></li>
<li><a href="#x3.0-configurable-mongo-MS">MongoDB support: New <code>ConfigurableMongoDbMessageStore</code></a></li>
<li><a href="#x3.0-syslog">Syslog Support</a></li>
<li><a href="#x3.0-tail"><code>tail</code> Support</a></li>
<li><a href="#x3.0-jmx">JMX Support</a></li>
<li><a href="#x3.0-tcp-events">TCP/IP Connection Events and Connection Management</a></li>
<li><a href="#x3.0-inbound-script">Inbound Channel Adapter Script Support</a></li>
<li><a href="#x3.0-content-enricher-headers">Content Enricher: Headers Enrichment Support</a></li>
</ul>
</li>
<li><a href="#x3.0-general">I.12.2. General Changes</a>
<ul class="sectlevel4">
<li><a href="#x3.0-message-id">Message ID Generation</a></li>
<li><a href="#x3.0-gateway">&#8220;&lt;gateway&gt;&#8221; Changes</a></li>
<li><a href="#x3.0-http-endpointss">HTTP Endpoint Changes</a></li>
<li><a href="#x3.0-json-transformers">Jackson Support (JSON)</a></li>
<li><a href="#x3.0-id-for-chain-sub-components">Chain Elements <code>id</code> Attribute</a></li>
<li><a href="#x3.0-corr-endpoint-empty-groups">Aggregator 'empty-group-min-timeout' property</a></li>
<li><a href="#x3.0-filelistfilter">Persistent File List Filters (file, (S)FTP)</a></li>
<li><a href="#x3.0-scripting-variables">Scripting Support: Variables Changes</a></li>
<li><a href="#x3.0-direct-channel-lb-ref">Direct Channel Load Balancing configuration</a></li>
<li><a href="#x3.0-pub-sub">PublishSubscribeChannel Behavior</a></li>
<li><a href="#x3.0--s-ftp-changes">FTP, SFTP and FTPS Changes</a></li>
<li><a href="#x3.0-outbound-gateway-requires-reply">'requires-reply' Attribute for Outbound Gateways</a></li>
<li><a href="#x3.0-amqp-mapping">AMQP Outbound Gateway Header Mapping</a></li>
<li><a href="#x3.0-stored-proc-sql-return-type">Stored Procedure Components Improvements</a></li>
<li><a href="#x3.0-ws-outbound-uri-substitution">Web Service Outbound URI Configuration</a></li>
<li><a href="#x3.0-redis">Redis Adapter Changes</a></li>
<li><a href="#x3.0-advising-filters">Advising Filters</a></li>
<li><a href="#x3.0-annotation-advice">Advising Endpoints using Annotations</a></li>
<li><a href="#x3.0-o-t-s-t">ObjectToStringTransformer Improvements</a></li>
<li><a href="#x3.0-jpa-changes">JPA Support Changes</a></li>
<li><a href="#x3.0-dalay-expression">Delayer: delay expression</a></li>
<li><a href="#x3.0-jdbc-mysql-v5_6_4">JDBC Message Store Improvements</a></li>
<li><a href="#x3.0-event-for-imap-idle">IMAP Idle Connection Exceptions</a></li>
<li><a href="#x3.0-tcp-headers">Message Headers and TCP</a></li>
<li><a href="#x3.0-jms-mdca-te">JMS Message Driven Channel Adapter</a></li>
<li><a href="#x3.0-rmi-ec">RMI Inbound Gateway</a></li>
<li><a href="#x3.0-xslt-transformer"><code>XsltPayloadTransformer</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migration-2.1-2.2">I.13. Changes between 2.1 and 2.2</a>
<ul class="sectlevel3">
<li><a href="#x2.2-new-components">I.13.1. New Components</a>
<ul class="sectlevel4">
<li><a href="#x2.2-redis-store-adapters"><code>RedisStore</code> Inbound and Outbound Channel Adapters</a></li>
<li><a href="#x2.2-mongo-adapters">MongoDB Inbound and Outbound Channel Adapters</a></li>
<li><a href="#x2.2-jpa">JPA Endpoints</a></li>
</ul>
</li>
<li><a href="#x2.2-general">I.13.2. General Changes</a>
<ul class="sectlevel4">
<li><a href="#x2.2-spring-31">Spring 3.1 Used by Default</a></li>
<li><a href="#x2.2-handler-advice">Adding Behavior to Endpoints</a></li>
<li><a href="#x2.2-transaction-sync">Transaction Synchronization and Pseudo Transactions</a></li>
<li><a href="#x2.2-file-adapter">File Adapter: Improved File Overwrite and Append Handling</a></li>
<li><a href="#x2.2-outbound-gateways">Reply-Timeout Added to More Outbound Gateways</a></li>
<li><a href="#x2.2-amqp-11">Spring-AMQP 1.1</a></li>
<li><a href="#x2.2-jdbc-11">JDBC Support - Stored Procedures Components</a></li>
<li><a href="#x2.2-jdbc-gateway-update-optional">JDBC Support: Outbound Gateway</a></li>
<li><a href="#x2.2-jdbc-message-store-channels">JDBC Support: Channel-specific Message Store Implementation</a></li>
<li><a href="#x2.2-shutdown">Orderly Shutdown</a></li>
<li><a href="#x2.2-jms-og">JMS Outbound Gateway Improvements</a></li>
<li><a href="#x2.2-o-t-j-t"><code>ObjectToJsonTransformer</code></a></li>
<li><a href="#httpChanges">HTTP Support</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migration-2.0-2.1">I.14. Changes between 2.0 and 2.1</a>
<ul class="sectlevel3">
<li><a href="#x2.1-new-components">I.14.1. New Components</a>
<ul class="sectlevel4">
<li><a href="#x2.1-new-scripting-support">JSR-223 Scripting Support</a></li>
<li><a href="#x2.1-new-gemfire-support">GemFire Support</a></li>
<li><a href="#x2.1-new-amqp-support">AMQP Support</a></li>
<li><a href="#x2.1-new-mongodb-support">MongoDB Support</a></li>
<li><a href="#x2.1-new-redis-support">Redis Support</a></li>
<li><a href="#x2.1-new-resource-support">Support for Spring&#8217;s Resource abstraction</a></li>
<li><a href="#x2.1-new-stored-proc-support">Stored Procedure Components</a></li>
<li><a href="#x2.1-new-xpath-filter-support">XPath and XML Validating Filter</a></li>
<li><a href="#x2.1-new-payload-enricher-support">Payload Enricher</a></li>
<li><a href="#x2.1-new-ftp-outbound-gateway">FTP and SFTP Outbound Gateways</a></li>
<li><a href="#x2.1-new-ftp-session-caching">FTP Session Caching</a></li>
</ul>
</li>
<li><a href="#x2.1-framework-refactorings">I.14.2. Framework Refactoring</a>
<ul class="sectlevel4">
<li><a href="#x2.1-router-standardization">Standardizing Router Configuration</a></li>
<li><a href="#x2.1-schema-updated">XML Schemas updated to 2.1</a></li>
</ul>
</li>
<li><a href="#x2.1-source-control-infrastructure">I.14.3. Source Control Management and Build Infrastructure</a>
<ul class="sectlevel4">
<li><a href="#x2.1-move-to-github">Source Code Now Hosted on Github</a></li>
<li><a href="#x2.1-sonar">Improved Source Code Visibility with Sonar</a></li>
</ul>
</li>
<li><a href="#x2.1-new-samples">I.14.4. New Samples</a></li>
</ul>
</li>
<li><a href="#migration-1.0-2.0">I.15. Changes between Versions 1.0 and 2.0</a>
<ul class="sectlevel3">
<li><a href="#migration-spring-30-support">I.15.1. Spring 3 support</a>
<ul class="sectlevel4">
<li><a href="#conversion-support">Conversion Service and Converter</a></li>
<li><a href="#task-scheduler-poller-support"><code>TaskScheduler</code> and <code>Trigger</code></a></li>
<li><a href="#rest-support"><code>RestTemplate</code> and <code>HttpMessageConverter</code></a></li>
</ul>
</li>
<li><a href="#new-eip">I.15.2. Enterprise Integration Pattern Additions</a>
<ul class="sectlevel4">
<li><a href="#new-message-history">Message History</a></li>
<li><a href="#new-message-store">Message Store</a></li>
<li><a href="#new-claim-check">Claim Check</a></li>
<li><a href="#new-control-bus">Control Bus</a></li>
</ul>
</li>
<li><a href="#new-adapters">I.15.3. New Channel Adapters and Gateways</a>
<ul class="sectlevel4">
<li><a href="#new-ip">TCP and UDP Adapters</a></li>
<li><a href="#new-twitter">Twitter Adapters</a></li>
<li><a href="#new-xmpp">XMPP Adapters</a></li>
<li><a href="#new-ftp">FTP and FTPS Adapters</a></li>
<li><a href="#new-sftp">SFTP Adapters</a></li>
<li><a href="#new-feed">Feed Adapters</a></li>
</ul>
</li>
<li><a href="#new-other">I.15.4. Other Additions</a>
<ul class="sectlevel4">
<li><a href="#new-groovy">Groovy Support</a></li>
<li><a href="#new-map-transformer">Map Transformers</a></li>
<li><a href="#new-json-transformer">JSON Transformers</a></li>
<li><a href="#new-serialize-transformer">Serialization Transformers</a></li>
</ul>
</li>
<li><a href="#new-refactoring">I.15.5. Framework Refactoring</a></li>
<li><a href="#new-infrastructure">I.15.6. New Source Control Management and Build Infrastructure</a></li>
<li><a href="#new-samples">I.15.7. New Spring Integration Samples</a></li>
<li><a href="#new-sts">I.15.8. Spring Tool Suite Visual Editor for Spring Integration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>5.1.5.RELEASE</strong></p>
</div>
<div class="paragraph">
<p>&#169; 2009 - 2019 Pivotal Software, Inc.
All rights reserved.</p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
</div>
<h1 id="preface" class="sect0"><a class="anchor" href="#preface"></a>Preface</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This chapter includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#system-requirements">Requirements</a></p>
</li>
<li>
<p><a href="#code-conventions">Code Conventions</a></p>
</li>
<li>
<p><a href="#guide-conventions">Conventions in This Guide</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="system-requirements"><a class="anchor" href="#system-requirements"></a>1. Requirements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section details the compatible <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Java</a> and <a href="https://www.springsource.org/spring-framework">Spring Framework</a> versions.</p>
</div>
<div class="sect2">
<h3 id="supported-java-versions"><a class="anchor" href="#supported-java-versions"></a>1.1. Compatible Java Versions</h3>
<div class="paragraph">
<p>For Spring Integration 5.1.x, the minimum compatible Java version is Java SE 8.
Older versions of Java are not supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="supported-spring-versions"><a class="anchor" href="#supported-spring-versions"></a>1.2. Compatible Versions of the Spring Framework</h3>
<div class="paragraph">
<p>Spring Integration 5.1.x requires Spring Framework 5.1 or later.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="code-conventions"><a class="anchor" href="#code-conventions"></a>2. Code Conventions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework 2.0 introduced support for namespaces, which simplifies the XML configuration of the application context and lets Spring Integration provide broad namespace support.</p>
</div>
<div class="paragraph">
<p>In this reference guide, the <code>int</code> namespace prefix is used for Spring Integration&#8217;s core namespace support.
Each Spring Integration adapter type (also called a module) provides its own namespace, which is configured by using the following convention:</p>
</div>
<div class="paragraph">
<p>The following example shows the <code>int</code>, <code>int-event</code>, and <code>int-stream</code> namespaces in use:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-webflux="http://www.springframework.org/schema/integration/webflux"
  xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
  xsi:schemaLocation="
   http://www.springframework.org/schema/beans
   https://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/integration
   https://www.springframework.org/schema/integration/spring-integration.xsd
   http://www.springframework.org/schema/integration/webflux
   https://www.springframework.org/schema/integration/webflux/spring-integration-webflux.xsd
   http://www.springframework.org/schema/integration/stream
   https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd"&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For a detailed explanation regarding Spring Integration&#8217;s namespace support, see <a href="#configuration-namespace">Namespace Support</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The namespace prefix can be freely chosen.
You may even choose not to use any namespace prefixes at all.
Therefore, you should apply the convention that best suits your application.
Be aware, though, that SpringSource Tool Suite (STS) uses the same namespace conventions for Spring Integration as used in this reference guide.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="guide-conventions"><a class="anchor" href="#guide-conventions"></a>3. Conventions in This Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In some cases, to aid formatting when specifying long fully qualified class names, we shorten
<code>org.springframework</code> to <code>o.s</code> and <code>org.springframework.integration</code> to <code>o.s.i</code>, such as with
<code>o.s.i.transaction.TransactionSynchronizationFactory</code>.</p>
</div>
</div>
</div>
<h1 id="whats-new-part" class="sect0"><a class="anchor" href="#whats-new-part"></a>What&#8217;s New?</h1>
<div class="openblock partintro">
<div class="content">
<div id="spring-integration-intro-new" class="paragraph">
<p>For those who are already familiar with Spring Integration, this chapter provides a brief overview of the new features of version 5.1.</p>
</div>
<div class="paragraph">
<p>If you are interested in the changes and features that were introduced in earlier versions, see the <a href="#history">Change History</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="whats-new"><a class="anchor" href="#whats-new"></a>4. What&#8217;s New in Spring Integration 5.1?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides an overview of the new features and improvements that have been introduced with Spring
Integration <code>5.1</code>.
If you are interested in more details, see the Issue Tracker tickets that were resolved as part of the 5.1 development process.</p>
</div>
<div class="sect2">
<h3 id="x5.1-new-components"><a class="anchor" href="#x5.1-new-components"></a>4.1. New Components</h3>
<div class="paragraph">
<p>The following components are new in 5.1:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#x5.1-AmqpDedicatedChannelAdvice"><code>AmqpDedicatedChannelAdvice</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="x5.1-AmqpDedicatedChannelAdvice"><a class="anchor" href="#x5.1-AmqpDedicatedChannelAdvice"></a>4.1.1. <code>AmqpDedicatedChannelAdvice</code></h4>
<div class="paragraph">
<p>See <a href="#amqp-strict-ordering">Strict Message Ordering</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-Functions"><a class="anchor" href="#x5.1-Functions"></a>4.1.2. Improved Function Support</h4>
<div class="paragraph">
<p>The <code>java.util.function</code> interfaces now have improved integration support in the Framework components.
Also Kotlin lambdas now can be used for handler and source methods.</p>
</div>
<div class="paragraph">
<p>See <a href="#functions-support"><code>java.util.function</code> Interfaces Support</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-LongRunningTest"><a class="anchor" href="#x5.1-LongRunningTest"></a>4.1.3. <code>@LongRunningTest</code></h4>
<div class="paragraph">
<p>A JUnit 5 <code>@LongRunningTest</code> conditional annotation is provided to check the environment or system properties for the <code>RUN_LONG_INTEGRATION_TESTS</code> entry with the value of <code>true</code> to determine if test should be run or skipped.</p>
</div>
<div class="paragraph">
<p>See <a href="#test-junit-rules">JUnit Rules and Conditions</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-general"><a class="anchor" href="#x5.1-general"></a>4.2. General Changes</h3>
<div class="paragraph">
<p>The following changes have been made in version 5.1:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#x5.1-java-dsl">Java DSL</a></p>
</li>
<li>
<p><a href="#x5.1-dispatcher-exceptions">Dispatcher Exceptions</a></p>
</li>
<li>
<p><a href="#x5.1-global-channel-interceptors">Global Channel Interceptors</a></p>
</li>
<li>
<p><a href="#x5.1-object-to-json-transformer"><code>ObjectToJsonTransformer</code></a></p>
</li>
<li>
<p><a href="#x5.1-integration-flows-generated-bean-names">Integration Flows: Generated Bean Names</a></p>
</li>
<li>
<p><a href="#x5.1-aggregator">Aggregator Changes</a></p>
</li>
<li>
<p><a href="#x5.1-publisher">@Publisher annotation changes</a></p>
</li>
<li>
<p><a href="#x51.-integration-graph">Integration Graph Customization</a></p>
</li>
<li>
<p><a href="#x51.-global-properties">Integration Global Properties</a></p>
</li>
<li>
<p><a href="#x51.-poller-annotation">The <code>receiveTimeout</code> for <code>@Poller</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="x5.1-java-dsl"><a class="anchor" href="#x5.1-java-dsl"></a>4.2.1. Java DSL</h4>
<div class="paragraph">
<p>The <code>IntegrationFlowContext</code> is now an interface and <code>IntegrationFlowRegistration</code> is an inner interface of <code>IntegrationFlowContext</code>.</p>
</div>
<div class="paragraph">
<p>A new <code>logAndReply()</code> operator has been introduced for convenience when you wish to log at the end of a flow for request-reply configurations.
This avoid confusion with <code>log()</code> which is treated as a one-way end flow component.</p>
</div>
<div class="paragraph">
<p>A generated bean name for any <code>NamedComponent</code> within an integration flow is now based on the component type for better readability from visual tools, logs analyzers and metrics collectors.</p>
</div>
<div class="paragraph">
<p>The <code>GenericHandler.handle()</code> now excepts a <code>MessageHeaders</code> type for the second argument.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-dispatcher-exceptions"><a class="anchor" href="#x5.1-dispatcher-exceptions"></a>4.2.2. Dispatcher Exceptions</h4>
<div class="paragraph">
<p>Exceptions caught and re-thrown by <code>AbstractDispatcher</code> are now more consistent:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>MessagingException</code> of any kind that has a <code>failedMessage</code> property is re-thrown unchanged.</p>
</li>
<li>
<p>All other exceptions are wrapped in a <code>MessageDeliveryException</code> with the <code>failedMessage</code> property set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Previously:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>MessagingException</code> of any kind that has a <code>failedMessage</code> property was re-thrown unchanged</p>
</li>
<li>
<p>A <code>MessagingException</code> that had no <code>failedMessage</code> property was wrapped in a <code>MessagingException</code> with the <code>failedMessage</code> property set.</p>
</li>
<li>
<p>Other <code>RuntimeException</code> instances were re-thrown unchanged.</p>
</li>
<li>
<p>Checked exceptions were wrapped in a <code>MessageDeliveryException</code> with the <code>failedMessage</code> property set.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-global-channel-interceptors"><a class="anchor" href="#x5.1-global-channel-interceptors"></a>4.2.3. Global Channel Interceptors</h4>
<div class="paragraph">
<p>Global channel interceptors now apply to dynamically registered channels, such as through the <code>IntegrationFlowContext</code> when using the Java DSL or beans that are initialized using <code>beanFactory.initializeBean()</code>.
Previously, when beans were created after the application context was refreshed, interceptors were not applied.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-channel-interceptors"><a class="anchor" href="#x5.1-channel-interceptors"></a>4.2.4. Channel Interceptors</h4>
<div class="paragraph">
<p><code>ChannelInterceptor.postReceive()</code> is no longer called when no message is received; it is no longer necessary to check for a <code>null</code> <code>Message&lt;?&gt;</code>.
Previously, the method was called.
If you have an interceptor that relies on the previous behavior, implement <code>afterReceiveCompleted()</code> instead, since that method is invoked, regardless of whether a message is received or not.
Furthermore, the <code>PolledAmqpChannel</code> and <code>PolledJmsChannel</code> previously did not invoke <code>afterReceiveCompleted()</code> with <code>null</code>; they now do.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-object-to-json-transformer"><a class="anchor" href="#x5.1-object-to-json-transformer"></a>4.2.5. <code>ObjectToJsonTransformer</code></h4>
<div class="paragraph">
<p>A new <code>ResultType.BYTES</code> mode is introduced for the <code>ObjectToJsonTransformer</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#json-transformers">JSON Transformers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-integration-flows-generated-bean-names"><a class="anchor" href="#x5.1-integration-flows-generated-bean-names"></a>4.2.6. Integration Flows: Generated Bean Names</h4>
<div class="paragraph">
<p>Starting with version 5.0.5, generated bean names for the components in an <code>IntegrationFlow</code> include the flow bean name, followed by a dot, as a prefix.
For example, if a flow bean were named <code>flowBean</code>, a generated bean might be named <code>flowBean.generatedBean</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#java-dsl-flows">Working With Message Flows</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-aggregator"><a class="anchor" href="#x5.1-aggregator"></a>4.2.7. Aggregator Changes</h4>
<div class="paragraph">
<p>If the <code>groupTimeout</code> is evaluated to a negative value, an aggregator now expires the group immediately.
Only <code>null</code> is considered as a signal to do nothing for the current message.</p>
</div>
<div class="paragraph">
<p>A new <code>popSequence</code> property has been introduced to allow (by default) to call a <code>MessageBuilder.popSequenceDetails()</code> for the output message.
Also an <code>AbstractAggregatingMessageGroupProcessor</code> returns now an <code>AbstractIntegrationMessageBuilder</code> instead of the whole <code>Message</code> for optimization.</p>
</div>
<div class="paragraph">
<p>See <a href="#aggregator">Aggregator</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x5.1-publisher"><a class="anchor" href="#x5.1-publisher"></a>4.2.8. @Publisher annotation changes</h4>
<div class="paragraph">
<p>Starting with version 5.1, you must explicitly turn on the <code>@Publisher</code> AOP functionality by using <code>@EnablePublisher</code> or by using the <code>&lt;int:enable-publisher&gt;</code> child element on <code>&lt;int:annotation-config&gt;</code>.
Also the <code>proxy-target-class</code> and <code>order</code> attributes have been added for tuning the <code>ProxyFactory</code> configuration.</p>
</div>
<div class="paragraph">
<p>See <a href="#publisher-annotation">Annotation-driven Configuration with the <code>@Publisher</code> Annotation</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-files"><a class="anchor" href="#x5.1-files"></a>4.3. Files Changes</h3>
<div class="paragraph">
<p>If you are using <code>FileExistsMode.APPEND</code> or <code>FileExistsMode.APPEND_NO_FLUSH</code> you can provide a <code>newFileCallback</code> that will be called when creating a new file.
This callback receives the newly created file and the message that triggered the callback.
This could be used to write a CSV header, for an example.</p>
</div>
<div class="paragraph">
<p>The <code>FileReadingMessageSource</code> now doesn&#8217;t check and create a directory until its <code>start()</code> is called.
So, if an Inbound Channel Adapter for the <code>FileReadingMessageSource</code> has <code>autoStartup = false</code>, there are no failures against the file system during application start up.</p>
</div>
<div class="paragraph">
<p>See <a href="#files">File Support</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-amqp"><a class="anchor" href="#x5.1-amqp"></a>4.4. AMQP Changes</h3>
<div class="paragraph">
<p>We have made <code>ID</code> and <code>Timestamp</code> header mapping changes in the <code>DefaultAmqpHeaderMapper</code>.
See the note near the bottom of <a href="#amqp-message-headers">AMQP Message Headers</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>contentType</code> header is now correctly mapped as an entry in the general headers map.
See <a href="#amqp-content-type">contentType Header</a> for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1.3, if a message conversion exception occurs when using manual acknowledgments, and an error channel is defined, the payload is a <code>ManualAckListenerExecutionFailedException</code> with additional <code>channel</code> and <code>deliveryTag</code> properties.
This enables the error flow to ack/nack the original message.
See <a href="#amqp-conversion-inbound">Inbound Message Conversion</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-jdbc"><a class="anchor" href="#x5.1-jdbc"></a>4.5. JDBC Changes</h3>
<div class="paragraph">
<p>A confusing <code>max-rows-per-poll</code> property on the JDBC Inbound Channel Adapter and JDBC Outbound Gateway has been deprecated in favor of the newly introduced <code>max-rows</code> property.</p>
</div>
<div class="paragraph">
<p>The <code>JdbcMessageHandler</code> supports now a <code>batchUpdate</code> functionality when the payload of the request message is an instance of an <code>Iterable</code> type.</p>
</div>
<div class="paragraph">
<p>The indexes for the <code>INT_CHANNEL_MESSAGE</code> table (for the <code>JdbcChannelMessageStore</code>) have been optimized.
If you have large message groups in such a store, you may wish to alter the indexes.</p>
</div>
<div class="paragraph">
<p>See <a href="#jdbc">JDBC Support</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-ftp-sftp"><a class="anchor" href="#x5.1-ftp-sftp"></a>4.6. FTP and SFTP Changes</h3>
<div class="paragraph">
<p>A <code>RotatingServerAdvice</code> is now available to poll multiple servers and directories with the inbound channel adapters.
See <a href="#ftp-rotating-server-advice">Inbound Channel Adapters: Polling Multiple Servers and Directories</a> and <a href="#sftp-rotating-server-advice">Inbound Channel Adapters: Polling Multiple Servers and Directories</a> for more information.</p>
</div>
<div class="paragraph">
<p>Also, inbound adapter <code>localFilenameExpression</code> instances can contain the <code>#remoteDirectory</code> variable, which contains the remote directory being polled.
The generic type of the comparators (used to sort the fetched file list for the streaming adapters) has changed from <code>Comparator&lt;AbstractFileInfo&lt;F&gt;&gt;</code> to <code>Comparator&lt;F&gt;</code>.
See <a href="#ftp-streaming">FTP Streaming Inbound Channel Adapter</a> and <a href="#sftp-streaming">SFTP Streaming Inbound Channel Adapter</a> for more information.</p>
</div>
<div class="paragraph">
<p>In addition, the synchronizers for inbound channel adapters can now be provided with a <code>Comparator</code>.
This is useful when using <code>maxFetchSize</code> to limit the files retrieved.</p>
</div>
<div class="paragraph">
<p>The <code>CachingSessionFactory</code> has a new property <code>testSession</code> which, when true, causes the factory to perform a <code>test()</code> operation on the <code>Session</code> when checking out an existing session from the cache.</p>
</div>
<div class="paragraph">
<p>See <a href="#sftp-session-caching">SFTP Session Caching</a> and <a href="#ftp-session-caching">FTP Session Caching</a> for more information.</p>
</div>
<div class="paragraph">
<p>The outbound gateway MPUT command now supports a message payload with a collection of files or strings.
See <a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a> and <a href="#ftp-outbound-gateway">FTP Outbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-tcp"><a class="anchor" href="#x51.-tcp"></a>4.7. TCP Support</h3>
<div class="paragraph">
<p>When using SSL, host verification is now enabled, by default, to prevent man-in-the-middle attacks with a trusted certificate.
See <a href="#tcp-ssl-host-verification">Host Verification</a> for more information.</p>
</div>
<div class="paragraph">
<p>In addition the key and trust store types can now be configured on the <code>DefaultTcpSSLContextSupport</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="x5.1-twitter"><a class="anchor" href="#x5.1-twitter"></a>4.8. Twitter Support</h3>
<div class="paragraph">
<p>Since the Spring Social project has moved to <a href="https://spring.io/blog/2018/07/03/spring-social-end-of-life-announcement">end of life status</a>, Twitter support in Spring Integration has been moved to the Extensions project.
See <a href="https://github.com/spring-projects/spring-integration-extensions/tree/master/spring-integration-social-twitter">Spring Integration Social Twitter</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-jms"><a class="anchor" href="#x51.-jms"></a>4.9. JMS Support</h3>
<div class="paragraph">
<p>The <code>JmsSendingMessageHandler</code> now provides <code>deliveryModeExpression</code> and <code>timeToLiveExpression</code> options to determine respective QoS options for JMS message to send at runtime.
The <code>DefaultJmsHeaderMapper</code> now allows to map inbound <code>JMSDeliveryMode</code> and <code>JMSExpiration</code> properties via setting to <code>true</code> respective <code>setMapInboundDeliveryMode()</code> and <code>setMapInboundExpiration()</code> options.
When a <code>JmsMessageDrivenEndpoint</code> or <code>JmsInboundGateway</code> is stopped, the associated listener container is now shut down; this closes its shared connection and any consumers.
You can configure the endpoints to revert to the previous behavior.</p>
</div>
<div class="paragraph">
<p>See <a href="#jms">JMS Support</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-http"><a class="anchor" href="#x51.-http"></a>4.10. HTTP/WebFlux Support</h3>
<div class="paragraph">
<p>The <code>statusCodeExpression</code> (and <code>Function</code>) is now supplied with the <code>RequestEntity&lt;?&gt;</code> as a root object for evaluation context, so request headers, method, URI and body are available for target status code calculation.</p>
</div>
<div class="paragraph">
<p>See <a href="#http">HTTP Support</a> and <a href="#webflux">WebFlux Support</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-jmx"><a class="anchor" href="#x51.-jmx"></a>4.11. JMX Changes</h3>
<div class="paragraph">
<p>Object name key values are now quoted if they contain any characters other than those allowed in a Java identifier (or period <code>.</code>).
For example <code>org.springframework.integration:type=MessageChannel,</code> <code>name="input:foo.myGroup.errors"</code>.
This has the side effect that previously "allowed" names, with such characters, will now be quoted.
For example <code>org.springframework.integration:type=MessageChannel,</code> <code>name="input#foo.myGroup.errors"</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-micrometer"><a class="anchor" href="#x51.-micrometer"></a>4.12. Micrometer Support Changes</h3>
<div class="paragraph">
<p>It is now simpler to customize the standard Micrometer meters created by the framework.
See <a href="#micrometer-integration">Micrometer Integration</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-integration-graph"><a class="anchor" href="#x51.-integration-graph"></a>4.13. Integration Graph Customization</h3>
<div class="paragraph">
<p>It is now possible to add additional properties to the <code>IntegrationNode</code> s via <code>Function&lt;NamedComponent, Map&lt;String, Object&gt;&gt; additionalPropertiesCallback</code> on the <code>IntegrationGraphServer</code>.
See <a href="#integration-graph">Integration Graph</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-global-properties"><a class="anchor" href="#x51.-global-properties"></a>4.14. Integration Global Properties</h3>
<div class="paragraph">
<p>The Integration global properties (including defaults) can now be printed in the logs, when a <code>DEBUG</code> logic level is turned on for the <code>org.springframework.integration</code> category.
See <a href="#global-properties">Global Properties</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="x51.-poller-annotation"><a class="anchor" href="#x51.-poller-annotation"></a>4.15. The <code>receiveTimeout</code> for <code>@Poller</code></h3>
<div class="paragraph">
<p>The <code>@Poller</code> annotation now provides a <code>receiveTimeout</code> option for convenience.
See <a href="#configuration-using-poller-annotation">Using the <code>@Poller</code> Annotation</a> for more information.</p>
</div>
</div>
</div>
</div>
<h1 id="spring-integration-introduction" class="sect0"><a class="anchor" href="#spring-integration-introduction"></a>Overview of Spring Integration Framework</h1>
<div class="openblock partintro">
<div class="content">
<div id="spring-integration-intro" class="paragraph">
<p>Spring Integration provides an extension of the Spring programming model to support the well known <a href="https://www.enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a>.
It enables lightweight messaging within Spring-based applications and supports integration with external systems through declarative adapters.
Those adapters provide a higher level of abstraction over Spring&#8217;s support for remoting, messaging, and scheduling.</p>
</div>
<div class="paragraph">
<p>Spring Integration&#8217;s primary goal is to provide a simple model for building enterprise integration solutions while maintaining the separation of concerns that is essential for producing maintainable, testable code.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>5. Spring Integration Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides a high-level introduction to Spring Integration&#8217;s core concepts and components.
It includes some programming tips to help you make the most of Spring Integration.</p>
</div>
<div class="sect2">
<h3 id="overview-background"><a class="anchor" href="#overview-background"></a>5.1. Background</h3>
<div class="paragraph">
<p>One of the key themes of the Spring Framework is Inversion of Control (IoC).
In its broadest sense, this means that the framework handles responsibilities on behalf of the components that are managed within its context.
The components themselves are simplified, because they are relieved of those responsibilities.
For example, dependency injection relieves the components of the responsibility of locating or creating their dependencies.
Likewise, aspect-oriented programming relieves business components of generic cross-cutting concerns by modularizing them into reusable aspects.
In each case, the end result is a system that is easier to test, understand, maintain, and extend.</p>
</div>
<div class="paragraph">
<p>Furthermore, the Spring framework and portfolio provide a comprehensive programming model for building enterprise applications.
Developers benefit from the consistency of this model and especially from the fact that it is based upon well established best practices, such as programming to interfaces and favoring composition over inheritance.
Spring&#8217;s simplified abstractions and powerful support libraries boost developer productivity while simultaneously increasing the level of testability and portability.</p>
</div>
<div class="paragraph">
<p>Spring Integration is motivated by these same goals and principles.
It extends the Spring programming model into the messaging domain and builds upon Spring&#8217;s existing enterprise integration support to provide an even higher level of abstraction.
It supports message-driven architectures where inversion of control applies to runtime concerns, such as when certain business logic should run and where the response should be sent.
It supports routing and transformation of messages so that different transports and different data formats can be integrated without impacting testability.
In other words, the messaging and integration concerns are handled by the framework.
Business components are further isolated from the infrastructure, and developers are relieved of complex integration responsibilities.</p>
</div>
<div class="paragraph">
<p>As an extension of the Spring programming model, Spring Integration provides a wide variety of configuration options, including annotations, XML with namespace support, XML with generic &#8220;bean&#8221; elements, and direct usage of the underlying API.
That API is based upon well defined strategy interfaces and non-invasive, delegating adapters.
Spring Integration&#8217;s design is inspired by the recognition of a strong affinity between common patterns within Spring and the well known patterns described in <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a>, by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004).
Developers who have read that book should be immediately comfortable with the Spring Integration concepts and terminology.</p>
</div>
</div>
<div class="sect2">
<h3 id="overview-goalsandprinciples"><a class="anchor" href="#overview-goalsandprinciples"></a>5.2. Goals and Principles</h3>
<div class="paragraph">
<p>Spring Integration is motivated by the following goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide a simple model for implementing complex enterprise integration solutions.</p>
</li>
<li>
<p>Facilitate asynchronous, message-driven behavior within a Spring-based application.</p>
</li>
<li>
<p>Promote intuitive, incremental adoption for existing Spring users.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Integration is guided by the following principles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Components should be loosely coupled for modularity and testability.</p>
</li>
<li>
<p>The framework should enforce separation of concerns between business logic and integration logic.</p>
</li>
<li>
<p>Extension points should be abstract in nature (but within well-defined boundaries) to promote reuse and portability.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="overview-components"><a class="anchor" href="#overview-components"></a>5.3. Main Components</h3>
<div class="paragraph">
<p>From a vertical perspective, a layered architecture facilitates separation of concerns, and interface-based contracts between layers promote loose coupling.
Spring-based applications are typically designed this way, and the Spring framework and portfolio provide a strong foundation for following this best practice for the full stack of an enterprise application.
Message-driven architectures add a horizontal perspective, yet these same goals are still relevant.
Just as &#8220;layered architecture&#8221; is an extremely generic and abstract paradigm, messaging systems typically follow the similarly abstract &#8220;pipes-and-filters&#8221; model.
The &#8220;filters&#8221; represent any components capable of producing or consuming messages, and the &#8220;pipes&#8221; transport the messages between filters so that the components themselves remain loosely-coupled.
It is important to note that these two high-level paradigms are not mutually exclusive.
The underlying messaging infrastructure that supports the &#8220;pipes&#8221; should still be encapsulated in a layer whose contracts are defined as interfaces.
Likewise, the &#8220;filters&#8221; themselves should be managed within a layer that is logically above the application&#8217;s service layer, interacting with those services through interfaces in much the same way that a web tier would.</p>
</div>
<div class="sect3">
<h4 id="overview-components-message"><a class="anchor" href="#overview-components-message"></a>5.3.1. Message</h4>
<div class="paragraph">
<p>In Spring Integration, a message is a generic wrapper for any Java object combined with metadata used by the framework while handling that object.
It consists of a payload and headers.
The payload can be of any type, and the headers hold commonly required information such as ID, timestamp, correlation ID, and return address.
Headers are also used for passing values to and from connected transports.
For example, when creating a message from a received file, the file name may be stored in a header to be accessed by downstream components.
Likewise, if a message&#8217;s content is ultimately going to be sent by an outbound mail adapter, the various properties (to, from, cc, subject, and others) may be configured as message header values by an upstream component.
Developers can also store any arbitrary key-value pairs in the headers.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/message.jpg" alt="Message">
</div>
<div class="title">Figure 1. Message</div>
</div>
</div>
<div class="sect3">
<h4 id="overview-components-channel"><a class="anchor" href="#overview-components-channel"></a>5.3.2. Message Channel</h4>
<div class="paragraph">
<p>A message channel represents the &#8220;pipe&#8221; of a pipes-and-filters architecture.
Producers send messages to a channel, and consumers receive messages from a channel.
The message channel therefore decouples the messaging components and also provides a convenient point for interception and monitoring of messages.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/channel.jpg" alt="Message Channel">
</div>
<div class="title">Figure 2. Message Channel</div>
</div>
<div class="paragraph">
<p>A message channel may follow either point-to-point or publish-subscribe semantics.
With a point-to-point channel, no more than one consumer can receive each message sent to the channel.
Publish-subscribe channels, on the other hand, attempt to broadcast each message to all subscribers on the channel.
Spring Integration supports both of these models.</p>
</div>
<div class="paragraph">
<p>Whereas &#8220;point-to-point&#8221; and "publish-subscribe" define the two options for how many consumers ultimately receive each message, there is another important consideration: Should the channel buffer messages?
In Spring Integration, pollable channels are capable of buffering Messages within a queue.
The advantage of buffering is that it allows for throttling the inbound messages and thereby prevents overloading a consumer.
However, as the name suggests, this also adds some complexity, since a consumer can only receive the messages from such a channel if a poller is configured.
On the other hand, a consumer connected to a subscribable channel is simply message-driven.
<a href="#channel-implementations">Message Channel Implementations</a> has a detailed discussion of the variety of channel implementations available in Spring Integration.</p>
</div>
</div>
<div class="sect3">
<h4 id="overview-components-endpoint"><a class="anchor" href="#overview-components-endpoint"></a>5.3.3. Message Endpoint</h4>
<div class="paragraph">
<p>One of the primary goals of Spring Integration is to simplify the development of enterprise integration solutions through inversion of control.
This means that you should not have to implement consumers and producers directly, and you should not even have to build messages and invoke send or receive operations on a message channel.
Instead, you should be able to focus on your specific domain model with an implementation based on plain objects.
Then, by providing declarative configuration, you can &#8220;connect&#8221; your domain-specific code to the messaging infrastructure provided by Spring Integration.
The components responsible for these connections are message endpoints.
This does not mean that you should necessarily connect your existing application code directly.
Any real-world enterprise integration solution requires some amount of code focused upon integration concerns such as routing and transformation.
The important thing is to achieve separation of concerns between the integration logic and the business logic.
In other words, as with the Model-View-Controller (MVC) paradigm for web applications, the goal should be to provide a thin but dedicated layer that translates inbound requests into service layer invocations and then translates service layer return values into outbound replies.
The next section provides an overview of the message endpoint types that handle these responsibilities, and, in upcoming chapters, you can see how Spring Integration&#8217;s declarative configuration options provide a non-invasive way to use each of these.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="overview-endpoints"><a class="anchor" href="#overview-endpoints"></a>5.4. Message Endpoints</h3>
<div class="paragraph">
<p>A Message Endpoint represents the &#8220;filter&#8221; of a pipes-and-filters architecture.
As mentioned earlier, the endpoint&#8217;s primary role is to connect application code to the messaging framework and to do so in a non-invasive manner.
In other words, the application code should ideally have no awareness of the message objects or the message channels.
This is similar to the role of a controller in the MVC paradigm.
Just as a controller handles HTTP requests, the message endpoint handles messages.
Just as controllers are mapped to URL patterns, message endpoints are mapped to message channels.
The goal is the same in both cases: isolate application code from the infrastructure.
These concepts and all of the patterns that follow are discussed at length in the <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a> book.
Here, we provide only a high-level description of the main endpoint types supported by Spring Integration and the roles associated with those types.
The chapters that follow elaborate and provide sample code as well as configuration examples.</p>
</div>
<div class="sect3">
<h4 id="overview-endpoints-transformer"><a class="anchor" href="#overview-endpoints-transformer"></a>5.4.1. Message Transformer</h4>
<div class="paragraph">
<p>A message transformer is responsible for converting a message&#8217;s content or structure and returning the modified message.
Probably the most common type of transformer is one that converts the payload of the message from one format to another (such as
from XML to <code>java.lang.String</code>).
Similarly, a transformer can add, remove, or modify the message&#8217;s header values.</p>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-filter"><a class="anchor" href="#overview-endpoints-filter"></a>5.4.2. Message Filter</h4>
<div class="paragraph">
<p>A message filter determines whether a message should be passed to an output channel at all.
This simply requires a boolean test method that may check for a particular payload content type, a property value, the presence of a header, or other conditions.
If the message is accepted, it is sent to the output channel.
If not, it is dropped (or, for a more severe implementation, an <code>Exception</code> could be thrown).
Message filters are often used in conjunction with a publish-subscribe channel, where multiple consumers may receive the same message and use the criteria of the filter to narrow down the set of messages to be processed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Be careful not to confuse the generic use of &#8220;filter&#8221; within the pipes-and-filters architectural pattern with this specific endpoint type that selectively narrows down the messages flowing between two channels.
The pipes-and-filters concept of a &#8220;filter&#8221; matches more closely with Spring Integration&#8217;s message endpoint: any component that can be connected to a message channel in order to send or receive messages.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-router"><a class="anchor" href="#overview-endpoints-router"></a>5.4.3. Message Router</h4>
<div class="paragraph">
<p>A message router is responsible for deciding what channel or channels (if any) should receive the message next.
Typically, the decision is based upon the message&#8217;s content or the metadata available in the message headers.
A message router is often used as a dynamic alternative to a statically configured output channel on a service activator or other endpoint capable of sending reply messages.
Likewise, a message router provides a proactive alternative to the reactive message filters used by multiple subscribers, as described earlier.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/router.jpg" alt="Router">
</div>
<div class="title">Figure 3. Message Router</div>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-splitter"><a class="anchor" href="#overview-endpoints-splitter"></a>5.4.4. Splitter</h4>
<div class="paragraph">
<p>A splitter is another type of message endpoint whose responsibility is to accept a message from its input channel, split that message into multiple messages, and send each of those to its output channel.
This is typically used for dividing a &#8220;composite&#8221; payload object into a group of messages containing the subdivided payloads.</p>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-aggregator"><a class="anchor" href="#overview-endpoints-aggregator"></a>5.4.5. Aggregator</h4>
<div class="paragraph">
<p>Basically a mirror-image of the splitter, the aggregator is a type of message endpoint that receives multiple messages and combines them into a single message.
In fact, aggregators are often downstream consumers in a pipeline that includes a splitter.
Technically, the aggregator is more complex than a splitter, because it is required to maintain state (the messages to be aggregated), to decide when the complete group of messages is available, and to timeout if necessary.
Furthermore, in case of a timeout, the aggregator needs to know whether to send the partial results, discard them, or send them to a separate channel.
Spring Integration provides a <code>CorrelationStrategy</code>, a <code>ReleaseStrategy</code>, and configurable settings for timeout, whether
to send partial results upon timeout, and a discard channel.</p>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-service-activator"><a class="anchor" href="#overview-endpoints-service-activator"></a>5.4.6. Service Activator</h4>
<div class="paragraph">
<p>A Service Activator is a generic endpoint for connecting a service instance to the messaging system.
The input message channel must be configured, and, if the service method to be invoked is capable of returning a value, an output message Channel may also be provided.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The output channel is optional, since each message may also provide its own 'Return Address' header.
This same rule applies for all consumer endpoints.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The service activator invokes an operation on some service object to process the request message, extracting the request message&#8217;s payload and converting (if the method does not expect a message-typed parameter).
Whenever the service object&#8217;s method returns a value, that return value is likewise converted to a reply message if necessary (if it is not already a message type).
That reply message is sent to the output channel.
If no output channel has been configured, the reply is sent to the channel specified in the message&#8217;s &#8220;return address&#8221;, if available.</p>
</div>
<div class="paragraph">
<p>A request-reply service activator endpoint connects a target object&#8217;s method to input and output Message Channels.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/handler-endpoint.jpg" alt="handler endpoint">
</div>
<div class="title">Figure 4. Service Activator</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As discussed earlier, in <a href="#overview-components-channel">Message Channel</a>, channels can be pollable or subscribable.
In the preceding diagram, this is depicted by the &#8220;clock&#8221; symbol and the solid arrow (poll) and the dotted arrow (subscribe).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="overview-endpoints-channeladapter"><a class="anchor" href="#overview-endpoints-channeladapter"></a>5.4.7. Channel Adapter</h4>
<div class="paragraph">
<p>A channel adapter is an endpoint that connects a message channel to some other system or transport.
Channel adapters may be either inbound or outbound.
Typically, the channel adapter does some mapping between the message and whatever object or resource is received from or sent to the other system (file, HTTP Request, JMS message, and others).
Depending on the transport, the channel adapter may also populate or extract message header values.
Spring Integration provides a number of channel adapters, which are described in upcoming chapters.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/source-endpoint.jpg" alt="source endpoint">
</div>
<div class="title">Figure 5. An inbound channel adapter endpoint connects a source system to a <code>MessageChannel</code>.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Message sources can be pollable (for example, POP3) or message-driven_ (for example, IMAP Idle).
In the preceding diagram, this is depicted by the &#8220;clock&#8221; symbol and the solid arrow (poll) and the dotted arrow (message-driven).
</td>
</tr>
</table>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/target-endpoint.jpg" alt="target endpoint">
</div>
<div class="title">Figure 6. An outbound channel adapter endpoint connects a <code>MessageChannel</code> to a target system.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As discussed earlier in <a href="#overview-components-channel">Message Channel</a>, channels can be pollable or subscribable.
In the preceding diagram, this is depicted by the &#8220;clock&#8221; symbol and the solid arrow (poll) and the dotted arrow (subscribe).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-bean-names"><a class="anchor" href="#endpoint-bean-names"></a>5.4.8. Endpoint Bean Names</h4>
<div class="paragraph">
<p>Consuming endpoints (anything with an <code>inputChannel</code>) consist of two beans, the consumer and the message handler.
The consumer has a reference to the message handler and invokes it as messages arrive.</p>
</div>
<div class="paragraph">
<p>Consider the following XML example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator id = "someService" ... /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer: <code>someService</code> (the <code>id</code>)</p>
</li>
<li>
<p>Handler: <code>someService.handler</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using Enterprise Integration Pattern (EIP) annotations, the names depend on several factors.
Consider the following example of an annotated POJO:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class SomeComponent {

    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer: <code>someComponent.someMethod.serviceActivator</code></p>
</li>
<li>
<p>Handler: <code>someComponent.someMethod.serviceActivator.handler</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with version 5.0.4, you can modify these names by using the <code>@EndpointId</code> annotation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class SomeComponent {

    @EndpointId("someService")
    @ServiceActivator(inputChannel = ...)
    public String someMethod(...) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer: <code>someService</code></p>
</li>
<li>
<p>Handler: <code>someService.handler</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>@EndpointId</code> creates names as created by the <code>id</code> attribute with XML configuration.
Consider the following example of an annotated bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuratiom
public class SomeConfiguration {

    @Bean
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer: <code>someConfiguration.someHandler.serviceActivator</code></p>
</li>
<li>
<p>Handler: <code>someHandler</code> (the <code>@Bean</code> name)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with version 5.0.4, you can modify these names by using the <code>@EndpointId</code> annotation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuratiom
public class SomeConfiguration {

    @Bean("someService.handler")             <i class="conum" data-value="1"></i><b>(1)</b>
    @EndpointId("someService")               <i class="conum" data-value="2"></i><b>(2)</b>
    @ServiceActivator(inputChannel = ...)
    public MessageHandler someHandler() {
        ...
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Handler: <code>someService.handler</code> (the bean name)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Consumer: <code>someService</code> (the endpoint ID)</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@EndpointId</code> annotation creates names as created by the <code>id</code> attribute with XML configuration, as long as you use the convention of appending <code>.handler</code> to the <code>@Bean</code> name.</p>
</div>
<div class="paragraph">
<p>There is one special case where a third bean is created: For architectural reasons, if a <code>MessageHandler</code> <code>@Bean</code> does not define an <code>AbstractReplyProducingMessageHandler</code>, the framework wraps the provided bean in a <code>ReplyProducingMessageHandlerWrapper</code>.
This wrapper supports request handler advice handling and emits the normal 'produced no reply' debug log messages.
Its bean name is the handler bean name plus <code>.wrapper</code> (when there is an <code>@EndpointId</code>&#8201;&#8212;&#8201;otherwise, it is the normal generated handler name).</p>
</div>
<div class="paragraph">
<p>Similarly <a href="#pollable-message-source">Pollable Message Sources</a> create two beans, a <code>SourcePollingChannelAdapter</code> (SPCA) and a <code>MessageSource</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id = "someAdapter" ... /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding XML configuration, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SPCA: <code>someAdapter</code> (the <code>id</code>)</p>
</li>
<li>
<p>Handler: <code>someAdapter.source</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following Java configuration of a POJO to define an <code>@EndpointId</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public String pojoSource() {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding Java configuration example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SPCA: <code>someAdapter</code></p>
</li>
<li>
<p>Handler: <code>someAdapter.source</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following Java configuration of a bean to define an <code>@EndpointID</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean("someAdapter.source")
@EndpointId("someAdapter")
@InboundChannelAdapter(channel = "channel3", poller = @Poller(fixedDelay = "5000"))
public MessageSource&lt;?&gt; source() {
    return () -&gt; {
        ...
    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example, the bean names are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SPCA: <code>someAdapter</code></p>
</li>
<li>
<p>Handler: <code>someAdapter.source</code> (as long as you use the convention of appending <code>.source</code> to the <code>@Bean</code> name)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-enable-integration"><a class="anchor" href="#configuration-enable-integration"></a>5.5. Configuration and <code>@EnableIntegration</code></h3>
<div class="paragraph">
<p>Throughout this document, you can see references to XML namespace support for declaring elements in a Spring Integration flow.
This support is provided by a series of namespace parsers that generate appropriate bean definitions to implement a particular component.
For example, many endpoints consist of a <code>MessageHandler</code> bean and a <code>ConsumerEndpointFactoryBean</code> into which the handler and an input channel name are injected.</p>
</div>
<div class="paragraph">
<p>The first time a Spring Integration namespace element is encountered, the framework automatically declares a number of beans (a task scheduler, an implicit channel creator, and others) that are used to support the runtime environment.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Version 4.0 introduced the <code>@EnableIntegration</code> annotation, to allow the
registration of Spring Integration infrastructure beans (see the
<a href="https://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/config/EnableIntegration.html">Javadoc</a>).
This annotation is required when only Java configuration is used&#8201;&#8212;&#8201;for example with Spring Boot or Spring Integration Messaging Annotation support and Spring Integration Java DSL with no XML integration configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>@EnableIntegration</code> annotation is also useful when you have a parent context with no Spring Integration components
and two or more child contexts that use Spring Integration.
It lets these common components be declared once only, in the parent context.</p>
</div>
<div class="paragraph">
<p>The <code>@EnableIntegration</code> annotation registers many infrastructure components with the application context.
In particular, it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Registers some built-in beans, such as <code>errorChannel</code> and its <code>LoggingHandler</code>, <code>taskScheduler</code> for pollers, <code>jsonPath</code> SpEL-function, and others.</p>
</li>
<li>
<p>Adds several <code>BeanFactoryPostProcessor</code> instances to enhance the <code>BeanFactory</code> for global and default integration environment.</p>
</li>
<li>
<p>Adds several <code>BeanPostProcessor</code> instances to enhance or convert and wrap particular beans for integration purposes.</p>
</li>
<li>
<p>Adds annotation processors to parse messaging annotations and registers components for them with the application context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>@IntegrationComponentScan</code> annotation also permits classpath scanning.
This annotation plays a similar role as the standard Spring Framework <code>@ComponentScan</code> annotation, but it is restricted to components and annotations that are specific to Spring Integration, which the standard Spring Framework component scan mechanism cannot reach.
For an example, see <a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a>.</p>
</div>
<div class="paragraph">
<p>The <code>@EnablePublisher</code> annotation registers a <code>PublisherAnnotationBeanPostProcessor</code> bean and configures the <code>default-publisher-channel</code> for those <code>@Publisher</code> annotations that are provided without a <code>channel</code> attribute.
If more than one <code>@EnablePublisher</code> annotation is found, they must all have the same value for the default channel.
See <a href="#publisher-annotation">Annotation-driven Configuration with the <code>@Publisher</code> Annotation</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>@GlobalChannelInterceptor</code> annotation has been introduced to mark <code>ChannelInterceptor</code> beans for global channel interception.
This annotation is an analogue of the <code>&lt;int:channel-interceptor&gt;</code> XML element (see <a href="#global-channel-configuration-interceptors">Global Channel Interceptor Configuration</a>).
<code>@GlobalChannelInterceptor</code> annotations can be placed at the class level (with a <code>@Component</code> stereotype annotation) or on <code>@Bean</code> methods within <code>@Configuration</code> classes.
In either case, the bean must implement <code>ChannelInterceptor</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, global channel interceptors apply to dynamically registered channels&#8201;&#8212;&#8201;such as beans that are initialized by using <code>beanFactory.initializeBean()</code> or through the <code>IntegrationFlowContext</code> when using the Java DSL.
Previously, interceptors were not applied when beans were created after the application context was refreshed.</p>
</div>
<div class="paragraph">
<p>The <code>@IntegrationConverter</code> annotation marks <code>Converter</code>, <code>GenericConverter</code>, or <code>ConverterFactory</code> beans as candidate converters for <code>integrationConversionService</code>.
This annotation is an analogue of the <code>&lt;int:converter&gt;</code> XML element (see <a href="#payload-type-conversion">Payload Type Conversion</a>).
You can place <code>@IntegrationConverter</code> annotations at the class level (with a <code>@Component</code> stereotype annotation) or on <code>@Bean</code> methods within <code>@Configuration</code> classes.</p>
</div>
<div class="paragraph">
<p>See <a href="#annotations">Annotation Support</a> for more information about messaging mnnotations.</p>
</div>
</div>
<div class="sect2">
<h3 id="programming-considerations"><a class="anchor" href="#programming-considerations"></a>5.6. Programming Considerations</h3>
<div class="paragraph">
<p>You should use plain old java objects (POJOs) whenever possible and only expose the framework in your code when absolutely necessary.
See <a href="#pojo-invocation">POJO Method invocation</a> for more information.</p>
</div>
<div class="paragraph">
<p>If you do expose the framework to your classes, there are some considerations that need to be taken into account, especially during application startup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If your component is <code>ApplicationContextAware</code>, you should generally not use the <code>ApplicationContext</code> in the <code>setApplicationContext()</code> method.
Instead, store a reference and defer such uses until later in the context lifecycle.</p>
</li>
<li>
<p>If your component is an <code>InitializingBean</code> or uses <code>@PostConstruct</code> methods, do not send any messages from these initialization methods.
The application context is not yet initialized when these methods are called, and sending such messages is likely to fail.
If you need to send a messages during startup, implement <code>ApplicationListener</code> and wait for the <code>ContextRefreshedEvent</code>.
Alternatively, implement <code>SmartLifecycle</code>, put your bean in a late phase, and send the messages from the <code>start()</code> method.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="shaded"><a class="anchor" href="#shaded"></a>5.6.1. Considerations When Using Packaged (for example, Shaded) Jars</h4>
<div class="paragraph">
<p>Spring Integration bootstraps certain features by using Spring Framework&#8217;s <code>SpringFactories</code> mechanism to load several <code>IntegrationConfigurationInitializer</code> classes.
This includes the <code>-core</code> jar as well as certain others, including <code>-http</code> and <code>-jmx</code>.
The information for this process is stored in a <code>META-INF/spring.factories</code> file in each jar.</p>
</div>
<div class="paragraph">
<p>Some developers prefer to repackage their application and all dependencies into a single jar by using well known tools, such as the <a href="https://maven.apache.org/plugins/maven-shade-plugin/">Apache Maven Shade Plugin</a>.</p>
</div>
<div class="paragraph">
<p>By default, the shade plugin does not merge the <code>spring.factories</code> files when producing the shaded jar.</p>
</div>
<div class="paragraph">
<p>In addition to <code>spring.factories</code>, other <code>META-INF</code> files (<code>spring.handlers</code> and <code>spring.schemas</code>) are used for XML configuration.
These files also need to be merged.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html">Spring Boot&#8217;s executable jar mechanism</a> takes a different approach, in that it nests the jars, thus retaining each <code>spring.factories</code> file on the class path.
So, with a Spring Boot application, nothing more is needed if you use its default executable jar format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even if you do not use Spring Boot, you can still use the tooling provided by Boot to enhance the shade plugin by adding transformers for the above mentioned files.</p>
</div>
<div class="paragraph">
<p>You may wish to consult the current <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/spring-boot-starter-parent/pom.xml">spring-boot-starter-parent pom</a> to see the current settings that boot uses.
The following example shows how to configure the plugin:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">...
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;keepDependenciesWithProvidedScope&gt;true&lt;/keepDependenciesWithProvidedScope&gt;
                &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;
            &lt;/configuration&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt; <i class="conum" data-value="1"></i><b>(1)</b>
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;${spring.boot.version}&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;shade&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;transformers&gt; <i class="conum" data-value="2"></i><b>(2)</b>
                            &lt;transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt;
                                &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;
                            &lt;/transformer&gt;
                            &lt;transformer
                                implementation="org.springframework.boot.maven.PropertiesMergingResourceTransformer"&gt;
                                &lt;resource&gt;META-INF/spring.factories&lt;/resource&gt;
                            &lt;/transformer&gt;
                            &lt;transformer
                                implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer"&gt;
                                &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;
                            &lt;/transformer&gt;
                            &lt;transformer
                                implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" /&gt;
                        &lt;/transformers&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifically,</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add the <code>spring-boot-maven-plugin</code> as a dependency.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configure the transformers.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can add a property for <code>${spring.boot.version}</code> or use an explicit version.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="programming-tips"><a class="anchor" href="#programming-tips"></a>5.7. Programming Tips and Tricks</h3>
<div class="paragraph">
<p>This section documents some of the ways to get the most from Spring Integration.</p>
</div>
<div class="sect3">
<h4 id="xml-schemas"><a class="anchor" href="#xml-schemas"></a>5.7.1. XML Schemas</h4>
<div class="paragraph">
<p>When using XML configuration, to avoid getting false schema validation errors, you should use a &#8220;Spring-aware&#8221; IDE, such as the Spring Tool Suite (STS), Eclipse with the Spring IDE plugins, or IntelliJ IDEA.
These IDEs know how to resolve the correct XML schema from the classpath (by using the <code>META-INF/spring.schemas</code> file in the jars).
When using STS or Eclipse with the plugin, you must enable <code>Spring Project Nature</code> on the project.</p>
</div>
<div class="paragraph">
<p>The schemas hosted on the internet for certain legacy modules (those that existed in version 1.0) are the 1.0 versions for compatibility reasons.
If your IDE uses these schemas, you are likely to see false errors.</p>
</div>
<div class="paragraph">
<p>Each of these online schemas has a warning similar to the following:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This schema is for the 1.0 version of Spring Integration Core.
We cannot update it to the current schema because that will break any applications using 1.0.3 or lower.
For subsequent versions, the unversioned schema is resolved from the classpath and obtained from the jar.
Please refer to github:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config" class="bare">github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The affected modules are</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code>  (<code>spring-integration.xsd</code>)</p>
</li>
<li>
<p><code>file</code></p>
</li>
<li>
<p><code>http</code></p>
</li>
<li>
<p><code>jms</code></p>
</li>
<li>
<p><code>mail</code></p>
</li>
<li>
<p><code>rmi</code></p>
</li>
<li>
<p><code>security</code></p>
</li>
<li>
<p><code>stream</code></p>
</li>
<li>
<p><code>ws</code></p>
</li>
<li>
<p><code>xml</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="finding-class-names-for-java-and-dsl-configuration"><a class="anchor" href="#finding-class-names-for-java-and-dsl-configuration"></a>5.7.2. Finding Class Names for Java and DSL Configuration</h4>
<div class="paragraph">
<p>With XML configuration and Spring Integration Namespace support, the XML parsers hide how target beans are declared and wired together.
For Java configuration, it is important to understand the Framework API for target end-user applications.</p>
</div>
<div class="paragraph">
<p>The first-class citizens for EIP implementation are <code>Message</code>, <code>Channel</code>, and <code>Endpoint</code> (see <a href="#overview-components">Main Components</a>, earlier in this chapter).
Their implementations (contracts) are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.messaging.Message</code>: See <a href="#message">Message</a>;</p>
</li>
<li>
<p><code>org.springframework.messaging.MessageChannel</code>: See <a href="#channel">Message Channels</a>;</p>
</li>
<li>
<p><code>org.springframework.integration.endpoint.AbstractEndpoint</code>: See <a href="#polling-consumer">Poller</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two are simple enough to understand how to implement, configure, and use.
The last one deserves more attention</p>
</div>
<div class="paragraph">
<p>The <code>AbstractEndpoint</code> is widely used throughout the Spring Framework for different component implementations.
Its main implementations are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EventDrivenConsumer</code>, used when we subscribe to a <code>SubscribableChannel</code> to listen for messages.</p>
</li>
<li>
<p><code>PollingConsumer</code>, used when we poll for messages from a <code>PollableChannel</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you use messaging annotations or the Java DSL, you need ot worry about these components, because the Framework automatically produces them with appropriate annotations and <code>BeanPostProcessor</code> implementations.
When building components manually, you should use the <code>ConsumerEndpointFactoryBean</code> to help determine the target <code>AbstractEndpoint</code> consumer implementation to create, based on the provided <code>inputChannel</code> property.</p>
</div>
<div class="paragraph">
<p>On the other hand, the <code>ConsumerEndpointFactoryBean</code> delegates to an another first class citizen in the Framework:
<code>org.springframework.messaging.MessageHandler</code>.
The goal of the implementation of this interface is to handle the message consumed by the endpoint from the channel.
All EIP components in Spring Integration are <code>MessageHandler</code> implementations (for example, <code>AggregatingMessageHandler</code>, <code>MessageTransformingHandler</code>, <code>AbstractMessageSplitter</code>, and others).
The target protocol outbound adapters (<code>FileWritingMessageHandler</code>, <code>HttpRequestExecutingMessageHandler</code>, <code>AbstractMqttMessageHandler</code>, and others) are also <code>MessageHandler</code> implementations.
When you develop Spring Integration applications with Java configuration, you should look into the Spring Integration module to find an appropriate <code>MessageHandler</code> implementation to use for the <code>@ServiceActivator</code>\ configuration.
For example, to send an XMPP message (see <a href="#xmpp">XMPP Support</a>) you should configure something like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "input")
public MessageHandler sendChatMessageHandler(XMPPConnection xmppConnection) {
    ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(xmppConnection);

    DefaultXmppHeaderMapper xmppHeaderMapper = new DefaultXmppHeaderMapper();
    xmppHeaderMapper.setRequestHeaderNames("*");
    handler.setHeaderMapper(xmppHeaderMapper);

    return handler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>MessageHandler</code> implementations represent the outbound and processing part of the message flow.</p>
</div>
<div class="paragraph">
<p>The inbound message flow side has its own components, which are divided into polling and listening behaviors.
The listening (message-driven) components are simple and typically require only one target class implementation to be ready to
produce messages.
Listening components can be one-way <code>MessageProducerSupport</code> implementations, (such as <code>AbstractMqttMessageDrivenChannelAdapter</code> and <code>ImapIdleChannelAdapter</code>) or request-reply  <code>MessagingGatewaySupport</code> implementations (such as <code>AmqpInboundGateway</code> and <code>AbstractWebServiceInboundGateway</code>).</p>
</div>
<div class="paragraph">
<p>Polling inbound endpoints are for those protocols that do not provide a listener API or are not intended for
such a behavior, including any file based protocol (such as FTP), any data bases (RDBMS or NoSQL), and others.</p>
</div>
<div class="paragraph">
<p>These inbound endpoints consist of two components: the poller configuration, to initiate the polling task periodically,
and a message source class to read data from the target protocol and produce a message for the downstream integration flow.
The first class for the poller configuration is a <code>SourcePollingChannelAdapter</code>.
It is one more <code>AbstractEndpoint</code> implementation, but especially for polling to initiate an integration flow.
Typically, with the messaging annotations or Java DSL, you should not worry about this class.
The Framework produces a bean for it, based on the <code>@InboundChannelAdapter</code> configuration or a Java DSL builder spec.</p>
</div>
<div class="paragraph">
<p>Message source components are more important for the target application development, and they all implement the <code>MessageSource</code> interface (for example, <code>MongoDbMessageSource</code> and <code>AbstractTwitterMessageSource</code>).
With that in mind, our config for reading data from an RDBMS table with JDBC could resemble the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@InboundChannelAdapter(value = "fooChannel", poller = @Poller(fixedDelay="5000"))
public MessageSource&lt;?&gt; storedProc(DataSource dataSource) {
    return new JdbcPollingChannelAdapter(dataSource, "SELECT * FROM foo where status = 0");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can find all the required inbound and outbound classes for the target protocols in the particular Spring Integration module (in most cases, in the respective package).
For example, the <code>spring-integration-websocket</code> adapters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>o.s.i.websocket.inbound.WebSocketInboundChannelAdapter</code>: Implements <code>MessageProducerSupport</code> to listen for frames on the socket and produce message to the channel.</p>
</li>
<li>
<p><code>o.s.i.websocket.outbound.WebSocketOutboundMessageHandler</code>: The one-way <code>AbstractMessageHandler</code> implementation to convert incoming messages to the appropriate frame and send over websocket.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are familiar with Spring Integration XML configuration, starting with version 4.3, we provide information in the
XSD element definitions about which target classes are used to declare beans for the adapter or gateway, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;xsd:element name="outbound-async-gateway"&gt;
    &lt;xsd:annotation&gt;
		&lt;xsd:documentation&gt;
Configures a Consumer Endpoint for the 'o.s.i.amqp.outbound.AsyncAmqpOutboundGateway'
that will publish an AMQP Message to the provided Exchange and expect a reply Message.
The sending thread returns immediately; the reply is sent asynchronously; uses 'AsyncRabbitTemplate.sendAndReceive()'.
       &lt;/xsd:documentation&gt;
	&lt;/xsd:annotation&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pojo-invocation"><a class="anchor" href="#pojo-invocation"></a>5.8. POJO Method invocation</h3>
<div class="paragraph">
<p>As discussed in <a href="#programming-considerations">Programming Considerations</a>, we recommend using a POJO programming style, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator
public String myService(String payload) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the framework extracts a <code>String</code> payload, invokes your method, and wraps the result in a message to send to the next component in the flow (the original headers are copied to the new message).
In fact, if you use XML configuration, you do not even need the <code>@ServiceActivator</code> annotation, as the following paired examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator ... ref="myPojo" method="myService" /&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String myService(String payload) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can omit the <code>method</code> attribute as long as there is no ambiguity in the public methods on the class.</p>
</div>
<div class="paragraph">
<p>You can also obtain header information in your POJO methods, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator
public String myService(@Payload String payload, @Header("foo") String fooHeader) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also dereference properties on the message, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator
public String myService(@Payload("payload.foo") String foo, @Header("bar.baz") String barbaz) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Because various POJO method invocations are available, versions prior to 5.0 used SpEL (Spring Expression Language) to invoke the POJO methods.
SpEL (even interpreted) is usually &#8220;fast enough&#8221; for these operations, when compared to the actual work usually done in the methods.
However, starting with version 5.0, the <code>org.springframework.messaging.handler.invocation.InvocableHandlerMethod</code> is used by default whenever possible.
This technique is usually faster to execute than interpreted SpEL and is consistent with other Spring messaging projects.
The <code>InvocableHandlerMethod</code> is similar to the technique used to invoke controller methods in Spring MVC.
There are certain methods that are still always invoked when using SpEL.
Examples include annotated parameters with dereferenced properties, as discussed earlier.
This is because SpEL has the capability to navigate a property path.</p>
</div>
<div class="paragraph">
<p>There may be some other corner cases that we have not considered that also do not work with <code>InvocableHandlerMethod</code> instances.
For this reason, we automatically fall back to using SpEL in those cases.</p>
</div>
<div class="paragraph">
<p>If you wish, you can also set up your POJO method such that it always uses SpEL, with the <code>UseSpelInvoker</code> annotation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@UseSpelInvoker(compilerMode = "IMMEDIATE")
public void bar(String bar) { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>compilerMode</code> property is omitted, the <code>spring.expression.compiler.mode</code> system property determines the compiler mode.
See <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/expressions.html#expressions-spel-compilation">SpEL compilation</a> for more information about compiled SpEL.</p>
</div>
</div>
</div>
</div>
<h1 id="spring-integration-core-messaging" class="sect0"><a class="anchor" href="#spring-integration-core-messaging"></a>Core Messaging</h1>
<div class="openblock partintro">
<div class="content">
<div id="spring-integration-core-msg" class="paragraph">
<p>This section covers all aspects of the core messaging API in Spring Integration.
It covers messages, message channels, and message endpoints.
It also covers many of the enterprise integration patterns, such as filter, router, transformer, service activator , splitter, and aggregator.</p>
</div>
<div class="paragraph">
<p>This section also contains material about system management, including the control bus and message history support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="messaging-channels-section"><a class="anchor" href="#messaging-channels-section"></a>6. Messaging Channels</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="channel"><a class="anchor" href="#channel"></a>6.1. Message Channels</h3>
<div class="paragraph">
<p>While the <code>Message</code> plays the crucial role of encapsulating data, it is the <code>MessageChannel</code> that decouples message producers from message consumers.</p>
</div>
<div class="sect3">
<h4 id="channel-interfaces"><a class="anchor" href="#channel-interfaces"></a>6.1.1. The MessageChannel Interface</h4>
<div class="paragraph">
<p>Spring Integration&#8217;s top-level <code>MessageChannel</code> interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageChannel {

    boolean send(Message message);

    boolean send(Message message, long timeout);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When sending a message, the return value is <code>true</code> if the message is sent successfully.
If the send call times out or is interrupted, it returns <code>false</code>.</p>
</div>
<div class="sect4">
<h5 id="channel-interfaces-pollablechannel"><a class="anchor" href="#channel-interfaces-pollablechannel"></a><code>PollableChannel</code></h5>
<div class="paragraph">
<p>Since message channels may or may not buffer messages (as discussed in the <a href="#overview">Spring Integration Overview</a>), two sub-interfaces define the buffering (pollable) and non-buffering (subscribable) channel behavior.
The following listing shows the definition of the <code>PollableChannel</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface PollableChannel extends MessageChannel {

    Message&lt;?&gt; receive();

    Message&lt;?&gt; receive(long timeout);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As with the send methods, when receiving a message, the return value is null in the case of a timeout or interrupt.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-interfaces-subscribablechannel"><a class="anchor" href="#channel-interfaces-subscribablechannel"></a><code>SubscribableChannel</code></h5>
<div class="paragraph">
<p>The <code>SubscribableChannel</code> base interface is implemented by channels that send messages directly to their subscribed <code>MessageHandler</code> instances.
Therefore, they do not provide receive methods for polling.
Instead, they define methods for managing those subscribers.
The following listing shows the definition of the <code>SubscribableChannel</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SubscribableChannel extends MessageChannel {

    boolean subscribe(MessageHandler handler);

    boolean unsubscribe(MessageHandler handler);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="channel-implementations"><a class="anchor" href="#channel-implementations"></a>6.1.2. Message Channel Implementations</h4>
<div class="paragraph">
<p>Spring Integration provides several different message channel implementations.
The following sections briefly describe each one.</p>
</div>
<div class="sect4">
<h5 id="channel-implementations-publishsubscribechannel"><a class="anchor" href="#channel-implementations-publishsubscribechannel"></a><code>PublishSubscribeChannel</code></h5>
<div class="paragraph">
<p>The <code>PublishSubscribeChannel</code> implementation broadcasts any <code>Message</code> sent to it to all of its subscribed handlers.
This is most often used for sending event messages, whose primary role is notification (as opposed to document messages, which are generally intended to be processed by a single handler).
Note that the <code>PublishSubscribeChannel</code> is intended for sending only.
Since it broadcasts to its subscribers directly when its <code>send(Message)</code> method is invoked, consumers cannot poll for messages (it does not implement <code>PollableChannel</code> and therefore has no <code>receive()</code> method).
Instead, any subscriber must itself be a <code>MessageHandler</code>, and the subscriber&#8217;s <code>handleMessage(Message)</code> method is invoked in turn.</p>
</div>
<div class="paragraph">
<p>Prior to version 3.0, invoking the <code>send</code> method on a <code>PublishSubscribeChannel</code> that had no subscribers returned <code>false</code>.
When used in conjunction with a <code>MessagingTemplate</code>, a <code>MessageDeliveryException</code> was thrown.
Starting with version 3.0, the behavior has changed such that a <code>send</code> is always considered successful if at least the minimum subscribers are present (and successfully handle the message).
This behavior can be modified by setting the <code>minSubscribers</code> property, which defaults to <code>0</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use a <code>TaskExecutor</code>, only the presence of the correct number of subscribers is used for this determination, because the actual handling of the message is performed asynchronously.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="channel-implementations-queuechannel"><a class="anchor" href="#channel-implementations-queuechannel"></a><code>QueueChannel</code></h5>
<div class="paragraph">
<p>The <code>QueueChannel</code> implementation wraps a queue.
Unlike the <code>PublishSubscribeChannel</code>, the <code>QueueChannel</code> has point-to-point semantics.
In other words, even if the channel has multiple consumers, only one of them should receive any <code>Message</code> sent to that channel.
It provides a default no-argument constructor (providing an essentially unbounded capacity of <code>Integer.MAX_VALUE</code>) as well as a constructor that accepts the queue capacity, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public QueueChannel(int capacity)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A channel that has not reached its capacity limit storeS messages in its internal queue, and the <code>send()</code> method returns immediately, even if no receiver is ready to handle the message.
If the queue has reached capacity, the sender blocks until room is available.
Alternatively, if you use the send call that accepts a timeout, the queue blocks until either room is available or the timeout period elapses, whichever occurs first.
Similarly, a <code>receive</code> call returns immediately if a message is available on the queue, but, if the queue is empty, then a receive call may block until either a message is available or the timeout elapses.
In either case, it is possible to force an immediate return regardless of the queue&#8217;s state by passing a timeout value of 0.
Note, however, that calls to the no-arg versions of <code>send()</code> and <code>receive()</code> block indefinitely.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-implementations-prioritychannel"><a class="anchor" href="#channel-implementations-prioritychannel"></a><code>PriorityChannel</code></h5>
<div class="paragraph">
<p>Whereas the <code>QueueChannel</code> enforces first-in-first-out (FIFO) ordering, the <code>PriorityChannel</code> is an alternative implementation that allows for messages to be ordered within the channel based upon a priority.
By default, the priority is determined by the <code>priority</code> header within each message.
However, for custom priority determination logic, a comparator of type <code>Comparator&lt;Message&lt;?&gt;&gt;</code> can be provided to the <code>PriorityChannel</code> constructor.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-implementations-rendezvouschannel"><a class="anchor" href="#channel-implementations-rendezvouschannel"></a><code>RendezvousChannel</code></h5>
<div class="paragraph">
<p>The <code>RendezvousChannel</code> enables a &#8220;direct-handoff&#8221; scenario, wherein a sender blocks until another party invokes the channel&#8217;s <code>receive()</code> method.
The other party blocks until the sender sends the message.
Internally, this implementation is quite similar to the <code>QueueChannel</code>, except that it uses a <code>SynchronousQueue</code> (a zero-capacity implementation of <code>BlockingQueue</code>).
This works well in situations where the sender and receiver operate in different threads, but asynchronously dropping the message in a queue is not appropriate.
In other words, with a <code>RendezvousChannel</code>, the sender knows that some receiver has accepted the message, whereas with a <code>QueueChannel</code>, the message would have been stored to the internal queue and potentially never received.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Keep in mind that all of these queue-based channels are storing messages in-memory only by default.
When persistence is required, you can either provide a 'message-store' attribute within the 'queue' element to reference a persistent <code>MessageStore</code> implementation or you can replace the local channel with one that is backed by a persistent broker, such as a JMS-backed channel or channel adapter.
The latter option lets you take advantage of any JMS provider&#8217;s implementation for message persistence, as discussed in <a href="#jms">JMS Support</a>.
However, when buffering in a queue is not necessary, the simplest approach is to rely upon the <code>DirectChannel</code>, discussed in the next section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>RendezvousChannel</code> is also useful for implementing request-reply operations.
The sender can create a temporary, anonymous instance of <code>RendezvousChannel</code>, which it then sets as the 'replyChannel' header when building a <code>Message</code>.
After sending that <code>Message</code>, the sender can immediately call <code>receive</code> (optionally providing a timeout value) in order to block while waiting for a reply <code>Message</code>.
This is very similar to the implementation used internally by many of Spring Integration&#8217;s request-reply components.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-implementations-directchannel"><a class="anchor" href="#channel-implementations-directchannel"></a><code>DirectChannel</code></h5>
<div class="paragraph">
<p>The <code>DirectChannel</code> has point-to-point semantics but otherwise is more similar to the <code>PublishSubscribeChannel</code> than any of the queue-based channel implementations described earlier.
It implements the <code>SubscribableChannel</code> interface instead of the <code>PollableChannel</code> interface, so it dispatches messages directly to a subscriber.
As a point-to-point channel, however, it differs from the <code>PublishSubscribeChannel</code> in that it sends each <code>Message</code> to a single subscribed <code>MessageHandler</code>.</p>
</div>
<div class="paragraph">
<p>In addition to being the simplest point-to-point channel option, one of its most important features is that it enables a single thread to perform the operations on &#8220;both sides&#8221; of the channel.
For example, if a handler subscribes to a <code>DirectChannel</code>, then sending a <code>Message</code> to that channel triggers invocation of that handler&#8217;s <code>handleMessage(Message)</code> method directly in the sender&#8217;s thread, before the <code>send()</code> method invocation can return.</p>
</div>
<div class="paragraph">
<p>The key motivation for providing a channel implementation with this behavior is to support transactions that must span across the channel while still benefiting from the abstraction and loose coupling that the channel provides.
If the send call is invoked within the scope of a transaction, the outcome of the handler&#8217;s invocation (for example,
updating a database record) plays a role in determining the ultimate result of that transaction (commit or rollback).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since the <code>DirectChannel</code> is the simplest option and does not add any additional overhead that would be required for scheduling and managing the threads of a poller, it is the default channel type within Spring Integration.
The general idea is to define the channels for an application, consider which of those need to provide buffering or to throttle input, and modify those to be queue-based <code>PollableChannels</code>.
Likewise, if a channel needs to broadcast messages, it should not be a <code>DirectChannel</code> but rather a <code>PublishSubscribeChannel</code>.
Later, we show how each of these channels can be configured.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>DirectChannel</code> internally delegates to a message dispatcher to invoke its subscribed message handlers, and that dispatcher can have a load-balancing strategy exposed by <code>load-balancer</code> or <code>load-balancer-ref</code> attributes (mutually exclusive).
The load balancing strategy is used by the message dispatcher to help determine how messages are distributed amongst message handlers when multiple message handlers subscribe to the same channel.
As a convenience, the <code>load-balancer</code> attribute exposes an enumeration of values pointing to pre-existing implementations of <code>LoadBalancingStrategy</code>.
<code>round-robin</code> (load-balances across the handlers in rotation) and <code>none</code> (for the cases where one wants to explicitly disable load balancing) are the only available values.
Other strategy implementations may be added in future versions.
However, since version 3.0, you can provide your own implementation of the <code>LoadBalancingStrategy</code> and inject it by using the <code>load-balancer-ref</code> attribute, which should point to a bean that implements <code>LoadBalancingStrategy</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="lbRefChannel"&gt;
  &lt;int:dispatcher load-balancer-ref="lb"/&gt;
&lt;/int:channel&gt;

&lt;bean id="lb" class="foo.bar.SampleLoadBalancingStrategy"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>load-balancer</code> and <code>load-balancer-ref</code> attributes are mutually exclusive.</p>
</div>
<div class="paragraph">
<p>The load-balancing also works in conjunction with a boolean <code>failover</code> property.
If the &#8220;failover&#8221; value is true (the default), the dispatcher falls back to any subsequent handlers (as necessary) when preceding handlers throw exceptions.
The order is determined by an optional order value defined on the handlers themselves or, if no such value exists, the order in which the handlers subscribed.</p>
</div>
<div class="paragraph">
<p>If a certain situation requires that the dispatcher always try to invoke the first handler and then fall back in the same fixed order sequence every time an error occurs, no load-balancing strategy should be provided.
In other words, the dispatcher still supports the <code>failover</code> boolean property even when no load-balancing is enabled.
Without load-balancing, however, the invocation of handlers always begins with the first, according to their order.
For example, this approach works well when there is a clear definition of primary, secondary, tertiary, and so on.
When using the namespace support, the <code>order</code> attribute on any endpoint determines the order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Keep in mind that load-balancing and <code>failover</code> apply only when a channel has more than one subscribed message handler.
When using the namespace support, this means that more than one endpoint shares the same channel reference defined in the <code>input-channel</code> attribute.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="executor-channel"><a class="anchor" href="#executor-channel"></a><code>ExecutorChannel</code></h5>
<div class="paragraph">
<p>The <code>ExecutorChannel</code> is a point-to-point channel that supports the same dispatcher configuration as <code>DirectChannel</code> (load-balancing strategy and the <code>failover</code> boolean property).
The key difference between these two dispatching channel types is that the <code>ExecutorChannel</code> delegates to an instance of <code>TaskExecutor</code> to perform the dispatch.
This means that the send method typically does not block, but it also means that the handler invocation may not occur in the sender&#8217;s thread.
It therefore does not support transactions that span the sender and receiving handler.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The sender can sometimes block.
For example, when using a <code>TaskExecutor</code> with a rejection policy that throttles the client (such as the <code>ThreadPoolExecutor.CallerRunsPolicy</code>), the sender&#8217;s thread can execute the method any time the thread pool is at its maximum capacity and the executor&#8217;s work queue is full.
Since that situation would only occur in a non-predictable way, you should not rely upon it for transactions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="channel-implementations-threadlocalchannel"><a class="anchor" href="#channel-implementations-threadlocalchannel"></a>Scoped Channel</h5>
<div class="paragraph">
<p>Spring Integration 1.0 provided a <code>ThreadLocalChannel</code> implementation, but that has been removed as of 2.0.
Now the more general way to handle the same requirement is to add a <code>scope</code> attribute to a channel.
The value of the attribute can be the name of a scope that is available within the context.
For example, in a web environment, certain scopes are available, and any custom scope implementations can be registered with the context.
The following example shows a thread-local scope being applied to a channel, including the registration of the scope itself:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="threadScopedChannel" scope="thread"&gt;
     &lt;int:queue /&gt;
&lt;/int:channel&gt;

&lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
    &lt;property name="scopes"&gt;
        &lt;map&gt;
            &lt;entry key="thread" value="org.springframework.context.support.SimpleThreadScope" /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The channel defined in the previous example also delegates to a queue internally, but the channel is bound to the current thread, so the contents of the queue are similarly bound.
That way, the thread that sends to the channel can later receive those same messages, but no other thread would be able to access them.
While thread-scoped channels are rarely needed, they can be useful in situations where <code>DirectChannel</code> instances are being used to enforce a single thread of operation but any reply messages should be sent to a &#8220;terminal&#8221; channel.
If that terminal channel is thread-scoped, the original sending thread can collect its replies from the terminal channel.</p>
</div>
<div class="paragraph">
<p>Now, since any channel can be scoped, you can define your own scopes in addition to thread-Local.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="channel-interceptors"><a class="anchor" href="#channel-interceptors"></a>6.1.3. Channel Interceptors</h4>
<div class="paragraph">
<p>One of the advantages of a messaging architecture is the ability to provide common behavior and capture meaningful information about the messages passing through the system in a non-invasive way.
Since the <code>Message</code> instances are sent to and received from <code>MessageChannel</code> instances, those channels provide an opportunity for intercepting the send and receive operations.
The <code>ChannelInterceptor</code> strategy interface, shown in the following listing, provides methods for each of those operations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ChannelInterceptor {

    Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel);

    void postSend(Message&lt;?&gt; message, MessageChannel channel, boolean sent);

    void afterSendCompletion(Message&lt;?&gt; message, MessageChannel channel, boolean sent, Exception ex);

    boolean preReceive(MessageChannel channel);

    Message&lt;?&gt; postReceive(Message&lt;?&gt; message, MessageChannel channel);

    void afterReceiveCompletion(Message&lt;?&gt; message, MessageChannel channel, Exception ex);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After implementing the interface, registering the interceptor with a channel is just a matter of making the following call:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">channel.addInterceptor(someChannelInterceptor);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The methods that return a <code>Message</code> instance can be used for transforming the <code>Message</code> or can return 'null' to prevent further processing (of course, any of the methods can throw a <code>RuntimeException</code>).
Also, the <code>preReceive</code> method can return <code>false</code> to prevent the receive operation from proceeding.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Keep in mind that <code>receive()</code> calls are only relevant for <code>PollableChannels</code>.
In fact, the <code>SubscribableChannel</code> interface does not even define a <code>receive()</code> method.
The reason for this is that when a <code>Message</code> is sent to a <code>SubscribableChannel</code>, it is sent directly to zero or more subscribers, depending on the type of channel (for example,
a <code>PublishSubscribeChannel</code> sends to all of its subscribers).
Therefore, the <code>preReceive(&#8230;&#8203;)</code>, <code>postReceive(&#8230;&#8203;)</code>, and <code>afterReceiveCompletion(&#8230;&#8203;)</code> interceptor methods are invoked only when the interceptor is applied to a <code>PollableChannel</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Integration also provides an implementation of the <a href="https://www.enterpriseintegrationpatterns.com/WireTap.html">Wire Tap</a> pattern.
It is a simple interceptor that sends the <code>Message</code> to another channel without otherwise altering the existing flow.
It can be very useful for debugging and monitoring.
An example is shown in <a href="#channel-wiretap">Wire Tap</a>.</p>
</div>
<div class="paragraph">
<p>Because it is rarely necessary to implement all of the interceptor methods, the interface provides no-op methods (methods returning <code>void</code> method have no code, the <code>Message</code>-returning methods return the <code>Message</code> as-is, and the <code>boolean</code> method returns <code>true</code>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The order of invocation for the interceptor methods depends on the type of channel.
As described earlier, the queue-based channels are the only ones where the receive method is intercepted in the first place.
Additionally, the relationship between send and receive interception depends on the timing of the separate sender and receiver threads.
For example, if a receiver is already blocked while waiting for a message, the order could be as follows: <code>preSend</code>, <code>preReceive</code>, <code>postReceive</code>, <code>postSend</code>.
However, if a receiver polls after the sender has placed a message on the channel and has already returned, the order would be as follows: <code>preSend</code>, <code>postSend</code> (some-time-elapses), <code>preReceive</code>, <code>postReceive</code>.
The time that elapses in such a case depends on a number of factors and is therefore generally unpredictable (in fact, the receive may never happen).
The type of queue also plays a role (for example, rendezvous versus priority).
In short, you cannot rely on the order beyond the fact that <code>preSend</code> precedes <code>postSend</code> and <code>preReceive</code> precedes <code>postReceive</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with Spring Framework 4.1 and Spring Integration 4.1, the <code>ChannelInterceptor</code> provides new methods: <code>afterSendCompletion()</code> and <code>afterReceiveCompletion()</code>.
They are invoked after <code>send()' and 'receive()</code> calls, regardless of any exception that is raised, which allow for resource cleanup.
Note that the channel invokes these methods on the <code>ChannelInterceptor</code> list in the reverse order of the initial <code>preSend()</code> and <code>preReceive()</code> calls.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, global channel interceptors now apply to dynamically registered channels - such as through beans that are initialized by using <code>beanFactory.initializeBean()</code> or <code>IntegrationFlowContext</code> when using the Java DSL.
Previously, interceptors were not applied when beans were created after the application context was refreshed.</p>
</div>
<div class="paragraph">
<p>Also, starting with version 5.1, <code>ChannelInterceptor.postReceive()</code> is no longer called when no message is received; it is no longer necessary to check for a <code>null</code> <code>Message&lt;?&gt;</code>.
Previously, the method was called.
If you have an interceptor that relies on the previous behavior, implement <code>afterReceiveCompleted()</code> instead, since that method is invoked, regardless of whether a message is received or not.</p>
</div>
</div>
<div class="sect3">
<h4 id="channel-template"><a class="anchor" href="#channel-template"></a>6.1.4. <code>MessagingTemplate</code></h4>
<div class="paragraph">
<p>When the endpoints and their various configuration options are introduced, Spring Integration provides a foundation for messaging components that enables non-invasive invocation of your application code from the messaging system.
However, it is sometimes necessary to invoke the messaging system from your application code.
For convenience when implementing such use cases, Spring Integration provides a <code>MessagingTemplate</code> that supports a variety of operations across the message channels, including request and reply scenarios.
For example, it is possible to send a request and wait for a reply, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessagingTemplate template = new MessagingTemplate();

Message reply = template.sendAndReceive(someChannel, new GenericMessage("test"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, a temporary anonymous channel would be created internally by the template.
The 'sendTimeout' and 'receiveTimeout' properties may also be set on the template, and other exchange types are also supported.
The following listing shows the signatures for such methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public boolean send(final MessageChannel channel, final Message&lt;?&gt; message) { ...
}

public Message&lt;?&gt; sendAndReceive(final MessageChannel channel, final Message&lt;?&gt; request) { ...
}

public Message&lt;?&gt; receive(final PollableChannel&lt;?&gt; channel) { ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A less invasive approach that lets you invoke simple interfaces with payload or header values instead of <code>Message</code> instances is described in <a href="#gateway-proxy">Enter the <code>GatewayProxyFactoryBean</code></a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="channel-configuration"><a class="anchor" href="#channel-configuration"></a>6.1.5. Configuring Message Channels</h4>
<div class="paragraph">
<p>To create a message channel instance, you can use the &lt;channel/&gt; element, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The default channel type is point-to-point.
To create a publish-subscribe channel, use the <code>&lt;publish-subscribe-channel/&gt;</code> element, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:publish-subscribe-channel id="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use the <code>&lt;channel/&gt;</code> element without any sub-elements, it creates a <code>DirectChannel</code> instance (a <code>SubscribableChannel</code>).</p>
</div>
<div class="paragraph">
<p>However, you can alternatively provide a variety of <code>&lt;queue/&gt;</code> sub-elements to create any of the pollable channel types (as described in <a href="#channel-implementations">Message Channel Implementations</a>).
The following sections shows examples of each channel type.</p>
</div>
<div class="sect4">
<h5 id="channel-configuration-directchannel"><a class="anchor" href="#channel-configuration-directchannel"></a><code>DirectChannel</code> Configuration</h5>
<div class="paragraph">
<p>As mentioned earlier, <code>DirectChannel</code> is the default type.
The following listing shows who to define one in XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="directChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A default channel has a round-robin load-balancer and also has failover enabled (see <a href="#channel-implementations-directchannel"><code>DirectChannel</code></a> for more detail).
To disable one or both of these, add a <code>&lt;dispatcher/&gt;</code> sub-element and configure the attributes as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="failFastChannel"&gt;
    &lt;int:dispatcher failover="false"/&gt;
&lt;/channel&gt;

&lt;int:channel id="channelWithFixedOrderSequenceFailover"&gt;
    &lt;int:dispatcher load-balancer="none"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="channel-datatype-channel"><a class="anchor" href="#channel-datatype-channel"></a>Datatype Channel Configuration</h5>
<div class="paragraph">
<p>Sometimes, a consumer can process only a particular type of payload, forcing you to ensure the payload type of the input messages.
The first thing that comes to mind may be to use a message filter.
However, all that message filter can do is filter out messages that are not compliant with the requirements of the consumer.
Another way would be to use a content-based router and route messages with non-compliant data-types to specific transformers to enforce transformation and conversion to the required data type.
This would work, but a simpler way to accomplish the same thing is to apply the <a href="https://www.enterpriseintegrationpatterns.com/DatatypeChannel.html">Datatype Channel</a> pattern.
You can use separate datatype channels for each specific payload data type.</p>
</div>
<div class="paragraph">
<p>To create a datatype channel that accepts only messages that contain a certain payload type, provide the data type&#8217;s fully-qualified class name in the channel element&#8217;s <code>datatype</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="numberChannel" datatype="java.lang.Number"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the type check passes for any type that is assignable to the channel&#8217;s datatype.
In other words, the <code>numberChannel</code> in the preceding example would accept messages whose payload is <code>java.lang.Integer</code> or <code>java.lang.Double</code>.
Multiple types can be provided as a comma-delimited list, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="stringOrNumberChannel" datatype="java.lang.String,java.lang.Number"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So the 'numberChannel' in the preceding example accepts only messages with a data type of <code>java.lang.Number</code>.
But what happens if the payload of the message is not of the required type? It depends on whether you have defined a bean named <code>integrationConversionService</code> that is an instance of Spring&#8217;s <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-ConversionService-API">Conversion Service</a>.
If not, then an <code>Exception</code> would be thrown immediately.
However, if you have defined an <code>integrationConversionService</code> bean, it is used in an attempt to convert the message&#8217;s payload to the acceptable type.</p>
</div>
<div class="paragraph">
<p>You can even register custom converters.
For example, suppose you send a message with a <code>String</code> payload to the 'numberChannel' we configured above.
You might handle the message as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageChannel inChannel = context.getBean("numberChannel", MessageChannel.class);
inChannel.send(new GenericMessage&lt;String&gt;("5"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Typically this would be a perfectly legal operation.
However, since we use Datatype Channel, the result of such operation would generate an exception similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Exception in thread "main" org.springframework.integration.MessageDeliveryException:
Channel 'numberChannel'
expected one of the following datataypes [class java.lang.Number],
but received [class java.lang.String]
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The exception happens because we require the payload type to be a <code>Number</code>, but we sent a <code>String</code>.
So we need something to convert a <code>String</code> to a <code>Number</code>.
For that, we can implement a converter similar to the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class StringToIntegerConverter implements Converter&lt;String, Integer&gt; {
    public Integer convert(String source) {
        return Integer.parseInt(source);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then we can register it as a converter with the Integration Conversion Service, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;int:converter ref="strToInt"/&gt;

&lt;bean id="strToInt" class="org.springframework.integration.util.Demo.StringToIntegerConverter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the 'converter' element is parsed, it creates the <code>integrationConversionService</code> bean if one is not already defined.
With that converter in place, the <code>send</code> operation would now be successful, because the datatype channel uses that converter to convert the <code>String</code> payload to an <code>Integer</code>.</p>
</div>
<div class="paragraph">
<p>For more information regarding payload type conversion, see <a href="#payload-type-conversion">Payload Type Conversion</a>.</p>
</div>
<div class="paragraph">
<p>Beginning with version 4.0, the <code>integrationConversionService</code> is invoked by the <code>DefaultDatatypeChannelMessageConverter</code>, which looks up the conversion service in the application context.
To use a different conversion technique, you can specify the <code>message-converter</code> attribute on the channel.
This must be a reference to a <code>MessageConverter</code> implementation.
Only the <code>fromMessage</code> method is used.
It provides the converter with access to the message headers (in case the conversion might need information from the headers, such as <code>content-type</code>).
The method can return only the converted payload or a full <code>Message</code> object.
If the latter, the converter must be careful to copy all the headers from the inbound message.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can declare a <code>&lt;bean/&gt;</code> of type <code>MessageConverter</code> with an ID of <code>datatypeChannelMessageConverter</code>, and that converter is used by all channels with a <code>datatype</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-queuechannel"><a class="anchor" href="#channel-configuration-queuechannel"></a><code>QueueChannel</code> Configuration</h5>
<div class="paragraph">
<p>To create a <code>QueueChannel</code>, use the <code>&lt;queue/&gt;</code> sub-element.
You may specify the channel&#8217;s capacity as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="queueChannel"&gt;
    &lt;queue capacity="25"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not provide a value for the 'capacity' attribute on this <code>&lt;queue/&gt;</code> sub-element, the resulting queue is unbounded.
To avoid issues such as running out of memory, we highly recommend that you set an explicit value for a bounded queue.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="persistent-queuechannel-configuration"><a class="anchor" href="#persistent-queuechannel-configuration"></a>Persistent <code>QueueChannel</code> Configuration</h6>
<div class="paragraph">
<p>Since a <code>QueueChannel</code> provides the capability to buffer messages but does so in-memory only by default, it also introduces a possibility that messages could be lost in the event of a system failure.
To mitigate this risk, a <code>QueueChannel</code> may be backed by a persistent implementation of the <code>MessageGroupStore</code> strategy interface.
For more details on <code>MessageGroupStore</code> and <code>MessageStore</code>, see <a href="#message-store">Message Store</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>capacity</code> attribute is not allowed when the <code>message-store</code> attribute is used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a <code>QueueChannel</code> receives a <code>Message</code>, it adds the message to the message store.
When a <code>Message</code> is polled from a <code>QueueChannel</code>, it is removed from the message store.</p>
</div>
<div class="paragraph">
<p>By default, a <code>QueueChannel</code> stores its messages in an in-memory queue, which can lead to the lost message scenario mentioned earlier.
However, Spring Integration provides persistent stores, such as the <code>JdbcChannelMessageStore</code>.</p>
</div>
<div class="paragraph">
<p>You can configure a message store for any <code>QueueChannel</code> by adding the <code>message-store</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="dbBackedChannel"&gt;
    &lt;int:queue message-store="channelStore"/&gt;
&lt;/int:channel&gt;

&lt;bean id="channelStore" class="o.s.i.jdbc.store.JdbcChannelMessageStore"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="channelMessageStoreQueryProvider" ref="queryProvider"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The Spring Integration JDBC module also provides a schema Data Definition Language (DDL) for a number of popular databases.
These schemas are located in the org.springframework.integration.jdbc.store.channel package of that module (<code>spring-integration-jdbc</code>).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
One important feature is that, with any transactional persistent store (such as <code>JdbcChannelMessageStore</code>), as long as the poller has a transaction configured, a message removed from the store can be permanently removed only if the transaction completes successfully.
Otherwise the transaction rolls back, and the <code>Message</code> is not lost.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Many other implementations of the message store are available as the growing number of Spring projects related to &#8220;NoSQL&#8221; data stores come to provide underlying support for these stores.
You can also provide your own implementation of the <code>MessageGroupStore</code> interface if you cannot find one that meets your particular needs.</p>
</div>
<div class="paragraph">
<p>Since version 4.0, we recommend that <code>QueueChannel</code> instances be configured to use a <code>ChannelMessageStore</code>, if possible.
These are generally optimized for this use, as compared to a general message store.
If the <code>ChannelMessageStore</code> is a <code>ChannelPriorityMessageStore</code>, the messages are received in FIFO within priority order.
The notion of priority is determined by the message store implementation.
For example, the following example shows the Java configuration for the <a href="#mongodb-priority-channel-message-store">MongoDB Channel Message Store</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public BasicMessageGroupStore mongoDbChannelMessageStore(MongoDbFactory mongoDbFactory) {
    MongoDbChannelMessageStore store = new MongoDbChannelMessageStore(mongoDbFactory);
    store.setPriorityEnabled(true);
    return store;
}

@Bean
public PollableChannel priorityQueue(BasicMessageGroupStore mongoDbChannelMessageStore) {
    return new PriorityChannel(new MessageGroupQueue(mongoDbChannelMessageStore, "priorityQueue"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pay attention to the <code>MessageGroupQueue</code> class.
That is a <code>BlockingQueue</code> implementation to use the <code>MessageGroupStore</code> operations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same implementation with Java DSL might look like the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow priorityFlow(PriorityCapableChannelMessageStore mongoDbChannelMessageStore) {
    return IntegrationFlows.from((Channels c) -&gt;
            c.priority("priorityChannel", mongoDbChannelMessageStore, "priorityGroup"))
            ....
            .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option to customize the <code>QueueChannel</code> environment is provided by the <code>ref</code> attribute of the <code>&lt;int:queue&gt;</code> sub-element or its particular constructor.
This attribute supplies the reference to any <code>java.util.Queue</code> implementation.
For example, a Hazelcast distributed <a href="https://hazelcast.com/use-cases/imdg/imdg-messaging/"><code>IQueue</code></a> can be configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public HazelcastInstance hazelcastInstance() {
    return Hazelcast.newHazelcastInstance(new Config()
                                           .setProperty("hazelcast.logging.type", "log4j"));
}

@Bean
public PollableChannel distributedQueue() {
    return new QueueChannel(hazelcastInstance()
                              .getQueue("springIntegrationQueue"));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-pubsubchannel"><a class="anchor" href="#channel-configuration-pubsubchannel"></a><code>PublishSubscribeChannel</code> Configuration</h5>
<div class="paragraph">
<p>To create a <code>PublishSubscribeChannel</code>, use the &lt;publish-subscribe-channel/&gt; element.
When using this element, you can also specify the <code>task-executor</code> used for publishing messages (if none is specified, it publishes in the sender&#8217;s thread), as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:publish-subscribe-channel id="pubsubChannel" task-executor="someExecutor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you provide a resequencer or aggregator downstream from a <code>PublishSubscribeChannel</code>, you can set the 'apply-sequence' property on the channel to <code>true</code>.
Doing so indicates that the channel should set the <code>sequence-size</code> and <code>sequence-number</code> message headers as well as the correlation ID prior to passing along the messages.
For example, if there are five subscribers, the <code>sequence-size</code> would be set to <code>5</code>, and the messages would have <code>sequence-number</code> header values ranging from <code>1</code> to <code>5</code>.</p>
</div>
<div class="paragraph">
<p>Along with the <code>Executor</code>, you can also configure an <code>ErrorHandler</code>.
By default, the <code>PublishSubscribeChannel</code> uses a <code>MessagePublishingErrorHandler</code> implementation to send an error to the <code>MessageChannel</code> from the <code>errorChannel</code> header or into the global <code>errorChannel</code> instance.
If an <code>Executor</code> is not configured, the <code>ErrorHandler</code> is ignored and exceptions are thrown directly to the caller&#8217;s thread.</p>
</div>
<div class="paragraph">
<p>If you provide a <code>Resequencer</code> or <code>Aggregator</code> downstream from a <code>PublishSubscribeChannel</code>, you can set the 'apply-sequence' property on the channel to <code>true</code>.
Doing so indicates that the channel should set the sequence-size and sequence-number message headers as well as the correlation ID prior to passing along the messages.
For example, if there are five subscribers, the sequence-size would be set to <code>5</code>, and the messages would have sequence-number header values ranging from <code>1</code> to <code>5</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to set the <code>apply-sequence</code> header to <code>true</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:publish-subscribe-channel id="pubsubChannel" apply-sequence="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>apply-sequence</code> value is <code>false</code> by default so that a publish-subscribe channel can send the exact same message instances to multiple outbound channels.
Since Spring Integration enforces immutability of the payload and header references, when the flag is set to <code>true</code>, the channel creates new <code>Message</code> instances with the same payload reference but different header values.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-executorchannel"><a class="anchor" href="#channel-configuration-executorchannel"></a><code>ExecutorChannel</code></h5>
<div class="paragraph">
<p>To create an <code>ExecutorChannel</code>, add the <code>&lt;dispatcher&gt;</code> sub-element with a <code>task-executor</code> attribute.
The attribute&#8217;s value can reference any <code>TaskExecutor</code> within the context.
For example, doing so enables configuration of a thread pool for dispatching messages to subscribed handlers.
As mentioned earlier, doing so breaks the single-threaded execution context between sender and receiver so that any active transaction context is not shared by the invocation of the handler (that is, the handler may throw an <code>Exception</code>, but the <code>send</code> invocation has already returned successfully).
The following example shows how to use the <code>dispatcher</code> element and specify an executor in the <code>task-executor</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="executorChannel"&gt;
    &lt;int:dispatcher task-executor="someExecutor"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>load-balancer</code> and <code>failover</code> options are also both available on the &lt;dispatcher/&gt; sub-element, as described earlier in <a href="#channel-configuration-directchannel"><code>DirectChannel</code> Configuration</a>.
The same defaults apply.
Consequently, the channel has a round-robin load-balancing strategy with failover enabled unless explicit configuration is provided for one or both of those attributes, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="executorChannelWithoutFailover"&gt;
    &lt;int:dispatcher task-executor="someExecutor" failover="false"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-prioritychannel"><a class="anchor" href="#channel-configuration-prioritychannel"></a><code>PriorityChannel</code> Configuration</h5>
<div class="paragraph">
<p>To create a <code>PriorityChannel</code>, use the <code>&lt;priority-queue/&gt;</code> sub-element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="priorityChannel"&gt;
    &lt;int:priority-queue capacity="20"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the channel consults the <code>priority</code> header of the message.
However, you can instead provide a custom <code>Comparator</code> reference.
Also, note that the <code>PriorityChannel</code> (like the other types) does support the <code>datatype</code> attribute.
As with the <code>QueueChannel</code>, it also supports a <code>capacity</code> attribute.
The following example demonstrates all of these:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="priorityChannel" datatype="example.Widget"&gt;
    &lt;int:priority-queue comparator="widgetComparator"
                    capacity="10"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since version 4.0, the <code>priority-channel</code> child element supports the <code>message-store</code> option (<code>comparator</code> and <code>capacity</code> are not allowed in that case).
The message store must be a <code>PriorityCapableChannelMessageStore</code>.
Implementations of the <code>PriorityCapableChannelMessageStore</code> are currently provided for <code>Redis</code>, <code>JDBC</code>, and <code>MongoDB</code>.
See <a href="#channel-configuration-queuechannel"><code>QueueChannel</code> Configuration</a> and <a href="#message-store">Message Store</a> for more information.
You can find sample configuration in <a href="#jdbc-message-store-channels">Backing Message Channels</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-rendezvouschannel"><a class="anchor" href="#channel-configuration-rendezvouschannel"></a><code>RendezvousChannel</code> Configuration</h5>
<div class="paragraph">
<p>A <code>RendezvousChannel</code> is created when the queue sub-element is a <code>&lt;rendezvous-queue&gt;</code>.
It does not provide any additional configuration options to those described earlier, and its queue does not accept any capacity value, since it is a zero-capacity direct handoff queue.
The following example shows how to declare a <code>RendezvousChannel</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="rendezvousChannel"/&gt;
    &lt;int:rendezvous-queue/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-threadlocalchannel"><a class="anchor" href="#channel-configuration-threadlocalchannel"></a>Scoped Channel Configuration</h5>
<div class="paragraph">
<p>Any channel can be configured with a <code>scope</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="threadLocalChannel" scope="thread"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="channel-configuration-interceptors"><a class="anchor" href="#channel-configuration-interceptors"></a>Channel Interceptor Configuration</h5>
<div class="paragraph">
<p>Message channels may also have interceptors, as described in <a href="#channel-interceptors">Channel Interceptors</a>.
The <code>&lt;interceptors/&gt;</code> sub-element can be added to a <code>&lt;channel/&gt;</code> (or the more specific element types).
You can provide the <code>ref</code> attribute to reference any Spring-managed object that implements the <code>ChannelInterceptor</code> interface, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="exampleChannel"&gt;
    &lt;int:interceptors&gt;
        &lt;ref bean="trafficMonitoringInterceptor"/&gt;
    &lt;/int:interceptors&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In general, we recommend defining the interceptor implementations in a separate location, since they usually provide common behavior that can be reused across multiple channels.</p>
</div>
</div>
<div class="sect4">
<h5 id="global-channel-configuration-interceptors"><a class="anchor" href="#global-channel-configuration-interceptors"></a>Global Channel Interceptor Configuration</h5>
<div class="paragraph">
<p>Channel interceptors provide a clean and concise way of applying cross-cutting behavior per individual channel.
If the same behavior should be applied on multiple channels, configuring the same set of interceptors for each channel would not be the most efficient way.
To avoid repeated configuration while also enabling interceptors to apply to multiple channels, Spring Integration provides global interceptors.
Consider the following pair of examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel-interceptor pattern="input*, thing2*, thing1, !cat*" order="3"&gt;
    &lt;bean class="thing1.thing2SampleInterceptor"/&gt;
&lt;/int:channel-interceptor&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel-interceptor ref="myInterceptor" pattern="input*, thing2*, thing1, !cat*" order="3"/&gt;

&lt;bean id="myInterceptor" class="thing1.thing2SampleInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each <code>&lt;channel-interceptor/&gt;</code> element lets you define a global interceptor, which is applied on all channels that match any patterns defined by the <code>pattern</code> attribute.
In the preceding case, the global interceptor is applied on the 'thing1' channel and all other channels that begin with 'thing2' or 'input' but not to channels starting with 'thing3' (since version 5.0).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The addition of this syntax to the pattern causes one possible (though perhaps unlikely) problem.
If you have a bean named <code>!thing1</code> and you included a pattern of <code>!thing1</code> in your channel interceptor&#8217;s  <code>pattern</code> patterns, it no longer matches.
The pattern now matches all beans not named <code>thing1</code>.
In this case, you can escape the <code>!</code> in the pattern with <code>\</code>.
The pattern <code>\!thing1</code> matches a bean named <code>!thing1</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The order attribute lets you manage where this interceptor is injected when there are multiple interceptors on a given channel.
For example, channel 'inputChannel' could have individual interceptors configured locally (see below), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="inputChannel"&gt;
  &lt;int:interceptors&gt;
    &lt;int:wire-tap channel="logger"/&gt;
  &lt;/int:interceptors&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A reasonable question is &#8220;how is a global interceptor injected in relation to other interceptors configured locally or through other global interceptor definitions?&#8221;
The current implementation provides a simple mechanism for defining the order of interceptor execution.
A positive number in the <code>order</code> attribute ensures interceptor injection after any existing interceptors, while a negative number ensures that the interceptor is injected before existing interceptors.
This means that, in the preceding example, the global interceptor is injected after (since its <code>order</code> is greater than <code>0</code>) the 'wire-tap' interceptor configured locally.
If there were another global interceptor with a matching <code>pattern</code>, its order would be determined by comparing the values of both interceptors' <code>order</code> attributes.
To inject a global interceptor before the existing interceptors, use a negative value for the <code>order</code> attribute.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that both the <code>order</code> and <code>pattern</code> attributes are optional.
The default value for <code>order</code> will be 0 and for <code>pattern</code>, the default is '*' (to match all channels).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3.15, you can configure the <code>spring.integration.postProcessDynamicBeans = true</code> property to apply any global interceptors to dynamically created <code>MessageChannel</code> beans.
See <a href="#global-properties">Global Properties</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-wiretap"><a class="anchor" href="#channel-wiretap"></a>Wire Tap</h5>
<div class="paragraph">
<p>As mentioned earlier, Spring Integration provides a simple wire tap interceptor.
You can configure a wire tap on any channel within an <code>&lt;interceptors/&gt;</code> element.
Doing so is especially useful for debugging and can be used in conjunction with Spring Integration&#8217;s logging channel adapter as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="in"&gt;
    &lt;int:interceptors&gt;
        &lt;int:wire-tap channel="logger"/&gt;
    &lt;/int:interceptors&gt;
&lt;/int:channel&gt;

&lt;int:logging-channel-adapter id="logger" level="DEBUG"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The 'logging-channel-adapter' also accepts an 'expression' attribute so that you can evaluate a SpEL expression against the 'payload' and 'headers' variables.
Alternatively, to log the full message <code>toString()</code> result, provide a value of <code>true</code> for the 'log-full-message' attribute.
By default, it is <code>false</code> so that only the payload is logged.
Setting it to <code>true</code> enables logging of all headers in addition to the payload.
The 'expression' option provides the most flexibility (for example, <code>expression="payload.user.name"</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One of the common misconceptions about the wire tap and other similar components (<a href="#message-publishing-config">Message Publishing Configuration</a>) is that they are automatically asynchronous in nature.
By default, wire tap as a component is not invoked asynchronously.
Instead, Spring Integration focuses on a single unified approach to configuring asynchronous behavior: the message channel.
What makes certain parts of the message flow synchronous or asynchronous is the type of Message Channel that has been configured within that flow.
That is one of the primary benefits of the message channel abstraction.
From the inception of the framework, we have always emphasized the need and the value of the message channel as a first-class citizen of the framework.
It is not just an internal, implicit realization of the EIP pattern.
It is fully exposed as a configurable component to the end user.
So, the wire tap component is only responsible for performing the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Intercept a message flow by tapping into a channel (for example, <code>channelA</code>)</p>
</li>
<li>
<p>Grab each message</p>
</li>
<li>
<p>Send the message to another channel (for example, <code>channelB</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is essentially a variation of the bridge pattern, but it is encapsulated within a channel definition (and hence easier to enable and disable without disrupting a flow).
Also, unlike the bridge, it basically forks another message flow.
Is that flow synchronous or asynchronous? The answer depends on the type of message channel that 'channelB' is.
We have the following options: direct channel, pollable channel, and executor channel.
The last two break the thread boundary, making communication over such channels asynchronous, because the dispatching of the message from that channel to its subscribed handlers happens on a different thread than the one used to send the message to that channel.
That is what is going to make your wire-tap flow synchronous or asynchronous.
It is consistent with other components within the framework (such as message publisher) and adds a level of consistency and simplicity by sparing you from worrying in advance (other than writing thread-safe code) about whether a particular piece of code should be implemented as synchronous or asynchronous.
The actual wiring of two pieces of code (say, component A and component B) over a message channel is what makes their collaboration synchronous or asynchronous.
You may even want to change from synchronous to asynchronous in the future, and message channel lets you to do it swiftly without ever touching the code.</p>
</div>
<div class="paragraph">
<p>One final point regarding the wire tap is that, despite the rationale provided above for not being asynchronous by default, you should keep in mind that it is usually desirable to hand off the message as soon as possible.
Therefore, it would be quite common to use an asynchronous channel option as the wire tap&#8217;s outbound channel.
However we doe not enforce asynchronous behavior by default.
There are a number of use cases that would break if we did, including that you might not want to break a transactional boundary.
Perhaps you use the wire tap pattern for auditing purposes, and you do want the audit messages to be sent within the original transaction.
As an example, you might connect the wire tap to a JMS outbound channel adapter.
That way, you get the best of both worlds: 1) the sending of a JMS Message can occur within the transaction while 2) it is still a &#8220;fire-and-forget&#8221; action, thereby preventing any noticeable delay in the main message flow.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 4.0, it is important to avoid circular references when an interceptor (such as the <a href="https://docs.spring.io/autorepo/docs/spring-integration/current/api/org/springframework/integration/channel/interceptor/WireTap.html"><code>WireTap</code> class</a>) references a channel.
You need to exclude such channels from those being intercepted by the current interceptor.
This can be done with appropriate patterns or programmatically.
If you have a custom <code>ChannelInterceptor</code> that references a <code>channel</code>, consider implementing <code>VetoCapableInterceptor</code>.
That way, the framework asks the interceptor if it is OK to intercept each channel that is a candidate, based on the supplied pattern.
You can also add runtime protection in the interceptor methods to ensure that the channel is not one that is referenced by the interceptor.
The <code>WireTap</code> uses both of these techniques.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3, the <code>WireTap</code> has additional constructors that take a <code>channelName</code> instead of a
<code>MessageChannel</code> instance.
This can be convenient for Java configuration and when channel auto-creation logic is being used.
The target <code>MessageChannel</code> bean is resolved from the provided <code>channelName</code> later, on the first interaction with the
interceptor.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Channel resolution requires a <code>BeanFactory</code>, so the wire tap instance must be a Spring-managed bean.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This late-binding approach also allows simplification of typical wire-tapping patterns with Java DSL configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PollableChannel myChannel() {
    return MessageChannels.queue()
            .wireTap("loggingFlow.input")
            .get();
}

@Bean
public IntegrationFlow loggingFlow() {
    return f -&gt; f.log();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="conditional-wiretap"><a class="anchor" href="#conditional-wiretap"></a>Conditional Wire Taps</h5>
<div class="paragraph">
<p>Wire taps can be made conditional by using the <code>selector</code> or <code>selector-expression</code> attributes.
The <code>selector</code> references a <code>MessageSelector</code> bean, which can determine at runtime whether the message should go to the tap channel.
Similarly, the <code>selector-expression</code> is a boolean SpEL expression that performs the same purpose: If the expression evaluates to <code>true</code>, the message is sent to the tap channel.</p>
</div>
</div>
<div class="sect4">
<h5 id="channel-global-wiretap"><a class="anchor" href="#channel-global-wiretap"></a>Global Wire Tap Configuration</h5>
<div class="paragraph">
<p>It is possible to configure a global wire tap as a special case of the <a href="#global-channel-configuration-interceptors">Global Channel Interceptor Configuration</a>.
To do so, configure a top level <code>wire-tap</code> element.
Now, in addition to the normal <code>wire-tap</code> namespace support, the <code>pattern</code> and <code>order</code> attributes are supported and work in exactly the same way as they do for the <code>channel-interceptor</code>.
The following examlpe shows how to configure a global wire tap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:wire-tap pattern="input*, thing2*, thing1" order="3" channel="wiretapChannel"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A global wire tap provides a convenient way to configure a single-channel wire tap externally without modifying the existing channel configuration.
To do so, set the <code>pattern</code> attribute to the target channel name.
For example, you can use this technique to configure a test case to verify messages on a channel.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="channel-special-channels"><a class="anchor" href="#channel-special-channels"></a>6.1.6. Special Channels</h4>
<div class="paragraph">
<p>If namespace support is enabled, two special channels are defined within the application context by default: <code>errorChannel</code> and <code>nullChannel</code>.
The 'nullChannel' acts like <code>/dev/null</code>, logging any message sent to it at the <code>DEBUG</code> level and returning immediately.
Any time you face channel resolution errors for a reply that you do not care about, you can set the affected component&#8217;s <code>output-channel</code> attribute to 'nullChannel' (the name, 'nullChannel', is reserved within the application context).
The 'errorChannel' is used internally for sending error messages and may be overridden with a custom configuration.
This is discussed in greater detail in <a href="#namespace-errorhandler">Error Handling</a>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#java-dsl-channels">Message Channels</a> in the Java DSL chapter for more information about message channel and interceptors.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="polling-consumer"><a class="anchor" href="#polling-consumer"></a>6.2. Poller</h3>
<div class="paragraph">
<p>This section describes how polling works in Spring Integration.</p>
</div>
<div class="sect3">
<h4 id="polling-consumer-2"><a class="anchor" href="#polling-consumer-2"></a>6.2.1. Polling Consumer</h4>
<div class="paragraph">
<p>When Message Endpoints (Channel Adapters) are connected to channels and instantiated, they produce one of the following instances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/PollingConsumer.html"><code>PollingConsumer</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/EventDrivenConsumer.html"><code>EventDrivenConsumer</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The actual implementation depends on the type of channel to which these endpoints connect.
A channel adapter connected to a channel that implements the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/index.html?org/springframework/messaging/SubscribableChannel.html"><code>org.springframework.messaging.SubscribableChannel</code></a> interface produces an instance of <code>EventDrivenConsumer</code>.
On the other hand, a channel adapter connected to a channel that implements the  <a href="https://docs.spring.io/spring/docs/current/javadoc-api/index.html?org/springframework/messaging/PollableChannel.html"><code>org.springframework.messaging.PollableChannel</code></a> interface (such as a <code>QueueChannel</code>) produces an instance of <code>PollingConsumer</code>.</p>
</div>
<div class="paragraph">
<p>Polling consumers let Spring Integration components actively poll for Messages rather than process messages in an event-driven manner.</p>
</div>
<div class="paragraph">
<p>They represent a critical cross-cutting concern in many messaging scenarios.
In Spring Integration, polling consumers are based on the pattern with the same name, which is described in the book <em>Enterprise Integration Patterns</em>, by Gregor Hohpe and Bobby Woolf.
You can find a description of the pattern on the <a href="https://www.enterpriseintegrationpatterns.com/PollingConsumer.html">book&#8217;s website</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pollable-message-source"><a class="anchor" href="#pollable-message-source"></a>6.2.2. Pollable Message Source</h4>
<div class="paragraph">
<p>Spring Integration offers a second variation of the polling consumer pattern.
When inbound channel adapters are used, these adapters are often wrapped by a <code>SourcePollingChannelAdapter</code>.
For example, when retrieving messages from a remote FTP Server location, the adapter described in <a href="#ftp-inbound">FTP Inbound Channel Adapter</a> is configured with a poller to periodically retrieve messages.
So, when components are configured with pollers, the resulting instances are of one of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/PollingConsumer.html"><code>PollingConsumer</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/SourcePollingChannelAdapter.html"><code>SourcePollingChannelAdapter</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This means that pollers are used in both inbound and outbound messaging scenarios.
Here are some use cases in which pollers are used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Polling certain external systems, such as FTP Servers, Databases, and Web Services</p>
</li>
<li>
<p>Polling internal (pollable) message channels</p>
</li>
<li>
<p>Polling internal services (such as repeatedly executing methods on a Java class)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
AOP advice classes can be applied to pollers, in an <code>advice-chain</code>, such as a transaction advice to start a transaction.
Starting with version 4.1, a <code>PollSkipAdvice</code> is provided.
Pollers use triggers to determine the time of the next poll.
The <code>PollSkipAdvice</code> can be used to suppress (skip) a poll, perhaps because there is some downstream condition that would prevent the message being processed.
To use this advice, you have to provide it with an implementation of a <code>PollSkipStrategy</code>.
Starting with version 4.2.5, a <code>SimplePollSkipStrategy</code> is provided.
To use it, you can add an instance as a bean to the application context, inject it into a <code>PollSkipAdvice</code>, and add that to the poller&#8217;s advice chain.
To skip polling, call <code>skipPolls()</code>.
To resume polling, call <code>reset()</code>.
Version 4.2 added more flexibility in this area.
See <a href="#conditional-pollers">Conditional Pollers for Message Sources</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This chapter is meant to only give a high-level overview of polling consumers and how they fit into the concept of message channels (see <a href="#channel">Message Channels</a>) and channel adapters (see <a href="#channel-adapter">Channel Adapter</a>).
For more information regarding messaging endpoints in general and polling consumers in particular, see <a href="#endpoint">Message Endpoints</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="deferred-acks-message-source"><a class="anchor" href="#deferred-acks-message-source"></a>6.2.3. Deferred Acknowledgment Pollable Message Source</h4>
<div class="paragraph">
<p>Starting with version 5.0.1, certain modules provide <code>MessageSource</code> implementations that support deferring acknowledgment until the downstream flow completes (or hands off the message to another thread).
This is currently limited to the <code>AmqpMessageSource</code> and the <code>KafkaMessageSource</code> provided by the <code>spring-integration-kafka</code> <a href="https://github.com/spring-projects/spring-integration-kafka">extension project</a>.</p>
</div>
<div class="paragraph">
<p>With these message sources, the <code>IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK</code> header (see <a href="#message-header-accessor"><code>MessageHeaderAccessor</code> API</a>) is added to the message.
The value of the header is an instance of <code>AcknowledgmentCallback</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FunctionalInterface
public interface AcknowledgmentCallback {

    void acknowledge(Status status);

    boolean isAcknowledged();

    void noAutoAck();

    default boolean isAutoAck();

    enum Status {

        /**
         * Mark the message as accepted.
         */
        ACCEPT,

        /**
         * Mark the message as rejected.
         */
        REJECT,

        /**
         * Reject the message and requeue so that it will be redelivered.
         */
        REQUEUE

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not all message sources (for example, Kafka) support the <code>REJECT</code> status.
It is treated the same as <code>ACCEPT</code>.</p>
</div>
<div class="paragraph">
<p>Applications can acknowledge a message at any time, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;?&gt; received = source.receive();

...

StaticMessageHeaderAccessor.getAcknowledgmentCallback(received)
        .acknowledge(Status.ACCEPT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>MessageSource</code> is wired into a <code>SourcePollingChannelAdapter</code>, when the poller thread returns to the adapter after the downstream flow completes, the adapter checks whether the acknowledgment has already been acknowledged and, if not, sets its status to <code>ACCEPT</code> it (or <code>REJECT</code> if the flow throws an exception).
The status values are defined in the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/support/AcknowledgmentCallback.Status.html"><code>AcknowledgmentCallback.Status</code> enumeration</a>.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides <code>MessageSourcePollingTemplate</code> to perform ad-hoc polling of a <code>MessageSource</code>.
This, too, takes care of setting <code>ACCEPT</code> or <code>REJECT</code> on the <code>AcknowledgmentCallback</code> when the <code>MessageHandler</code> callback returns (or throws an exception).
The following example shows how to poll with the <code>MessageSourcePollingTemplate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageSourcePollingTemplate template =
    new MessageSourcePollingTemplate(this.source);
template.poll(h -&gt; {
    ...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases (<code>SourcePollingChannelAdapter</code> and <code>MessageSourcePollingTemplate</code>), you can disable auto ack/nack by calling <code>noAutoAck()</code> on the callback.
You might do this if you hand off the message to another thread and wish to acknowledge later.
Not all implementations support this (for example, Apache Kafka does not, because the offset commit has to be performed on the same thread).</p>
</div>
</div>
<div class="sect3">
<h4 id="conditional-pollers"><a class="anchor" href="#conditional-pollers"></a>6.2.4. Conditional Pollers for Message Sources</h4>
<div class="paragraph">
<p>This section covers how to use conditional pollers.</p>
</div>
<div class="sect4">
<h5 id="background"><a class="anchor" href="#background"></a>Background</h5>
<div class="paragraph">
<p><code>Advice</code> objects, in an <code>advice-chain</code> on a poller, advise the whole polling task (both message retrieval and processing).
These &#8220;around advice&#8221; methods do not have access to any context for the poll&#8201;&#8212;&#8201;only the poll itself.
This is fine for requirements such as making a task transactional or skipping a poll due to some external condition, as discussed earlier.
What if we wish to take some action depending on the result of the <code>receive</code> part of the poll or if we want to adjust the poller depending on conditions? For those instances, Spring Integration offers &#8220;Smart&#8221; Polling.</p>
</div>
</div>
<div class="sect4">
<h5 id="smart-polling"><a class="anchor" href="#smart-polling"></a>&#8220;Smart&#8221; Polling</h5>
<div class="paragraph">
<p>Version 4.2 introduced the <code>AbstractMessageSourceAdvice</code>.
Any <code>Advice</code> objects in the <code>advice-chain</code> that subclass this class are applied only to the receive operation.
Such classes implement the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>beforeReceive(MessageSource&lt;?&gt; source)</code>
This method is called before the <code>MessageSource.receive()</code> method.
It lets you examine and reconfigure the source.
Returning <code>false</code> cancels this poll (similar to the <code>PollSkipAdvice</code> mentioned earlier).</p>
</li>
<li>
<p><code>Message&lt;?&gt; afterReceive(Message&lt;?&gt; result, MessageSource&lt;?&gt; source)</code>
This method is called after the <code>receive()</code> method.
Again, you can reconfigure the source or take any action (perhaps depending on the result, which can be <code>null</code> if there was no message created by the source).
You can even return a different message</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Thread safety</div>
<div class="paragraph">
<p>If an advice mutates the <code>MessageSource</code>, you should not configure the poller with a <code>TaskExecutor</code>.
If an advice mutates the source, such mutations are not thread safe and could cause unexpected results, especially with high frequency pollers.
If you need to process poll results concurrently, consider using a downstream <code>ExecutorChannel</code> instead of adding an executor to the poller.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Advice Chain Ordering</div>
<div class="paragraph">
<p>You should understand how the advice chain is processed during initialization.
<code>Advice</code> objects that do not extend <code>AbstractMessageSourceAdvice</code> are applied to the whole poll process and are all invoked first, in order, before any <code>AbstractMessageSourceAdvice</code>.
Then <code>AbstractMessageSourceAdvice</code> objects are invoked in order around the <code>MessageSource</code> <code>receive()</code> method.
If you have, for example, <code>Advice</code> objects <code>a, b, c, d</code>, where <code>b</code> and <code>d</code> are <code>AbstractMessageSourceAdvice</code>, the objects are applied in the following order: <code>a, c, b, d</code>.
Also, if a <code>MessageSource</code> is already a <code>Proxy</code>, the <code>AbstractMessageSourceAdvice</code> is invoked after any existing <code>Advice</code> objects.
If you wish to change the order, you must wire up the proxy yourself.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="simpleactiveidlemessagesourceadvice"><a class="anchor" href="#simpleactiveidlemessagesourceadvice"></a><code>SimpleActiveIdleMessageSourceAdvice</code></h5>
<div class="paragraph">
<p>This advice is a simple implementation of <code>AbstractMessageSourceAdvice</code>.
When used in conjunction with a <code>DynamicPeriodicTrigger</code>, it adjusts the polling frequency, depending on whether or not the previous poll resulted in a message or not.
The poller must also have a reference to the same <code>DynamicPeriodicTrigger</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Important: Async Handoff</div>
<code>SimpleActiveIdleMessageSourceAdvice</code> modifies the trigger based on the <code>receive()</code> result.
This works only if the advice is called on the poller thread.
It does not work if the poller has a <code>task-executor</code>.
To use this advice where you wish to use async operations after the result of a poll, do the async handoff later, perhaps by using an <code>ExecutorChannel</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="compoundtriggeradvice"><a class="anchor" href="#compoundtriggeradvice"></a><code>CompoundTriggerAdvice</code></h5>
<div class="paragraph">
<p>This advice allows the selection of one of two triggers based on whether a poll returns a message or not.
Consider a poller that uses a <code>CronTrigger</code>.
<code>CronTrigger</code> instances are immutable, so they cannot be altered once constructed.
Consider a use case where we want to use a cron expression to trigger a poll once each hour but, if no message is received, poll once per minute and, when a message is retrieved, revert to using the cron expression.</p>
</div>
<div class="paragraph">
<p>The advice (and poller) use a <code>CompoundTrigger</code> for this purpose.
The trigger&#8217;s <code>primary</code> trigger can be a <code>CronTrigger</code>.
When the advice detects that no message is received, it adds the secondary trigger to the <code>CompoundTrigger</code>.
When the <code>CompoundTrigger</code> instance&#8217;s <code>nextExecutionTime</code> method is invoked, it delegates to the secondary trigger, if present.
Otherwise, it delegates to the primary trigger.</p>
</div>
<div class="paragraph">
<p>The poller must also have a reference to the same <code>CompoundTrigger</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows the configuration for the hourly cron expression with a fallback to every minute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter channel="nullChannel" auto-startup="false"&gt;
    &lt;bean class="org.springframework.integration.endpoint.PollerAdviceTests.Source" /&gt;
    &lt;int:poller trigger="compoundTrigger"&gt;
        &lt;int:advice-chain&gt;
            &lt;bean class="org.springframework.integration.aop.CompoundTriggerAdvice"&gt;
                &lt;constructor-arg ref="compoundTrigger"/&gt;
                &lt;constructor-arg ref="secondary"/&gt;
            &lt;/bean&gt;
        &lt;/int:advice-chain&gt;
    &lt;/int:poller&gt;
&lt;/int:inbound-channel-adapter&gt;

&lt;bean id="compoundTrigger" class="org.springframework.integration.util.CompoundTrigger"&gt;
    &lt;constructor-arg ref="primary" /&gt;
&lt;/bean&gt;

&lt;bean id="primary" class="org.springframework.scheduling.support.CronTrigger"&gt;
    &lt;constructor-arg value="0 0 * * * *" /&gt; &lt;!-- top of every hour --&gt;
&lt;/bean&gt;

&lt;bean id="secondary" class="org.springframework.scheduling.support.PeriodicTrigger"&gt;
    &lt;constructor-arg value="60000" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Important: Async Handoff</div>
<code>CompoundTriggerAdvice</code> modifies the trigger based on the <code>receive()</code> result.
This works only if the advice is called on the poller thread.
It does not work if the poller has a <code>task-executor</code>.
To use this advice where you wish to use async operations after the result of a poll, do the async handoff later, perhaps by using an <code>ExecutorChannel</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="channel-adapter"><a class="anchor" href="#channel-adapter"></a>6.3. Channel Adapter</h3>
<div class="paragraph">
<p>A channel adapter is a message endpoint that enables connecting a single sender or receiver to a message channel.
Spring Integration provides a number of adapters to support various transports, such as JMS, file, HTTP, web services, mail, and more.
Upcoming chapters of this reference guide discuss each adapter.
However, this chapter focuses on the simple but flexible method-invoking channel adapter support.
There are both inbound and outbound adapters, and each may be configured with XML elements provided in the core namespace.
These provide an easy way to extend Spring Integration, as long as you have a method that can be invoked as either a source or a destination.</p>
</div>
<div class="sect3">
<h4 id="channel-adapter-namespace-inbound"><a class="anchor" href="#channel-adapter-namespace-inbound"></a>6.3.1. Configuring An Inbound Channel Adapter</h4>
<div class="paragraph">
<p>An <code>inbound-channel-adapter</code> element can invoke any method on a Spring-managed object and send a non-null return value to a <code>MessageChannel</code> after converting the method&#8217;s output to a <code>Message</code>.
When the adapter&#8217;s subscription is activated, a poller tries to receive messages from the source.
The poller is scheduled with the <code>TaskScheduler</code> according to the provided configuration.
To configure the polling interval or cron expression for an individual channel adapter, you can provide a 'poller' element with one of the scheduling attributes, such as 'fixed-rate' or 'cron'.
The following example defines two <code>inbound-channel-adapter</code> instances:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter ref="source1" method="method1" channel="channel1"&gt;
    &lt;int:poller fixed-rate="5000"/&gt;
&lt;/int:inbound-channel-adapter&gt;

&lt;int:inbound-channel-adapter ref="source2" method="method2" channel="channel2"&gt;
    &lt;int:poller cron="30 * 9-17 * * MON-FRI"/&gt;
&lt;/int:channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#channel-adapter-expressions-and-scripts">Channel Adapter Expressions and Scripts</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If no poller is provided, then a single default poller must be registered within the context.
See <a href="#endpoint-namespace">Endpoint Namespace Support</a> for more detail.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Important: Poller Configuration</div>
<div class="paragraph">
<p>Some <code>inbound-channel-adapter</code> types are backed by a <code>SourcePollingChannelAdapter</code>, which means they contain a poller configuration that polls the <code>MessageSource</code> (to invoke a custom method that produces the value that becomes a <code>Message</code> payload) based on the configuration specified in the Poller.
The following example shows the configuration of two pollers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller max-messages-per-poll="1" fixed-rate="1000"/&gt;

&lt;int:poller max-messages-per-poll="10" fixed-rate="1000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the the first configuration, the polling task is invoked once per poll, and, during each task (poll), the method (which results in the production of the message) is invoked once, based on the <code>max-messages-per-poll</code> attribute value.
In the second configuration, the polling task is invoked 10 times per poll or until it returns 'null', thus possibly producing ten messages per poll while each poll happens at one-second intervals.
However, what happens if the configuration looks like the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller fixed-rate="1000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that there is no <code>max-messages-per-poll</code> specified.
As we cover later, the identical poller configuration in the <code>PollingConsumer</code> (for example, service-activator, filter, router, and others) would have a default value of -1 for <code>max-messages-per-poll</code>, which means &#8220;execute the polling task non-stop unless the polling method returns null (perhaps because there are no more messages in the <code>QueueChannel</code>)&#8221; and then sleep for one second.</p>
</div>
<div class="paragraph">
<p>However, in the <code>SourcePollingChannelAdapter</code>, it is a bit different.
The default value for <code>max-messages-per-poll</code> is <code>1</code>, unless you explicitly set it to a negative value (such as <code>-1</code>).
This makes sure that the poller can react to lifecycle events (such as start and stop) and prevents it from potentially spinning in an infinite loop if the implementation of the custom method of the <code>MessageSource</code> has a potential to never return null and happens to be non-interruptible.</p>
</div>
<div class="paragraph">
<p>However, if you are sure that your method can return null and you need to poll for as many sources as available per each poll, you should explicitly set <code>max-messages-per-poll</code> to a negative value, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller max-messages-per-poll="-1" fixed-rate="1000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="channel-adapter-namespace-outbound"><a class="anchor" href="#channel-adapter-namespace-outbound"></a>6.3.2. Configuring An Outbound Channel Adapter</h4>
<div class="paragraph">
<p>An <code>outbound-channel-adapter</code> element can also connect a <code>MessageChannel</code> to any POJO consumer method that should be invoked with the payload of messages sent to that channel.
The following example shows how to define an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:outbound-channel-adapter channel="channel1" ref="target" method="handle"/&gt;

&lt;beans:bean id="target" class="org.MyPojo"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the channel being adapted is a <code>PollableChannel</code>, you must provide a poller sub-element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:outbound-channel-adapter channel="channel2" ref="target" method="handle"&gt;
    &lt;int:poller fixed-rate="3000" /&gt;
&lt;/int:outbound-channel-adapter&gt;

&lt;beans:bean id="target" class="org.MyPojo"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You should use a <code>ref</code> attribute if the POJO consumer implementation can be reused in other <code>&lt;outbound-channel-adapter&gt;</code> definitions.
However, if the consumer implementation is referenced by only a single definition of the <code>&lt;outbound-channel-adapter&gt;</code>, you can define it as an inner bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:outbound-channel-adapter channel="channel" method="handle"&gt;
    &lt;beans:bean class="org.Foo"/&gt;
&lt;/int:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both the <code>ref</code> attribute and an inner handler definition in the same <code>&lt;outbound-channel-adapter&gt;</code> configuration is not allowed, as it creates an ambiguous condition.
Such a configuration results in an exception being thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any channel adapter can be created without a <code>channel</code> reference, in which case it implicitly creates an instance of <code>DirectChannel</code>.
The created channel&#8217;s name matches the <code>id</code> attribute of the <code>&lt;inbound-channel-adapter&gt;</code> or <code>&lt;outbound-channel-adapter&gt;</code> element.
Therefore, if <code>channel</code> is not provided, <code>id</code> is required.</p>
</div>
</div>
<div class="sect3">
<h4 id="channel-adapter-expressions-and-scripts"><a class="anchor" href="#channel-adapter-expressions-and-scripts"></a>6.3.3. Channel Adapter Expressions and Scripts</h4>
<div class="paragraph">
<p>Like many other Spring Integration components, the <code>&lt;inbound-channel-adapter&gt;</code> and <code>&lt;outbound-channel-adapter&gt;</code> also provide support for SpEL expression evaluation.
To use SpEL, provide the expression string in the 'expression' attribute instead of providing the 'ref' and 'method' attributes that are used for method-invocation on a bean.
When an expression is evaluated, it follows the same contract as method-invocation where: the expression for an <code>&lt;inbound-channel-adapter&gt;</code> generates a message any time the evaluation result is a non-null value, while the expression for an <code>&lt;outbound-channel-adapter&gt;</code> must be the equivalent of a void-returning method invocation.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, an <code>&lt;int:inbound-channel-adapter/&gt;</code> can also be configured with a SpEL <code>&lt;expression/&gt;</code> (or even with a <code>&lt;script/&gt;</code>) sub-element, for when more sophistication is required than can be achieved with the simple 'expression' attribute.
If you provide a script as a <code>Resource</code> by using the <code>location</code> attribute, you can also set <code>refresh-check-delay</code>, which allows the resource to be periodically refreshed.
If you want the script to be checked on each poll, you would need to coordinate this setting with the poller&#8217;s trigger, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter ref="source1" method="method1" channel="channel1"&gt;
    &lt;int:poller max-messages-per-poll="1" fixed-delay="5000"/&gt;
    &lt;script:script lang="ruby" location="Foo.rb" refresh-check-delay="5000"/&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also the <code>cacheSeconds</code> property on the <code>ReloadableResourceBundleExpressionSource</code> when using the <code>&lt;expression/&gt;</code> sub-element.
For more information regarding expressions, see <a href="#spel">Spring Expression Language (SpEL)</a>.
For scripts, see <a href="#groovy">Groovy support</a> and <a href="#scripting">Scripting Support</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>&lt;int:inbound-channel-adapter/&gt;</code> is endpoint starts a message flow by periodically triggering to poll some underlying <code>MessageSource</code>.
Since, at the time of polling, there is no message object, expressions and scripts do not have access to a root <code>Message</code>, so there are no payload or headers properties that are available in most other messaging SpEL expressions.
The script can generate and return a complete <code>Message</code> object with headers and payload or only a payload, which is added to a message with basic headers.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bridge"><a class="anchor" href="#bridge"></a>6.4. Messaging Bridge</h3>
<div class="paragraph">
<p>A messaging bridge is a relatively trivial endpoint that connects two message channels or channel adapters.
For example, you may want to connect a <code>PollableChannel</code> to a <code>SubscribableChannel</code> so that the subscribing endpoints do not have to worry about any polling configuration.
Instead, the messaging bridge provides the polling configuration.</p>
</div>
<div class="paragraph">
<p>By providing an intermediary poller between two channels, you can use a messaging bridge to throttle inbound messages.
The poller&#8217;s trigger determines the rate at which messages arrive on the second channel, and the poller&#8217;s <code>maxMessagesPerPoll</code> property enforces a limit on the throughput.</p>
</div>
<div class="paragraph">
<p>Another valid use for a messaging bridge is to connect two different systems.
In such a scenario, Spring Integration&#8217;s role is limited to making the connection between these systems and managing a poller, if necessary.
It is probably more common to have at least a transformer between the two systems, to translate between their formats.
In that case, the channels can be provided as the 'input-channel' and 'output-channel' of a transformer endpoint.
If data format translation is not required, the messaging bridge may indeed be sufficient.</p>
</div>
<div class="sect3">
<h4 id="bridge-namespace"><a class="anchor" href="#bridge-namespace"></a>6.4.1. Configuring a Bridge with XML</h4>
<div class="paragraph">
<p>You can use the <code>&lt;bridge&gt;</code> element is used to create a messaging bridge between two message channels or channel adapters.
To do so, provide the <code>input-channel</code> and <code>output-channel</code> attributes, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:bridge input-channel="input" output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As mentioned above, a common use case for the messaging bridge is to connect a <code>PollableChannel</code> to a <code>SubscribableChannel</code>.
When performing this role, the messaging bridge may also serve as a throttler:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:bridge input-channel="pollable" output-channel="subscribable"&gt;
     &lt;int:poller max-messages-per-poll="10" fixed-rate="5000"/&gt;
 &lt;/int:bridge&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use a similar mechanism to connecting channel adapters.
The following example shows a simple &#8220;echo&#8221; between the <code>stdin</code> and <code>stdout</code> adapters from Spring Integration&#8217;s <code>stream</code> namespace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-stream:stdin-channel-adapter id="stdin"/&gt;

 &lt;int-stream:stdout-channel-adapter id="stdout"/&gt;

 &lt;int:bridge id="echo" input-channel="stdin" output-channel="stdout"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similar configurations work for other (potentially more useful) Channel Adapter bridges, such as file-to-JMS or mail-to-file.
Upcoming chapters cover the various channel adapters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If no 'output-channel' is defined on a bridge, the reply channel provided by the inbound message is used, if available.
If neither an output nor a reply channel is available, an exception is thrown.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="bridge-annot"><a class="anchor" href="#bridge-annot"></a>6.4.2. Configuring a Bridge with Java Configuration</h4>
<div class="paragraph">
<p>The following example shows how to configure a bridge in Java by using the <code>@BridgeFrom</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PollableChannel polled() {
    return new QueueChannel();
}

@Bean
@BridgeFrom(value = "polled", poller = @Poller(fixedDelay = "5000", maxMessagesPerPoll = "10"))
public SubscribableChannel direct() {
    return new DirectChannel();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a bridge in Java by using the <code>@BridgeTo</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@BridgeTo(value = "direct", poller = @Poller(fixedDelay = "5000", maxMessagesPerPoll = "10"))
public PollableChannel polled() {
    return new QueueChannel();
}

@Bean
public SubscribableChannel direct() {
    return new DirectChannel();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can use a <code>BridgeHandler</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "polled",
        poller = @Poller(fixedRate = "5000", maxMessagesPerPoll = "10"))
public BridgeHandler bridge() {
    BridgeHandler bridge = new BridgeHandler();
    bridge.setOutputChannelName("direct");
    return bridge;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bridge-dsl"><a class="anchor" href="#bridge-dsl"></a>6.4.3. Configuring a Bridge with the Java DSL</h4>
<div class="paragraph">
<p>You can use the Java Domain Specific Language (DSL) to configure a bridge, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow bridgeFlow() {
    return IntegrationFlows.from("polled")
            .bridge(e -&gt; e.poller(Pollers.fixedDelay(5000).maxMessagesPerPoll(10)))
            .channel("direct")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="message"><a class="anchor" href="#message"></a>7. Message</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Integration <code>Message</code> is a generic container for data.
Any object can be provided as the payload, and each <code>Message</code> instance includes headers containing user-extensible properties as key-value pairs.</p>
</div>
<div class="sect2">
<h3 id="message-interface"><a class="anchor" href="#message-interface"></a>7.1. The <code>Message</code> Interface</h3>
<div class="paragraph">
<p>The following listing shows the definition of the <code>Message</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Message&lt;T&gt; {

    T getPayload();

    MessageHeaders getHeaders();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Message</code> interface is a core part of the API.
By encapsulating the data in a generic wrapper, the messaging system can pass it around without any knowledge of the data&#8217;s type.
As an application evolves to support new types or when the types themselves are modified or extended, the messaging system is not affected.
On the other hand, when some component in the messaging system does require access to information about the <code>Message</code>, such metadata can typically be stored to and retrieved from the metadata in the message headers.</p>
</div>
</div>
<div class="sect2">
<h3 id="message-headers"><a class="anchor" href="#message-headers"></a>7.2. Message Headers</h3>
<div class="paragraph">
<p>Just as Spring Integration lets any <code>Object</code> be used as the payload of a <code>Message</code>, it also supports any <code>Object</code> types as header values.
In fact, the <code>MessageHeaders</code> class implements the <code>java.util.Map_ interface</code>, as the following class definition shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MessageHeaders implements Map&lt;String, Object&gt;, Serializable {
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Even though the <code>MessageHeaders</code> class implements <code>Map</code>, it is effectively a read-only implementation.
Any attempt to <code>put</code> a value in the Map results in an <code>UnsupportedOperationException</code>.
The same applies for <code>remove</code> and <code>clear</code>.
Since messages may be passed to multiple consumers, the structure of the <code>Map</code> cannot be modified.
Likewise, the message&#8217;s payload <code>Object</code> can not be <code>set</code> after the initial creation.
However, the mutability of the header values themselves (or the payload Object) is intentionally left as a decision for the framework user.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As an implementation of <code>Map</code>, the headers can be retrieved by calling <code>get(..)</code> with the name of the header.
Alternatively, you can provide the expected <code>Class</code> as an additional parameter.
Even better, when retrieving one of the pre-defined values, convenient getters are available.
The following example shows each of these three options:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object someValue = message.getHeaders().get("someKey");

CustomerId customerId = message.getHeaders().get("customerId", CustomerId.class);

Long timestamp = message.getHeaders().getTimestamp();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following table describes the pre-defined message headers:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Pre-defined Message Headers</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Name</th>
<th class="tableblock halign-left valign-top">Header Type</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> MessageHeaders.ID</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.util.UUID</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An identifier for this message instance.
Changes each time a message is mutated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> MessageHeaders.
TIMESTAMP</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Long</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time the message was created.
Changes each time a message is mutated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> MessageHeaders.
REPLY_CHANNEL</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Object
(String or
MessageChannel)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A channel to which a reply (if any) is sent when no explicit output channel is configured and there is no <code>ROUTING_SLIP</code> or the <code>ROUTING_SLIP</code> is exhausted.
If the value is a <code>String</code>, it must represent a bean name or have been generated by a <code>ChannelRegistry.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> MessageHeaders.
ERROR_CHANNEL</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Object
(String or
MessageChannel)</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A channel to which errors are sent.
If the value is a <code>String</code>, it must represent a bean name or have been generated by a <code>ChannelRegistry.</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Many inbound and outbound adapter implementations also provide or expect certain headers, and you can configure additional user-defined headers.
Constants for these headers can be found in those modules where such headers exist&#8201;&#8212;&#8201;for example.
<code>AmqpHeaders</code>, <code>JmsHeaders</code>, and so on.</p>
</div>
<div class="sect3">
<h4 id="message-header-accessor"><a class="anchor" href="#message-header-accessor"></a>7.2.1. <code>MessageHeaderAccessor</code> API</h4>
<div class="paragraph">
<p>Starting with Spring Framework 4.0 and Spring Integration 4.0, the core messaging abstraction has been moved to the <code>spring-messaging</code> module, and the <code>MessageHeaderAccessor</code> API has been introduced to provide additional abstraction over messaging implementations.
All (core) Spring Integration-specific message headers constants are now declared in the <code>IntegrationMessageHeaderAccessor</code> class.
The following table describes the pre-defined message headers:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Pre-defined Message Headers</caption>
<colgroup>
<col style="width: 38.4615%;">
<col style="width: 23.0769%;">
<col style="width: 38.4616%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Name</th>
<th class="tableblock halign-left valign-top">Header Type</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
CORRELATION_ID</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Object</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to correlate two or more messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
SEQUENCE_NUMBER</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Integer</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usually a sequence number with a group of messages with a <code>SEQUENCE_SIZE</code> but can also be used in a <code>&lt;resequencer/&gt;</code> to resequence an unbounded group of messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
SEQUENCE_SIZE</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Integer</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The number of messages within a group of correlated messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
EXPIRATION_DATE</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Long</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates when a message is expired.
Not used by the framework directly but can be set with a header enricher and used in a <code>&lt;filter/&gt;</code> that is configured with an <code>UnexpiredMessageSelector</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
PRIORITY</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Integer</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message priority&#8201;&#8212;&#8201;for example, within a <code>PriorityChannel</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
DUPLICATE_MESSAGE</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.Boolean</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True if a message was detected as a duplicate by an idempotent receiver interceptor.
See <a href="#idempotent-receiver">Idempotent Receiver Enterprise Integration Pattern</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
CLOSEABLE_RESOURCE</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.io.Closeable</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This header is present if the message is associated with a <code>Closeable</code> that should be closed when message processing is complete.
An example is the <code>Session</code> associated with a streamed file transfer using FTP, SFTP, and so on.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
DELIVERY_ATTEMPT</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.lang.
AtomicInteger</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a message-driven channel adapter supports the configuration of a <code>RetryTemplate</code>, this header contains the current delivery attempt.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
ACKNOWLEDGMENT_CALLBACK</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> o.s.i.support.
Acknowledgment
Callback</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a message source supports it, a call back to accept, reject, or requeue a message.
See <a href="#deferred-acks-message-source">Deferred Acknowledgment Pollable Message Source</a>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Convenient typed getters for some of these headers are provided on the <code>IntegrationMessageHeaderAccessor</code> class, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntegrationMessageHeaderAccessor accessor = new IntegrationMessageHeaderAccessor(message);
int sequenceNumber = accessor.getSequenceNumber();
Object correlationId = accessor.getCorrelationId();
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following table describes headers that also appear in the <code>IntegrationMessageHeaderAccessor</code> but are generally not used by user code (that is, they are generally used by internal parts of Spring Integration&#8201;&#8212;&#8201;their inclusion here is for completeness):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Pre-defined Message Headers</caption>
<colgroup>
<col style="width: 38.4615%;">
<col style="width: 23.0769%;">
<col style="width: 38.4616%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Name</th>
<th class="tableblock halign-left valign-top">Header Type</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
SEQUENCE_DETAILS</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.util.
List&lt;List&lt;Object&gt;&gt;</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A stack of correlation data used when nested correlation is needed (for example,
<code>splitter&#8594;&#8230;&#8203;&#8594;splitter&#8594;&#8230;&#8203;&#8594;aggregator&#8594;&#8230;&#8203;&#8594;aggregator</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> IntegrationMessageHeaderAccessor.
ROUTING_SLIP</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> java.util.
Map&lt;List&lt;Object&gt;, Integer&gt;</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#routing-slip">Routing Slip</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="message-id-generation"><a class="anchor" href="#message-id-generation"></a>7.2.2. Message ID Generation</h4>
<div class="paragraph">
<p>When a message transitions through an application, each time it is mutated (for example,
by a transformer) a new message ID is assigned.
The message ID is a <code>UUID</code>.
Beginning with Spring Integration 3.0, the default strategy used for IS generation is more efficient than the previous <code>java.util.UUID.randomUUID()</code> implementation.
It uses simple random numbers based on a secure random seed instead of creating a secure random number each time.</p>
</div>
<div class="paragraph">
<p>A different UUID generation strategy can be selected by declaring a bean that implements <code>org.springframework.util.IdGenerator</code> in the application context.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Only one UUID generation strategy can be used in a classloader.
This means that, if two or more application contexts run in the same classloader, they share the same strategy.
If one of the contexts changes the strategy, it is used by all contexts.
If two or more contexts in the same classloader declare a bean of type <code>org.springframework.util.IdGenerator</code>, they must all be an instance of the same class.
Otherwise, the context attempting to replace a custom strategy fails to initialize.
If the strategy is the same, but parameterized, the strategy in the first context to be initialized is used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the default strategy, two additional <code>IdGenerators</code> are provided.
<code>org.springframework.util.JdkIdGenerator</code> uses the previous <code>UUID.randomUUID()</code> mechanism.
You can use <code>o.s.i.support.IdGenerators.SimpleIncrementingIdGenerator</code> when a UUID is not really needed and a simple incrementing value is sufficient.</p>
</div>
</div>
<div class="sect3">
<h4 id="read-only-headers"><a class="anchor" href="#read-only-headers"></a>7.2.3. Read-only Headers</h4>
<div class="paragraph">
<p>The <code>MessageHeaders.ID</code> and <code>MessageHeaders.TIMESTAMP</code> are read-only headers and cannot be overridden.</p>
</div>
<div class="paragraph">
<p>Since version 4.3.2, the <code>MessageBuilder</code> provides the <code>readOnlyHeaders(String&#8230;&#8203; readOnlyHeaders)</code> API to customize a list of headers that should not be copied from an upstream <code>Message</code>.
Only the <code>MessageHeaders.ID</code> and <code>MessageHeaders.TIMESTAMP</code> are read only by default.
The global <code>spring.integration.readOnly.headers</code> property (see <a href="#global-properties">Global Properties</a>) is provided to customize <code>DefaultMessageBuilderFactory</code> for framework components.
This can be useful when you would like do not populate some out-of-the-box headers, such as <code>contentType</code> by the <code>ObjectToJsonTransformer</code> (see <a href="#json-transformers">JSON Transformers</a>).</p>
</div>
<div class="paragraph">
<p>When you try to build a new message using <code>MessageBuilder</code>, this kind of header is ignored and a particular <code>INFO</code> message is emitted to logs.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, <a href="#gateway">Messaging Gateway</a>, <a href="#header-enricher">Header Enricher</a>, <a href="#payload-enricher">Content Enricher</a> and <a href="#header-filter">Header Filter</a> do not let you configure the <code>MessageHeaders.ID</code> and <code>MessageHeaders.TIMESTAMP</code> header names when <code>DefaultMessageBuilderFactory</code> is used, and they throw <code>BeanInitializationException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="header-propagation"><a class="anchor" href="#header-propagation"></a>7.2.4. Header Propagation</h4>
<div class="paragraph">
<p>When messages are processed (and modified) by message-producing endpoints (such as a <a href="#service-activator">service activator</a>), in general, inbound headers are propagated to the outbound message.
One exception to this is a <a href="#transformer">transformer</a>, when a complete message is returned to the framework.
In that case, the user code is responsible for the entire outbound message.
When a transformer just returns the payload, the inbound headers are propagated.
Also, a header is only propagated if it does not already exist in the outbound message, letting you change header values as needed.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.10, you can configure message handlers (that modify messages and produce output) to suppress the propagation of specific headers.
To configure the header(s) you do not want to be copied, call the <code>setNotPropagatedHeaders()</code> or <code>addNotPropagatedHeaders()</code> methods on the <code>MessageProducingMessageHandler</code> abstract class.</p>
</div>
<div class="paragraph">
<p>You can also globally suppress propagation of specific message headers by setting the <code>readOnlyHeaders</code> property in <code>META-INF/spring.integration.properties</code> to a comma-delimited list of headers.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>setNotPropagatedHeaders()</code> implementation on the <code>AbstractMessageProducingHandler</code> applies simple patterns (<code>xxx*</code>, <code><strong>xxx</code>, <code>*xxx</strong></code>, or <code>xxx*yyy</code>) to allow filtering headers with a common suffix or prefix.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/util/PatternMatchUtils.html"><code>PatternMatchUtils</code> Javadoc</a> for more information.
When one of the patterns is <code>*</code> (asterisk), no headers are propagated.
All other patterns are ignored.
In that case, the service activator behaves the same way as a transformer and any required headers must be supplied in the <code>Message</code> returned from the service method.
The <code>notPropagatedHeaders()</code> option is available in the <code>ConsumerEndpointSpec</code> for the Java DSL
It is also available for XML configuration of the <code>&lt;service-activator&gt;</code> component as a <code>not-propagated-headers</code> attribute.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Header propagation suppression does not apply to those endpoints that do not modify the message, such as <a href="#bridge">bridges</a> and <a href="#router">routers</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-implementations"><a class="anchor" href="#message-implementations"></a>7.3. Message Implementations</h3>
<div class="paragraph">
<p>The base implementation of the <code>Message</code> interface is <code>GenericMessage&lt;T&gt;</code>, and it provides two constructors, shown in the following listing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new GenericMessage&lt;T&gt;(T payload);

new GenericMessage&lt;T&gt;(T payload, Map&lt;String, Object&gt; headers)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When a <code>Message</code> is created, a random unique ID is generated.
The constructor that accepts a <code>Map</code> of headers copies the provided headers to the newly created <code>Message</code>.</p>
</div>
<div class="paragraph">
<p>There is also a convenient implementation of <code>Message</code> designed to communicate error conditions.
This implementation takes a <code>Throwable</code> object as its payload, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ErrorMessage message = new ErrorMessage(someThrowable);

Throwable t = message.getPayload();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that this implementation takes advantage of the fact that the <code>GenericMessage</code> base class is parameterized.
Therefore, as shown in both examples, no casting is necessary when retrieving the <code>Message</code> payload <code>Object</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="message-builder"><a class="anchor" href="#message-builder"></a>7.4. The <code>MessageBuilder</code> Helper Class</h3>
<div class="paragraph">
<p>You may notice that the <code>Message</code> interface defines retrieval methods for its payload and headers but provides no setters.
The reason for this is that a <code>Message</code> cannot be modified after its initial creation.
Therefore, when a <code>Message</code> instance is sent to multiple consumers (for example,
through a publish-subscribe Channel), if one of those consumers needs to send a reply with a different payload type, it must create a new <code>Message</code>.
As a result, the other consumers are not affected by those changes.
Keep in mind that multiple consumers may access the same payload instance or header value, and whether such an instance is itself immutable is a decision left to you.
In other words, the contract for <code>Message</code> instances is similar to that of an unmodifiable <code>Collection</code>, and the <code>MessageHeaders</code> map further exemplifies that.
Even though the <code>MessageHeaders</code> class implements <code>java.util.Map</code>, any attempt to invoke a <code>put</code> operation (or 'remove' or 'clear') on a <code>MessageHeaders</code> instance results in an <code>UnsupportedOperationException</code>.</p>
</div>
<div class="paragraph">
<p>Rather than requiring the creation and population of a Map to pass into the GenericMessage constructor, Spring Integration does provide a far more convenient way to construct Messages: <code>MessageBuilder</code>.
The <code>MessageBuilder</code> provides two factory methods for creating <code>Message</code> instances from either an existing <code>Message</code> or with a payload <code>Object</code>.
When building from an existing <code>Message</code>, the headers and payload of that <code>Message</code> are copied to the new <code>Message</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;String&gt; message1 = MessageBuilder.withPayload("test")
        .setHeader("foo", "bar")
        .build();

Message&lt;String&gt; message2 = MessageBuilder.fromMessage(message1).build();

assertEquals("test", message2.getPayload());
assertEquals("bar", message2.getHeaders().get("foo"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to create a <code>Message</code> with a new payload but still want to copy the headers from an existing <code>Message</code>, you can use one of the 'copy' methods, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;String&gt; message3 = MessageBuilder.withPayload("test3")
        .copyHeaders(message1.getHeaders())
        .build();

Message&lt;String&gt; message4 = MessageBuilder.withPayload("test4")
        .setHeader("foo", 123)
        .copyHeadersIfAbsent(message1.getHeaders())
        .build();

assertEquals("bar", message3.getHeaders().get("foo"));
assertEquals(123, message4.getHeaders().get("foo"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>copyHeadersIfAbsent</code> method does not overwrite existing values.
Also, in the preceding example, you can see how to set any user-defined header with <code>setHeader</code>.
Finally, there are <code>set</code> methods available for the predefined headers as well as a non-destructive method for setting any header (<code>MessageHeaders</code> also defines constants for the pre-defined header names).</p>
</div>
<div class="paragraph">
<p>You can also use <code>MessageBuilder</code> to set the priority of messages, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;Integer&gt; importantMessage = MessageBuilder.withPayload(99)
        .setPriority(5)
        .build();

assertEquals(5, importantMessage.getHeaders().getPriority());

Message&lt;Integer&gt; lessImportantMessage = MessageBuilder.fromMessage(importantMessage)
        .setHeaderIfAbsent(IntegrationMessageHeaderAccessor.PRIORITY, 2)
        .build();

assertEquals(2, lessImportantMessage.getHeaders().getPriority());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>priority</code> header is considered only when using a <code>PriorityChannel</code> (as described in the next chapter).
It is defined as a <code>java.lang.Integer</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="messaging-routing-chapter"><a class="anchor" href="#messaging-routing-chapter"></a>8. Message Routing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers the details of using Spring Integration to route messages.</p>
</div>
<div class="sect2">
<h3 id="router"><a class="anchor" href="#router"></a>8.1. Routers</h3>
<div class="paragraph">
<p>This section covers how routers work.
It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#router-overview">Overview</a></p>
</li>
<li>
<p><a href="#router-common-parameters">Common Router Parameters</a></p>
</li>
<li>
<p><a href="#router-implementations">Router Implementations</a></p>
</li>
<li>
<p><a href="#router-namespace">Configuring a Generic Router</a></p>
</li>
<li>
<p><a href="#router-spel">Routers and the Spring Expression Language (SpEL)</a></p>
</li>
<li>
<p><a href="#dynamic-routers">Dynamic Routers</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="router-overview"><a class="anchor" href="#router-overview"></a>8.1.1. Overview</h4>
<div class="paragraph">
<p>Routers are a crucial element in many messaging architectures.
They consume messages from a message channel and forward each consumed message to one or more different message channels depending on a set of conditions.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides the following routers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#router-implementations-payloadtyperouter">Payload Type Router</a></p>
</li>
<li>
<p><a href="#router-implementations-headervaluerouter">Header Value Router</a></p>
</li>
<li>
<p><a href="#router-implementations-recipientlistrouter">Recipient List Router</a></p>
</li>
<li>
<p><a href="#xml-xpath-routing">XPath Router (part of the XML module)</a></p>
</li>
<li>
<p><a href="#router-implementations-exception-router">Error Message Exception Type Router</a></p>
</li>
<li>
<p><a href="#router-namespace">(Generic) Router</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Router implementations share many configuration parameters.
However, certain differences exist between routers.
Furthermore, the availability of configuration parameters depends on whether routers are used inside or outside of a chain.
In order to provide a quick overview, all available attributes are listed in the two following tables .</p>
</div>
<div class="paragraph">
<p>The following table shows the configuration parameters available for a router outside of a chain:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Routers Outside of a Chain</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">router</th>
<th class="tableblock halign-left valign-top">header value router</th>
<th class="tableblock halign-left valign-top">xpath router</th>
<th class="tableblock halign-left valign-top">payload type router</th>
<th class="tableblock halign-left valign-top">recipient list route</th>
<th class="tableblock halign-left valign-top">exception type router</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apply-sequence</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">default-output-channel</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">resolution-required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ignore-send-failures</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timeout</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">auto-startup</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">input-channel</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">order</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ref</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">expression</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">header-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluate-as-string</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">xpath-expression-ref</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">converter</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table shows the configuration parameters available for a router inside of a chain:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Routers Inside of a Chain</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">router</th>
<th class="tableblock halign-left valign-top">header value router</th>
<th class="tableblock halign-left valign-top">xpath router</th>
<th class="tableblock halign-left valign-top">payload type router</th>
<th class="tableblock halign-left valign-top">recipient list router</th>
<th class="tableblock halign-left valign-top">exception type router</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apply-sequence</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">default-output-channel</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">resolution-required</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ignore-send-failures</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timeout</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">auto-startup</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">input-channel</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ref</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">expression</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">header-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluate-as-string</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">xpath-expression-ref</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">converter</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="images/tickmark.png" alt="tickmark">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Integration 2.1, router parameters have been more standardized across all router implementations.
Consequently, a few minor changes may break older Spring Integration based applications.</p>
</div>
<div class="paragraph">
<p>Since Spring Integration 2.1, the <code>ignore-channel-name-resolution-failures</code> attribute is removed in favor of consolidating its behavior with the <code>resolution-required</code> attribute.
Also, the <code>resolution-required</code> attribute now defaults to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Prior to these changes, the <code>resolution-required</code> attribute defaulted to <code>false</code>, causing messages to be silently dropped when no channel was resolved and no <code>default-output-channel</code> was set.
The new behavior requires at least one resolved channel and, by default, throws a <code>MessageDeliveryException</code> if no channel was determined (or an attempt to send was not successful).</p>
</div>
<div class="paragraph">
<p>If you do desire to drop messages silently, you can set <code>default-output-channel="nullChannel"</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="router-common-parameters"><a class="anchor" href="#router-common-parameters"></a>8.1.2. Common Router Parameters</h4>
<div class="paragraph">
<p>This section describes the parameters common to all router parameters (the parameters with all their boxes ticked in the two tables shown earlier in this chapter).</p>
</div>
<div class="sect4">
<h5 id="router-common-parameters-all"><a class="anchor" href="#router-common-parameters-all"></a>Inside and Outside of a Chain</h5>
<div class="paragraph">
<p>The following parameters are valid for all routers inside and outside of chains.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>apply-sequence</code></dt>
<dd>
<p>This attribute specifies whether sequence number and size headers should be added to each message.
This optional attribute defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>default-output-channel</code></dt>
<dd>
<p>If set, this attribute provides a reference to the channel where messages should be sent if channel resolution fails to return any channels.
If no default output channel is provided, the router throws an exception.
If you would like to silently drop those messages instead, set the default output channel attribute value to <code>nullChannel</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A message is sent only to the <code>default-output-channel</code> if <code>resolution-required</code> is <code>false</code> and the channel is not resolved.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>resolution-required</code></dt>
<dd>
<p>This attribute specifies whether channel names must always be successfully resolved to channel instances that exist.
If set to <code>true</code>, a <code>MessagingException</code> is raised when the channel cannot be resolved.
Setting this attribute to <code>false</code> causes any unresovable channels to be ignored.
This optional attribute defaults to <code>true</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A Message is sent only to the <code>default-output-channel</code>, if specified, when <code>resolution-required</code> is <code>false</code> and the channel is not resolved.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>ignore-send-failures</code></dt>
<dd>
<p>If set to <code>true</code>, failures to send to a message channel is ignored.
If set to <code>false</code>, a <code>MessageDeliveryException</code> is thrown instead, and, if the router resolves more than one channel, any subsequent channels do not receive the message.</p>
<div class="paragraph">
<p>The exact behavior of this attribute depends on the type of the <code>Channel</code> to which the messages are sent.
For example, when using direct channels (single threaded), send failures can be caused by exceptions thrown by components much further downstream.
However, when sending messages to a simple queue channel (asynchronous), the likelihood of an exception to be thrown is rather remote.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While most routers route to a single channel, they can return more than one channel name.
The <code>recipient-list-router</code>, for instance, does exactly that.
If you set this attribute to <code>true</code> on a router that only routes to a single channel, any caused exception is swallowed, which usually makes little sense.
In that case, it would be better to catch the exception in an error flow at the flow entry point.
Therefore, setting the <code>ignore-send-failures</code> attribute to <code>true</code> usually makes more sense when the router implementation returns more than one channel name, because the other channel(s) following the one that fails would still receive the message.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This attribute defaults to <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<p>The <code>timeout</code> attribute specifies the maximum amount of time in milliseconds to wait when sending messages to the target Message Channels.
By default, the send operation blocks indefinitely.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="router-common-parameters-top"><a class="anchor" href="#router-common-parameters-top"></a>Top-Level (Outside of a Chain)</h5>
<div class="paragraph">
<p>The following parameters are valid only across all top-level routers that are outside of chains.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>id</code></dt>
<dd>
<p>Identifies the underlying Spring bean definition, which, in the case of routers, is an instance of <code>EventDrivenConsumer</code> or <code>PollingConsumer</code>, depending on whether the router&#8217;s <code>input-channel</code> is a <code>SubscribableChannel</code> or a <code>PollableChannel</code>, respectively.
This is an optional attribute.</p>
</dd>
<dt class="hdlist1"><code>auto-startup</code></dt>
<dd>
<p>This &#8220;lifecycle&#8221; attribute signaled whether this component should be started during startup of the application context.
This optional attribute defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>input-channel</code></dt>
<dd>
<p>The receiving message channel of this endpoint.</p>
</dd>
<dt class="hdlist1"><code>order</code></dt>
<dd>
<p>This attribute defines the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel uses a failover dispatching strategy.
It has no effect when this endpoint itself is a polling consumer for a channel with a queue.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="router-implementations"><a class="anchor" href="#router-implementations"></a>8.1.3. Router Implementations</h4>
<div class="paragraph">
<p>Since content-based routing often requires some domain-specific logic, most use cases require Spring Integration&#8217;s options for delegating to POJOs by using either the XML namespace support or annotations.
Both of these are discussed later.
However, we first present a couple of implementations that fulfill common requirements.</p>
</div>
<div class="sect4">
<h5 id="router-implementations-payloadtyperouter"><a class="anchor" href="#router-implementations-payloadtyperouter"></a><code>PayloadTypeRouter</code></h5>
<div class="paragraph">
<p>A <code>PayloadTypeRouter</code> sends messages to the channel defined by payload-type mappings, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="payloadTypeRouter"
      class="org.springframework.integration.router.PayloadTypeRouter"&gt;
    &lt;property name="channelMapping"&gt;
        &lt;map&gt;
            &lt;entry key="java.lang.String" value-ref="stringChannel"/&gt;
            &lt;entry key="java.lang.Integer" value-ref="integerChannel"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Configuration of the <code>PayloadTypeRouter</code> is also supported by the namespace provided by Spring Integration (see <code><a href="#configuration-namespace">Namespace Support</a></code>), which essentially simplifies configuration by combining the <code>&lt;router/&gt;</code> configuration and its corresponding implementation (defined by using a <code>&lt;bean/&gt;</code> element) into a single and more concise configuration element.
The following example shows a <code>PayloadTypeRouter</code> configuration that is equivalent to the one above but uses the namespace support:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:payload-type-router input-channel="routingChannel"&gt;
    &lt;int:mapping type="java.lang.String" channel="stringChannel" /&gt;
    &lt;int:mapping type="java.lang.Integer" channel="integerChannel" /&gt;
&lt;/int:payload-type-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "routingChannel")
@Bean
public PayloadTypeRouter router() {
    PayloadTypeRouter router = new PayloadTypeRouter();
    router.setChannelMapping(String.class.getName(), "stringChannel");
    router.setChannelMapping(Integer.class.getName(), "integerChannel");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using the Java DSL, there are two options.</p>
</div>
<div class="paragraph">
<p>First, you can define the router object as shown in the preceding example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow1() {
    return IntegrationFlows.from("routingChannel")
            .route(router())
            .get();
}

public PayloadTypeRouter router() {
    PayloadTypeRouter router = new PayloadTypeRouter();
    router.setChannelMapping(String.class.getName(), "stringChannel");
    router.setChannelMapping(Integer.class.getName(), "integerChannel");
    return router;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the router can be, but does not have to be, a <code>@Bean</code>.
The flow registers it if it is not a <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>Second, you can define the routing function within the DSL flow itself, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow2() {
    return IntegrationFlows.from("routingChannel")
            .&lt;Object, Class&lt;?&gt;&gt;route(Object::getClass, m -&gt; m
                    .channelMapping(String.class, "stringChannel")
                    .channelMapping(Integer.class, "integerChannel"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="router-implementations-headervaluerouter"><a class="anchor" href="#router-implementations-headervaluerouter"></a><code>HeaderValueRouter</code></h5>
<div class="paragraph">
<p>A <code>HeaderValueRouter</code> sends Messages to the channel based on the individual header value mappings.
When a <code>HeaderValueRouter</code> is created, it is initialized with the name of the header to be evaluated.
The value of the header could be one of two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An arbitrary value</p>
</li>
<li>
<p>A channel name</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If it is an arbitrary value, additional mappings for these header values to channel names are required.
Otherwise, no additional configuration is needed.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides a simple namespace-based XML configuration to configure a <code>HeaderValueRouter</code>.
The following example demonstrates configuration for the <code>HeaderValueRouter</code> when mapping of header values to channels is required:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-value-router input-channel="routingChannel" header-name="testHeader"&gt;
    &lt;int:mapping value="someHeaderValue" channel="channelA" /&gt;
    &lt;int:mapping value="someOtherHeaderValue" channel="channelB" /&gt;
&lt;/int:header-value-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>During the resolution process, the router defined in the preceding example may encounter channel resolution failures, causing an exception.
If you want to suppress such exceptions and send unresolved messages to the default output channel (identified with the <code>default-output-channel</code> attribute) set <code>resolution-required</code> to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Normally, messages for which the header value is not explicitly mapped to a channel are sent to the <code>default-output-channel</code>.
However, when the header value is mapped to a channel name but the channel cannot be resolved, setting the <code>resolution-required</code> attribute to <code>false</code> results in routing such messages to the <code>default-output-channel</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As of Spring Integration 2.1, the attribute was changed from <code>ignore-channel-name-resolution-failures</code> to <code>resolution-required</code>.
Attribute <code>resolution-required</code> defaults to <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "routingChannel")
@Bean
public HeaderValueRouter router() {
    HeaderValueRouter router = new HeaderValueRouter("testHeader");
    router.setChannelMapping("someHeaderValue", "channelA");
    router.setChannelMapping("someOtherHeaderValue", "channelB");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using the Java DSL, there are two options.
First, you can define the router object as shown in the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow1() {
    return IntegrationFlows.from("routingChannel")
            .route(router())
            .get();
}

public HeaderValueRouter router() {
    HeaderValueRouter router = new HeaderValueRouter("testHeader");
    router.setChannelMapping("someHeaderValue", "channelA");
    router.setChannelMapping("someOtherHeaderValue", "channelB");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the router can be, but does not have to be, a <code>@Bean</code>.
The flow registers it if it is not a <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>Second, you can define the routing function within the DSL flow itself, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow2() {
    return IntegrationFlows.from("routingChannel")
            .&lt;Message&lt;?&gt;, String&gt;route(m -&gt; m.getHeaders().get("testHeader", String.class), m -&gt; m
                    .channelMapping("someHeaderValue", "channelA")
                    .channelMapping("someOtherHeaderValue", "channelB"),
                e -&gt; e.id("headerValueRouter"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Configuration where mapping of header values to channel names is not required, because header values themselves represent channel names.
The following example shows a router that does not require mapping of header values to channel names:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-value-router input-channel="routingChannel" header-name="testHeader"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Spring Integration 2.1, the behavior of resolving channels is more explicit.
For example, if you omit the <code>default-output-channel</code> attribute, the router was unable to resolve at least one valid channel, and any channel name resolution failures were ignored by setting <code>resolution-required</code> to <code>false</code>, then a <code>MessageDeliveryException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Basically, by default, the router must be able to route messages successfully to at least one channel.
If you really want to drop messages, you must also have <code>default-output-channel</code> set to <code>nullChannel</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="router-implementations-recipientlistrouter"><a class="anchor" href="#router-implementations-recipientlistrouter"></a><code>RecipientListRouter</code></h5>
<div class="paragraph">
<p>A <code>RecipientListRouter</code> sends each received message to a statically defined list of message channels.
The following example creates a <code>RecipientListRouter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="recipientListRouter"
      class="org.springframework.integration.router.RecipientListRouter"&gt;
    &lt;property name="channels"&gt;
        &lt;list&gt;
            &lt;ref bean="channel1"/&gt;
            &lt;ref bean="channel2"/&gt;
            &lt;ref bean="channel3"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Integration also provides namespace support for the <code>RecipientListRouter</code> configuration (see <a href="#configuration-namespace">Namespace Support</a>) as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:recipient-list-router id="customRouter" input-channel="routingChannel"
        timeout="1234"
        ignore-send-failures="true"
        apply-sequence="true"&gt;
  &lt;int:recipient channel="channel1"/&gt;
  &lt;int:recipient channel="channel2"/&gt;
&lt;/int:recipient-list-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "routingChannel")
@Bean
public RecipientListRouter router() {
    RecipientListRouter router = new RecipientListRouter();
    router.setSendTimeout(1_234L);
    router.setIgnoreSendFailures(true);
    router.setApplySequence(true);
    router.addRecipient("channel1");
    router.addRecipient("channel2");
    router.addRecipient("channel3");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured by using the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .routeToRecipients(r -&gt; r
                    .applySequence(true)
                    .ignoreSendFailures(true)
                    .recipient("channel1")
                    .recipient("channel2")
                    .recipient("channel3")
                    .sendTimeout(1_234L))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 'apply-sequence' flag here has the same effect as it does for a publish-subscribe-channel, and, as with a publish-subscribe-channel, it is disabled by default on the <code>recipient-list-router</code>.
See <a href="#channel-configuration-pubsubchannel"><code>PublishSubscribeChannel</code> Configuration</a> for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another convenient option when configuring a <code>RecipientListRouter</code> is to use Spring Expression Language (SpEL) support as selectors for individual recipient channels.
Doing so is similar to using a filter at the beginning of a 'chain' to act as a &#8220;selective consumer&#8221;.
However, in this case, it is all combined rather concisely into the router&#8217;s configuration, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:recipient-list-router id="customRouter" input-channel="routingChannel"&gt;
    &lt;int:recipient channel="channel1" selector-expression="payload.equals('foo')"/&gt;
    &lt;int:recipient channel="channel2" selector-expression="headers.containsKey('bar')"/&gt;
&lt;/int:recipient-list-router&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, a SpEL expression identified by the <code>selector-expression</code> attribute is evaluated to determine whether this recipient should be included in the recipient list for a given input message.
The evaluation result of the expression must be a boolean.
If this attribute is not defined, the channel is always among the list of recipients.</p>
</div>
</div>
<div class="sect4">
<h5 id="recipient-list-router-management"><a class="anchor" href="#recipient-list-router-management"></a><code>RecipientListRouterManagement</code></h5>
<div class="paragraph">
<p>Starting with version 4.1, the <code>RecipientListRouter</code> provides several operations to manipulate recipients dynamically at runtime.
These management operations are presented by <code>RecipientListRouterManagement</code> through the <code>@ManagedResource</code> annotation.
They are available by using <a href="#control-bus">Control Bus</a> as well as by using JMX, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;control-bus input-channel="controlBus"/&gt;

&lt;recipient-list-router id="simpleRouter" input-channel="routingChannelA"&gt;
   &lt;recipient channel="channel1"/&gt;
&lt;/recipient-list-router&gt;

&lt;channel id="channel2"/&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">messagingTemplate.convertAndSend(controlBus, "@'simpleRouter.handler'.addRecipient('channel2')");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>From the application start up the <code>simpleRouter</code>, has only one <code>channel1</code> recipient.
But after the <code>addRecipient</code> command, <code>channel2</code> recipient is added.
It is a &#8220;registering an interest in something that is part of the message&#8221; use case, when we may be interested in messages from the router at some time period, so we are subscribing to the the <code>recipient-list-router</code> and, at some point, decide to unsubscribe.</p>
</div>
<div class="paragraph">
<p>Because of the runtime management operation for the <code>&lt;recipient-list-router&gt;</code>, it can be configured without any <code>&lt;recipient&gt;</code> from the start.
In this case, the behavior of <code>RecipientListRouter</code> is the same when there is no one matching recipient for the message.
If <code>defaultOutputChannel</code> is configured, the message is sent there.
Otherwise the <code>MessageDeliveryException</code> is thrown.</p>
</div>
</div>
<div class="sect4">
<h5 id="router-implementations-xpath-router"><a class="anchor" href="#router-implementations-xpath-router"></a>XPath Router</h5>
<div class="paragraph">
<p>The XPath Router is part of the XML Module.
See <a href="#xml-xpath-routing">Routing XML Messages with XPath</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="router-implementations-exception-router"><a class="anchor" href="#router-implementations-exception-router"></a>Routing and Error Handling</h5>
<div class="paragraph">
<p>Spring Integration also provides a special type-based router called <code>ErrorMessageExceptionTypeRouter</code> for routing error messages (defined as messages whose <code>payload</code> is a <code>Throwable</code> instance).
<code>ErrorMessageExceptionTypeRouter</code> is similar to the <code>PayloadTypeRouter</code>.
In fact, they are almost identical.
The only difference is that, while <code>PayloadTypeRouter</code> navigates the instance hierarchy of a payload instance (for example, <code>payload.getClass().getSuperclass()</code>) to find the most specific type and channel mappings,
the <code>ErrorMessageExceptionTypeRouter</code> navigates the hierarchy of 'exception causes' (for example, <code>payload.getCause()</code>)
to find the most specific <code>Throwable</code> type or channel mappings and uses <code>mappingClass.isInstance(cause)</code> to match the
<code>cause</code> to the class or any super class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since version 4.3 the <code>ErrorMessageExceptionTypeRouter</code> loads all mapping classes during the initialization
phase to fail-fast for a <code>ClassNotFoundException</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a sample configuration for <code>ErrorMessageExceptionTypeRouter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:exception-type-router input-channel="inputChannel"
                           default-output-channel="defaultChannel"&gt;
    &lt;int:mapping exception-type="java.lang.IllegalArgumentException"
                 channel="illegalChannel"/&gt;
    &lt;int:mapping exception-type="java.lang.NullPointerException"
                 channel="npeChannel"/&gt;
&lt;/int:exception-type-router&gt;

&lt;int:channel id="illegalChannel" /&gt;
&lt;int:channel id="npeChannel" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="router-namespace"><a class="anchor" href="#router-namespace"></a>8.1.4. Configuring a Generic Router</h4>
<div class="paragraph">
<p>Spring Integration provides a generic router.
You can use it for general-purpose routing (as opposed to the other routers provided by Spring Integration, each of which has some form of specialization).</p>
</div>
<div class="sect4">
<h5 id="configuring-a-content-based-router-with-xml"><a class="anchor" href="#configuring-a-content-based-router-with-xml"></a>Configuring a Content-based Router with XML</h5>
<div class="paragraph">
<p>The <code>router</code> element provides a way to connect a router to an input channel and also accepts the optional <code>default-output-channel</code> attribute.
The <code>ref</code> attribute references the bean name of a custom router implementation (which must extend <code>AbstractMessageRouter</code>).
The following example shows three generic routers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router ref="payloadTypeRouter" input-channel="input1"
            default-output-channel="defaultOutput1"/&gt;

&lt;int:router ref="recipientListRouter" input-channel="input2"
            default-output-channel="defaultOutput2"/&gt;

&lt;int:router ref="customRouter" input-channel="input3"
            default-output-channel="defaultOutput3"/&gt;

&lt;beans:bean id="customRouterBean" class="org.foo.MyCustomRouter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, <code>ref</code> may point to a POJO that contains the <code>@Router</code> annotation (shown later), or you can combine the <code>ref</code> with an explicit method name.
Specifying a method applies the same behavior described in the <code>@Router</code> annotation section, later in this document.
The following example defines a router that points to a POJO in its <code>ref</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router input-channel="input" ref="somePojo" method="someMethod"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We generally recommend using a <code>ref</code> attribute if the custom router implementation is referenced in other <code>&lt;router&gt;</code> definitions.
However if the custom router implementation should be scoped to a single definition of the <code>&lt;router&gt;</code>, you can provide an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router method="someMethod" input-channel="input3"
            default-output-channel="defaultOutput3"&gt;
    &lt;beans:bean class="org.foo.MyCustomRouter"/&gt;
&lt;/int:router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both the <code>ref</code> attribute and an inner handler definition in the same <code>&lt;router&gt;</code> configuration is not allowed.
Doing so creates an ambiguous condition and throws an exception.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the <code>ref</code> attribute references a bean that extends <code>AbstractMessageProducingHandler</code> (such as routers provided by the framework itself), the configuration is optimized to reference the router directly.
In this case, each <code>ref</code> attribute must refer to a separate bean instance (or a <code>prototype</code>-scoped bean) or use the inner <code>&lt;bean/&gt;</code> configuration type.
However, this optimization applies only if you do not provide any router-specific attributes in the router XML definition.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Router(inputChannel = "routingChannel")
public AbstractMessageRouter myCustomRouter() {
    return new AbstractMessageRouter() {

        @Override
        protected Collection&lt;MessageChannel&gt; determineTargetChannels(Message&lt;?&gt; message) {
            return // determine channel(s) for message
        }

    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured by using the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .route(myCustomRouter())
            .get();
}

public AbstractMessageRouter myCustomRouter() {
    return new AbstractMessageRouter() {

        @Override
        protected Collection&lt;MessageChannel&gt; determineTargetChannels(Message&lt;?&gt; message) {
            return // determine channel(s) for message
        }

    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can route on data from the message payload, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .route(String.class, p -&gt; p.contains("foo") ? "fooChannel" : "barChannel")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="router-spel"><a class="anchor" href="#router-spel"></a>8.1.5. Routers and the Spring Expression Language (SpEL)</h4>
<div class="paragraph">
<p>Sometimes, the routing logic may be simple, and writing a separate class for it and configuring it as a bean may seem like overkill.
As of Spring Integration 2.0, we offer an alternative that lets you use SpEL to implement simple computations that previously required a custom POJO router.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information about the Spring Expression Language, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions">relevant chapter in the Spring Framework Reference Guide</a>:
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Generally, a SpEL expression is evaluated and its result is mapped to a channel, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router input-channel="inChannel" expression="payload.paymentType"&gt;
    &lt;int:mapping value="CASH" channel="cashPaymentChannel"/&gt;
    &lt;int:mapping value="CREDIT" channel="authorizePaymentChannel"/&gt;
    &lt;int:mapping value="DEBIT" channel="authorizePaymentChannel"/&gt;
&lt;/int:router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Router(inputChannel = "routingChannel")
@Bean
public ExpressionEvaluatingRouter router() {
    ExpressionEvaluatingRouter router = new ExpressionEvaluatingRouter("payload.paymentType");
    router.setChannelMapping("CASH", "cashPaymentChannel");
    router.setChannelMapping("CREDIT", "authorizePaymentChannel");
    router.setChannelMapping("DEBIT", "authorizePaymentChannel");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent router configured in the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
        .route("payload.paymentType", r -&gt; r
            .channelMapping("CASH", "cashPaymentChannel")
            .channelMapping("CREDIT", "authorizePaymentChannel")
            .channelMapping("DEBIT", "authorizePaymentChannel"))
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To simplify things even more, the SpEL expression may evaluate to a channel name, as the following expression shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router input-channel="inChannel" expression="payload + 'Channel'"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, the result channel is computed by the SpEL expression, which concatenates the value of the <code>payload</code> with the literal <code>String</code>, 'Channel'.</p>
</div>
<div class="paragraph">
<p>Another virtue of SpEL for configuring routers is that an expression can return a <code>Collection</code>, effectively making every <code>&lt;router&gt;</code> a recipient list router.
Whenever the expression returns multiple channel values, the message is forwarded to each channel.
The following example shows such an expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:router input-channel="inChannel" expression="headers.channels"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the above configuration, if the message includes a header with a name of 'channels' and the value of that header is a <code>List</code> of channel names, the message is sent to each channel in the list.
You may also find collection projection and collection selection expressions useful when you need to select multiple channels.
For further information, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-collection-projection">Collection Projection</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-collection-selection">Collection Selection</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="router-annotation"><a class="anchor" href="#router-annotation"></a>Configuring a Router with Annotations</h5>
<div class="paragraph">
<p>When using <code>@Router</code> to annotate a method, the method may return either a <code>MessageChannel</code> or a <code>String</code> type.
In the latter case, the endpoint resolves the channel name as it does for the default output channel.
Additionally, the method may return either a single value or a collection.
If a collection is returned, the reply message is sent to multiple channels.
To summarize, the following method signatures are all valid:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Router
public MessageChannel route(Message message) {...}

@Router
public List&lt;MessageChannel&gt; route(Message message) {...}

@Router
public String route(Foo payload) {...}

@Router
public List&lt;String&gt; route(Foo payload) {...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition to payload-based routing, a message may be routed based on metadata available within the message header as either a property or an attribute.
In this case, a method annotated with <code>@Router</code> may include a parameter annotated with <code>@Header</code>, which is mapped to a header value as the following example shows and documented in <a href="#annotations">Annotation Support</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Router
public List&lt;String&gt; route(@Header("orderStatus") OrderStatus status)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For routing of XML-based Messages, including XPath support, see <a href="#xml">XML Support - Dealing with XML Payloads</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See also <a href="#java-dsl-routers">Message Routers</a> in the Java DSL chapter for more information about router configuration.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-routers"><a class="anchor" href="#dynamic-routers"></a>8.1.6. Dynamic Routers</h4>
<div class="paragraph">
<p>Spring Integration provides quite a few different router configurations for common content-based routing use cases as well as the option of implementing custom routers as POJOs.
For example, <code>PayloadTypeRouter</code> provides a simple way to configure a router that computes channels based on the payload type of the incoming message while <code>HeaderValueRouter</code> provides the same convenience in configuring a router that computes channels by evaluating the value of a particular message Header.
There are also expression-based (SpEL) routers, in which the channel is determined based on evaluating an expression.
All of these type of routers exhibit some dynamic characteristics.</p>
</div>
<div class="paragraph">
<p>However, these routers all require static configuration.
Even in the case of expression-based routers, the expression itself is defined as part of the router configuration, which means that the same expression operating on the same value always results in the computation of the same channel.
This is acceptable in most cases, since such routes are well defined and therefore predictable.
But there are times when we need to change router configurations dynamically so that message flows may be routed to a different channel.</p>
</div>
<div class="paragraph">
<p>For example, you might want to bring down some part of your system for maintenance and temporarily re-reroute messages to a different message flow.
As another example, you may want to introduce more granularity to your message flow by adding another route to handle a more concrete type of <code>java.lang.Number</code> (in the case of <code>PayloadTypeRouter</code>).</p>
</div>
<div class="paragraph">
<p>Unfortunately, with static router configuration to accomplish either of those goals, you would have to bring down your entire application, change the configuration of the router (change routes), and bring the application back up.
This is obviously not a solution anyone wants.</p>
</div>
<div class="paragraph">
<p>The <a href="https://www.enterpriseintegrationpatterns.com/DynamicRouter.html">dynamic router</a> pattern describes the mechanisms by which you can change or configure routers dynamically without bringing down the system or individual routers.</p>
</div>
<div class="paragraph">
<p>Before we get into the specifics of how Spring Integration supports dynamic routing, we need to consider the typical flow of a router:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compute a channel identifier, which is a value calculated by the router once it receives the message.
Typically, it is a String or an instance of the actual <code>MessageChannel</code>.</p>
</li>
<li>
<p>Resolve the channel identifier to a channel name.
We describe specifics of this process later in this section.</p>
</li>
<li>
<p>Resolve the channel name to the actual <code>MessageChannel</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There is not much that can be done with regard to dynamic routing if Step 1 results in the actual instance of the <code>MessageChannel</code>, because the <code>MessageChannel</code> is the final product of any router&#8217;s job.
However, if the first step results in a channel identifier that is not an instance of <code>MessageChannel</code>, you have quite a few possible ways to influence the process of deriving the <code>MessageChannel</code>.
Consider the following example of a payload type router:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:payload-type-router input-channel="routingChannel"&gt;
    &lt;int:mapping type="java.lang.String"  channel="channel1" /&gt;
    &lt;int:mapping type="java.lang.Integer" channel="channel2" /&gt;
&lt;/int:payload-type-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Within the context of a payload type router, the three steps mentioned earlier would be realized as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compute a channel identifier that is the fully qualified name of the payload type (for example, <code>java.lang.String</code>).</p>
</li>
<li>
<p>Resolve the channel identifier to a channel name, where the result of the previous step is used to select the appropriate value from the payload type mapping defined in the <code>mapping</code> element.</p>
</li>
<li>
<p>Resolve the channel name to the actual instance of the <code>MessageChannel</code> as a reference to a bean within the application context (which is hopefully a <code>MessageChannel</code>) identified by the result of the previous step.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In other words, each step feeds the next step until the process completes.</p>
</div>
<div class="paragraph">
<p>Now consider an example of a header value router:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-value-router input-channel="inputChannel" header-name="testHeader"&gt;
    &lt;int:mapping value="foo" channel="fooChannel" /&gt;
    &lt;int:mapping value="bar" channel="barChannel" /&gt;
&lt;/int:header-value-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can consider how the three steps work for a header value router:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Compute a channel identifier that is the value of the header identified by the <code>header-name</code> attribute.</p>
</li>
<li>
<p>Resolve the channel identifier a to channel name, where the result of the previous step is used to select the appropriate value from the general mapping defined in the <code>mapping</code> element.</p>
</li>
<li>
<p>Resolve the channel name to the actual instance of the <code>MessageChannel</code> as a reference to a bean within the application context (which is hopefully a <code>MessageChannel</code>) identified by the result of the previous step.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The preceding two configurations of two different router types look almost identical.
However, if you look at the alternate configuration of the <code>HeaderValueRouter</code> we clearly see that there is no <code>mapping</code> sub element, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-value-routerinput-channel="inputChannel"header-name="testHeader"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, the configuration is still perfectly valid.
So the natural question is what about the mapping in the second step?</p>
</div>
<div class="paragraph">
<p>The second step is now optional.
If <code>mapping</code> is not defined, then the channel identifier value computed in the first step is automatically treated as the <code>channel name</code>, which is now resolved to the actual <code>MessageChannel</code>, as in the third step.
What it also means is that the second step is one of the key steps to providing dynamic characteristics to the routers, since it introduces a process that lets you change the way channel identifier resolves to the channel name, thus influencing the process of determining the final instance of the <code>MessageChannel</code> from the initial channel identifier.</p>
</div>
<div class="paragraph">
<p>For example, in the preceding configuration, assume that the <code>testHeader</code> value is 'kermit', which is now a channel identifier (the first step).
Since there is no mapping in this router, resolving this channel identifier to a channel name (the second step) is impossible and this channel identifier is now treated as the channel name.
However, what if there was a mapping but for a different value?
The end result would still be the same, because, if a new value cannot be determined through the process of resolving the channel identifier to a channel name, the channel identifier becomes the channel name.</p>
</div>
<div class="paragraph">
<p>All that is left is for the third step to resolve the channel name ('kermit') to an actual instance of the <code>MessageChannel</code> identified by this name.
That basically involves a bean lookup for the provided name.
Now all messages that contain the header-value pair as <code>testHeader=kermit</code> are going to be routed to a <code>MessageChannel</code> whose bean name (its <code>id</code>) is 'kermit'.</p>
</div>
<div class="paragraph">
<p>But what if you want to route these messages to the 'simpson' channel? Obviously changing a static configuration works, but doing so also requires bringing your system down.
However, if you had access to the channel identifier map, you could introduce a new mapping where the header-value pair is now <code>kermit=simpson</code>, thus letting the second step treat 'kermit' as a channel identifier while resolving it to 'simpson' as the channel name.</p>
</div>
<div class="paragraph">
<p>The same obviously applies for <code>PayloadTypeRouter</code>, where you can now remap or remove a particular payload type mapping.
In fact, it applies to every other router, including expression-based routers, since their computed values now have a chance to go through the second step to be resolved to the actual <code>channel name</code>.</p>
</div>
<div class="paragraph">
<p>Any router that is a subclass of the <code>AbstractMappingMessageRouter</code> (which includes most framework-defined routers) is a dynamic router, because the <code>channelMapping</code> is defined at the <code>AbstractMappingMessageRouter</code> level.
That map&#8217;s setter method is exposed as a public method along with the 'setChannelMapping' and 'removeChannelMapping' methods.
These let you  change, add, and remove router mappings at runtime, as long as you have a reference to the router itself.
It also means that you could expose these same configuration options through JMX (see <a href="#jmx">JMX Support</a>) or the Spring Integration control bus (see <a href="#control-bus">Control Bus</a>) functionality.</p>
</div>
<div class="sect4">
<h5 id="dynamic-routers-control-bus"><a class="anchor" href="#dynamic-routers-control-bus"></a>Manage Router Mappings using the Control Bus</h5>
<div class="paragraph">
<p>One way to manage the router mappings is through the <a href="https://www.enterpriseintegrationpatterns.com/ControlBus.html">control bus</a> pattern, which exposes a control channel to which you can send control messages to manage and monitor Spring Integration components, including routers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information about the control bus, see <a href="#control-bus">Control Bus</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically, you would send a control message asking to invoke a particular operation on a particular managed component (such as a
router).
The following managed operations (methods) are specific to changing the router resolution process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public void setChannelMapping(String key, String channelName)</code>: Lets you add a new or modify an existing mapping between <code>channel identifier</code> and <code>channel name</code></p>
</li>
<li>
<p><code>public void removeChannelMapping(String key)</code>: Lets you remove a particular channel mapping, thus disconnecting the relationship between <code>channel identifier</code> and <code>channel name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that these methods can be used for simple changes (such as updating a single route or adding or removing a route).
However, if you want to remove one route and add another, the updates are not atomic.
This means that the routing table may be in an indeterminate state between the updates.
Starting with version 4.0, you can now use the control bus to update the entire routing table atomically.
The following methods let you do so:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public Map&lt;String, String&gt;getChannelMappings()</code>: Returns the current mappings.</p>
</li>
<li>
<p><code>public void replaceChannelMappings(Properties channelMappings)</code>: Updates the mappings.
Note that the <code>channelMappings</code> parameter is a <code>Properties</code> object.
This arrangement lets a control bus command use the built-in <code>StringToPropertiesConverter</code>, as the following example shows:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>"@'router.handler'.replaceChannelMappings('foo=qux \n baz=bar')"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that each mapping is separated by a newline character (<code>\n</code>).
For programmatic changes to the map, we recommend that you use the <code>setChannelMappings</code> method, due to type-safety concerns.
<code>replaceChannelMappings</code> ignores keys or values that are not <code>String</code> objects.</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-routers-jmx"><a class="anchor" href="#dynamic-routers-jmx"></a>Manage Router Mappings by Using JMX</h5>
<div class="paragraph">
<p>You can also use Spring&#8217;s JMX support to expose a router instance and then use your favorite JMX client (for example, JConsole) to manage those operations (methods) for changing the router&#8217;s configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information about Spring Integration&#8217;s JMX support, see <a href="#jmx">JMX Support</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="routing-slip"><a class="anchor" href="#routing-slip"></a>Routing Slip</h5>
<div class="paragraph">
<p>Starting with version 4.1, Spring Integration provides an implementation of the <a href="https://www.enterpriseintegrationpatterns.com/RoutingTable.html">routing slip</a> enterprise integration pattern.
It is implemented as a <code>routingSlip</code> message header, which is used to determine the next channel in <code>AbstractMessageProducingHandler</code> instances, when an <code>outputChannel</code> is not specified for the endpoint.
This pattern is useful in complex, dynamic cases, when it can become difficult to configure multiple routers to determine message flow.
When a message arrives at an endpoint that has no <code>output-channel</code>, the <code>routingSlip</code> is consulted to determine the next channel to which the message is sent.
When the routing slip is exhausted, normal <code>replyChannel</code> processing resumes.</p>
</div>
<div class="paragraph">
<p>Configuration for the routing slip is presented as a <code>HeaderEnricher</code> option&#8201;&#8212;&#8201;a semicolon-separated routing slip that contains <code>path</code> entries, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:properties id="properties"&gt;
    &lt;beans:prop key="myRoutePath1"&gt;channel1&lt;/beans:prop&gt;
    &lt;beans:prop key="myRoutePath2"&gt;request.headers[myRoutingSlipChannel]&lt;/beans:prop&gt;
&lt;/util:properties&gt;

&lt;context:property-placeholder properties-ref="properties"/&gt;

&lt;header-enricher input-channel="input" output-channel="process"&gt;
    &lt;routing-slip
        value="${myRoutePath1}; @routingSlipRoutingPojo.get(request, reply);
               routingSlipRoutingStrategy; ${myRoutePath2}; finishChannel"/&gt;
&lt;/header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example has:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>&lt;context:property-placeholder&gt;</code> configuration to demonstrate that the entries in the routing slip <code>path</code> can be specified as resolvable keys.</p>
</li>
<li>
<p>The <code>&lt;header-enricher&gt;</code> <code>&lt;routing-slip&gt;</code> sub-element is used to populate the <code>RoutingSlipHeaderValueMessageProcessor</code> to the <code>HeaderEnricher</code> handler.</p>
</li>
<li>
<p>The <code>RoutingSlipHeaderValueMessageProcessor</code> accepts a <code>String</code> array of resolved routing slip <code>path</code> entries and returns (from <code>processMessage()</code>) a <code>singletonMap</code> with the <code>path</code> as <code>key</code> and <code>0</code> as initial <code>routingSlipIndex</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Routing Slip <code>path</code> entries can contain <code>MessageChannel</code> bean names, <code>RoutingSlipRouteStrategy</code> bean names, and Spring expressions (SpEL).
The <code>RoutingSlipHeaderValueMessageProcessor</code> checks each routing slip <code>path</code> entry against the <code>BeanFactory</code> on the first <code>processMessage</code> invocation.
It converts entries (which are not bean names in the application context) to <code>ExpressionEvaluatingRoutingSlipRouteStrategy</code> instances.
<code>RoutingSlipRouteStrategy</code> entries are invoked multiple times, until they return null or an empty <code>String</code>.</p>
</div>
<div class="paragraph">
<p>Since the routing slip is involved in the <code>getOutputChannel</code> process, we have a request-reply context.
The <code>RoutingSlipRouteStrategy</code> has been introduced to determine the next <code>outputChannel</code> that uses the <code>requestMessage</code> and the <code>reply</code> object.
An implementation of this strategy should be registered as a bean in the application context, and its bean name is used in the routing slip <code>path</code>.
The <code>ExpressionEvaluatingRoutingSlipRouteStrategy</code> implementation is provided.
It accepts a SpEL expression and an internal <code>ExpressionEvaluatingRoutingSlipRouteStrategy.RequestAndReply</code> object is used as the root object of the evaluation context.
This is to avoid the overhead of <code>EvaluationContext</code> creation for each <code>ExpressionEvaluatingRoutingSlipRouteStrategy.getNextPath()</code> invocation.
It is a simple Java bean with two properties: <code>Message&lt;?&gt; request</code> and <code>Object reply</code>.
With this expression implementation, we can specify routing slip <code>path</code> entries by using SpEL (for example, <code>@routingSlipRoutingPojo.get(request, reply)</code> and <code>request.headers[myRoutingSlipChannel]</code>) and avoid defining a bean for the <code>RoutingSlipRouteStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>requestMessage</code> argument is always a <code>Message&lt;?&gt;</code>.
Depending on context, the reply object may be a <code>Message&lt;?&gt;</code>, an <code>AbstractIntegrationMessageBuilder</code>, or an arbitrary application domain object (when, for example, it is returned by a POJO method invoked by a service activator).
In the first two cases, the usual <code>Message</code> properties (<code>payload</code> and <code>headers</code>) are available when using SpEL (or a Java implementation).
For an arbitrary domain object, these properties are not available.
For this reason, be careful when you use routing slips in conjunction with POJO methods if the result is used to determine the
next path.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If a routing slip is involved in a distributed environment, we recommend not using inline expressions for the Routing Slip <code>path</code>.
This recommendation applies to distributed environments such as cross-JVM applications, using a <code>request-reply</code> through a message broker (such as<a href="#amqp">AMQP Support</a> or <a href="#jms">JMS Support</a>), or using a persistent <code>MessageStore</code> (<a href="#message-store">Message Store</a>) in the integration flow.
The framework uses <code>RoutingSlipHeaderValueMessageProcessor</code> to convert them to <code>ExpressionEvaluatingRoutingSlipRouteStrategy</code> objects, and they are used in the <code>routingSlip</code> message header.
Since this class is not <code>Serializable</code> (it cannot be, because it depends on the <code>BeanFactory</code>), the entire <code>Message</code> becomes non-serializable and, in any distributed operation, we end up with a <code>NotSerializableException</code>.
To overcome this limitation, register an <code>ExpressionEvaluatingRoutingSlipRouteStrategy</code> bean with the desired SpEL and use its bean name in the routing slip <code>path</code> configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For Java configuration, you can add a <code>RoutingSlipHeaderValueMessageProcessor</code> instance to the <code>HeaderEnricher</code> bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel = "routingSlipHeaderChannel")
public HeaderEnricher headerEnricher() {
    return new HeaderEnricher(Collections.singletonMap(IntegrationMessageHeaderAccessor.ROUTING_SLIP,
            new RoutingSlipHeaderValueMessageProcessor("myRoutePath1",
                                                       "@routingSlipRoutingPojo.get(request, reply)",
                                                       "routingSlipRoutingStrategy",
                                                       "request.headers[myRoutingSlipChannel]",
                                                       "finishChannel")));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The routing slip algorithm works as follows when an endpoint produces a reply and no <code>outputChannel</code> has been defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>routingSlipIndex</code> is used to get a value from the routing slip <code>path</code> list.</p>
</li>
<li>
<p>If the value from <code>routingSlipIndex</code> is <code>String</code>, it is used to get a bean from <code>BeanFactory</code>.</p>
</li>
<li>
<p>If a returned bean is an instance of <code>MessageChannel</code>, it is used as the next <code>outputChannel</code> and the <code>routingSlipIndex</code> is incremented in the reply message header (the routing slip <code>path</code> entries remain unchanged).</p>
</li>
<li>
<p>If a returned bean is an instance of <code>RoutingSlipRouteStrategy</code> and its <code>getNextPath</code> does not return an empty <code>String</code>, that result is used as a bean name for the next <code>outputChannel</code>.
The <code>routingSlipIndex</code> remains unchanged.</p>
</li>
<li>
<p>If <code>RoutingSlipRouteStrategy.getNextPath</code> returns an empty <code>String</code>, the <code>routingSlipIndex</code> is incremented and the <code>getOutputChannelFromRoutingSlip</code> is invoked recursively for the next Routing Slip <code>path</code> item.</p>
</li>
<li>
<p>If the next routing slip <code>path</code> entry is not a <code>String</code>, it must be an instance of <code>RoutingSlipRouteStrategy</code>.</p>
</li>
<li>
<p>When the <code>routingSlipIndex</code> exceeds the size of the routing slip <code>path</code> list, the algorithm moves to the default behavior for the standard <code>replyChannel</code> header.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="process-manager"><a class="anchor" href="#process-manager"></a>Process Manager Enterprise Integration Pattern</h5>
<div class="paragraph">
<p>Enterprise integration patterns include the <a href="https://www.enterpriseintegrationpatterns.com/ProcessManager.html">process manager</a> pattern.
You can now easily implement this pattern by using custom process manager logic encapsulated in a <code>RoutingSlipRouteStrategy</code> within the routing slip.
In addition to a bean name, the <code>RoutingSlipRouteStrategy</code> can return any <code>MessageChannel</code> object, and there is no requirement that this <code>MessageChannel</code> instance be a bean in the application context.
This way, we can provide powerful dynamic routing logic when there is no way to predict which channel should be used.
A <code>MessageChannel</code> can be created within the <code>RoutingSlipRouteStrategy</code> and returned.
A <code>FixedSubscriberChannel</code> with an associated <code>MessageHandler</code> implementation is a good combination for such cases.
For example, you can route to a <a href="https://github.com/reactor/reactor/wiki/Streams">reactor stream</a>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PollableChannel resultsChannel() {
    return new QueueChannel();
}
@Bean
public RoutingSlipRouteStrategy routeStrategy() {
    return (requestMessage, reply) -&gt; requestMessage.getPayload() instanceof String
            ? new FixedSubscriberChannel(m -&gt;
            Mono.just((String) m.getPayload())
                    .map(String::toUpperCase)
                    .subscribe(v -&gt; messagingTemplate().convertAndSend(resultsChannel(), v)))
            : new FixedSubscriberChannel(m -&gt;
            Mono.just((Integer) m.getPayload())
                    .map(v -&gt; v * 2)
                    .subscribe(v -&gt; messagingTemplate().convertAndSend(resultsChannel(), v)));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filter"><a class="anchor" href="#filter"></a>8.2. Filter</h3>
<div class="paragraph">
<p>Message filters are used to decide whether a <code>Message</code> should be passed along or dropped based on some criteria, such as a message header value or message content itself.
Therefore, a message filter is similar to a router, except that, for each message received from the filter&#8217;s input channel, that same message may or may not be sent to the filter&#8217;s output channel.
Unlike the router, it makes no decision regarding which message channel to send the message to but decides only whether to send the message at all.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As we describe later in this section, the filter also supports a discard channel.
In certain cases, it can play the role of a very simple router (or &#8220;switch&#8221;), based on a boolean condition.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Spring Integration, you can configure a message filter as a message endpoint that delegates to an implementation of the <code>MessageSelector</code> interface.
That interface is itself quite simple, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageSelector {

    boolean accept(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>MessageFilter</code> constructor accepts a selector instance, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageFilter filter = new MessageFilter(someSelector);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In combination with the namespace and SpEL, you can configure powerful filters with very little Java code.</p>
</div>
<div class="sect3">
<h4 id="filter-xml"><a class="anchor" href="#filter-xml"></a>8.2.1. Configuring a Filter with XML</h4>
<div class="paragraph">
<p>You can use the <code>&lt;filter&gt;</code> element is used to create a message-selecting endpoint.
In addition to <code>input-channel</code> and <code>output-channel</code> attributes, it requires a <code>ref</code> attribute.
The <code>ref</code> can point to a <code>MessageSelector</code> implementation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" ref="selector" output-channel="output"/&gt;

&lt;bean id="selector" class="example.MessageSelectorImpl"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can add the <code>method</code> attribute.
In that case, the <code>ref</code> attribute may refer to any object.
The referenced method may expect either the <code>Message</code> type or the payload type of inbound messages.
The method must return a boolean value.
If the method returns 'true', the message is sent to the output channel.
The following example shows how to configure a filter that uses the <code>method</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" output-channel="output"
    ref="exampleObject" method="someBooleanReturningMethod"/&gt;

&lt;bean id="exampleObject" class="example.SomeObject"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the selector or adapted POJO method returns <code>false</code>, a few settings  control the handling of the rejected message.
By default (if configured as in the preceding example), rejected messages are silently dropped.
If rejection should instead result in an error condition, set the <code>throw-exception-on-rejection</code> attribute to <code>true</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" ref="selector"
    output-channel="output" throw-exception-on-rejection="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you want rejected messages to be routed to a specific channel, provide that reference as the <code>discard-channel</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" ref="selector"
    output-channel="output" discard-channel="rejectedMessages"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#advising-filters">Advising Filters</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Message filters are commonly used in conjunction with a publish-subscribe channel.
Many filter endpoints may be subscribed to the same channel, and they decide whether or not to pass the message to the next endpoint, which could be any of the supported types (such as a service activator).
This provides a reactive alternative to the more proactive approach of using a message router with a single point-to-point input channel and multiple output channels.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We recommend using a <code>ref</code> attribute if the custom filter implementation is referenced in other <code>&lt;filter&gt;</code> definitions.
However, if the custom filter implementation is scoped to a single <code>&lt;filter&gt;</code> element, you should provide an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter method="someMethod" input-channel="inChannel" output-channel="outChannel"&gt;
  &lt;beans:bean class="org.foo.MyCustomFilter"/&gt;
&lt;/filter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both the <code>ref</code> attribute and an inner handler definition in the same <code>&lt;filter&gt;</code> configuration is not allowed, as it creates an ambiguous condition and throws an exception.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the <code>ref</code> attribute references a bean that extends <code>MessageFilter</code> (such as filters provided by the framework itself), the configuration is optimized by injecting the output channel into the filter bean directly.
In this case, each <code>ref</code> must be to a separate bean instance (or a <code>prototype</code>-scoped bean) or use the inner <code>&lt;bean/&gt;</code> configuration type.
However, this optimization applies only if you do not provide any filter-specific attributes in the filter XML definition.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With the introduction of SpEL support, Spring Integration added the <code>expression</code> attribute to the filter element.
It can be used to avoid Java entirely for simple filters, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" expression="payload.equals('nonsense')"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The string passed as the value of the expression attribute is evaluated as a SpEL expression with the message available in the evaluation context.
If you must include the result of an expression in the scope of the application context, you can use the <code>#{}</code> notation, as defined in the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-beandef">SpEL reference documentation</a>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input"
            expression="payload.matches(#{filterPatterns.nonsensePattern})"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the expression itself needs to be dynamic, you can use an 'expression' sub-element.
That provides a level of indirection for resolving the expression by its key from an <code>ExpressionSource</code>.
That is a strategy interface that you can implement directly, or you can rely upon a version available in Spring Integration that loads expressions from a &#8220;resource bundle&#8221; and can check for modifications after a given number of seconds.
All of this is demonstrated in the following configuration example, where the expression could be reloaded within one minute if the underlying file had been modified:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="input" output-channel="output"&gt;
    &lt;int:expression key="filterPatterns.example" source="myExpressions"/&gt;
&lt;/int:filter&gt;

&lt;beans:bean id="myExpressions" id="myExpressions"
    class="o.s.i.expression.ReloadableResourceBundleExpressionSource"&gt;
    &lt;beans:property name="basename" value="config/integration/expressions"/&gt;
    &lt;beans:property name="cacheSeconds" value="60"/&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>ExpressionSource</code> bean is named <code>expressionSource</code>, you need not provide the` source` attribute on the <code>&lt;expression&gt;</code> element.
However, in the preceding example, we show it for completeness.</p>
</div>
<div class="paragraph">
<p>The 'config/integration/expressions.properties' file (or any more-specific version with a locale extension to be resolved in the typical way that resource-bundles are loaded) can contain a key/value pair, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>filterPatterns.example=payload &gt; 100</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All of these examples that use <code>expression</code> as an attribute or sub-element can also be applied within transformer, router, splitter, service-activator, and header-enricher elements.
The semantics and role of the given component type would affect the interpretation of the evaluation result, in the same way that the return value of a method-invocation would be interpreted.
For example, an expression can return strings that are to be treated as message channel names by a router component.
However, the underlying functionality of evaluating the expression against the message as the root object and resolving bean names if prefixed with '@' is consistent across all of the core EIP components within Spring Integration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="filter-annotations"><a class="anchor" href="#filter-annotations"></a>8.2.2. Configuring a Filter with Annotations</h4>
<div class="paragraph">
<p>The following example shows how to configure a filter by using annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PetFilter {
    ...
    @Filter  <i class="conum" data-value="1"></i><b>(1)</b>
    public boolean dogsOnly(String input) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An annotation indicating that this method is to be used as a filter.
It must be specified if this class is to be used as a filter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All of the configuration options provided by the XML element are also available for the <code>@Filter</code> annotation.</p>
</div>
<div class="paragraph">
<p>The filter can be either referenced explicitly from XML or, if the <code>@MessageEndpoint</code> annotation is defined on the class, detected automatically through classpath scanning.</p>
</div>
<div class="paragraph">
<p>See also <a href="#advising-with-annotations">Advising Endpoints Using Annotations</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="splitter"><a class="anchor" href="#splitter"></a>8.3. Splitter</h3>
<div class="paragraph">
<p>The splitter is a component whose role is to partition a message into several parts and send the resulting messages to be processed independently.
Very often, they are upstream producers in a pipeline that includes an aggregator.</p>
</div>
<div class="sect3">
<h4 id="programming-model"><a class="anchor" href="#programming-model"></a>8.3.1. Programming Model</h4>
<div class="paragraph">
<p>The API for performing splitting consists of one base class, <code>AbstractMessageSplitter</code>.
It is a <code>MessageHandler</code> implementation that encapsulates features common to splitters, such as filling in the appropriate message headers (<code>CORRELATION_ID</code>, <code>SEQUENCE_SIZE</code>, and <code>SEQUENCE_NUMBER</code>) on the messages that are produced.
This filling enables tracking down the messages and the results of their processing (in a typical scenario, these headers get copied to the messages that are produced by the various transforming endpoints).
The values can then be used, for example, by a <a href="https://www.enterpriseintegrationpatterns.com/DistributionAggregate.html">composed message processor</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows an excerpt from <code>AbstractMessageSplitter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public abstract class AbstractMessageSplitter
    extends AbstractReplyProducingMessageConsumer {
    ...
    protected abstract Object splitMessage(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement a specific splitter in an application, you can extend <code>AbstractMessageSplitter</code> and implement the <code>splitMessage</code> method, which contains logic for splitting the messages.
The return value can be one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>Collection</code> or an array of messages or an <code>Iterable</code> (or <code>Iterator</code>) that iterates over messages.
In this case, the messages are sent as messages (after the <code>CORRELATION_ID</code>, <code>SEQUENCE_SIZE</code> and <code>SEQUENCE_NUMBER</code> are populated).
Using this approach gives you more control&#8201;&#8212;&#8201;for example, to populate custom message headers as part of the splitting process.</p>
</li>
<li>
<p>A <code>Collection</code> or an array of non-message objects or an <code>Iterable</code> (or <code>Iterator</code>) that iterates over non-message objects.
It works like the prior case, except that each collection element is used as a message payload.
Using this approach lets you focus on the domain objects without having to consider the messaging system and produces code that is easier to test.</p>
</li>
<li>
<p>a <code>Message</code> or non-message object (but not a collection or an array).
It works like the previous cases, except that a single message is sent out.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Spring Integration, any POJO can implement the splitting algorithm, provided that it defines a method that accepts a single argument and has a return value.
In this case, the return value of the method is interpreted as described earlier.
The input argument might either be a <code>Message</code> or a simple POJO.
In the latter case, the splitter receives the payload of the incoming message.
We recommend this approach, because it decouples the code from the Spring Integration API and is typically easier to test.</p>
</div>
<div class="sect4">
<h5 id="iterators"><a class="anchor" href="#iterators"></a>Iterators</h5>
<div class="paragraph">
<p>Starting with version 4.1, the <code>AbstractMessageSplitter</code> supports the <code>Iterator</code> type for the <code>value</code> to split.
Note, in the case of an <code>Iterator</code> (or <code>Iterable</code>), we don&#8217;t have access to the number of underlying items and the <code>SEQUENCE_SIZE</code> header is set to <code>0</code>.
This means that the default <code>SequenceSizeReleaseStrategy</code> of an <code>&lt;aggregator&gt;</code> won&#8217;t work and the group for the <code>CORRELATION_ID</code> from the <code>splitter</code> won&#8217;t be released; it will remain as <code>incomplete</code>.
In this case you should use an appropriate custom <code>ReleaseStrategy</code> or rely on <code>send-partial-result-on-expiry</code> together with <code>group-timeout</code> or a <code>MessageGroupStoreReaper</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>AbstractMessageSplitter</code> provides <code>protected obtainSizeIfPossible()</code> methods to allow the determination of the size of the <code>Iterable</code> and <code>Iterator</code> objects if that is possible.
For example <code>XPathMessageSplitter</code> can determine the size of the underlying <code>NodeList</code> object.
And starting with version 5.0.9, this method also properly returns a size of the <code>com.fasterxml.jackson.core.TreeNode</code>.</p>
</div>
<div class="paragraph">
<p>An <code>Iterator</code> object is useful to avoid the need for building an entire collection in the memory before splitting.
For example, when underlying items are populated from some external system (e.g. DataBase or FTP <code>MGET</code>) using iterations or streams.</p>
</div>
</div>
<div class="sect4">
<h5 id="stream-and-flux"><a class="anchor" href="#stream-and-flux"></a>Stream and Flux</h5>
<div class="paragraph">
<p>Starting with version 5.0, the <code>AbstractMessageSplitter</code> supports the Java <code>Stream</code> and Reactive Streams <code>Publisher</code> types for the <code>value</code> to split.
In this case, the target <code>Iterator</code> is built on their iteration functionality.</p>
</div>
<div class="paragraph">
<p>In addition, if the splitter&#8217;s output channel is an instance of a <code>ReactiveStreamsSubscribableChannel</code>, the <code>AbstractMessageSplitter</code> produces a <code>Flux</code> result instead of an <code>Iterator</code>, and the output channel is subscribed to this <code>Flux</code> for back-pressure-based splitting on downstream flow demand.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-a-splitter-with-xml"><a class="anchor" href="#configuring-a-splitter-with-xml"></a>8.3.2. Configuring a Splitter with XML</h4>
<div class="paragraph">
<p>A splitter can be configured through XML as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="inputChannel"/&gt;

&lt;int:splitter id="splitter"         <i class="conum" data-value="1"></i><b>(1)</b>
  ref="splitterBean"                <i class="conum" data-value="2"></i><b>(2)</b>
  method="split"                    <i class="conum" data-value="3"></i><b>(3)</b>
  input-channel="inputChannel"      <i class="conum" data-value="4"></i><b>(4)</b>
  output-channel="outputChannel" /&gt; <i class="conum" data-value="5"></i><b>(5)</b>

&lt;int:channel id="outputChannel"/&gt;

&lt;beans:bean id="splitterBean" class="sample.PojoSplitter"/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The ID of the splitter is optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A reference to a bean defined in the application context.
The bean must implement the splitting logic, as described in the earlier section.
Optional.
If a reference to a bean is not provided, it is assumed that the payload of the message that arrived on the <code>input-channel</code> is an implementation of <code>java.util.Collection</code> and the default splitting logic is applied to the collection, incorporating each individual element into a message and sending it to the <code>output-channel</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method (defined on the bean) that implements the splitting logic.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The input channel of the splitter.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The channel to which the splitter sends the results of splitting the incoming message.
Optional (because incoming messages can specify a reply channel themselves).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We recommend using a <code>ref</code> attribute if the custom splitter implementation can be referenced in other <code>&lt;splitter&gt;</code> definitions.
However if the custom splitter handler implementation should be scoped to a single definition of the <code>&lt;splitter&gt;</code>, you can configure an inner bean definition, as the following example follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:splitter id="testSplitter" input-channel="inChannel" method="split"
                output-channel="outChannel"&gt;
  &lt;beans:bean class="org.foo.TestSplitter"/&gt;
&lt;/int:splitter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both a <code>ref</code> attribute and an inner handler definition in the same <code>&lt;int:splitter&gt;</code> configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the <code>ref</code> attribute references a bean that extends <code>AbstractMessageProducingHandler</code> (such as splitters provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.
In this case, each <code>ref</code> must be a separate bean instance (or a <code>prototype</code>-scoped bean) or use the inner <code>&lt;bean/&gt;</code> configuration type.
However, this optimization applies only if you do not provide any splitter-specific attributes in the splitter XML definition.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuring-a-splitter-with-annotations"><a class="anchor" href="#configuring-a-splitter-with-annotations"></a>8.3.3. Configuring a Splitter with Annotations</h4>
<div class="paragraph">
<p>The <code>@Splitter</code> annotation is applicable to methods that expect either the <code>Message</code> type or the message payload type, and the return values of the method should be a <code>Collection</code> of any type.
If the returned values are not actual <code>Message</code> objects, each item is wrapped in a <code>Message</code> as the payload of the <code>Message</code>.
Each resulting <code>Message</code> is sent to the designated output channel for the endpoint on which the <code>@Splitter</code> is defined.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a splitter by using the <code>@Splitter</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Splitter
List&lt;LineItem&gt; extractItems(Order order) {
    return order.getItems()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#advising-with-annotations">Advising Endpoints Using Annotations</a>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#java-dsl-splitters">Splitters</a> in the Java DSL chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aggregator"><a class="anchor" href="#aggregator"></a>8.4. Aggregator</h3>
<div class="paragraph">
<p>Basically a mirror-image of the splitter, the aggregator is a type of message handler that receives multiple messages and combines them into a single message.
In fact, an aggregator is often a downstream consumer in a pipeline that includes a splitter.</p>
</div>
<div class="paragraph">
<p>Technically, the aggregator is more complex than a splitter, because it is stateful.
It must hold the messages to be aggregated and determine when the complete group of messages is ready to be aggregated.
In order to do so, it requires a <code>MessageStore</code>.</p>
</div>
<div class="sect3">
<h4 id="aggregator-functionality"><a class="anchor" href="#aggregator-functionality"></a>8.4.1. Functionality</h4>
<div class="paragraph">
<p>The Aggregator combines a group of related messages, by correlating and storing them, until the group is deemed to be complete.
At that point, the aggregator creates a single message by processing the whole group and sends the aggregated message as output.</p>
</div>
<div class="paragraph">
<p>Implementing an aggregator requires providing the logic to perform the aggregation (that is, the creation of a single message from many).
Two related concepts are correlation and release.</p>
</div>
<div class="paragraph">
<p>Correlation determines how messages are grouped for aggregation.
In Spring Integration, correlation is done by default, based on the <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> message header.
Messages with the same <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> are grouped together.
However, you can customize the correlation strategy to allow other ways of specifying how the messages should be grouped together.
To do so, you can implement a <code>CorrelationStrategy</code> (covered later in this chapter).</p>
</div>
<div class="paragraph">
<p>To determine the point at which a group of messages is ready to be processed, a <code>ReleaseStrategy</code> is consulted.
The default release strategy for the aggregator releases a group when all messages included in a sequence are present, based on the <code>IntegrationMessageHeaderAccessor.SEQUENCE_SIZE</code> header.
You can override this default strategy by providing a reference to a custom <code>ReleaseStrategy</code> implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="aggregator-api"><a class="anchor" href="#aggregator-api"></a>8.4.2. Programming Model</h4>
<div class="paragraph">
<p>The Aggregation API consists of a number of classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The interface <code>MessageGroupProcessor</code>, and its subclasses: <code>MethodInvokingAggregatingMessageGroupProcessor</code> and <code>ExpressionEvaluatingMessageGroupProcessor</code></p>
</li>
<li>
<p>The <code>ReleaseStrategy</code> interface and its default implementation: <code>SimpleSequenceSizeReleaseStrategy</code></p>
</li>
<li>
<p>The <code>CorrelationStrategy</code> interface and its default implementation: <code>HeaderAttributeCorrelationStrategy</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="aggregatingmessagehandler"><a class="anchor" href="#aggregatingmessagehandler"></a><code>AggregatingMessageHandler</code></h5>
<div class="paragraph">
<p>The <code>AggregatingMessageHandler</code> (a subclass of <code>AbstractCorrelatingMessageHandler</code>) is a <code>MessageHandler</code> implementation, encapsulating the common functionality of an aggregator (and other correlating use cases), which are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Correlating messages into a group to be aggregated</p>
</li>
<li>
<p>Maintaining those messages in a <code>MessageStore</code> until the group can be released</p>
</li>
<li>
<p>Deciding when the group can be released</p>
</li>
<li>
<p>Aggregating the released group into a single message</p>
</li>
<li>
<p>Recognizing and responding to an expired group</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The responsibility for deciding how the messages should be grouped together is delegated to a <code>CorrelationStrategy</code> instance.
The responsibility for deciding whether the message group can be released is delegated to a <code>ReleaseStrategy</code> instance.</p>
</div>
<div class="paragraph">
<p>The following listing shows a brief highlight of the base <code>AbstractAggregatingMessageGroupProcessor</code> (the responsibility for implementing the <code>aggregatePayloads</code> method is left to the developer):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public abstract class AbstractAggregatingMessageGroupProcessor
              implements MessageGroupProcessor {

    protected Map&lt;String, Object&gt; aggregateHeaders(MessageGroup group) {
        // default implementation exists
    }

    protected abstract Object aggregatePayloads(MessageGroup group, Map&lt;String, Object&gt; defaultHeaders);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CorrelationStrategy</code> is owned by the <code>AbstractCorrelatingMessageHandler</code> and  has a default value based on the <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> message header, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store,
        CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) {
    ...
    this.correlationStrategy = correlationStrategy == null ?
        new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy;
    this.releaseStrategy = releaseStrategy == null ? new SimpleSequenceSizeReleaseStrategy() : releaseStrategy;
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As for the actual processing of the message group, the default implementation is the <code>DefaultAggregatingMessageGroupProcessor</code>.
It creates a single <code>Message</code> whose payload is a <code>List</code> of the payloads received for a given group.
This works well for simple scatter-gather implementations with a splitter, a publish-subscribe channel, or a recipient list router upstream.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using a publish-subscribe channel or a recipient list router in this type of scenario, be sure to enable the <code>apply-sequence</code> flag.
Doing so adds the necessary headers: <code>CORRELATION_ID</code>, <code>SEQUENCE_NUMBER</code>, and <code>SEQUENCE_SIZE</code>.
That behavior is enabled by default for splitters in Spring Integration, but it is not enabled for publish-subscribe channels or for recipient list routers because those components may be used in a variety of contexts in which these headers are not necessary.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When implementing a specific aggregator strategy for an application, you can extend <code>AbstractAggregatingMessageGroupProcessor</code> and implement the <code>aggregatePayloads</code> method.
However, there are better solutions, less coupled to the API, for implementing the aggregation logic, which can be configured either through XML or through annotations.</p>
</div>
<div class="paragraph">
<p>In general, any POJO can implement the aggregation algorithm if it provides a method that accepts a single <code>java.util.List</code> as an argument (parameterized lists are supported as well).
This method is invoked for aggregating messages as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the argument is a <code>java.util.Collection&lt;T&gt;</code> and the parameter type T is assignable to <code>Message</code>, the whole list of messages accumulated for aggregation is sent to the aggregator.</p>
</li>
<li>
<p>If the argument is a non-parameterized <code>java.util.Collection</code> or the parameter type is not assignable to <code>Message</code>, the method receives the payloads of the accumulated messages.</p>
</li>
<li>
<p>If the return type is not assignable to <code>Message</code>, it is treated as the payload for a <code>Message</code> that is automatically created by the framework.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the interest of code simplicity and promoting best practices such as low coupling, testability, and others, the preferred way of implementing the aggregation logic is through a POJO and using the XML or annotation support for configuring it in the application.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1, after processing message group, an <code>AbstractCorrelatingMessageHandler</code> performs a <code>MessageBuilder.popSequenceDetails()</code> message headers modification for the proper splitter-aggregator scenario with several nested levels.
It is done only if the message group release result is not a message or collection of messages.
In that case a target <code>MessageGroupProcessor</code> is responsible for the <code>MessageBuilder.popSequenceDetails()</code> call while building those messages.
This functionality can be controlled by a new <code>popSequence</code> <code>boolean</code> property, so the <code>MessageBuilder.popSequenceDetails()</code> can be disabled in some scenarios when correlation details have not been populated by the standard splitter.
This property, essentially, undoes what has been done by the nearest upstream <code>applySequence = true</code> in the <code>AbstractMessageSplitter</code>.
See <a href="#splitter">Splitter</a> for more information.</p>
</div>
<div id="agg-message-collection" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>SimpleMessageGroup.getMessages()</code> method returns an <code>unmodifiableCollection</code>.
Therefore, if your aggregating POJO method has a <code>Collection&lt;Message&gt;</code> parameter, the argument passed in is exactly that <code>Collection</code> instance and, when you use a <code>SimpleMessageStore</code> for the aggregator, that original <code>Collection&lt;Message&gt;</code> is cleared after releasing the group.
Consequently, the <code>Collection&lt;Message&gt;</code> variable in the POJO is cleared too, if it is passed out of the aggregator.
If you wish to simply release that collection as-is for further processing, you must build a new <code>Collection</code> (for example, <code>new ArrayList&lt;Message&gt;(messages)</code>).
Starting with version 4.3, the framework no longer copies the messages to a new collection, to avoid undesired extra object creation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the <code>processMessageGroup</code> method of the <code>MessageGroupProcessor</code> returns a collection, it must be a collection of <code>Message&lt;?&gt;</code> objects.
In this case, the messages are individually released.
Prior to version 4.2, it was not possible to provide a <code>MessageGroupProcessor</code> by using XML configuration.
Only POJO methods could be used for aggregation.
Now, if the framework detects that the referenced (or inner) bean implements <code>MessageProcessor</code>, it is used as the aggregator&#8217;s output processor.</p>
</div>
<div class="paragraph">
<p>If you wish to release a collection of objects from a custom <code>MessageGroupProcessor</code> as the payload of a message, your class should extend <code>AbstractAggregatingMessageGroupProcessor</code> and implement <code>aggregatePayloads()</code>.</p>
</div>
<div class="paragraph">
<p>Also, since version 4.2, a <code>SimpleMessageGroupProcessor</code> is provided.
It returns the collection of messages from the group, which, as indicated earlier, causes the released messages to be sent individually.</p>
</div>
<div class="paragraph">
<p>This lets the aggregator work as a message barrier, where arriving messages are held until the release strategy fires and the group is released as a sequence of individual messages.</p>
</div>
</div>
<div class="sect4">
<h5 id="releasestrategy"><a class="anchor" href="#releasestrategy"></a><code>ReleaseStrategy</code></h5>
<div class="paragraph">
<p>The <code>ReleaseStrategy</code> interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ReleaseStrategy {

  boolean canRelease(MessageGroup group);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In general, any POJO can implement the completion decision logic if it provides a method that accepts a single <code>java.util.List</code> as an argument (parameterized lists are supported as well) and returns a boolean value.
This method is invoked after the arrival of each new message, to decide whether the group is complete or not, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the argument is a <code>java.util.List&lt;T&gt;</code> and the parameter type <code>T</code> is assignable to <code>Message</code>, the whole list of messages accumulated in the group is sent to the method.</p>
</li>
<li>
<p>If the argument is a non-parametrized <code>java.util.List</code> or the parameter type is not assignable to <code>Message</code>, the method receives the payloads of the accumulated messages.</p>
</li>
<li>
<p>The method must return <code>true</code> if the message group is ready for aggregation or false otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@ReleaseStrategy</code> annotation for a <code>List</code> of type <code>Message</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyReleaseStrategy {

    @ReleaseStrategy
    public boolean canMessagesBeReleased(List&lt;Message&lt;?&gt;&gt;) {...}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@ReleaseStrategy</code> annotation for a <code>List</code> of type <code>String</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyReleaseStrategy {

    @ReleaseStrategy
    public boolean canMessagesBeReleased(List&lt;String&gt;) {...}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Based on the signatures in the preceding two examples, the POJO-based release strategy is passed a <code>Collection</code> of not-yet-released messages (if you need access to the whole <code>Message</code>) or a <code>Collection</code> of payload objects (if the type parameter is anything other than <code>Message</code>).
This satisfies the majority of use cases.
However if, for some reason, you need to access the full <code>MessageGroup</code>, you should provide an implementation of the <code>ReleaseStrategy</code> interface.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When handling potentially large groups, you should understand how these methods are invoked, because the release strategy may be invoked multiple times before the group is released.
The most efficient is an implementation of <code>ReleaseStrategy</code>, because the aggregator can invoke it directly.
The second most efficient is a POJO method with a <code>Collection&lt;Message&lt;?&gt;&gt;</code> parameter type.
The least efficient is a POJO method with a <code>Collection&lt;Something&gt;</code> type.
The framework has to copy the payloads from the messages in the group into a new collection (and possibly attempt conversion on the payloads to <code>Something</code>) every time the release strategy is called.
Using <code>Collection&lt;?&gt;</code> avoids the conversion but still requires creating the new <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p>For these reasons, for large groups, we recommended that you implement <code>ReleaseStrategy</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the group is released for aggregation, all its not-yet-released messages are processed and removed from the group.
If the group is also complete (that is, if all messages from a sequence have arrived or if there is no sequence defined), then the group is marked as complete.
Any new messages for this group are sent to the discard channel (if defined).
Setting <code>expire-groups-upon-completion</code> to <code>true</code> (the default is <code>false</code>) removes the entire group, and any new messages (with the same correlation ID as the removed group) form a new group.
You can release partial sequences by using a <code>MessageGroupStoreReaper</code> together with <code>send-partial-result-on-expiry</code> being set to <code>true</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To facilitate discarding of late-arriving messages, the aggregator must maintain state about the group after it has been released.
This can eventually cause out-of-memory conditions.
To avoid such situations, you should consider configuring a <code>MessageGroupStoreReaper</code> to remove the group metadata.
The expiry parameters should be set to expire groups once a point has been reach after after which late messages are not expected to arrive.
For information about configuring a reaper, see <a href="#reaper">Managing State in an Aggregator: <code>MessageGroupStore</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Integration provides an implementation for <code>ReleaseStrategy</code>: <code>SimpleSequenceSizeReleaseStrategy</code>.
This implementation consults the <code>SEQUENCE_NUMBER</code> and <code>SEQUENCE_SIZE</code> headers of each arriving message to decide when a message group is complete and ready to be aggregated.
As shown earlier, it is also the default strategy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before version 5.0, the default release strategy was <code>SequenceSizeReleaseStrategy</code>, which does not perform well with large groups.
With that strategy, duplicate sequence numbers are detected and rejected.
This operation can be expensive.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are aggregating large groups, you don&#8217;t need to release partial groups, and you don&#8217;t need to detect/reject duplicate sequences, consider using the <code>SimpleSequenceSizeReleaseStrategy</code> instead - it is much more efficient for these use cases, and is the default since <em>version 5.0</em> when partial group release is not specified.</p>
</div>
</div>
<div class="sect4">
<h5 id="aggregating-large-groups"><a class="anchor" href="#aggregating-large-groups"></a>Aggregating Large Groups</h5>
<div class="paragraph">
<p>The 4.3 release changed the default <code>Collection</code> for messages in a <code>SimpleMessageGroup</code> to <code>HashSet</code> (it was previously a <code>BlockingQueue</code>).
This was expensive when removing individual messages from large groups (an O(n) linear scan was required).
Although the hash set is generally much faster to remove, it can be expensive for large messages, because the hash has to be calculated on both inserts and removes.
If you have messages that are expensive to hash, consider using some other collection type.
As discussed in <a href="#message-group-factory">Using <code>MessageGroupFactory</code></a>, a <code>SimpleMessageGroupFactory</code> is provided so that you can select the <code>Collection</code> that best suits your needs.
You can also provide your own factory implementation to create some other <code>Collection&lt;Message&lt;?&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure an aggregator with the previous implementation and a <code>SimpleSequenceSizeReleaseStrategy</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:aggregator input-channel="aggregate"
    output-channel="out" message-store="store" release-strategy="releaser" /&gt;

&lt;bean id="store" class="org.springframework.integration.store.SimpleMessageStore"&gt;
    &lt;property name="messageGroupFactory"&gt;
        &lt;bean class="org.springframework.integration.store.SimpleMessageGroupFactory"&gt;
            &lt;constructor-arg value="BLOCKING_QUEUE"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="releaser" class="SimpleSequenceSizeReleaseStrategy" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="correlation-strategy"><a class="anchor" href="#correlation-strategy"></a>Correlation Strategy</h5>
<div class="paragraph">
<p>The <code>CorrelationStrategy</code> interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CorrelationStrategy {

  Object getCorrelationKey(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The method returns an <code>Object</code> that represents the correlation key used for associating the message with a message group.
The key must satisfy the criteria used for a key in a <code>Map</code> with respect to the implementation of <code>equals()</code> and <code>hashCode()</code>.</p>
</div>
<div class="paragraph">
<p>In general, any POJO can implement the correlation logic, and the rules for mapping a message to a method&#8217;s argument (or arguments) are the same as for a <code>ServiceActivator</code> (including support for <code>@Header</code> annotations).
The method must return a value, and the value must not be <code>null</code>.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides an implementation for <code>CorrelationStrategy</code>: <code>HeaderAttributeCorrelationStrategy</code>.
This implementation returns the value of one of the message headers (whose name is specified by a constructor argument) as the correlation key.
By default, the correlation strategy is a <code>HeaderAttributeCorrelationStrategy</code> that returns the value of the <code>CORRELATION_ID</code> header attribute.
If you have a custom header name you would like to use for correlation, you can configure it on an instance of <code>HeaderAttributeCorrelationStrategy</code> and provide that as a reference for the aggregator&#8217;s correlation strategy.</p>
</div>
</div>
<div class="sect4">
<h5 id="lock-registry"><a class="anchor" href="#lock-registry"></a>Lock Registry</h5>
<div class="paragraph">
<p>Changes to groups are thread safe.
So, when you send messages for the same correlation ID concurrently, only one of them will be processed in the aggregator, making it effectively as a <strong>single-threaded per message group</strong>.
A <code>LockRegistry</code> is used to obtain a lock for the resolved correlation ID.
A <code>DefaultLockRegistry</code> is used by default (in-memory).
For synchronizing updates across servers where a shared <code>MessageGroupStore</code> is being used, you must configure a shared lock registry.</p>
</div>
</div>
<div class="sect4">
<h5 id="aggregator-deadlocks"><a class="anchor" href="#aggregator-deadlocks"></a>Avoiding Deadlocks</h5>
<div class="paragraph">
<p>As discussed above, when message groups are mutated (messages added or released) a lock is held.</p>
</div>
<div class="paragraph">
<p>Consider the following flow:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>...-&gt;aggregator1-&gt; ... -&gt;aggregator2-&gt; ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If there are multiple threads, <strong>and the aggregators share a common lock registry</strong>, it is possible to get a deadlock.
This will cause hung threads and <code>jstack &lt;pid&gt;</code> might present a result such as:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Found one Java-level deadlock:
=============================
"t2":
  waiting for ownable synchronizer 0x000000076c1cbfa0, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),
  which is held by "t1"
"t1":
  waiting for ownable synchronizer 0x000000076c1ccc00, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),
  which is held by "t2"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are several ways to avoid this problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ensure each aggregator has its own lock registry (this can be a shared registry across application instances but two or more aggregators in the flow must each have a distinct registry)</p>
</li>
<li>
<p>use an <code>ExecutorChannel</code> or <code>QueueChannel</code> as the output channel of the aggregator so that the downstream flow runs on a new thread</p>
</li>
<li>
<p>starting with version 5.1.1, set the <code>releaseLockBeforeSend</code> aggregator property to <code>true</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This problem can also be caused if, for some reason, the output of a single aggregator is eventually routed back to the same aggregator.
Of course, the first solution above does not apply in this case.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aggregator-java-dsl"><a class="anchor" href="#aggregator-java-dsl"></a>8.4.3. Configuring an Aggregator in Java DSL</h4>
<div class="paragraph">
<p>See <a href="#java-dsl-aggregators">Aggregators and Resequencers</a> for how to configure an aggregator in Java DSL.</p>
</div>
<div class="sect4">
<h5 id="aggregator-xml"><a class="anchor" href="#aggregator-xml"></a>Configuring an Aggregator with XML</h5>
<div class="paragraph">
<p>Spring Integration supports the configuration of an aggregator with XML through the <code>&lt;aggregator/&gt;</code> element.
The following example shows an example of an aggregator:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;channel id="inputChannel"/&gt;

&lt;int:aggregator id="myAggregator"                          <i class="conum" data-value="1"></i><b>(1)</b>
        auto-startup="true"                                <i class="conum" data-value="2"></i><b>(2)</b>
        input-channel="inputChannel"                       <i class="conum" data-value="3"></i><b>(3)</b>
        output-channel="outputChannel"                     <i class="conum" data-value="4"></i><b>(4)</b>
        discard-channel="throwAwayChannel"                 <i class="conum" data-value="5"></i><b>(5)</b>
        message-store="persistentMessageStore"             <i class="conum" data-value="6"></i><b>(6)</b>
        order="1"                                          <i class="conum" data-value="7"></i><b>(7)</b>
        send-partial-result-on-expiry="false"              <i class="conum" data-value="8"></i><b>(8)</b>
        send-timeout="1000"                                <i class="conum" data-value="9"></i><b>(9)</b>

        correlation-strategy="correlationStrategyBean"     <i class="conum" data-value="10"></i><b>(10)</b>
        correlation-strategy-method="correlate"            <i class="conum" data-value="11"></i><b>(11)</b>
        correlation-strategy-expression="headers['foo']"   <i class="conum" data-value="12"></i><b>(12)</b>

        ref="aggregatorBean"                               <i class="conum" data-value="13"></i><b>(13)</b>
        method="aggregate"                                 <i class="conum" data-value="14"></i><b>(14)</b>

        release-strategy="releaseStrategyBean"             <i class="conum" data-value="15"></i><b>(15)</b>
        release-strategy-method="release"                  <i class="conum" data-value="16"></i><b>(16)</b>
        release-strategy-expression="size() == 5"          <i class="conum" data-value="17"></i><b>(17)</b>

        expire-groups-upon-completion="false"              <i class="conum" data-value="18"></i><b>(18)</b>
        empty-group-min-timeout="60000"                    <i class="conum" data-value="19"></i><b>(19)</b>

        lock-registry="lockRegistry"                       <i class="conum" data-value="20"></i><b>(20)</b>

        group-timeout="60000"                              <i class="conum" data-value="21"></i><b>(21)</b>
        group-timeout-expression="size() ge 2 ? 100 : -1"  <i class="conum" data-value="22"></i><b>(22)</b>
        expire-groups-upon-timeout="true"                  <i class="conum" data-value="23"></i><b>(23)</b>

        scheduler="taskScheduler" &gt;                        <i class="conum" data-value="24"></i><b>(24)</b>
            &lt;expire-transactional/&gt;                        <i class="conum" data-value="25"></i><b>(25)</b>
            &lt;expire-advice-chain/&gt;                         <i class="conum" data-value="26"></i><b>(26)</b>
&lt;/aggregator&gt;

&lt;int:channel id="outputChannel"/&gt;

&lt;int:channel id="throwAwayChannel"/&gt;

&lt;bean id="persistentMessageStore" class="org.springframework.integration.jdbc.store.JdbcMessageStore"&gt;
    &lt;constructor-arg ref="dataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="aggregatorBean" class="sample.PojoAggregator"/&gt;

&lt;bean id="releaseStrategyBean" class="sample.PojoReleaseStrategy"/&gt;

&lt;bean id="correlationStrategyBean" class="sample.PojoCorrelationStrategy"/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The id of the aggregator is optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lifecycle attribute signaling whether the aggregator should be started during application context startup.
Optional (the default is 'true').</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The channel from which where aggregator receives messages.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The channel to which the aggregator sends the aggregation results.
Optional (because incoming messages can themselves specify a reply channel in the 'replyChannel' message header).</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The channel to which the aggregator sends the messages that timed out (if <code>send-partial-result-on-expiry</code> is <code>false</code>).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A reference to a <code>MessageGroupStore</code> used to store groups of messages under their correlation key until they are complete.
Optional.
By default, it is a volatile in-memory store.
See <a href="#message-store">Message Store</a> for more information.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The order of this aggregator when more than one handle is subscribed to the same <code>DirectChannel</code> (use for load-balancing purposes).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Indicates that expired messages should be aggregated and sent to the 'output-channel' or 'replyChannel' once their containing <code>MessageGroup</code> is expired (see <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageGroupStore.html#expireMessageGroups-long"><code>MessageGroupStore.expireMessageGroups(long)</code></a>).
One way of expiring a <code>MessageGroup</code> is by configuring a <code>MessageGroupStoreReaper</code>.
However you can alternatively expire <code>MessageGroup</code> by calling <code>MessageGroupStore.expireMessageGroups(timeout)</code>.
You can accomplish that through a Control Bus operation or, if you have a reference to the <code>MessageGroupStore</code> instance, by invoking <code>expireMessageGroups(timeout)</code>.
Otherwise, by itself, this attribute does nothing.
It serves only as an indicator of whether to discard or send to the output or reply channel any messages that are still in the <code>MessageGroup</code> that is about to be expired.
Optional (the default is <code>false</code>).
NOTE: This attribute might more properly be called <code>send-partial-result-on-timeout</code>, because the group may not actually expire if <code>expire-groups-upon-timeout</code> is set to <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The timeout interval to wait when sending a reply <code>Message</code> to the <code>output-channel</code> or <code>discard-channel</code>.
Defaults to <code>-1</code>, which results in blocking indefinitely.
It is applied only if the output channel has some 'sending' limitations, such as a <code>QueueChannel</code> with a fixed 'capacity'.
In this case, a <code>MessageDeliveryException</code> is thrown.
For <code>AbstractSubscribableChannel</code> implementations, the <code>send-timeout</code> is ignored .
For <code>group-timeout(-expression)</code>, the <code>MessageDeliveryException</code> from the scheduled expire task leads this task to be rescheduled.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A reference to a bean that implements the message correlation (grouping) algorithm.
The bean can be an implementation of the <code>CorrelationStrategy</code> interface or a POJO.
In the latter case, the <code>correlation-strategy-method</code> attribute must be defined as well.
Optional (by default, the aggregator uses the <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> header).</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>A method defined on the bean referenced by <code>correlation-strategy</code>.
It implements the correlation decision algorithm.
Optional, with restrictions (<code>correlation-strategy</code> must be present).</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>A SpEL expression representing the correlation strategy.
Example: <code>"headers['something']"</code>.
Only one of <code>correlation-strategy</code> or <code>correlation-strategy-expression</code> is allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>A reference to a bean defined in the application context.
The bean must implement the aggregation logic, as described earlier.
Optional (by default, the list of aggregated messages becomes a payload of the output message).</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>A method defined on the bean referenced by the <code>ref</code> attribute.
It implements the message aggregation algorithm.
Optional (it depends on <code>ref</code> attribute being defined).</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>A reference to a bean that implements the release strategy.
The bean can be an implementation of the <code>ReleaseStrategy</code> interface or a POJO.
In the latter case, the <code>release-strategy-method</code> attribute must be defined as well.
Optional (by default, the aggregator uses the <code>IntegrationMessageHeaderAccessor.SEQUENCE_SIZE</code> header attribute).</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>A method defined on the bean referenced by the <code>release-strategy</code> attribute.
It implements the completion decision algorithm.
Optional, with restrictions (<code>release-strategy</code> must be present).</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>A SpEL expression representing the release strategy.
The root object for the expression is a <code>MessageGroup</code>.
Example: <code>"size() == 5"</code>.
Only one of <code>release-strategy</code> or <code>release-strategy-expression</code> is allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>When set to <code>true</code> (the default is <code>false</code>), completed groups are removed from the message store, letting subsequent messages with the same correlation form a new group.
The default behavior is to send messages with the same correlation as a completed group to the <code>discard-channel</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="19"></i><b>19</b></td>
<td>Applies only if a <code>MessageGroupStoreReaper</code> is configured for the <code>MessageStore</code> of the <code>&lt;aggregator&gt;</code>.
By default, when a <code>MessageGroupStoreReaper</code> is configured to expire partial groups, empty groups are also removed.
Empty groups exist after a group is normally released.
The empty groups enable the detection and discarding of late-arriving messages.
If you wish to expire empty groups on a longer schedule than expiring partial groups, set this property.
Empty groups are then not removed from the <code>MessageStore</code> until they have not been modified for at least this number of milliseconds.
Note that the actual time to expire an empty group is also affected by the reaper&#8217;s <code>timeout</code> property, and it could be as much as this value plus the timeout.</td>
</tr>
<tr>
<td><i class="conum" data-value="20"></i><b>20</b></td>
<td>A reference to a <code>org.springframework.integration.util.LockRegistry</code> bean.
It used to obtain a <code>Lock</code> based on the <code>groupId</code> for concurrent operations on the <code>MessageGroup</code>.
By default, an internal <code>DefaultLockRegistry</code> is used.
Use of a distributed <code>LockRegistry</code>, such as the <code>ZookeeperLockRegistry</code>, ensures only one instance of the aggregator can operate on a group concurrently.
See <a href="#redis-lock-registry">Redis Lock Registry</a>, <a href="#gemfire-lock-registry">Gemfire Lock Registry</a>, and <a href="#zk-lock-registry">Zookeeper Lock Registry</a> for more information.</td>
</tr>
<tr>
<td><i class="conum" data-value="21"></i><b>21</b></td>
<td>A timeout (in milliseconds) to force the <code>MessageGroup</code> complete when the <code>ReleaseStrategy</code> does not release the group when the current message arrives.
This attribute provides a built-in time-based release strategy for the aggregator when there is a need to emit a partial result (or discard the group) if a new message does not arrive for the <code>MessageGroup</code> within the timeout.
When a new message arrives at the aggregator, any existing <code>ScheduledFuture&lt;?&gt;</code> for its <code>MessageGroup</code> is canceled.
If the <code>ReleaseStrategy</code> returns <code>false</code> (meaning do not release) and <code>groupTimeout &gt; 0</code>, a new task is scheduled to expire the group.
We do not advise setting this attribute to zero (or a negative value).
Doing so effectively disables the aggregator, because every message group is immediately completed.
You can, however, conditionally set it to zero (or a negative value) by using an expression.
See <code>group-timeout-expression</code> for information.
The action taken during the completion depends on the <code>ReleaseStrategy</code> and the <code>send-partial-group-on-expiry</code> attribute.
See <a href="#agg-and-group-to">Aggregator and Group Timeout</a> for more information.
It is mutually exclusive with 'group-timeout-expression' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="22"></i><b>22</b></td>
<td>The SpEL expression that evaluates to a <code>groupTimeout</code> with the <code>MessageGroup</code> as the <code>#root</code> evaluation context object.
Used for scheduling the <code>MessageGroup</code> to be forced complete.
If the expression evaluates to <code>null</code>, the completion is not scheduled.
If it evaluates to zero, the group is completed immediately on the current thread.
In effect, this provides a dynamic <code>group-timeout</code> property.
See <code>group-timeout</code> for more information.
Mutually exclusive with 'group-timeout' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="23"></i><b>23</b></td>
<td>When a group is completed due to a timeout (or by a <code>MessageGroupStoreReaper</code>), the group is expired (completely removed) by default.
Late arriving messages start a new group.
You can set this to <code>false</code> to complete the group but have its metadata remain so that late arriving messages are discarded.
Empty groups can be expired later using a <code>MessageGroupStoreReaper</code> together with the <code>empty-group-min-timeout</code> attribute.
It defaults to 'true'.</td>
</tr>
<tr>
<td><i class="conum" data-value="24"></i><b>24</b></td>
<td>A <code>TaskScheduler</code> bean reference to schedule the <code>MessageGroup</code> to be forced complete if no new message arrives for the <code>MessageGroup</code> within the <code>groupTimeout</code>.
If not provided, the default scheduler (<code>taskScheduler</code>) registered in the <code>ApplicationContext</code> (<code>ThreadPoolTaskScheduler</code>) is used.
This attribute does not apply if <code>group-timeout</code> or <code>group-timeout-expression</code> is not specified.</td>
</tr>
<tr>
<td><i class="conum" data-value="25"></i><b>25</b></td>
<td>Since version 4.1.
It lets a transaction be started for the <code>forceComplete</code> operation.
It is initiated from a <code>group-timeout(-expression)</code> or by a <code>MessageGroupStoreReaper</code> and is not applied to the normal <code>add</code>, <code>release</code>, and <code>discard</code> operations.
Only this sub-element or <code>&lt;expire-advice-chain/&gt;</code> is allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="26"></i><b>26</b></td>
<td>Since <em>version 4.1</em>.
It allows the configuration of any <code>Advice</code> for the <code>forceComplete</code> operation.
It is initiated from a <code>group-timeout(-expression)</code> or by a <code>MessageGroupStoreReaper</code> and is not applied to the normal <code>add</code>, <code>release</code>, and <code>discard</code> operations.
Only this sub-element or <code>&lt;expire-transactional/&gt;</code> is allowed.
A transaction <code>Advice</code> can also be configured here by using the Spring <code>tx</code> namespace.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Expiring Groups</div>
<div class="paragraph">
<p>There are two attributes related to expiring (completely removing) groups.
When a group is expired, there is no record of it, and, if a new message arrives with the same correlation, a new group is started.
When a group is completed (without expiry), the empty group remains and late-arriving messages are discarded.
Empty groups can be removed later by using a <code>MessageGroupStoreReaper</code> in combination with the <code>empty-group-min-timeout</code> attribute.</p>
</div>
<div class="paragraph">
<p><code>expire-groups-upon-completion</code> relates to &#8220;normal&#8221; completion when the <code>ReleaseStrategy</code> releases the group.
This defaults to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>If a group is not completed normally but is released or discarded because of a timeout, the group is normally expired.
Since version 4.1, you can control this behavior by using <code>expire-groups-upon-timeout</code>.
It defaults to <code>true</code> for backwards compatibility.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a group is timed out, the <code>ReleaseStrategy</code> is given one more opportunity to release the group.
If it does so and <code>expire-groups-upon-timeout</code> is false, expiration is controlled by <code>expire-groups-upon-completion</code>.
If the group is not released by the release strategy during timeout, then the expiration is controlled by the <code>expire-groups-upon-timeout</code>.
Timed-out groups are either discarded or a partial release occurs (based on <code>send-partial-result-on-expiry</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since version 5.0, empty groups are also scheduled for removal after <code>empty-group-min-timeout</code>.
If <code>expireGroupsUponCompletion == false</code> and <code>minimumTimeoutForEmptyGroups &gt; 0</code>, the task to remove the group is scheduled when normal or partial sequences release happens.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We generally recommend using a <code>ref</code> attribute if a custom aggregator handler implementation may be referenced in other <code>&lt;aggregator&gt;</code> definitions.
However, if a custom aggregator implementation is only being used by a single definition of the <code>&lt;aggregator&gt;</code>, you can use an inner bean definition (starting with version 1.0.3) to configure the aggregation POJO within the <code>&lt;aggregator&gt;</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aggregator input-channel="input" method="sum" output-channel="output"&gt;
    &lt;beans:bean class="org.foo.PojoAggregator"/&gt;
&lt;/aggregator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both a <code>ref</code> attribute and an inner bean definition in the same <code>&lt;aggregator&gt;</code> configuration is not allowed, as it creates an ambiguous condition.
In such cases, an Exception is thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows an implementation of the aggregator bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PojoAggregator {

  public Long add(List&lt;Long&gt; results) {
    long total = 0l;
    for (long partialResult: results) {
      total += partialResult;
    }
    return total;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>An implementation of the completion strategy bean for the preceding example might be as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PojoReleaseStrategy {
...
  public boolean canRelease(List&lt;Long&gt; numbers) {
    int sum = 0;
    for (long number: numbers) {
      sum += number;
    }
    return sum &gt;= maxValue;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Wherever it makes sense to do so, the release strategy method and the aggregator method can be combined into a single bean.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An implementation of the correlation strategy bean for the example above might be as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PojoCorrelationStrategy {
...
  public Long groupNumbersByLastDigit(Long number) {
    return number % 10;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The aggregator in the preceding example would group numbers by some criterion (in this case, the remainder after dividing by ten) and hold the group until the sum of the numbers provided by the payloads exceeds a certain value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Wherever it makes sense to do so, the release strategy method, the correlation strategy method, and the aggregator method can be combined in a single bean.
(Actually, all of them or any two of them can be combined.)
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="aggregator-spel"><a class="anchor" href="#aggregator-spel"></a>Aggregators and Spring Expression Language (SpEL)</h6>
<div class="paragraph">
<p>Since Spring Integration 2.0, you can handle the various strategies (correlation, release, and aggregation) with <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">SpEL</a>, which we recommend if the logic behind such a release strategy is relatively simple.
Suppose you have a legacy component that was designed to receive an array of objects.
We know that the default release strategy assembles all aggregated messages in the <code>List</code>.
Now we have two problems.
First, we need to extract individual messages from the list.
Second, we need to extract the payload of each message and assemble the array of objects.
The following example solves both problems:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String[] processRelease(List&lt;Message&lt;String&gt;&gt; messages){
    List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
    for (Message&lt;String&gt; message : messages) {
        stringList.add(message.getPayload());
    }
    return stringList.toArray(new String[]{});
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, with SpEL, such a requirement could actually be handled relatively easily with a one-line expression, thus sparing you from writing a custom class and configuring it as a bean.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:aggregator input-channel="aggChannel"
    output-channel="replyChannel"
    expression="#this.![payload].toArray()"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, we use a <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-collection-projection">collection projection</a> expression to assemble a new collection from the payloads of all the messages in the list and then transform it to an array, thus achieving the same result as the earlier Java code.</p>
</div>
<div class="paragraph">
<p>You can apply the same expression-based approach when dealing with custom release and correlation strategies.</p>
</div>
<div class="paragraph">
<p>Instead of defining a bean for a custom <code>CorrelationStrategy</code> in the <code>correlation-strategy</code> attribute, you can implement your simple correlation logic as a SpEL expression and configure it in the <code>correlation-strategy-expression</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">correlation-strategy-expression="payload.person.id"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we assume that the payload has a <code>person</code> attribute with an <code>id</code>, which is going to be used to correlate messages.</p>
</div>
<div class="paragraph">
<p>Likewise, for the <code>ReleaseStrategy</code>, you can implement your release logic as a SpEL expression and configure it in the <code>release-strategy-expression</code> attribute.
The root object for evaluation context is the <code>MessageGroup</code> itself.
The <code>List</code> of messages can be referenced by using the <code>message</code> property of the group within the expression.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In releases prior to version 5.0, the root object was the collection of <code>Message&lt;?&gt;</code>, as the previous example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">release-strategy-expression="!messages.?[payload==5].empty"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the root object of the SpEL evaluation context is the <code>MessageGroup</code> itself, and you are stating that, as soon as there is a message with payload of <code>5</code> in this group, the group should be released.</p>
</div>
</div>
<div class="sect5">
<h6 id="agg-and-group-to"><a class="anchor" href="#agg-and-group-to"></a>Aggregator and Group Timeout</h6>
<div class="paragraph">
<p>Starting with version 4.0, two new mutually exclusive attributes have been introduced: <code>group-timeout</code> and <code>group-timeout-expression</code> (see the earlier description).
See <a href="#aggregator-xml">Configuring an Aggregator with XML</a>.
In some cases, you may need to emit the aggregator result (or discard the group) after a timeout if the <code>ReleaseStrategy</code> does not release when the current message arrives.
For this purpose, the <code>groupTimeout</code> option lets scheduling the <code>MessageGroup</code> be forced to complete, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aggregator input-channel="input" output-channel="output"
        send-partial-result-on-expiry="true"
        group-timeout-expression="size() ge 2 ? 10000 : -1"
        release-strategy-expression="messages[0].headers.sequenceNumber == messages[0].headers.sequenceSize"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With this example, the normal release is possible if the aggregator receives the last message in sequence as defined by the <code>release-strategy-expression</code>.
If that specific message does not arrive, the <code>groupTimeout</code> forces the group to complete after ten seconds, as long as the group contains at least two Messages.</p>
</div>
<div class="paragraph">
<p>The results of forcing the group to complete depends on the <code>ReleaseStrategy</code> and the <code>send-partial-result-on-expiry</code>.
First, the release strategy is again consulted to see if a normal release is to be made.
While the group has not changed, the <code>ReleaseStrategy</code> can decide to release the group at this time.
If the release strategy still does not release the group, it is expired.
If <code>send-partial-result-on-expiry</code> is <code>true</code>, existing messages in the (partial) <code>MessageGroup</code> are released as a normal aggregator reply message to the <code>output-channel</code>.
Otherwise, it is discarded.</p>
</div>
<div class="paragraph">
<p>There is a difference between <code>groupTimeout</code> behavior and <code>MessageGroupStoreReaper</code> (see <a href="#aggregator-xml">Configuring an Aggregator with XML</a>).
The reaper initiates forced completion for all <code>MessageGroup</code> s in the <code>MessageGroupStore</code> periodically.
The <code>groupTimeout</code> does it for each <code>MessageGroup</code> individually if a new message does not arrive during the <code>groupTimeout</code>.
Also, the reaper can be used to remove empty groups (empty groups are retained in order to discard late messages if <code>expire-groups-upon-completion</code> is false).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aggregator-annotations"><a class="anchor" href="#aggregator-annotations"></a>Configuring an Aggregator with Annotations</h5>
<div class="paragraph">
<p>The following example shows an aggregator configured with annotations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Waiter {
  ...

  @Aggregator  <i class="conum" data-value="1"></i><b>(1)</b>
  public Delivery aggregatingMethod(List&lt;OrderItem&gt; items) {
    ...
  }

  @ReleaseStrategy  <i class="conum" data-value="2"></i><b>(2)</b>
  public boolean releaseChecker(List&lt;Message&lt;?&gt;&gt; messages) {
    ...
  }

  @CorrelationStrategy  <i class="conum" data-value="3"></i><b>(3)</b>
  public String correlateBy(OrderItem item) {
    ...
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An annotation indicating that this method should be used as an aggregator.
It must be specified if this class is used as an aggregator.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>An annotation indicating that this method is used as the release strategy of an aggregator.
If not present on any method, the aggregator uses the <code>SimpleSequenceSizeReleaseStrategy</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An annotation indicating that this method should be used as the correlation strategy of an aggregator.
If no correlation strategy is indicated, the aggregator uses the <code>HeaderAttributeCorrelationStrategy</code> based on <code>CORRELATION_ID</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>All of the configuration options provided by the XML element are also available for the <code>@Aggregator</code> annotation.</p>
</div>
<div class="paragraph">
<p>The aggregator can be either referenced explicitly from XML or, if the <code>@MessageEndpoint</code> is defined on the class, detected automatically through classpath scanning.</p>
</div>
<div class="paragraph">
<p>Annotation configuration (<code>@Aggregator</code> and others) for the Aggregator component covers only simple use cases, where most default options are sufficient.
If you need more control over those options when using annotation configuration, consider using a <code>@Bean</code> definition for the <code>AggregatingMessageHandler</code> and mark its <code>@Bean</code> method with <code>@ServiceActivator</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "aggregatorChannel")
@Bean
public MessageHandler aggregator(MessageGroupStore jdbcMessageGroupStore) {
     AggregatingMessageHandler aggregator =
                       new AggregatingMessageHandler(new DefaultAggregatingMessageGroupProcessor(),
                                                 jdbcMessageGroupStore);
     aggregator.setOutputChannel(resultsChannel());
     aggregator.setGroupTimeoutExpression(new ValueExpression&lt;&gt;(500L));
     aggregator.setTaskScheduler(this.taskScheduler);
     return aggregator;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#aggregator-api">Programming Model</a> and <a href="#annotations_on_beans">Annotations on <code>@Bean</code> Methods</a> for more information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 4.2, the <code>AggregatorFactoryBean</code> is available to simplify Java configuration for the <code>AggregatingMessageHandler</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reaper"><a class="anchor" href="#reaper"></a>8.4.4. Managing State in an Aggregator: <code>MessageGroupStore</code></h4>
<div class="paragraph">
<p>Aggregator (and some other patterns in Spring Integration) is a stateful pattern that requires decisions to be made based on a group of messages that have arrived over a period of time, all with the same correlation key.
The design of the interfaces in the stateful patterns (such as <code>ReleaseStrategy</code>) is driven by the principle that the components (whether defined by the framework or by a user) should be able to remain stateless.
All state is carried by the <code>MessageGroup</code> and its management is delegated to the <code>MessageGroupStore</code>.
The <code>MessageGroupStore</code> interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageGroupStore {

    int getMessageCountForAllMessageGroups();

    int getMarkedMessageCountForAllMessageGroups();

    int getMessageGroupCount();

    MessageGroup getMessageGroup(Object groupId);

    MessageGroup addMessageToGroup(Object groupId, Message&lt;?&gt; message);

    MessageGroup markMessageGroup(MessageGroup group);

    MessageGroup removeMessageFromGroup(Object key, Message&lt;?&gt; messageToRemove);

    MessageGroup markMessageFromGroup(Object key, Message&lt;?&gt; messageToMark);

    void removeMessageGroup(Object groupId);

    void registerMessageGroupExpiryCallback(MessageGroupCallback callback);

    int expireMessageGroups(long timeout);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information, see the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageGroupStore.html">Javadoc</a>.</p>
</div>
<div class="paragraph">
<p>The <code>MessageGroupStore</code> accumulates state information in <code>MessageGroups</code> while waiting for a release strategy to be triggered, and that event might not ever happen.
So, to prevent stale messages from lingering, and for volatile stores to provide a hook for cleaning up when the application shuts down, the <code>MessageGroupStore</code> lets you register callbacks to apply to its <code>MessageGroups</code> when they expire.
The interface is very straightforward, as the following listing shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageGroupCallback {

    void execute(MessageGroupStore messageGroupStore, MessageGroup group);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The callback has direct access to the store and the message group so that it can manage the persistent state (for example, by entirely removing the group from the store).</p>
</div>
<div class="paragraph">
<p>The <code>MessageGroupStore</code> maintains a list of these callbacks, which it applies, on demand, to all messages whose timestamps are earlier than a time supplied as a parameter (see the <code>registerMessageGroupExpiryCallback(..)</code> and <code>expireMessageGroups(..)</code> methods, described earlier).
For more detail, see <a href="#reaper">Managing State in an Aggregator: <code>MessageGroupStore</code></a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It is important not to use the same <code>MessageGroupStore</code> instance in different aggregator components, when you intend to rely on the <code>expireMessageGroups</code> functionality.
Every <code>AbstractCorrelatingMessageHandler</code> registers its own <code>MessageGroupCallback</code> based on the <code>forceComplete()</code> callback.
This way each group for expiration may be completed or discarded by the wrong aggregator.
Starting with version 5.0.10, a <code>UniqueExpiryCallback</code> is used from the <code>AbstractCorrelatingMessageHandler</code> for the registration callback in the <code>MessageGroupStore</code>.
The <code>MessageGroupStore</code>, in turn, checks for presence an instance of this class and logs an error with an appropriate message if one is already present in the callbacks set.
This way the Framework disallows usage of the <code>MessageGroupStore</code> instance in different aggregators/resequencers to avoid the mentioned side effect of expiration the groups not created by the particular correlation handler.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can call the <code>expireMessageGroups</code> method with a timeout value.
Any message older than the current time minus this value is expired and has the callbacks applied.
Thus, it is the user of the store that defines what is meant by message group &#8220;expiry&#8221;.</p>
</div>
<div class="paragraph">
<p>As a convenience for users, Spring Integration provides a wrapper for the message expiry in the form of a <code>MessageGroupStoreReaper</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="reaper" class="org...MessageGroupStoreReaper"&gt;
    &lt;property name="messageGroupStore" ref="messageStore"/&gt;
    &lt;property name="timeout" value="30000"/&gt;
&lt;/bean&gt;

&lt;task:scheduled-tasks scheduler="scheduler"&gt;
    &lt;task:scheduled ref="reaper" method="run" fixed-rate="10000"/&gt;
&lt;/task:scheduled-tasks&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The reaper is a <code>Runnable</code>.
In the preceding example, the message group store&#8217;s expire method is called every ten seconds.
The timeout itself is 30 seconds.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that the 'timeout' property of <code>MessageGroupStoreReaper</code> is an approximate value and is impacted by the the rate of the task scheduler, since this property is only checked on the next scheduled execution of the <code>MessageGroupStoreReaper</code> task.
For example, if the timeout is set for ten minutes but the <code>MessageGroupStoreReaper</code> task is scheduled to run every hour and the last execution of the <code>MessageGroupStoreReaper</code> task happened one minute before the timeout, the <code>MessageGroup</code> does not expire for the next 59 minutes.
Consequently, we recommend setting the rate to be at least equal to the value of the timeout or shorter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the reaper, the expiry callbacks are invoked when the application shuts down through a lifecycle callback in the <code>AbstractCorrelatingMessageHandler</code>.</p>
</div>
<div class="paragraph">
<p>The <code>AbstractCorrelatingMessageHandler</code> registers its own expiry callback, and this is the link with the boolean flag <code>send-partial-result-on-expiry</code> in the XML configuration of the aggregator.
If the flag is set to <code>true</code>, then, when the expiry callback is invoked, any unmarked messages in groups that are not yet released can be sent on to the output channel.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When a shared <code>MessageStore</code> is used for different correlation endpoints, you must configure a proper <code>CorrelationStrategy</code> to ensure uniqueness for group IDs.
Otherwise, unexpected behavior may happen when one correlation endpoint releases or expire messages from others.
Messages with the same correlation key are stored in the same message group.</p>
</div>
<div class="paragraph">
<p>Some <code>MessageStore</code> implementations allow using the same physical resources, by partitioning the data.
For example, the <code>JdbcMessageStore</code> has a <code>region</code> property, and the <code>MongoDbMessageStore</code> has a <code>collectionName</code> property.</p>
</div>
<div class="paragraph">
<p>For more information about the <code>MessageStore</code> interface and its implementations, see <a href="#message-store">Message Store</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resequencer"><a class="anchor" href="#resequencer"></a>8.5. Resequencer</h3>
<div class="paragraph">
<p>The resequencer is related to the aggregator but serves a different purpose.
While the aggregator combines messages, the resequencer passes messages through without changing them.</p>
</div>
<div class="sect3">
<h4 id="resequencer-functionality"><a class="anchor" href="#resequencer-functionality"></a>8.5.1. Functionality</h4>
<div class="paragraph">
<p>The resequencer works in a similar way to the aggregator, in the sense that it uses the <code>CORRELATION_ID</code> to store messages in groups.
The difference is that the Resequencer does not process the messages in any way.
Instead, it releases them in the order of their <code>SEQUENCE_NUMBER</code> header values.</p>
</div>
<div class="paragraph">
<p>With respect to that, you can opt to release all messages at once (after the whole sequence, according to the <code>SEQUENCE_SIZE</code>, and other possibilities) or as soon as a valid sequence is available.
(We cover what we mean by "a valid sequence" later in this chapter.)</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The resequencer is intended to resequence relatively short sequences of messages with small gaps.
If you have a large number of disjoint sequences with many gaps, you may experience performance issues.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuring-a-resequencer"><a class="anchor" href="#configuring-a-resequencer"></a>8.5.2. Configuring a Resequencer</h4>
<div class="paragraph">
<p>See <a href="#java-dsl-aggregators">Aggregators and Resequencers</a> for configuring a resequencer in Java DSL.</p>
</div>
<div class="paragraph">
<p>Configuring a resequencer requires only including the appropriate element in XML.</p>
</div>
<div class="paragraph">
<p>The following example shows a resequencer configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="inputChannel"/&gt;

&lt;int:channel id="outputChannel"/&gt;

&lt;int:resequencer id="completelyDefinedResequencer"  <i class="conum" data-value="1"></i><b>(1)</b>
  input-channel="inputChannel"  <i class="conum" data-value="2"></i><b>(2)</b>
  output-channel="outputChannel"  <i class="conum" data-value="3"></i><b>(3)</b>
  discard-channel="discardChannel"  <i class="conum" data-value="4"></i><b>(4)</b>
  release-partial-sequences="true"  <i class="conum" data-value="5"></i><b>(5)</b>
  message-store="messageStore"  <i class="conum" data-value="6"></i><b>(6)</b>
  send-partial-result-on-expiry="true"  <i class="conum" data-value="7"></i><b>(7)</b>
  send-timeout="86420000"  <i class="conum" data-value="8"></i><b>(8)</b>
  correlation-strategy="correlationStrategyBean"  <i class="conum" data-value="9"></i><b>(9)</b>
  correlation-strategy-method="correlate"  <i class="conum" data-value="10"></i><b>(10)</b>
  correlation-strategy-expression="headers['something']"  <i class="conum" data-value="11"></i><b>(11)</b>
  release-strategy="releaseStrategyBean"  <i class="conum" data-value="12"></i><b>(12)</b>
  release-strategy-method="release"  <i class="conum" data-value="13"></i><b>(13)</b>
  release-strategy-expression="size() == 10"  <i class="conum" data-value="14"></i><b>(14)</b>
  empty-group-min-timeout="60000"  <i class="conum" data-value="15"></i><b>(15)</b>

  lock-registry="lockRegistry"  <i class="conum" data-value="16"></i><b>(16)</b>

  group-timeout="60000"  <i class="conum" data-value="17"></i><b>(17)</b>
  group-timeout-expression="size() ge 2 ? 100 : -1"  <i class="conum" data-value="18"></i><b>(18)</b>
  scheduler="taskScheduler" /&gt;  <i class="conum" data-value="19"></i><b>(19)</b>
  expire-group-upon-timeout="false" /&gt;  <i class="conum" data-value="20"></i><b>(20)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The id of the resequencer is optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The input channel of the resequencer.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The channel to which the resequencer sends the reordered messages.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The channel to which the resequencer  sends the messages that timed out (if <code>send-partial-result-on-timeout</code> is set to <code>false</code>).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Whether to send out ordered sequences as soon as they are available or only after the whole message group arrives.
Optional.
(The default is <code>false</code>.)</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A reference to a <code>MessageGroupStore</code> that can be used to store groups of messages under their correlation key until they are complete.
Optional.
(The default is a volatile in-memory store.)</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Whether, upon the expiration of the group, the ordered group should be sent out (even if some of the messages are missing).
Optional.
(The default is false.)
See <a href="#reaper">Managing State in an Aggregator: <code>MessageGroupStore</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The timeout interval to wait when sending a reply <code>Message</code> to the <code>output-channel</code> or <code>discard-channel</code>.
Defaults to <code>-1</code>, which blocks indefinitely.
It is applied only if the output channel has some 'sending' limitations, such as a  <code>QueueChannel</code> with a fixed 'capacity'.
In this case, a <code>MessageDeliveryException</code> is thrown.
The <code>send-timeout</code> is ignored for <code>AbstractSubscribableChannel</code> implementations.
For <code>group-timeout(-expression)</code>, the <code>MessageDeliveryException</code> from the scheduled expire task leads this task to be rescheduled.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>A reference to a bean that implements the message correlation (grouping) algorithm.
The bean can be an implementation of the <code>CorrelationStrategy</code> interface or a POJO.
In the latter case, the <code>correlation-strategy-method</code> attribute must also be defined.
Optional.
(By default, the aggregator uses the <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> header.)</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A method that is defined on the bean referenced by <code>correlation-strategy</code> and that implements the correlation decision algorithm.
Optional, with restrictions (requires <code>correlation-strategy</code> to be present).</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>A SpEL expression representing the correlation strategy.
Example: <code>"headers['something']"</code>.
Only one of <code>correlation-strategy</code> or <code>correlation-strategy-expression</code> is allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>A reference to a bean that implements the release strategy.
The bean can be an implementation of the <code>ReleaseStrategy</code> interface or a POJO.
In the latter case, the <code>release-strategy-method</code> attribute must also be defined.
Optional (by default, the aggregator will use the <code>IntegrationMessageHeaderAccessor.SEQUENCE_SIZE</code> header attribute).</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>A method that is defined on the bean referenced by <code>release-strategy</code> and that implements the completion decision algorithm.
Optional, with restrictions (requires <code>release-strategy</code> to be present).</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>A SpEL expression representing the release strategy.
The root object for the expression is a <code>MessageGroup</code>.
Example: <code>"size() == 5"</code>.
Only one of <code>release-strategy</code> or <code>release-strategy-expression</code> is allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>Only applies if a <code>MessageGroupStoreReaper</code> is configured for the <code>&lt;resequencer&gt;</code> <code>MessageStore</code>.
By default, when a <code>MessageGroupStoreReaper</code> is configured to expire partial groups, empty groups are also removed.
Empty groups exist after a group is released normally.
This is to enable the detection and discarding of late-arriving messages.
If you wish to expire empty groups on a longer schedule than expiring partial groups, set this property.
Empty groups are then not removed from the <code>MessageStore</code> until they have not been modified for at least this number of milliseconds.
Note that the actual time to expire an empty group is also affected by the reaper&#8217;s timeout property, and it could be as much as this value plus the timeout.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>See <a href="#aggregator-xml">Configuring an Aggregator with XML</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>See <a href="#aggregator-xml">Configuring an Aggregator with XML</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>See <a href="#aggregator-xml">Configuring an Aggregator with XML</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="19"></i><b>19</b></td>
<td>See <a href="#aggregator-xml">Configuring an Aggregator with XML</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="20"></i><b>20</b></td>
<td>By default, when a group is completed due to a timeout (or by a <code>MessageGroupStoreReaper</code>), the empty group&#8217;s metadata is retained.
Late arriving messages are immediately discarded.
Set this to <code>true</code> to remove the group completely.
Then, late arriving messages start a new group and are not be discarded until the group again times out.
The new group is never released normally because of the &#8220;hole&#8221; in the sequence range that caused the timeout.
Empty groups can be expired (completely removed) later by using a <code>MessageGroupStoreReaper</code> together with the <code>empty-group-min-timeout</code> attribute.
Starting with version 5.0, empty groups are also scheduled for removal after the <code>empty-group-min-timeout</code> elapses.
The default is 'false'.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since there is no custom behavior to be implemented in Java classes for resequencers, there is no annotation support for it.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="chain"><a class="anchor" href="#chain"></a>8.6. Message Handler Chain</h3>
<div class="paragraph">
<p>The <code>MessageHandlerChain</code> is an implementation of <code>MessageHandler</code> that can be configured as a single message endpoint while actually delegating to a chain of other handlers, such as filters, transformers, splitters, and so on.
When several handlers need to be connected in a fixed, linear progression, this can lead to a much simpler configuration.
For example, it is fairly common to provide a transformer before other components.
Similarly, when you provide a filter before some other component in a chain, you essentially create a <a href="https://www.enterpriseintegrationpatterns.com/MessageSelector.html">selective consumer</a>.
In either case, the chain requires only a single <code>input-channel</code> and a single <code>output-channel</code>, eliminating the need to define channels for each individual component.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Integration&#8217;s <code>Filter</code> provides a boolean property: <code>throwExceptionOnRejection</code>.
When you provide multiple selective consumers on the same point-to-point channel with different acceptance criteria, you should set this value 'true' (the default is <code>false</code>) so that the dispatcher knows that the message was rejected and, as a result, tries to pass the message on to other subscribers.
If the exception were not thrown, it would appear to the dispatcher that the message had been passed on successfully even though the filter had dropped the message to prevent further processing.
If you do indeed want to &#8220;drop&#8221; the messages, the filter&#8217;s 'discard-channel' might be useful, since it does give you a chance to perform some operation with the dropped message (such as sending it to a JMS queue or writing it to a log).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The handler chain simplifies configuration while internally maintaining the same degree of loose coupling between components, and it is trivial to modify the configuration if at some point a non-linear arrangement is required.</p>
</div>
<div class="paragraph">
<p>Internally, the chain is expanded into a linear setup of the listed endpoints, separated by anonymous channels.
The reply channel header is not taken into account within the chain.
Only after the last handler is invoked is the resulting message forwarded to the reply channel or the chain&#8217;s output channel.
Because of this setup, all handlers except the last must implement the <code>MessageProducer</code> interface (which provides a 'setOutputChannel()' method).
If the <code>outputChannel</code> on the <code>MessageHandlerChain</code> is set, the last handler needs only an output channel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with other endpoints, the <code>output-channel</code> is optional.
If there is a reply message at the end of the chain, the output-channel takes precedence.
However, if it is not available, the chain handler checks for a reply channel header on the inbound message as a fallback.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In most cases, you need not implement <code>MessageHandler</code> yourself.
The next section focuses on namespace support for the chain element.
Most Spring Integration endpoints, such as service activators and transformers, are suitable for use within a <code>MessageHandlerChain</code>.</p>
</div>
<div class="sect3">
<h4 id="chain-namespace"><a class="anchor" href="#chain-namespace"></a>8.6.1. Configuring a Chain</h4>
<div class="paragraph">
<p>The <code>&lt;chain&gt;</code> element provides an <code>input-channel</code> attribute.
If the last element in the chain is capable of producing reply messages (optional), it also supports an <code>output-channel</code> attribute.
The sub-elements are then filters, transformers, splitters, and service-activators.
The last element may also be a router or an outbound channel adapter.
The following example shows a chain definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:chain input-channel="input" output-channel="output"&gt;
    &lt;int:filter ref="someSelector" throw-exception-on-rejection="true"/&gt;
    &lt;int:header-enricher&gt;
        &lt;int:header name="thing1" value="thing2"/&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:service-activator ref="someService" method="someMethod"/&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;header-enricher&gt;</code> element used in the preceding example sets a message header named <code>thing1</code> with a value of <code>thing2</code> on the message.
A header enricher is a specialization of <code>Transformer</code> that touches only header values.
You could obtain the same result by implementing a <code>MessageHandler</code> that did the header modifications and wiring that as a bean, but the header-enricher is a simpler option.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;chain&gt;</code> can be configured as the last 'black-box' consumer of the message flow.
For this solution, you can to put it at the end of the &lt;chain&gt; some &lt;outbound-channel-adapter&gt;, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:chain input-channel="input"&gt;
    &lt;int-xml:marshalling-transformer marshaller="marshaller" result-type="StringResult" /&gt;
    &lt;int:service-activator ref="someService" method="someMethod"/&gt;
    &lt;int:header-enricher&gt;
        &lt;int:header name="thing1" value="thing2"/&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:logging-channel-adapter level="INFO" log-full-message="true"/&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Disallowed Attributes and Elements</div>
<div class="paragraph">
<p>Certain attributes, such as <code>order</code> and <code>input-channel</code> are not allowed to be specified on components used within a chain.
The same is true for the poller sub-element.</p>
</div>
<div class="paragraph">
<p>For the Spring Integration core components, the XML schema itself enforces some of these constraints.
However, for non-core components or your own custom components, these constraints are enforced by the XML namespace parser, not by the XML schema.</p>
</div>
<div class="paragraph">
<p>These XML namespace parser constraints were added with Spring Integration 2.2.
If you try to use disallowed attributes and elements, the XML namespace parser throws a <code>BeanDefinitionParsingException</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-the-id-attribute"><a class="anchor" href="#using-the-id-attribute"></a>8.6.2. Using the 'id' Attribute</h4>
<div class="paragraph">
<p>Beginning with Spring Integration 3.0, if a chain element is given an <code>id</code> attribute, the bean name for the element is a combination of the chain&#8217;s <code>id</code> and the <code>id</code> of the element itself.
Elements without <code>id</code> attributes are not registered as beans, but each one is given a <code>componentName</code> that includes the chain <code>id</code>.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:chain id="somethingChain" input-channel="input"&gt;
    &lt;int:service-activator id="somethingService" ref="someService" method="someMethod"/&gt;
    &lt;int:object-to-json-transformer/&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>&lt;chain&gt;</code> root element has an <code>id</code> of 'somethingChain'.
Consequently, the <code>AbstractEndpoint</code> implementation (<code>PollingConsumer</code> or <code>EventDrivenConsumer</code>, depending on the <code>input-channel</code> type) bean takes this value as its bean name.</p>
</li>
<li>
<p>The <code>MessageHandlerChain</code> bean acquires a bean alias ('somethingChain.handler'), which allows direct access to this bean from the <code>BeanFactory</code>.</p>
</li>
<li>
<p>The <code>&lt;service-activator&gt;</code> is not a fully fledged messaging endpoint (it is not a <code>PollingConsumer</code> or <code>EventDrivenConsumer</code>).
It is a <code>MessageHandler</code> within the <code>&lt;chain&gt;</code>.
In this case, the bean name registered with the <code>BeanFactory</code> is 'somethingChain$child.somethingService.handler'.</p>
</li>
<li>
<p>The <code>componentName</code> of this <code>ServiceActivatingHandler</code> takes the same value but without the '.handler' suffix.
It becomes 'somethingChain$child.somethingService'.</p>
</li>
<li>
<p>The last <code>&lt;chain&gt;</code> sub-component, <code>&lt;object-to-json-transformer&gt;</code>, does not have an <code>id</code> attribute.
Its <code>componentName</code> is based on its position in the <code>&lt;chain&gt;</code>.
In this case, it is 'somethingChain$child#1'.
(The final element of the name is the order within the chain, beginning with '#0').
Note, this transformer is not registered as a bean within the application context, so it does not get a <code>beanName</code>.
However its <code>componentName</code> has a value that is useful for logging and other purposes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>id</code> attribute for <code>&lt;chain&gt;</code> elements lets them be eligible for <a href="#jmx-mbean-exporter">JMX export</a>, and they are trackable in the <a href="#message-history">message history</a>.
You can access them from the <code>BeanFactory</code> by using the appropriate bean name, as discussed earlier.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is useful to provide an explicit <code>id</code> attribute on <code>&lt;chain&gt;</code> elements to simplify the identification of sub-components in logs and to provide access to them from the <code>BeanFactory</code> etc.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="calling-a-chain-from-within-a-chain"><a class="anchor" href="#calling-a-chain-from-within-a-chain"></a>8.6.3. Calling a Chain from within a Chain</h4>
<div class="paragraph">
<p>Sometimes, you need to make a nested call to another chain from within a chain and then come back and continue execution within the original chain.
To accomplish this, you can use a messaging gateway by including a &lt;gateway&gt; element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:chainid="main-chain"input-channel="in" output-channel="out"&gt;
    &lt;int:header-enricher&gt;
      &lt;int:header name="name" value="Many" /&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:service-activator&gt;
      &lt;bean class="org.foo.SampleService" /&gt;
    &lt;/int:service-activator&gt;
    &lt;int:gateway request-channel="inputA"/&gt; 
&lt;/int:chain&gt;

&lt;int:chainid="nested-chain-a"input-channel="inputA"&gt;
    &lt;int:header-enricher&gt;
        &lt;int:header name="name" value="Moe" /&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:gateway request-channel="inputB"/&gt;
    &lt;int:service-activator&gt;
        &lt;bean class="org.foo.SampleService" /&gt;
    &lt;/int:service-activator&gt;
&lt;/int:chain&gt;

&lt;int:chainid="nested-chain-b"input-channel="inputB"&gt;
    &lt;int:header-enricher&gt;
        &lt;int:header name="name" value="Jack" /&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:service-activator&gt;
        &lt;bean class="org.foo.SampleService" /&gt;
    &lt;/int:service-activator&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>nested-chain-a</code> is called at the end of <code>main-chain</code> processing by the 'gateway' element configured there.
While in <code>nested-chain-a</code>, a call to a <code>nested-chain-b</code> is made after header enrichment.
Then the flow comes back to finish execution in <code>nested-chain-b</code>.
Finally, the flow returns to <code>main-chain</code>.
When the nested version of a <code>&lt;gateway&gt;</code> element is defined in the chain, it does not require the <code>service-interface</code> attribute.
Instead, it takes the message in its current state and places it on the channel defined in the <code>request-channel</code> attribute.
When the downstream flow initiated by that gateway completes, a <code>Message</code> is returned to the gateway and continues its journey within the current chain.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scatter-gather"><a class="anchor" href="#scatter-gather"></a>8.7. Scatter-Gather</h3>
<div class="paragraph">
<p>Starting with version 4.1, Spring Integration provides an implementation of the <a href="https://www.enterpriseintegrationpatterns.com/BroadcastAggregate.html">scatter-gather</a> enterprise integration pattern.
It is a compound endpoint for which the goal is to send a message to the recipients and aggregate the results.
As noted in <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a>, it is a component for scenarios such as &#8220;best quote&#8221;, where we need to request information from several suppliers and decide which one provides us with the best term for the requested item.</p>
</div>
<div class="paragraph">
<p>Previously, the pattern could be configured by using discrete components.
This enhancement brings more convenient configuration.</p>
</div>
<div class="paragraph">
<p>The <code>ScatterGatherHandler</code> is a request-reply endpoint that combines a <code>PublishSubscribeChannel</code> (or a <code>RecipientListRouter</code>) and an <code>AggregatingMessageHandler</code>.
The request message is sent to the <code>scatter</code> channel, and the <code>ScatterGatherHandler</code> waits for the reply that the aggregator sends to the <code>outputChannel</code>.</p>
</div>
<div class="sect3">
<h4 id="scatter-gather-functionality"><a class="anchor" href="#scatter-gather-functionality"></a>8.7.1. Functionality</h4>
<div class="paragraph">
<p>The <code>Scatter-Gather</code> pattern suggests two scenarios: &#8220;auction&#8221; and &#8220;distribution&#8221;.
In both cases, the <code>aggregation</code> function is the same and provides all the options available for the <code>AggregatingMessageHandler</code>.
(Actually, the <code>ScatterGatherHandler</code> requires only an <code>AggregatingMessageHandler</code> as a constructor argument.)
See <a href="#aggregator">Aggregator</a> for more information.</p>
</div>
<div class="sect4">
<h5 id="auction"><a class="anchor" href="#auction"></a>Auction</h5>
<div class="paragraph">
<p>The auction <code>Scatter-Gather</code> variant uses &#8220;publish-subscribe&#8221; logic for the request message, where the &#8220;scatter&#8221; channel is a <code>PublishSubscribeChannel</code> with <code>apply-sequence="true"</code>.
However, this channel can be any <code>MessageChannel</code> implementation (as is the case with the <code>request-channel</code> in the <code>ContentEnricher</code>&#8201;&#8212;&#8201;see <a href="#content-enricher">Content Enricher</a>).
However, in this case, you should create your own custom <code>correlationStrategy</code> for the <code>aggregation</code> function.</p>
</div>
</div>
<div class="sect4">
<h5 id="distribution"><a class="anchor" href="#distribution"></a>Distribution</h5>
<div class="paragraph">
<p>The distribution <code>Scatter-Gather</code> variant is based on the <code>RecipientListRouter</code> (see <a href="#router-implementations-recipientlistrouter"><code>RecipientListRouter</code></a>) with all available options for the <code>RecipientListRouter</code>.
This is the second <code>ScatterGatherHandler</code> constructor argument.
If you want to rely on only the default <code>correlationStrategy</code> for the <code>recipient-list-router</code> and the <code>aggregator</code>, you should specify <code>apply-sequence="true"</code>.
Otherwise, you should supply a custom <code>correlationStrategy</code> for the <code>aggregator</code>.
Unlike the <code>PublishSubscribeChannel</code> variant (the auction variant), having a <code>recipient-list-router</code> <code>selector</code> option lets filter target suppliers based on the message.
With <code>apply-sequence="true"</code>, the default <code>sequenceSize</code> is supplied, and the <code>aggregator</code> can release the group correctly.
The distribution option is mutually exclusive with the auction option.</p>
</div>
<div class="paragraph">
<p>For both the auction and the distribution variants, the request (scatter) message is enriched with the <code>gatherResultChannel</code> header to wait for a reply message from the <code>aggregator</code>.</p>
</div>
<div class="paragraph">
<p>By default, all suppliers should send their result to the <code>replyChannel</code> header (usually by omitting the <code>output-channel</code> from the ultimate endpoint).
However, the <code>gatherChannel</code> option is also provided, letting suppliers send their reply to that channel for the aggregation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scatter-gather-namespace"><a class="anchor" href="#scatter-gather-namespace"></a>8.7.2. Configuring a Scatter-Gather Endpoint</h4>
<div class="paragraph">
<p>The following example shows Java configuration for the bean definition for <code>Scatter-Gather</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MessageHandler distributor() {
    RecipientListRouter router = new RecipientListRouter();
    router.setApplySequence(true);
    router.setChannels(Arrays.asList(distributionChannel1(), distributionChannel2(),
            distributionChannel3()));
    return router;
}

@Bean
public MessageHandler gatherer() {
	return new AggregatingMessageHandler(
			new ExpressionEvaluatingMessageGroupProcessor("^[payload gt 5] ?: -1D"),
			new SimpleMessageStore(),
			new HeaderAttributeCorrelationStrategy(
			       IntegrationMessageHeaderAccessor.CORRELATION_ID),
			new ExpressionEvaluatingReleaseStrategy("size() == 2"));
}

@Bean
@ServiceActivator(inputChannel = "distributionChannel")
public MessageHandler scatterGatherDistribution() {
	ScatterGatherHandler handler = new ScatterGatherHandler(distributor(), gatherer());
	handler.setOutputChannel(output());
	return handler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we configure the <code>RecipientListRouter</code> <code>distributor</code> bean with <code>applySequence="true"</code> and the list of recipient channels.
The next bean is for an <code>AggregatingMessageHandler</code>.
Finally, we inject both those beans into the <code>ScatterGatherHandler</code> bean definition and mark it as a <code>@ServiceActivator</code> to wire the scatter-gather component into the integration flow.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure the <code>&lt;scatter-gather&gt;</code> endpoint by using the XML namespace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;scatter-gather
		id=""  <i class="conum" data-value="1"></i><b>(1)</b>
		auto-startup=""  <i class="conum" data-value="2"></i><b>(2)</b>
		input-channel=""  <i class="conum" data-value="3"></i><b>(3)</b>
		output-channel=""  <i class="conum" data-value="4"></i><b>(4)</b>
		scatter-channel=""  <i class="conum" data-value="5"></i><b>(5)</b>
		gather-channel=""  <i class="conum" data-value="6"></i><b>(6)</b>
		order=""  <i class="conum" data-value="7"></i><b>(7)</b>
		phase=""  <i class="conum" data-value="8"></i><b>(8)</b>
		send-timeout=""  <i class="conum" data-value="9"></i><b>(9)</b>
		gather-timeout=""  <i class="conum" data-value="10"></i><b>(10)</b>
		requires-reply="" &gt; <i class="conum" data-value="11"></i><b>(11)</b>
			&lt;scatterer/&gt;  <i class="conum" data-value="12"></i><b>(12)</b>
			&lt;gatherer/&gt;  <i class="conum" data-value="13"></i><b>(13)</b>
&lt;/scatter-gather&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The id of the endpoint.
The <code>ScatterGatherHandler</code> bean is registered with an alias of <code>id + '.handler'</code>.
The <code>RecipientListRouter</code> bean is registered with an alias of <code>id + '.scatterer'</code>.
The <code>AggregatingMessageHandler`bean is registered with an alias of `id + '.gatherer'</code>.
Optional.
(The <code>BeanFactory</code> generates a default <code>id</code> value.)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lifecycle attribute signaling whether the endpoint should be started during application context initialization.
In addition, the <code>ScatterGatherHandler</code> also implements <code>Lifecycle</code> and starts and stops <code>gatherEndpoint</code>, which is created internally if a <code>gather-channel</code> is provided.
Optional.
(The default is <code>true</code>.)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The channel on which to receive request messages to handle them in the <code>ScatterGatherHandler</code>.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The channel to which the <code>ScatterGatherHandler</code> sends the aggregation results.
Optional.
(Incoming messages can specify a reply channel themselves in the <code>replyChannel</code> message header).</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The channel to which to send the scatter message for the auction scenario.
Optional.
Mutually exclusive with the <code>&lt;scatterer&gt;</code> sub-element.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The channel on which to receive replies from each supplier for the aggregation.
It is used as the <code>replyChannel</code> header in the scatter message.
Optional.
By default, the <code>FixedSubscriberChannel</code> is created.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The order of this component when more than one handler is subscribed to the same <code>DirectChannel</code> (use for load balancing purposes).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Specifies the phase in which the endpoint should be started and stopped.
The startup order proceeds from lowest to highest, and the shutdown order is from highest to lowest.
By default, this value is <code>Integer.MAX_VALUE</code>, meaning that this container starts as late as possible and stops as soon as possible.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The timeout interval to wait when sending a reply <code>Message</code> to the <code>output-channel</code>.
By default, the send blocks for one second.
It applies only if the output channel has some 'sending' limitations&#8201;&#8212;&#8201;for example, a <code>QueueChannel</code> with a fixed 'capacity' that is full.
In this case, a <code>MessageDeliveryException</code> is thrown.
The <code>send-timeout</code> is ignored for <code>AbstractSubscribableChannel</code> implementations.
For <code>group-timeout(-expression)</code>, the <code>MessageDeliveryException</code> from the scheduled expire task leads this task to be rescheduled.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Lets you specify how long the scatter-gather waits for the reply message before returning.
By default, it waits indefinitely.
'null' is returned if the reply times out.
Optional.
It defaults to <code>-1</code>, meaning to wait indefinitely.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Specifies whether the scatter-gather must return a non-null value.
This value is <code>true</code> by default.
Consequently, a <code>ReplyRequiredException</code> is thrown when the underlying aggregator returns a null value after <code>gather-timeout</code>.
Note, if <code>null</code> is a possibility, the <code>gather-timeout</code> should be specified to avoid an indefinite wait.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The <code>&lt;recipient-list-router&gt;</code> options.
Optional.
Mutually exclusive with <code>scatter-channel</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>The <code>&lt;aggregator&gt;</code> options.
Required.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scatter-gather-error-handling"><a class="anchor" href="#scatter-gather-error-handling"></a>8.7.3. Error Handling</h4>
<div class="paragraph">
<p>Since Scatter-Gather is a multi request-reply component, error handling has some extra complexity.
In some cases, it is better to just catch and ignore downstream exceptions if the <code>ReleaseStrategy</code> allows the process to finish with fewer replies than requests.
In other cases something like a &#8220;compensation message&#8221; should be considered for returning from sub-flow, when an error happens.</p>
</div>
<div class="paragraph">
<p>Every async sub-flow should be configured with a <code>errorChannel</code> header for the proper error message sending from the <code>MessagePublishingErrorHandler</code>.
Otherwise, an error will be sent to the global <code>errorChannel</code> with the common error handling logic.
See <a href="#namespace-errorhandler">Error Handling</a> for more information about async error processing.</p>
</div>
<div class="paragraph">
<p>Synchronous flows may use an <code>ExpressionEvaluatingRequestHandlerAdvice</code> for ignoring the exception or returning a compensation message.
When an exception is thrown from one of the sub-flows to the <code>ScatterGatherHandler</code>, it is just re-thrown to upstream.
This way all other sub-flows will work for nothing and their replies are going to be ignored in the <code>ScatterGatherHandler</code>.
This might be an expected behavior sometimes, but in most cases it would be better to handle the error in the particular sub-flow without impacting all others and the expectations in the gatherer.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1.3, the <code>ScatterGatherHandler</code> is supplied with the <code>errorChannelName</code> option.
It is populated to the <code>errorChannel</code> header of the scatter message and is used in the  when async error happens or can be used in the regular synchronous sub-flow for directly sending an error message.</p>
</div>
<div class="paragraph">
<p>The sample configuration below demonstrates async error handling by returning a compensation message:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow scatterGatherAndExecutorChannelSubFlow(TaskExecutor taskExecutor) {
    return f -&gt; f
            .scatterGather(
                    scatterer -&gt; scatterer
                            .applySequence(true)
                            .recipientFlow(f1 -&gt; f1.transform(p -&gt; "Sub-flow#1"))
                            .recipientFlow(f2 -&gt; f2
                                    .channel(c -&gt; c.executor(taskExecutor))
                                    .transform(p -&gt; {
                                        throw new RuntimeException("Sub-flow#2");
                                    })),
                    null,
                    s -&gt; s.errorChannel("scatterGatherErrorChannel"));
}

@ServiceActivator(inputChannel = "scatterGatherErrorChannel")
public Message&lt;?&gt; processAsyncScatterError(MessagingException payload) {
    return MessageBuilder.withPayload(payload.getCause().getCause())
            .copyHeaders(payload.getFailedMessage().getHeaders())
            .build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To produce a proper reply, we have to copy headers (including <code>replyChannel</code> and <code>errorChannel</code>) from the <code>failedMessage</code> of the <code>MessagingException</code> that has been sent to the <code>scatterGatherErrorChannel</code> by the <code>MessagePublishingErrorHandler</code>.
This way the target exception is returned to the gatherer of the <code>ScatterGatherHandler</code> for reply messages group completion.
Such an exception <code>payload</code> can be filtered out in the <code>MessageGroupProcessor</code> of the gatherer or processed other way downstream, after the scatter-gather endpoint.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before sending scattering results to the gatherer, <code>ScatterGatherHandler</code> reinstates the request message headers, including reply and error channels if any.
This way errors from the <code>AggregatingMessageHandler</code> are going to be propagated to the caller, even if an async hand off is applied in scatter recipient subflows.
In this case a reasonable, finite <code>gatherTimeout</code> must be configured for the <code>ScatterGatherHandler</code>.
Otherwise it is going to be blocked waiting for a reply from the gatherer forever, by default.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="barrier"><a class="anchor" href="#barrier"></a>8.8. Thread Barrier</h3>
<div class="paragraph">
<p>Sometimes, we need to suspend a message flow thread until some other asynchronous event occurs.
For example, consider an HTTP request that publishes a message to RabbitMQ.
We might wish to not reply to the user until the RabbitMQ broker has issued an acknowledgment that the message was
received.</p>
</div>
<div class="paragraph">
<p>In version 4.2, Spring Integration introduced the <code>&lt;barrier/&gt;</code> component for this purpose.
The underlying <code>MessageHandler</code> is the <code>BarrierMessageHandler</code>.
This class also implements
<code>MessageTriggerAction</code>, in which a message passed to the <code>trigger()</code> method releases a corresponding thread in the
<code>handleRequestMessage()</code> method (if present).</p>
</div>
<div class="paragraph">
<p>The suspended thread and trigger thread are correlated by invoking a <code>CorrelationStrategy</code> on the messages.
When a message is sent to the <code>input-channel</code>, the thread is suspended for up to <code>timeout</code> milliseconds, waiting for
a corresponding trigger message.
The default correlation strategy uses the <code>IntegrationMessageHeaderAccessor.CORRELATION_ID</code> header.
When a trigger message arrives with the same correlation, the thread is released.
The message sent to the <code>output-channel</code> after release is constructed by using a <code>MessageGroupProcessor</code>.
By default, the message is a <code>Collection&lt;?&gt;</code> of the two payloads, and the headers are merged by using a
<code>DefaultAggregatingMessageGroupProcessor</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
If the <code>trigger()</code> method is invoked first (or after the main thread times out), it is suspended for up to <code>timeout</code> waiting for the suspending message to arrive.
If you do not want to suspend the trigger thread, consider handing off to a <code>TaskExecutor</code> instead so that its thread is suspended instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>requires-reply</code> property determines the action to take if the suspended thread times out before the trigger message arrives.
By default, it is <code>false</code>, which means the endpoint returns <code>null</code>, the flow ends, and the thread returns to the
caller.
When <code>true</code>, a <code>ReplyRequiredException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>You can call the <code>trigger()</code> method programmatically (obtain the bean reference by using the name, <code>barrier.handler</code>&#8201;&#8212;&#8201;where <code>barrier</code> is the bean name of the barrier endpoint).
Alternatively, you can configure an <code>&lt;outbound-channel-adapter/&gt;</code> to trigger the release.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Only one thread can be suspended with the same correlation.
The same correlation can be used multiple times but only once concurrently.
An exception is thrown if a second thread arrives with the same correlation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use a custom header for correlation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:barrier id="barrier1" input-channel="in" output-channel="out"
        correlation-strategy-expression="headers['myHeader']"
        output-processor="myOutputProcessor"
        discard-channel="lateTriggerChannel"
        timeout="10000"&gt;
&lt;/int:barrier&gt;

&lt;int:outbound-channel-adapter channel="release" ref="barrier1.handler" method="trigger" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on which one has a message arrive first, either the thread sending a message to <code>in</code> or the thread sending a message to <code>release</code> waits for up to ten seconds until the other message arrives.
When the message is released, the <code>out</code> channel is sent a message that combines the result of invoking the custom <code>MessageGroupProcessor</code> bean, named <code>myOutputProcessor</code>.
If the main thread times out and a trigger arrives later, you can configure a discard channel to which the late trigger is sent.
The following example shows the Java configuration to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class Config {

    @ServiceActivator(inputChannel="in")
    @Bean
    public BarrierMessageHandler barrier() {
        BarrierMessageHandler barrier = new BarrierMessageHandler(10000);
        barrier.setOutputChannel(out());
        barrier.setDiscardChannel(lateTriggers());
        return barrier;
    }

    @ServiceActivator (inputChannel="release")
    @Bean
    public MessageHandler releaser() {
        return new MessageHandler() {

            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                barrier().trigger(message);
            }

        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an example of this component, see the <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/basic/barrier">barrier sample application</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="messaging-transformation-chapter"><a class="anchor" href="#messaging-transformation-chapter"></a>9. Message Transformation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="transformer"><a class="anchor" href="#transformer"></a>9.1. Transformer</h3>
<div class="paragraph">
<p>Message transformers play a very important role in enabling the loose-coupling of message producers and message consumers.
Rather than requiring every message-producing component to know what type is expected by the next consumer, you can add transformers between those components.
Generic transformers, such as one that converts a <code>String</code> to an XML Document, are also highly reusable.</p>
</div>
<div class="paragraph">
<p>For some systems, it may be best to provide a <a href="https://www.enterpriseintegrationpatterns.com/CanonicalDataModel.html">canonical data model</a>, but Spring Integration&#8217;s general philosophy is not to require any particular format.
Rather, for maximum flexibility, Spring Integration aims to provide the simplest possible model for extension.
As with the other endpoint types, the use of declarative configuration in XML or Java annotations enables simple POJOs to be adapted for the role of message transformers.
The rest of this chapter describes these configuration options.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the sake of maximizing flexibility, Spring does not require XML-based message payloads.
Nevertheless, the framework does provide some convenient transformers for dealing with XML-based payloads if that is indeed the right choice for your application.
For more information on those transformers, see <a href="#xml">XML Support - Dealing with XML Payloads</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="transformer-namespace"><a class="anchor" href="#transformer-namespace"></a>9.1.1. Configuring a Transformer with XML</h4>
<div class="paragraph">
<p>The <code>&lt;transformer&gt;</code> element is used to create a message-transforming endpoint.
In addition to <code>input-channel</code> and <code>output-channel</code> attributes, it requires a ` attribute`.
The <code>ref</code> may either point to an object that contains the <code>@Transformer</code> annotation on a single method (see <a href="#transformer-annotation">Configuring a Transformer with Annotations</a>), or it may be combined with an explicit method name value provided in the <code>method</code> attribute.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer id="testTransformer" ref="testTransformerBean" input-channel="inChannel"
             method="transform" output-channel="outChannel"/&gt;
&lt;beans:bean id="testTransformerBean" class="org.foo.TestTransformer" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using a <code>ref</code> attribute is generally recommended if the custom transformer handler implementation can be reused in other <code>&lt;transformer&gt;</code> definitions.
However, if the custom transformer handler implementation should be scoped to a single definition of the <code>&lt;transformer&gt;</code>, you can define an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer id="testTransformer" input-channel="inChannel" method="transform"
                output-channel="outChannel"&gt;
  &lt;beans:bean class="org.foo.TestTransformer"/&gt;
&lt;/transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both the <code>ref</code> attribute and an inner handler definition in the same <code>&lt;transformer&gt;</code> configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the <code>ref</code> attribute references a bean that extends <code>AbstractMessageProducingHandler</code> (such as transformers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.
In this case, each <code>ref</code> must be to a separate bean instance (or a <code>prototype</code>-scoped bean) or use the inner <code>&lt;bean/&gt;</code> configuration type.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using a POJO, the method that is used for transformation may expect either the <code>Message</code> type or the payload type of inbound messages.
It may also accept message header values either individually or as a full map by using the <code>@Header</code> and <code>@Headers</code> parameter annotations, respectively.
The return value of the method can be any type.
If the return value is itself a <code>Message</code>, that is passed along to the transformer&#8217;s output channel.</p>
</div>
<div class="paragraph">
<p>As of Spring Integration 2.0, a message transformer&#8217;s transformation method can no longer return <code>null</code>.
Returning <code>null</code> results in an exception, because a message transformer should always be expected to transform each source message into a valid target message.
In other words, a message transformer should not be used as a message filter, because there is a dedicated <code>&lt;filter&gt;</code> option for that.
However, if you do need this type of behavior (where a component might return <code>null</code> and that should not be considered an error), you could use a service activator.
Its <code>requires-reply</code> value is <code>false</code> by default, but that can be set to <code>true</code> in order to have exceptions thrown for <code>null</code> return values, as with the transformer.</p>
</div>
</div>
<div class="sect3">
<h4 id="transformers-and-spring-expression-language-spel"><a class="anchor" href="#transformers-and-spring-expression-language-spel"></a>9.1.2. Transformers and Spring Expression Language (SpEL)</h4>
<div class="paragraph">
<p>Like routers, aggregators, and other components, as of Spring Integration 2.0, transformers can also benefit from <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">SpEL support</a> whenever transformation logic is relatively simple.
The following example shows how to use a SpEL expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer input-channel="inChannel"
	output-channel="outChannel"
	expression="payload.toUpperCase() + '- [' + T(java.lang.System).currentTimeMillis() + ']'"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example transforms the payload without writing a custom transformer.
Our payload (assumed to be a <code>String</code>) is upper-cased, concatenated with the current timestamp, and has some formatting applied.</p>
</div>
</div>
<div class="sect3">
<h4 id="common-transformers"><a class="anchor" href="#common-transformers"></a>9.1.3. Common Transformers</h4>
<div class="paragraph">
<p>Spring Integration provides a few transformer implementations.</p>
</div>
<div class="sect4">
<h5 id="object-to-string-transformer"><a class="anchor" href="#object-to-string-transformer"></a>Object-to-String Transformer</h5>
<div class="paragraph">
<p>Because it is fairly common to use the <code>toString()</code> representation of an <code>Object</code>, Spring Integration provides an <code>ObjectToStringTransformer</code> whose output is a <code>Message</code> with a String <code>payload</code>.
That <code>String</code> is the result of invoking the <code>toString()</code> operation on the inbound Message&#8217;s payload.
The following example shows how to declare an instance of the object-to-string transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:object-to-string-transformer input-channel="in" output-channel="out"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A potential use for this transformer would be sending some arbitrary object to the 'outbound-channel-adapter' in the <code>file</code> namespace.
Whereas that channel adapter only supports <code>String</code>, byte-array, or <code>java.io.File</code> payloads by default, adding this transformer immediately before the adapter handles the necessary conversion.
That works fine as long as the result of the <code>toString()</code> call is what you want to be written to the file.
Otherwise, you can provide a custom POJO-based transformer by using the generic 'transformer' element shown previously.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When debugging, this transformer is not typically necessary, since the 'logging-channel-adapter' is capable of logging the message payload.
See <a href="#channel-wiretap">Wire Tap</a> for more detail.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The object-to-string transformer is very simple.
It invokes <code>toString()</code> on the inbound payload.
Since Spring Integration 3.0, there are two exceptions to this rule:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the payload is a <code>char[]</code>, it invokes <code>new String(payload)</code>.</p>
</li>
<li>
<p>If the payload is a <code>byte[]</code>, it invokes <code>new String(payload, charset)</code>, where <code>charset</code> is UTF-8 by default.
The <code>charset</code> can be modified by supplying the charset attribute on the transformer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more sophistication (such as selection of the charset dynamically, at runtime), you can use a SpEL expression-based transformer instead, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer input-channel="in" output-channel="out"
       expression="new java.lang.String(payload, headers['myCharset']" /&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to serialize an <code>Object</code> to a byte array or deserialize a byte array back into an <code>Object</code>, Spring Integration provides symmetrical serialization transformers.
These use standard Java serialization by default, but you can provide an implementation of Spring 3.0&#8217;s serializer or seserializer strategies by using the 'serializer' and 'deserializer' attributes, respectively.
The following example shows to use Spring&#8217;s serializer and deserializer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:payload-serializing-transformer input-channel="objectsIn" output-channel="bytesOut"/&gt;

&lt;int:payload-deserializing-transformer input-channel="bytesIn" output-channel="objectsOut"
    white-list="com.mycom.*,com.yourcom.*"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When deserializing data from untrusted sources, you should consider adding a <code>white-list</code> of package and class patterns.
By default, all classes are deserialized.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="object-to-map-and-map-to-object-transformers"><a class="anchor" href="#object-to-map-and-map-to-object-transformers"></a><code>Object</code>-to-<code>Map</code> and <code>Map</code>-to-<code>Object</code> Transformers</h5>
<div class="paragraph">
<p>Spring Integration also provides <code>Object</code>-to-<code>Map</code> and <code>Map</code>-to-<code>Object</code> transformers, which use the JSON to serialize and de-serialize the object graphs.
The object hierarchy is introspected to the most primitive types (<code>String</code>, <code>int</code>, and so on).
The path to this type is described with SpEL, which becomes the <code>key</code> in the transformed <code>Map</code>.
The primitive type becomes the value.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Parent{
 private Child child;
 private String name;
 // setters and getters are omitted
}

public class Child{
 private String name;
  private List&lt;String&gt; nickNames;
  // setters and getters are omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The two classes in the preceding example are transformed to the following <code>Map</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{person.name=George, person.child.name=Jenna, person.child.nickNames[0]=Jen ...}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The JSON-based <code>Map</code> lets you describe the object structure without sharing the actual types, which lets you restore and rebuild the object graph into a differently typed object graph, as long as you maintain the structure.</p>
</div>
<div class="paragraph">
<p>For example, the preceding structure could be restored back to the following object graph by using the <code>Map</code>-to-<code>Object</code> transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Father {
 private Kid child;
 private String name;
 // setters and getters are omitted
}

public class Kid {
 private String name;
  private List&lt;String&gt; nickNames;
  // setters and getters are omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to create a &#8220;structured&#8221; map, you can provide the 'flatten' attribute.
The default is 'true'.
If you set it to 'false', the structure is a <code>Map</code> of <code>Map</code> objects.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Parent {
	private Child child;
	private String name;
	// setters and getters are omitted
}

public class Child {
	private String name;
	private List&lt;String&gt; nickNames;
	// setters and getters are omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The two classes in the preceding example are transformed to the following <code>Map</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{name=George, child={name=Jenna, nickNames=[Bimbo, ...]}}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To configure these transformers, Spring Integration provides namespace support for Object-to-Map, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:object-to-map-transformer input-channel="directInput" output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also set the <code>flatten</code> attribute to false, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:object-to-map-transformer input-channel="directInput" output-channel="output" flatten="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Integration provides namespace support for Map-to-Object, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:map-to-object-transformer input-channel="input"
             output-channel="output"
              type="org.something.Person"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alterately, you could use a <code>ref</code> attribute and a prototype-scoped bean, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:map-to-object-transformer input-channel="inputA"
                 output-channel="outputA"
                 ref="person"/&gt;
&lt;bean id="person" class="org.something.Person" scope="prototype"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 'ref' and 'type' attributes are mutually exclusive.
Also, if you use the 'ref' attribute, you must point to a 'prototype' scoped bean.
Otherwise, a <code>BeanCreationException</code> is thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can supply the <code>ObjectToMapTransformer</code> with a customized <code>JsonObjectMapper</code>&#8201;&#8212;&#8201;for when you need special formats for dates or nulls for empty collections (and other uses).
See <a href="#json-transformers">JSON Transformers</a> for more information about <code>JsonObjectMapper</code> implementations.</p>
</div>
</div>
<div class="sect4">
<h5 id="stream-transformer"><a class="anchor" href="#stream-transformer"></a>Stream Transformer</h5>
<div class="paragraph">
<p>The <code>StreamTransformer</code> transforms <code>InputStream</code> payloads to a <code>byte[]</code>( or a <code>String</code> if a <code>charset</code> is provided).</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>stream-tansformer</code> element in XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:stream-transformer input-channel="directInput" output-channel="output"/&gt; &lt;!-- byte[] --&gt;

&lt;int:stream-transformer id="withCharset" charset="UTF-8"
    input-channel="charsetChannel" output-channel="output"/&gt; &lt;!-- String --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>StreamTransformer</code> class and the <code>@Transformer</code> annotation to configure a stream transformer in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel = "stream", outputChannel = "data")
public StreamTransformer streamToBytes() {
    return new StreamTransformer(); // transforms to byte[]
}

@Bean
@Transformer(inputChannel = "stream", outputChannel = "data")
public StreamTransformer streamToString() {
    return new StreamTransformer("UTF-8"); // transforms to String
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="json-transformers"><a class="anchor" href="#json-transformers"></a>JSON Transformers</h5>
<div class="paragraph">
<p>Spring Integration provides Object-to-JSON and JSON-to-Object transformers.
The following pair of examples show how to declare them in XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:object-to-json-transformer input-channel="objectMapperInput"/&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:json-to-object-transformer input-channel="objectMapperInput"
    type="foo.MyDomainObject"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the transformers in the preceding listing use a vanilla <code>JsonObjectMapper</code>.
It is based on an implementation from the classpath.
You can provide your own custom <code>JsonObjectMapper</code> implementation with appropriate options or based on a required library (such as GSON), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:json-to-object-transformer input-channel="objectMapperInput"
    type="something.MyDomainObject" object-mapper="customObjectMapper"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beginning with version 3.0, the <code>object-mapper</code> attribute references an instance of a new strategy interface: <code>JsonObjectMapper</code>.
This abstraction lets multiple implementations of JSON mappers be used.
Implementations that wrap <a href="https://github.com/RichardHightower/boon">Boon</a> and <a href="https://github.com/FasterXML">Jackson 2</a> are provided, with the version being detected on the classpath.
These classes are <code>BoonJsonObjectMapper</code> and <code>Jackson2JsonObjectMapper</code>, respectively.</p>
</div>
<div class="paragraph">
<p>Note, <code>BoonJsonObjectMapper</code> was added in version 4.1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you have requirements to use both Jackson and Boon in the same application, keep in mind that, before version 3.0, the JSON transformers used only Jackson 1.x.
From 4.1 on, the framework selects Jackson 2 by default, preferring it to the Boon implementation if both are on the classpath.
Jackson 1.x is no longer supported by the framework internally.
However, you can still use it within your code by including the necessary library.
To avoid unexpected issues with JSON mapping features when you use annotations, you may need to apply annotations from both Jackson and Boon on domain classes, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@org.codehaus.jackson.annotate.JsonIgnoreProperties(ignoreUnknown=true)
@com.fasterxml.jackson.annotation.JsonIgnoreProperties(ignoreUnknown=true)
@org.boon.json.annotations.JsonIgnoreProperties("thing1")
public class Thing1 {

        @org.codehaus.jackson.annotate.JsonProperty("thing1Thing2")
        @com.fasterxml.jackson.annotation.JsonProperty("thing1Thing2")
        @org.boon.json.annotations.JsonProperty("thing1Thing2")
        public Object thing2;

}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You may wish to consider using a <code>FactoryBean</code> or a factory method to create the <code>JsonObjectMapper</code> with the required characteristics.
The following example shows how to use such a factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ObjectMapperFactory {

    public static Jackson2JsonObjectMapper getMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
        return new Jackson2JsonObjectMapper(mapper);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to do the same thing in XML</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="customObjectMapper" class="something.ObjectMapperFactory"
            factory-method="getMapper"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beginning with version 2.2, the <code>object-to-json-transformer</code> sets the <code>content-type</code> header to <code>application/json</code>, by default, if the input message does not already have that header.</p>
</div>
<div class="paragraph">
<p>It you wish to set the <code>content-type</code> header to some other value or explicitly overwrite any existing header with some value (including <code>application/json</code>), use the <code>content-type</code> attribute.
If you wish to suppress the setting of the header, set the <code>content-type</code> attribute to an empty string (<code>""</code>).
Doing so results in a message with no <code>content-type</code> header, unless such a header was present on the input message.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Beginning with version 3.0, the <code>ObjectToJsonTransformer</code> adds headers, reflecting the source type, to the message.
Similarly, the <code>JsonToObjectTransformer</code> can use those type headers when converting the JSON to an object.
These headers are mapped in the AMQP adapters so that they are entirely compatible with the Spring-AMQP <a href="https://docs.spring.io/spring-amqp/api/"><code>JsonMessageConverter</code></a>.</p>
</div>
<div class="paragraph">
<p>This enables the following flows to work without any special configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&#8230;&#8203;&#8594;amqp-outbound-adapter---&#8594;</code></p>
</li>
<li>
<p><code>---&#8594;amqp-inbound-adapter&#8594;json-to-object-transformer&#8594;&#8230;&#8203;</code></p>
<div class="paragraph">
<p>Where the outbound adapter is configured with a <code>JsonMessageConverter</code> and the inbound adapter uses the default <code>SimpleMessageConverter</code>.</p>
</div>
</li>
<li>
<p><code>&#8230;&#8203;&#8594;object-to-json-transformer&#8594;amqp-outbound-adapter---&#8594;</code></p>
</li>
<li>
<p><code>---&#8594;amqp-inbound-adapter&#8594;&#8230;&#8203;</code></p>
<div class="paragraph">
<p>Where the outbound adapter is configured with a <code>SimpleMessageConverter</code> and the inbound adapter uses the default <code>JsonMessageConverter</code>.</p>
</div>
</li>
<li>
<p><code>&#8230;&#8203;&#8594;object-to-json-transformer&#8594;amqp-outbound-adapter---&#8594;</code></p>
</li>
<li>
<p><code>---&#8594;amqp-inbound-adapter&#8594;json-to-object-transformer&#8594;</code></p>
<div class="paragraph">
<p>Where both adapters are configured with a <code>SimpleMessageConverter</code>.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the headers to determine the type, you should not provide a <code>class</code> attribute, because it takes precedence over the headers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to JSON Transformers, Spring Integration provides a built-in <code>#jsonPath</code> SpEL function for use in expressions.
For more information see <a href="#spel">Spring Expression Language (SpEL)</a>.</p>
</div>
<div id="transformer-xpath-spel-function" class="paragraph">
<p>Since version 3.0, Spring Integration also provides a built-in <code>#xpath</code> SpEL function for use in expressions.
For more information see <a href="#xpath-spel-function">#xpath SpEL Function</a>.</p>
</div>
<div class="paragraph">
<p>Beginning with version 4.0, the <code>ObjectToJsonTransformer</code> supports the <code>resultType</code> property, to specify the node JSON representation.
The result node tree representation depends on the implementation of the provided <code>JsonObjectMapper</code>.
By default, the <code>ObjectToJsonTransformer</code> uses a <code>Jackson2JsonObjectMapper</code> and delegates the conversion of the object to the node tree to the <code>ObjectMapper#valueToTree</code> method.
The node JSON representation provides efficiency for using the <code>JsonPropertyAccessor</code> when the downstream message flow uses SpEL expressions with access to the properties of the JSON data.
See <a href="#spel-property-accessors">Property Accessors</a> for more information.
When using Boon, the <code>NODE</code> representation is a <code>Map&lt;String, Object&gt;</code></p>
</div>
<div class="paragraph">
<p>Beginning with version 5.1, the <code>resultType</code> can be configured as <code>BYTES</code> to produce a message with the <code>byte[]</code> payload for convenience when working with downstream handlers which operate with this data type.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transformer-annotation"><a class="anchor" href="#transformer-annotation"></a>9.1.4. Configuring a Transformer with Annotations</h4>
<div class="paragraph">
<p>You can add the <code>@Transformer</code> annotation to methods that expect either the <code>Message</code> type or the message payload type.
The return value is handled in the exact same way as described earlier <a href="#transformer-namespace">in the section describing the <code>&lt;transformer&gt;</code> element</a>.
The following example shows how to use the <code>@Transformer</code> annotation to transform a <code>String</code> into an <code>Order</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Transformer
Order generateOrder(String productId) {
    return new Order(productId);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Transformer methods can also accept the <code>@Header</code> and <code>@Headers</code> annotations, as documented in <code><a href="#annotations">Annotation Support</a></code>.
The following examples shows how to use the <code>@Header</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Transformer
Order generateOrder(String productId, @Header("customerName") String customer) {
    return new Order(productId, customer);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#advising-with-annotations">Advising Endpoints Using Annotations</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="header-filter"><a class="anchor" href="#header-filter"></a>9.1.5. Header Filter</h4>
<div class="paragraph">
<p>Sometimes, your transformation use case might be as simple as removing a few headers.
For such a use case, Spring Integration provides a header filter that lets you specify certain header names that should be removed from the output message (for example, removing headers for security reasons or a value that was needed only temporarily).
Basically, the header filter is the opposite  of the header enricher.
The latter is discussed in <a href="#header-enricher">Header Enricher</a>.
The following example defines a header filter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-filter input-channel="inputChannel"
		output-channel="outputChannel" header-names="lastName, state"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, configuration of a header filter is quite simple.
It is a typical endpoint with input and output channels and a <code>header-names</code> attribute.
That attribute accepts the names of the headers (delimited by commas if there are multiple) that need to be removed.
So, in the preceding example, the headers named 'lastName' and 'state' are not present on the outbound message.</p>
</div>
</div>
<div class="sect3">
<h4 id="codec-based-transformers"><a class="anchor" href="#codec-based-transformers"></a>9.1.6. Codec-Based Transformers</h4>
<div class="paragraph">
<p>See <a href="#codec">Codec</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="content-enricher"><a class="anchor" href="#content-enricher"></a>9.2. Content Enricher</h3>
<div class="paragraph">
<p>At times, you may have a requirement to enhance a request with more information than was provided by the target system.
The <a href="https://www.enterpriseintegrationpatterns.com/DataEnricher.html">data enricher</a> pattern describes various scenarios as well as the component (Enricher) that lets you address such requirements.</p>
</div>
<div class="paragraph">
<p>The Spring Integration <code>Core</code> module includes two enrichers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#header-enricher">Header Enricher</a></p>
</li>
<li>
<p><a href="#payload-enricher">Payload Enricher</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also includes three adapter-specific header enrichers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xml-xpath-header-enricher">XPath Header Enricher (XML Module)</a></p>
</li>
<li>
<p><a href="#mail-namespace">Mail Header Enricher (Mail Module)</a></p>
</li>
<li>
<p><a href="#xmpp-message-outbound-channel-adapter">XMPP Header Enricher (XMPP Module)</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the adapter-specific sections of this reference manual to learn more about those adapters.</p>
</div>
<div class="paragraph">
<p>For more information regarding expressions support, see <a href="#spel">Spring Expression Language (SpEL)</a>.</p>
</div>
<div class="sect3">
<h4 id="header-enricher"><a class="anchor" href="#header-enricher"></a>9.2.1. Header Enricher</h4>
<div class="paragraph">
<p>If you need do nothing more than add headers to a message and the headers are not dynamically determined by the message content, referencing a custom implementation of a transformer may be overkill.
For that reason, Spring Integration provides support for the header enricher pattern.
It is exposed through the <code>&lt;header-enricher&gt;</code> element.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher input-channel="in" output-channel="out"&gt;
    &lt;int:header name="foo" value="123"/&gt;
    &lt;int:header name="bar" ref="someBean"/&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The header enricher also provides helpful sub-elements to set well known header names, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher input-channel="in" output-channel="out"&gt;
    &lt;int:error-channel ref="applicationErrorChannel"/&gt;
    &lt;int:reply-channel ref="quoteReplyChannel"/&gt;
    &lt;int:correlation-id value="123"/&gt;
    &lt;int:priority value="HIGHEST"/&gt;
    &lt;routing-slip value="channel1; routingSlipRoutingStrategy; request.headers[myRoutingSlipChannel]"/&gt;
    &lt;int:header name="bar" ref="someBean"/&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration shows that, for well known headers (such as <code>errorChannel</code>, <code>correlationId</code>, <code>priority</code>, <code>replyChannel</code>, <code>routing-slip</code>, and others), instead of using generic <code>&lt;header&gt;</code> sub-elements where you would have to provide both header 'name' and 'value', you can use convenient sub-elements to set those values directly.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.1, the header enricher provides a <code>routing-slip</code> sub-element.
See <a href="#routing-slip">Routing Slip</a> for more information.</p>
</div>
<div class="sect4">
<h5 id="pojo-support"><a class="anchor" href="#pojo-support"></a>POJO Support</h5>
<div class="paragraph">
<p>Often, a header value cannot be defined statically and has to be determined dynamically based on some content in the message.
That is why the header enricher lets you also specify a bean reference by using the <code>ref</code> and <code>method</code> attributes.
The specified method calculates the header value.
Consider the following configuration and a bean with a method that modifies a <code>String</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher input-channel="in" output-channel="out"&gt;
    &lt;int:header name="something" method="computeValue" ref="myBean"/&gt;
&lt;/int:header-enricher&gt;

&lt;bean id="myBean" class="thing1.thing2.MyBean"/&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBean {

    public String computeValue(String payload){
        return payload.toUpperCase() + "_US";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also configure your POJO as an inner bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher  input-channel="inputChannel" output-channel="outputChannel"&gt;
    &lt;int:header name="some_header"&gt;
        &lt;bean class="org.MyEnricher"/&gt;
    &lt;/int:header&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can similarly point to a Groovy script, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher  input-channel="inputChannel" output-channel="outputChannel"&gt;
    &lt;int:header name="some_header"&gt;
        &lt;int-groovy:script location="org/SampleGroovyHeaderEnricher.groovy"/&gt;
    &lt;/int:header&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spel-support"><a class="anchor" href="#spel-support"></a>SpEL Support</h5>
<div class="paragraph">
<p>In Spring Integration 2.0, we introduced the convenience of the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">Spring Expression Language (SpEL)</a> to help configure many different components.
The header enricher is one of them.
Look again at the POJO example shown earlier.
You can see that the computation logic to determine the header value is pretty simple.
A natural question would be: "Is there an even simpler way to accomplish this?".
That is where SpEL shows its true power.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher input-channel="in" output-channel="out"&gt;
    &lt;int:header name="foo" expression="payload.toUpperCase() + '_US'"/&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using SpEL for such simple cases, you no longer have to provide a separate class and configure it in the application context.
All you need do is configured the <code>expression</code> attribute with a valid SpEL expression.
The 'payload' and 'headers' variables are bound to the SpEL evaluation context, giving you full access to the incoming message.</p>
</div>
</div>
<div class="sect4">
<h5 id="configuring-a-header-enricher-with-java-configuration"><a class="anchor" href="#configuring-a-header-enricher-with-java-configuration"></a>Configuring a Header Enricher with Java Configuration</h5>
<div class="paragraph">
<p>The following two examples show how to use Java Configuration for header enrichers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel = "enrichHeadersChannel", outputChannel = "emailChannel")
public HeaderEnricher enrichHeaders() {
    Map&lt;String, ? extends HeaderValueMessageProcessor&lt;?&gt;&gt; headersToAdd =
            Collections.singletonMap("emailUrl",
                      new StaticHeaderValueMessageProcessor&lt;&gt;(this.imapUrl));
    HeaderEnricher enricher = new HeaderEnricher(headersToAdd);
    return enricher;
}

@Bean
@Transformer(inputChannel="enrichHeadersChannel", outputChannel="emailChannel")
public HeaderEnricher enrichHeaders() {
    Map&lt;String, HeaderValueMessageProcessor&lt;?&gt;&gt; headersToAdd = new HashMap&lt;&gt;();
    headersToAdd.put("emailUrl", new StaticHeaderValueMessageProcessor&lt;String&gt;(this.imapUrl));
    Expression expression = new SpelExpressionParser().parseExpression("payload.from[0].toString()");
    headersToAdd.put("from",
               new ExpressionEvaluatingHeaderValueMessageProcessor&lt;&gt;(expression, String.class));
    HeaderEnricher enricher = new HeaderEnricher(headersToAdd);
    return enricher;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example adds a single literal header.
The second example adds two headers, a literal header and one based on a SpEL expression.</p>
</div>
</div>
<div class="sect4">
<h5 id="configuring-a-header-enricher-with-the-java-dsl"><a class="anchor" href="#configuring-a-header-enricher-with-the-java-dsl"></a>Configuring a Header Enricher with the Java DSL</h5>
<div class="paragraph">
<p>The following example shows Java DSL Configuration for a header enricher:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow enrichHeadersInFlow() {
    return f -&gt; f
                ...
                .enrichHeaders(h -&gt; h.header("emailUrl", this.emailUrl)
                                     .headerExpression("from", "payload.from[0].toString()"))
                .handle(...);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="header-channel-registry"><a class="anchor" href="#header-channel-registry"></a>Header Channel Registry</h5>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, a new sub-element <code>&lt;int:header-channels-to-string/&gt;</code> is available.
It has no attributes.
This new sub-element converts existing <code>replyChannel</code> and <code>errorChannel</code> headers (when they are a <code>MessageChannel</code>) to a <code>String</code> and stores the channels in a registry for later resolution, when it is time to send a reply or handle an error.
This is useful for cases where the headers might be lost&#8201;&#8212;&#8201;for example, when serializing a message into a message store or when transporting the message over JMS.
If the header does not already exist or it is not a <code>MessageChannel</code>, no changes are made.</p>
</div>
<div class="paragraph">
<p>Using this functionality requires the presence of a <code>HeaderChannelRegistry</code> bean.
By default, the framework creates a <code>DefaultHeaderChannelRegistry</code> with the default expiry (60 seconds).
Channels are removed from the registry after this time.
To change this behavior, define a bean with an <code>id</code> of <code>integrationHeaderChannelRegistry</code> and configure the required default delay by using a constructor argument (in milliseconds).</p>
</div>
<div class="paragraph">
<p>Since version 4.1, you can set a property called <code>removeOnGet</code> to <code>true</code> on the <code>&lt;bean/&gt;</code> definition, and the mapping entry is removed immediately on first use.
This might be useful in a high-volume environment and when the channel is only used once, rather than waiting for the reaper to remove it.</p>
</div>
<div class="paragraph">
<p>The <code>HeaderChannelRegistry</code> has a <code>size()</code> method to determine the current size of the registry.
The <code>runReaper()</code> method cancels the current scheduled task and runs the reaper immediately.
The task is then scheduled to run again based on the current delay.
These methods can be invoked directly by getting a reference to the registry, or you can send a message with, for example, the following content to a control bus:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>"@integrationHeaderChannelRegistry.runReaper()"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This sub-element is a convenience, and is the equivalent of specifying the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:reply-channel
    expression="@integrationHeaderChannelRegistry.channelToChannelName(headers.replyChannel)"
    overwrite="true" /&gt;
&lt;int:error-channel
    expression="@integrationHeaderChannelRegistry.channelToChannelName(headers.errorChannel)"
    overwrite="true" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.1, you can now override the registry&#8217;s configured reaper delay so that the the channel mapping is retained for at least the specified time, regardless of the reaper delay.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:header-enricher input-channel="inputTtl" output-channel="next"&gt;
    &lt;int:header-channels-to-string time-to-live-expression="120000" /&gt;
&lt;/int:header-enricher&gt;

&lt;int:header-enricher input-channel="inputCustomTtl" output-channel="next"&gt;
    &lt;int:header-channels-to-string
        time-to-live-expression="headers['channelTTL'] ?: 120000" /&gt;
&lt;/int:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the first case, the time to live for every header channel mapping will be two minutes.
In the second case, the time to live is specified in the message header and uses an Elvis operator to use two minutes if there is no header.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="payload-enricher"><a class="anchor" href="#payload-enricher"></a>9.2.2. Payload Enricher</h4>
<div class="paragraph">
<p>In certain situations, the header enricher, as discussed earlier, may not be sufficient and payloads themselves may have to be enriched with additional information.
For example, order messages that enter the Spring Integration messaging system have to look up the order&#8217;s customer based on the provided customer number and then enrich the original payload with that information.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.1 introduced the payload enricher.
The payload enricher defines an endpoint that passes a <code>Message</code> to the exposed request channel and then expects a reply message.
The reply message then becomes the root object for evaluation of expressions to enrich the target payload.</p>
</div>
<div class="paragraph">
<p>The payload enricher provides full XML namespace support through the <code>enricher</code> element.
In order to send request messages, the payload enricher has a <code>request-channel</code> attribute that lets you dispatch messages to a request channel.</p>
</div>
<div class="paragraph">
<p>Basically, by defining the request channel, the payload enricher acts as a gateway, waiting for the message sent to the request channel to return.
The enricher then augments the message&#8217;s payload with the data provided by the reply message.</p>
</div>
<div class="paragraph">
<p>When sending messages to the request channel, you also have the option to send only a subset of the original payload by using the <code>request-payload-expression</code> attribute.</p>
</div>
<div class="paragraph">
<p>The enriching of payloads is configured through SpEL expressions, providing a maximum degree of flexibility.
Therefore, you can not only enrich payloads with direct values from the reply channel&#8217;s <code>Message</code>, but you can use SpEL expressions to extract a subset from that message or to apply additional inline transformations, letting you further manipulate the data.</p>
</div>
<div class="paragraph">
<p>If you need only to enrich payloads with static values, you need not provide the <code>request-channel</code> attribute.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Enrichers are a variant of transformers.
In many cases, you could use a payload enricher or a generic transformer implementation to add additional data to your message payloads.
You should familiarize yourself with all transformation-capable components that are provided by Spring Integration and carefully select the implementation that semantically fits your business case best.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="payload-enricher-configuration"><a class="anchor" href="#payload-enricher-configuration"></a>Configuration</h5>
<div class="paragraph">
<p>The following example shows all available configuration options for the payload enricher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:enricher request-channel=""                           <i class="conum" data-value="1"></i><b>(1)</b>
              auto-startup="true"                          <i class="conum" data-value="2"></i><b>(2)</b>
              id=""                                        <i class="conum" data-value="3"></i><b>(3)</b>
              order=""                                     <i class="conum" data-value="4"></i><b>(4)</b>
              output-channel=""                            <i class="conum" data-value="5"></i><b>(5)</b>
              request-payload-expression=""                <i class="conum" data-value="6"></i><b>(6)</b>
              reply-channel=""                             <i class="conum" data-value="7"></i><b>(7)</b>
              error-channel=""                             <i class="conum" data-value="8"></i><b>(8)</b>
              send-timeout=""                              <i class="conum" data-value="9"></i><b>(9)</b>
              should-clone-payload="false"&gt;                <i class="conum" data-value="10"></i><b>(10)</b>
    &lt;int:poller&gt;&lt;/int:poller&gt;                              <i class="conum" data-value="11"></i><b>(11)</b>
    &lt;int:property name="" expression="" null-result-expression="'Could not determine the name'"/&gt;   <i class="conum" data-value="12"></i><b>(12)</b>
    &lt;int:property name="" value="23" type="java.lang.Integer" null-result-expression="'0'"/&gt;
    &lt;int:header name="" expression="" null-result-expression=""/&gt;   <i class="conum" data-value="13"></i><b>(13)</b>
    &lt;int:header name="" value="" overwrite="" type="" null-result-expression=""/&gt;
&lt;/int:enricher&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Channel to which a message is sent to get the data to use for enrichment.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lifecycle attribute signaling whether this component should be started during the application context startup.
Defaults to true.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ID of the underlying bean definition, which is either an <code>EventDrivenConsumer</code> or a <code>PollingConsumer</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a &#8220;failover&#8221; dispatching strategy.
It has no effect when this endpoint is itself a polling consumer for a channel with a queue.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Identifies the message channel where a message is sent after it is being processed by this endpoint.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>By default, the original message&#8217;s payload is used as payload that is sent to the <code>request-channel</code>.
By specifying a SpEL expression as the value for the <code>request-payload-expression</code> attribute, you can use a subset of the original payload, a header value, or any other resolvable SpEL expression as the basis for the payload that is sent to the request-channel.
For the expression evaluation, the full message is available as the 'root object'.
For instance, the following SpEL expressions (among others) are possible:
<div class="ulist">
<ul>
<li>
<p><code>payload.something</code></p>
</li>
<li>
<p><code>headers.something</code></p>
</li>
<li>
<p><code>new java.util.Date()</code></p>
</li>
<li>
<p><code>'thing1' + 'thing2'</code></p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Channel where a reply message is expected.
This is optional.
Typically, the auto-generated temporary reply channel suffices.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The channel to which an <code>ErrorMessage</code> is sent if an <code>Exception</code> occurs downstream of the <code>request-channel</code>.
This enables you to return an alternative object to use for enrichment.
If it is not set, an <code>Exception</code> is thrown to the caller.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Maximum amount of time in milliseconds to wait when sending a message to the channel, if the channel might block.
For example, a queue channel can block until space is available, if its maximum capacity has been reached.
Internally, the send timeout is set on the <code>MessagingTemplate</code> and ultimately applied when invoking the send operation on the <code>MessageChannel</code>.
By default, the send timeout is set to '-1', which can cause the send operation on the <code>MessageChannel</code>, depending on the implementation, to block indefinitely.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Boolean value indicating whether any payload that implements <code>Cloneable</code> should be cloned prior to sending the message to the request channel for acquiring the enriching data.
The cloned version would be used as the target payload for the ultimate reply.
The default is <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Lets you configure a message poller if this endpoint is a polling consumer.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Each <code>property</code> sub-element provides the name of a property (through the mandatory <code>name</code> attribute).
That property should be settable on the target payload instance.
Exactly one of the <code>value</code> or <code>expression</code> attributes must be provided as well&#8201;&#8212;&#8201;the former for a literal value to set and the latter for a SpEL expression to be evaluated.
The root object of the evaluation context is the message that was returned from the flow initiated by this enricher&#8201;&#8212;&#8201;the input message if there is no request channel or the application context (using the '@&lt;beanName&gt;.&lt;beanProperty&gt;' SpEL syntax).
Starting with version 4.0, when specifying a <code>value</code> attribute, you can also specify an optional <code>type</code> attribute.
When the destination is a typed setter method, the framework coerces the value appropriately (as long as a <code>PropertyEditor</code>) exists to handle the conversion.
If, however, the target payload is a <code>Map</code>, the entry is populated with the value without conversion.
The <code>type</code> attribute lets you, for example, convert a <code>String</code> containing a number to an <code>Integer</code> value in the target payload.
Starting with version 4.1, you can also specify an optional <code>null-result-expression</code> attribute.
When the <code>enricher</code> returns null, it is evaluated, and the output of the evaluation is returned instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Each <code>header</code> sub-element provides the name of a message header (through the mandatory <code>name</code> attribute).
Exactly one of the <code>value</code> or <code>expression</code> attributes must also be provided&#8201;&#8212;&#8201;the former for a literal value to set and the latter for a SpEL expression to be evaluated.
The root object of the evaluation context is the message that was returned from the flow initiated by this enricher&#8201;&#8212;&#8201;the input message if there is no request channel or the application context (using the '@&lt;beanName&gt;.&lt;beanProperty&gt;' SpEL syntax).
Note that, similarly to the <code>&lt;header-enricher&gt;</code>, the <code>&lt;enricher&gt;</code> element&#8217;s <code>header</code> element has <code>type</code> and <code>overwrite</code> attributes.
However, a key difference is that, with the <code>&lt;enricher&gt;</code>, the <code>overwrite</code> attribute is <code>true</code> by default, to be consistent with the <code>&lt;enricher&gt;</code> element&#8217;s <code>&lt;property&gt;</code> sub-element.
Starting with version 4.1, you can also specify an optional <code>null-result-expression</code> attribute.
When the <code>enricher</code> returns null, it is evaluated, and the output of the evaluation is returned instead.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="payload-enricher-examples"><a class="anchor" href="#payload-enricher-examples"></a>Examples</h5>
<div class="paragraph">
<p>This section contains several examples of using a payload enricher in various situations.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The code samples shown here are part of the Spring Integration Samples project.
See <a href="#samples">Spring Integration Samples</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the following example, a <code>User</code> object is passed as the payload of the <code>Message</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:enricher id="findUserEnricher"
              input-channel="findUserEnricherChannel"
              request-channel="findUserServiceChannel"&gt;
    &lt;int:property name="email"    expression="payload.email"/&gt;
    &lt;int:property name="password" expression="payload.password"/&gt;
&lt;/int:enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>User</code> has several properties, but only the <code>username</code> is set initially.
The enricher&#8217;s <code>request-channel</code> attribute is configured to pass the <code>User</code> to the <code>findUserServiceChannel</code>.</p>
</div>
<div class="paragraph">
<p>Through the implicitly set <code>reply-channel</code>, a <code>User</code> object is returned and, by using the <code>property</code> sub-element, properties from the reply are extracted and used to enrich the original payload.</p>
</div>
</div>
<div class="sect4">
<h5 id="how-do-i-pass-only-a-subset-of-data-to-the-request-channel"><a class="anchor" href="#how-do-i-pass-only-a-subset-of-data-to-the-request-channel"></a>How Do I Pass Only a Subset of Data to the Request Channel?</h5>
<div class="paragraph">
<p>When using a <code>request-payload-expression</code> attribute, a single property of the payload instead of the full message can be passed on to the request channel.
In the following example, the username property is passed on to the request channel:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:enricher id="findUserByUsernameEnricher"
              input-channel="findUserByUsernameEnricherChannel"
              request-channel="findUserByUsernameServiceChannel"
              request-payload-expression="payload.username"&gt;
    &lt;int:property name="email"    expression="payload.email"/&gt;
    &lt;int:property name="password" expression="payload.password"/&gt;
&lt;/int:enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that, although only the username is passed, the resulting message to the request channel contains the full set of <code>MessageHeaders</code>.</p>
</div>
<div class="sect5">
<h6 id="how-can-i-enrich-payloads-that-consist-of-collection-data"><a class="anchor" href="#how-can-i-enrich-payloads-that-consist-of-collection-data"></a>How Can I Enrich Payloads that Consist of Collection Data?</h6>
<div class="paragraph">
<p>In the following example, instead of a <code>User</code> object, a <code>Map</code> is passed in:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:enricher id="findUserWithMapEnricher"
              input-channel="findUserWithMapEnricherChannel"
              request-channel="findUserByUsernameServiceChannel"
              request-payload-expression="payload.username"&gt;
    &lt;int:property name="user" expression="payload"/&gt;
&lt;/int:enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Map</code> contains the username under the <code>username</code> map key.
Only the <code>username</code> is passed on to the request channel.
The reply contains a full <code>User</code> object, which is ultimately added to the <code>Map</code> under the <code>user</code> key.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-can-i-enrich-payloads-with-static-information-without-using-a-request-channel"><a class="anchor" href="#how-can-i-enrich-payloads-with-static-information-without-using-a-request-channel"></a>How Can I Enrich Payloads with Static Information without Using a Request Channel?</h5>
<div class="paragraph">
<p>The following example does not use a request channel at all but solely enriches the message&#8217;s payload with static values:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:enricher id="userEnricher"
              input-channel="input"&gt;
    &lt;int:property name="user.updateDate" expression="new java.util.Date()"/&gt;
    &lt;int:property name="user.firstName" value="William"/&gt;
    &lt;int:property name="user.lastName"  value="Shakespeare"/&gt;
    &lt;int:property name="user.age"       value="42"/&gt;
&lt;/int:enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the word, 'static', is used loosely here.
You can still use SpEL expressions for setting those values.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="claim-check"><a class="anchor" href="#claim-check"></a>9.3. Claim Check</h3>
<div class="paragraph">
<p>In earlier sections, we covered several content enricher components that can help you deal with situations where a message is missing a piece of data.
We also discussed content filtering, which lets you remove data items from a message.
However, there are times when we want to hide data temporarily.
For example, in a distributed system, we may receive a message with a very large payload.
Some intermittent message processing steps may not need access to this payload and some may only need to access certain headers, so carrying the large message payload through each processing step may cause performance degradation, may produce a security risk, and may make debugging more difficult.</p>
</div>
<div class="paragraph">
<p>The <a href="https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">store in library</a> (or claim check) pattern describes a mechanism that lets you store data in a well known place while maintaining only a pointer (a claim check) to where that data is located.
You can pass that pointer around as the payload of a new message, thereby letting any component within the message flow get the actual data as soon as it needs it.
This approach is very similar to the certified mail process, where you get a claim check in your mailbox and then have to go to the post office to claim your actual package.
It is also the same idea as baggage claim after a flight or in a hotel.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides two types of claim check transformers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Incoming Claim Check Transformer</p>
</li>
<li>
<p>Outgoing Claim Check Transformer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Convenient namespace-based mechanisms are available to configure them.</p>
</div>
<div class="sect3">
<h4 id="claim-check-in"><a class="anchor" href="#claim-check-in"></a>9.3.1. Incoming Claim Check Transformer</h4>
<div class="paragraph">
<p>An incoming claim check transformer transforms an incoming message by storing it in the message store identified by its <code>message-store</code> attribute.
The following example defines an incoming claim check transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:claim-check-in id="checkin"
        input-channel="checkinChannel"
        message-store="testMessageStore"
        output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, the message that is received on the <code>input-channel</code> is persisted to the message store identified with the <code>message-store</code> attribute and indexed with a generated ID.
That ID is the claim check for that message.
The claim check also becomes the payload of the new (transformed) message that is sent to the <code>output-channel</code>.</p>
</div>
<div class="paragraph">
<p>Now, assume that at some point you do need access to the actual message.
You can access the message store manually and get the contents of the message, or you can use the same approach (creating a transformer) except that now you transform the Claim Check to the actual message by using an outgoing claim check transformer.</p>
</div>
<div class="paragraph">
<p>The following listing provides an overview of all available parameters of an incoming claim check transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:claim-check-in auto-startup="true"  <i class="conum" data-value="1"></i><b>(1)</b>
                    id=""                           <i class="conum" data-value="2"></i><b>(2)</b>
                    input-channel=""                <i class="conum" data-value="3"></i><b>(3)</b>
                    message-store="messageStore"    <i class="conum" data-value="4"></i><b>(4)</b>
                    order=""                        <i class="conum" data-value="5"></i><b>(5)</b>
                    output-channel=""               <i class="conum" data-value="6"></i><b>(6)</b>
                    send-timeout=""&gt;                <i class="conum" data-value="7"></i><b>(7)</b>
    &lt;int:poller&gt;&lt;/int:poller&gt;                       <i class="conum" data-value="8"></i><b>(8)</b>
&lt;/int:claim-check-in&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lifecycle attribute signaling whether this component should be started during application context startup.
It defaults to <code>true</code>.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ID identifying the underlying bean definition (<code>MessageTransformingHandler</code>).
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receiving message channel of this endpoint.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Reference to the <code>MessageStore</code> to be used by this claim check transformer.
If not specified, the default reference is to a bean named <code>messageStore</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel uses a <code>failover</code> dispatching strategy.
It has no effect when this endpoint is itself a polling consumer for a channel with a queue.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Identifies the message channel where the message is sent after being processed by this endpoint.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Specifies the maximum amount of time (in milliseconds) to wait when sending a reply message to the output channel.
Defaults to <code>-1</code>&#8201;&#8212;&#8201;blocking indefinitely.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Defines a poller.
This element is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="claim-check-out"><a class="anchor" href="#claim-check-out"></a>9.3.2. Outgoing Claim Check Transformer</h4>
<div class="paragraph">
<p>An outgoing claim check transformer lets you transform a message with a claim check payload into a message with the original content as its payload.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:claim-check-out id="checkout"
        input-channel="checkoutChannel"
        message-store="testMessageStore"
        output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, the message received on the <code>input-channel</code> should have a claim check as its payload.
The outgoing claim check transformer transforms it into a message with the original payload by querying the message store for a message identified by the provided claim check.
It then sends the newly checked-out message to the <code>output-channel</code>.</p>
</div>
<div class="paragraph">
<p>The following listing provides an overview of all available parameters of an outgoing claim check transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:claim-check-out auto-startup="true"  <i class="conum" data-value="1"></i><b>(1)</b>
                     id=""                           <i class="conum" data-value="2"></i><b>(2)</b>
                     input-channel=""                <i class="conum" data-value="3"></i><b>(3)</b>
                     message-store="messageStore"    <i class="conum" data-value="4"></i><b>(4)</b>
                     order=""                        <i class="conum" data-value="5"></i><b>(5)</b>
                     output-channel=""               <i class="conum" data-value="6"></i><b>(6)</b>
                     remove-message="false"          <i class="conum" data-value="7"></i><b>(7)</b>
                     send-timeout=""&gt;                <i class="conum" data-value="8"></i><b>(8)</b>
    &lt;int:poller&gt;&lt;/int:poller&gt;                        <i class="conum" data-value="9"></i><b>(9)</b>
&lt;/int:claim-check-out&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lifecycle attribute signaling whether this component should be started during application context startup.
It defaults to <code>true</code>.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ID identifying the underlying bean definition (<code>MessageTransformingHandler</code>).
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receiving message channel of this endpoint.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Reference to the <code>MessageStore</code> to be used by this claim check transformer.
If not specified, the default reference is to a bean named <code>messageStore</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a <code>failover</code> dispatching strategy.
It has no effect when this endpoint is itself a polling consumer for a channel with a queue.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Identifies the message channel where the message is sent after being processed by this endpoint.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>If set to <code>true</code>, the message is removed from the <code>MessageStore</code> by this transformer.
This setting is useful when Message can be &#8220;claimed&#8221; only once.
It defaults to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Specifies the maximum amount of time (in milliseconds) to wait when sending a reply message to the output channel.
It defaults to <code>-1</code>&#8201;&#8212;&#8201;blocking indefinitely.
This attribute is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Defines a poller.
This element is not available inside a <code>Chain</code> element.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="claim-once"><a class="anchor" href="#claim-once"></a>9.3.3. Claim Once</h4>
<div class="paragraph">
<p>Sometimes, a particular message must be claimed only once.
As an analogy, consider process of handling airplane luggage.
You checking in your luggage on departure and claiming it on arrival.
Once the luggage has been claimed, it can not be claimed again without first checking it back in.
To accommodate such cases, we introduced a <code>remove-message</code> boolean attribute on the <code>claim-check-out</code> transformer.
This attribute is set to <code>false</code> by default.
However, if set to <code>true</code>, the claimed message is removed from the <code>MessageStore</code> so that it cannot be claimed again.</p>
</div>
<div class="paragraph">
<p>This feature has an impact in terms of storage space, especially in the case of the in-memory <code>Map</code>-based <code>SimpleMessageStore</code>, where failing to remove messages could ultimately lead to an <code>OutOfMemoryException</code>.
Therefore, if you do not expect multiple claims to be made, we recommend that you set the <code>remove-message</code> attribute&#8217;s value to <code>true</code>.
The following example show how to use the <code>remove-message</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:claim-check-out id="checkout"
        input-channel="checkoutChannel"
        message-store="testMessageStore"
        output-channel="output"
        remove-message="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="a-word-on-message-store"><a class="anchor" href="#a-word-on-message-store"></a>9.3.4. A Word on Message Store</h4>
<div class="paragraph">
<p>Although we rarely care about the details of the claim checks (as long as they work), you should know that the current implementation of the actual claim check (the pointer) in Spring Integration uses a UUID to ensure uniqueness.</p>
</div>
<div class="paragraph">
<p><code>org.springframework.integration.store.MessageStore</code> is a strategy interface for storing and retrieving messages.
Spring Integration provides two convenient implementations of it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleMessageStore</code>: An in-memory, <code>Map</code>-based implementation (the default, good for testing)</p>
</li>
<li>
<p><code>JdbcMessageStore</code>: An implementation that uses a relational database over JDBC</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="codec"><a class="anchor" href="#codec"></a>9.4. Codec</h3>
<div class="paragraph">
<p>Version 4.2 of Spring Integration introduced the <code>Codec</code> abstraction.
Codecs encode and decode objects to and from <code>byte[]</code>.
They offer an alternative to Java serialization.
One advantage is that, typically, objects need not implement <code>Serializable</code>.
We provide one implementation that uses <a href="https://github.com/EsotericSoftware/kryo">Kryo</a> for serialization, but you can provide your own implementation for use in any of the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EncodingPayloadTransformer</code></p>
</li>
<li>
<p><code>DecodingTransformer</code></p>
</li>
<li>
<p><code>CodecMessageConverter</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="encodingpayloadtransformer"><a class="anchor" href="#encodingpayloadtransformer"></a>9.4.1. <code>EncodingPayloadTransformer</code></h4>
<div class="paragraph">
<p>This transformer encodes the payload to a <code>byte[]</code> by using the codec.
It does not affect message headers.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/EncodingPayloadTransformer.html">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="decodingtransformer"><a class="anchor" href="#decodingtransformer"></a>9.4.2. <code>DecodingTransformer</code></h4>
<div class="paragraph">
<p>This transformer decodes a <code>byte[]</code> by using the codec.
It needs to be configured with the <code>Class</code> to which the object should be decoded (or an expression that resolves to a <code>Class</code>).
If the resulting object is a <code>Message&lt;?&gt;</code>, inbound headers are not retained.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/DecodingTransformer.html">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="codecmessageconverter"><a class="anchor" href="#codecmessageconverter"></a>9.4.3. <code>CodecMessageConverter</code></h4>
<div class="paragraph">
<p>Certain endpoints (such as TCP and Redis) have no concept of message headers.
They support the use of a <code>MessageConverter</code>, and the <code>CodecMessageConverter</code> can be used to convert a message to or from a <code>byte[]</code> for
transmission.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/codec/CodecMessageConverter.html">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="kryo"><a class="anchor" href="#kryo"></a>9.4.4. Kryo</h4>
<div class="paragraph">
<p>Currently, this is the only implementation of <code>Codec</code>, and it provides two kinds of <code>Codec</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PojoCodec</code>: Used in the transformers</p>
</li>
<li>
<p><code>MessageCodec</code>: Used in the <code>CodecMessageConverter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The framework provides several custom serializers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileSerializer</code></p>
</li>
<li>
<p><code>MessageHeadersSerializer</code></p>
</li>
<li>
<p><code>MutableMessageHeadersSerializer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first can be used with the <code>PojoCodec</code> by initializing it with the <code>FileKryoRegistrar</code>.
The second and third are used with the <code>MessageCodec</code>, which is initialized with the <code>MessageKryoRegistrar</code>.</p>
</div>
<div class="sect4">
<h5 id="customizing-kryo"><a class="anchor" href="#customizing-kryo"></a>Customizing Kryo</h5>
<div class="paragraph">
<p>By default, Kryo delegates unknown Java types to its <code>FieldSerializer</code>.
Kryo also registers default serializers for each primitive type, along with <code>String</code>, <code>Collection</code>, and <code>Map</code>.
<code>FieldSerializer</code> uses reflection to navigate the object graph.
A more efficient approach is to implement a custom serializer that is aware of the object&#8217;s structure and can directly serialize selected primitive fields.
The following example shows such a serializer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AddressSerializer extends Serializer&lt;Address&gt; {

    @Override
    public void write(Kryo kryo, Output output, Address address) {
        output.writeString(address.getStreet());
        output.writeString(address.getCity());
        output.writeString(address.getCountry());
    }

    @Override
    public Address read(Kryo kryo, Input input, Class&lt;Address&gt; type) {
        return new Address(input.readString(), input.readString(), input.readString());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Serializer</code> interface exposes <code>Kryo</code>, <code>Input</code>, and <code>Output</code>, which provide complete control over which fields are included and other internal settings, as described in the <a href="https://github.com/EsotericSoftware/kryo">Kryo documentation</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When registering your custom serializer, you need a registration ID.
The registration IDs are arbitrary.
However, in our case, the IDs must be explicitly defined, because each Kryo instance across the distributed application must use the same IDs.
Kryo recommends small positive integers and reserves a few ids (value &lt; 10).
Spring Integration currently defaults to using 40, 41, and 42 (for the file and message header serializers mentioned earlier).
We recommend you start at 60, to allow for expansion in the framework.
You can override these framework defaults by configuring the registrars mentioned earlier.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="using-a-custom-kryo-serializer"><a class="anchor" href="#using-a-custom-kryo-serializer"></a>Using a Custom Kryo Serializer</h6>
<div class="paragraph">
<p>If you need custom serialization, see the <a href="https://github.com/EsotericSoftware/kryo">Kryo</a> documentation, because you need to use the native API to do the customization.
For an example, see the <a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-core/src/main/java/org/springframework/integration/codec/kryo/MessageCodec.java"><code>MessageCodec</code></a> implementation.</p>
</div>
</div>
<div class="sect5">
<h6 id="implementing-kryoserializable"><a class="anchor" href="#implementing-kryoserializable"></a>Implementing KryoSerializable</h6>
<div class="paragraph">
<p>If you have write access to the domain object source code, you can implement <code>KryoSerializable</code> as described <a href="https://github.com/EsotericSoftware/kryo#kryoserializable">here</a>.
In this case, the class provides the serialization methods itself and no further configuration is required.
However benchmarks have shown this is not quite as efficient as registering a custom serializer explicitly.
The following example shows a custom Kryo serializer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Address implements KryoSerializable {
    ...

    @Override
    public void write(Kryo kryo, Output output) {
        output.writeString(this.street);
        output.writeString(this.city);
        output.writeString(this.country);
    }

    @Override
    public void read(Kryo kryo, Input input) {
        this.street = input.readString();
        this.city = input.readString();
        this.country = input.readString();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use this technique to wrap a serialization library other than Kryo.</p>
</div>
</div>
<div class="sect5">
<h6 id="using-the-defaultserializer-annotation"><a class="anchor" href="#using-the-defaultserializer-annotation"></a>Using the <code>@DefaultSerializer</code> Annotation</h6>
<div class="paragraph">
<p>Kryo also provides a <code>@DefaultSerializer</code> annotation, as described <a href="https://github.com/EsotericSoftware/kryo#default-serializers">here</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DefaultSerializer(SomeClassSerializer.class)
public class SomeClass {
       // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you have write access to the domain object, this may be a simpler way to specify a custom serializer.
Note that this does not register the class with an ID, which may make the technique unhelpful for certain situations.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="messaging-endpoints-chapter"><a class="anchor" href="#messaging-endpoints-chapter"></a>10. Messaging Endpoints</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="endpoint"><a class="anchor" href="#endpoint"></a>10.1. Message Endpoints</h3>
<div class="paragraph">
<p>The first part of this chapter covers some background theory and reveals quite a bit about the underlying API that drives Spring Integration&#8217;s various messaging components.
This information can be helpful if you want to really understand what goes on behind the scenes.
However, if you want to get up and running with the simplified namespace-based configuration of the various elements, feel free to skip ahead to <a href="#endpoint-namespace">Endpoint Namespace Support</a> for now.</p>
</div>
<div class="paragraph">
<p>As mentioned in the overview, message endpoints are responsible for connecting the various messaging components to channels.
Over the next several chapters, we cover a number of different components that consume messages.
Some of these are also capable of sending reply messages.
Sending messages is quite straightforward.
As shown earlier in <a href="#channel">Message Channels</a>, you can send a message to a message channel.
However, receiving is a bit more complicated.
The main reason is that there are two types of consumers: <a href="https://www.enterpriseintegrationpatterns.com/PollingConsumer.html">polling consumers</a> and <a href="https://www.enterpriseintegrationpatterns.com/EventDrivenConsumer.html">event-driven consumers</a>.</p>
</div>
<div class="paragraph">
<p>Of the two, event-driven consumers are much simpler.
Without any need to manage and schedule a separate poller thread, they are essentially listeners with a callback method.
When connecting to one of Spring Integration&#8217;s subscribable message channels, this simple option works great.
However, when connecting to a buffering, pollable message channel, some component has to schedule and manage the polling threads.
Spring Integration provides two different endpoint implementations to accommodate these two types of consumers.
Therefore, the consumers themselves need only implement the callback interface.
When polling is required, the endpoint acts as a container for the consumer instance.
The benefit is similar to that of using a container for hosting message-driven beans, but, since these consumers are Spring-managed objects running within an <code>ApplicationContext</code>, it more closely resembles Spring&#8217;s own <code>MessageListener</code> containers.</p>
</div>
<div class="sect3">
<h4 id="endpoint-handler"><a class="anchor" href="#endpoint-handler"></a>10.1.1. Message Handler</h4>
<div class="paragraph">
<p>Spring Integration&#8217;s <code>MessageHandler</code> interface is implemented by many of the components within the framework.
In other words, this is not part of the public API, and you would not typically implement <code>MessageHandler</code> directly.
Nevertheless, it is used by a message consumer for actually handling the consumed messages, so being aware of this strategy interface does help in terms of understanding the overall role of a consumer.
The interface is defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MessageHandler {

    void handleMessage(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Despite its simplicity, this interface provides the foundation for most of the components (routers, transformers, splitters, aggregators, service activators, and others) covered in the following chapters.
Those components each perform very different functionality with the messages they handle, but the requirements for actually receiving a message are the same, and the choice between polling and event-driven behavior is also the same.
Spring Integration provides two endpoint implementations that host these callback-based handlers and let them be connected to message channels.</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-eventdrivenconsumer"><a class="anchor" href="#endpoint-eventdrivenconsumer"></a>10.1.2. Event-driven Consumer</h4>
<div class="paragraph">
<p>Because it is the simpler of the two, we cover the event-driven consumer endpoint first.
You may recall that the <code>SubscribableChannel</code> interface provides a <code>subscribe()</code> method and that the method accepts a <code>MessageHandler</code> parameter (as shown in <a href="#channel-interfaces-subscribablechannel"><code>SubscribableChannel</code></a>).
The following listing shows the definition of the <code>subscribe</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">subscribableChannel.subscribe(messageHandler);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since a handler that is subscribed to a channel does not have to actively poll that channel, this is an event-driven consumer, and the implementation provided by Spring Integration accepts a <code>SubscribableChannel</code> and a <code>MessageHandler</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SubscribableChannel channel = context.getBean("subscribableChannel", SubscribableChannel.class);

EventDrivenConsumer consumer = new EventDrivenConsumer(channel, exampleHandler);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-pollingconsumer"><a class="anchor" href="#endpoint-pollingconsumer"></a>10.1.3. Polling Consumer</h4>
<div class="paragraph">
<p>Spring Integration also provides a <code>PollingConsumer</code>, and it can be instantiated in the same way except that the channel must implement <code>PollableChannel</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PollableChannel channel = context.getBean("pollableChannel", PollableChannel.class);

PollingConsumer consumer = new PollingConsumer(channel, exampleHandler);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information regarding polling consumers, see <a href="#polling-consumer">Poller</a> and <a href="#channel-adapter">Channel Adapter</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are many other configuration options for the polling consumer.
For example, the trigger is a required property.
The following example shows how to set the trigger:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PollingConsumer consumer = new PollingConsumer(channel, handler);

consumer.setTrigger(new IntervalTrigger(30, TimeUnit.SECONDS));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Integration currently provides two implementations of the <code>Trigger</code> interface: <code>IntervalTrigger</code> and <code>CronTrigger</code>.
The <code>IntervalTrigger</code> is typically defined with a simple interval (in milliseconds) but also supports an <code>initialDelay</code> property and a boolean <code>fixedRate</code> property (the default is <code>false</code>&#8201;&#8212;&#8201;that is, no fixed delay).
The following example sets both properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntervalTrigger trigger = new IntervalTrigger(1000);
trigger.setInitialDelay(5000);
trigger.setFixedRate(true);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the three settings in the preceding example is a trigger that waits five seconds and then triggers every second.</p>
</div>
<div class="paragraph">
<p>The <code>CronTrigger</code> requires a valid cron expression.
See the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/support/CronTrigger.html">Javadoc</a> for details.
The following example sets a new <code>CronTrigger</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CronTrigger trigger = new CronTrigger("*/10 * * * * MON-FRI");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the trigger defined in the previous example is a trigger that triggers every ten seconds, Monday through Friday.</p>
</div>
<div class="paragraph">
<p>In addition to the trigger, you can specify two other polling-related configuration properties: <code>maxMessagesPerPoll</code> and <code>receiveTimeout</code>.
The following example shows how to set these two properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PollingConsumer consumer = new PollingConsumer(channel, handler);

consumer.setMaxMessagesPerPoll(10);
consumer.setReceiveTimeout(5000);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>maxMessagesPerPoll</code> property specifies the maximum number of messages to receive within a given poll operation.
This means that the poller continues calling receive() without waiting, until either <code>null</code> is returned or the maximum value is reached.
For example, if a poller has a ten-second interval trigger and a <code>maxMessagesPerPoll</code> setting of <code>25</code>, and it is polling a channel that has 100 messages in its queue, all 100 messages can be retrieved within 40 seconds.
It grabs 25, waits ten seconds, grabs the next 25, and so on.</p>
</div>
<div class="paragraph">
<p>The <code>receiveTimeout</code> property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.
For example, consider two options that seem similar on the surface but are actually quite different: The first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds, while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.
The first one may receive a message up to 4950 milliseconds later than it arrived on the channel (if that message arrived immediately after one of its poll calls returned).
On the other hand, the second configuration never misses a message by more than 50 milliseconds.
The difference is that the second option requires a thread to wait.
However, as a result, it can respond much more quickly to arriving messages.
This technique, known as &#8220;long polling&#8221;, can be used to emulate event-driven behavior on a polled source.</p>
</div>
<div class="paragraph">
<p>A polling consumer can also delegate to a Spring <code>TaskExecutor</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PollingConsumer consumer = new PollingConsumer(channel, handler);

TaskExecutor taskExecutor = context.getBean("exampleExecutor", TaskExecutor.class);
consumer.setTaskExecutor(taskExecutor);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Furthermore, a <code>PollingConsumer</code> has a property called <code>adviceChain</code>.
This property lets you to specify a <code>List</code> of AOP advices for handling additional cross cutting concerns including transactions.
These advices are applied around the <code>doPoll()</code> method.
For more in-depth information, see the sections on AOP advice chains and transaction support under <a href="#endpoint-namespace">Endpoint Namespace Support</a>.</p>
</div>
<div class="paragraph">
<p>The earlier examples show dependency lookups.
However, keep in mind that these consumers are most often configured as Spring bean definitions.
In fact, Spring Integration also provides a <code>FactoryBean</code> called <code>ConsumerEndpointFactoryBean</code> that creates the appropriate consumer type based on the type of channel.
Also, Spring Integration has full XML namespace support to even further hide those details.
The namespace-based configuration is in this guide featured as each component type is introduced.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Many of the <code>MessageHandler</code> implementations can generate reply messages.
As mentioned earlier, sending messages is trivial when compared to receiving messages.
Nevertheless, when and how many reply messages are sent depends on the handler type.
For example, an aggregator waits for a number of messages to arrive and is often configured as a downstream consumer for a splitter, which can generate multiple replies for each message it handles.
When using the namespace configuration, you do not strictly need to know all of the details.
However, it still might be worth knowing that several of these components share a common base class, the <code>AbstractReplyProducingMessageHandler</code>, and that it provides a <code>setOutputChannel(..)</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-namespace"><a class="anchor" href="#endpoint-namespace"></a>10.1.4. Endpoint Namespace Support</h4>
<div class="paragraph">
<p>Throughout this reference manual, you can find specific configuration examples for endpoint elements, such as router, transformer, service-activator, and so on.
Most of these support an <code>input-channel</code> attribute and many support an <code>output-channel</code> attribute.
After being parsed, these endpoint elements produce an instance of either the <code>PollingConsumer</code> or the <code>EventDrivenConsumer</code>, depending on the type of the <code>input-channel</code> that is referenced: <code>PollableChannel</code> or <code>SubscribableChannel</code>, respectively.
When the channel is pollable, the polling behavior is based on the endpoint element&#8217;s <code>poller</code> sub-element and its attributes.</p>
</div>
<div class="paragraph">
<p>The following listing lists all of the available configuration options for a <code>poller</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller cron=""                                  <i class="conum" data-value="1"></i><b>(1)</b>
            default="false"                          <i class="conum" data-value="2"></i><b>(2)</b>
            error-channel=""                         <i class="conum" data-value="3"></i><b>(3)</b>
            fixed-delay=""                           <i class="conum" data-value="4"></i><b>(4)</b>
            fixed-rate=""                            <i class="conum" data-value="5"></i><b>(5)</b>
            id=""                                    <i class="conum" data-value="6"></i><b>(6)</b>
            max-messages-per-poll=""                 <i class="conum" data-value="7"></i><b>(7)</b>
            receive-timeout=""                       <i class="conum" data-value="8"></i><b>(8)</b>
            ref=""                                   <i class="conum" data-value="9"></i><b>(9)</b>
            task-executor=""                         <i class="conum" data-value="10"></i><b>(10)</b>
            time-unit="MILLISECONDS"                 <i class="conum" data-value="11"></i><b>(11)</b>
            trigger=""&gt;                              <i class="conum" data-value="12"></i><b>(12)</b>
            &lt;int:advice-chain /&gt;                     <i class="conum" data-value="13"></i><b>(13)</b>
            &lt;int:transactional /&gt;                    <i class="conum" data-value="14"></i><b>(14)</b>
&lt;/int:poller&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Provides the ability to configure pollers by using Cron expressions.
The underlying implementation uses an <code>org.springframework.scheduling.support.CronTrigger</code>.
If this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>trigger</code>, <code>fixed-rate</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>By setting this attribute to <code>true</code>, you can define exactly one global default poller.
An exception is raised if more than one default poller is defined in the application context.
Any endpoints connected to a <code>PollableChannel</code> (<code>PollingConsumer</code>) or any <code>SourcePollingChannelAdapter</code> that does not have an explicitly configured poller then uses the global default poller.
It defaults to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Identifies the channel to which error messages are sent if a failure occurs in this poller&#8217;s invocation.
To completely suppress exceptions, you can provide a reference to the <code>nullChannel</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The fixed delay trigger uses a <code>PeriodicTrigger</code> under the covers.
If you do not use the <code>time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code>fixed-rate</code>, <code>trigger</code>, <code>cron</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The fixed rate trigger uses a <code>PeriodicTrigger</code> under the covers.
If you do not use the <code>time-unit</code> attribute, the specified value is represented in milliseconds.
If this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>trigger</code>, <code>cron</code>, and <code>ref</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The ID referring to the poller&#8217;s underlying bean-definition, which is of type <code>org.springframework.integration.scheduling.PollerMetadata</code>.
The <code>id</code> attribute is required for a top-level poller element, unless it is the default poller (<code>default="true"</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>See <a href="#channel-adapter-namespace-inbound">Configuring An Inbound Channel Adapter</a> for more information.
If not specified, the default value depends on the context.
If you use a <code>PollingConsumer</code>, this attribute defaults to <code>-1</code>.
However, if you use a <code>SourcePollingChannelAdapter</code>, the <code>max-messages-per-poll</code> attribute defaults to <code>1</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Value is set on the underlying class <code>PollerMetadata</code>.
If not specified, it defaults to 1000 (milliseconds).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Bean reference to another top-level poller.
The <code>ref</code> attribute must not be present on the top-level <code>poller</code> element.
However, if this attribute is set, none of the following attributes must be specified: <code>fixed-rate</code>, <code>trigger</code>, <code>cron</code>, and <code>fixed-delay</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Provides the ability to reference a custom task executor.
See <a href="#taskexecutor-support">TaskExecutor Support</a> for further information.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>This attribute specifies the <code>java.util.concurrent.TimeUnit</code> enum value on the underlying <code>org.springframework.scheduling.support.PeriodicTrigger</code>.
Therefore, this attribute can be used only in combination with the <code>fixed-delay</code> or <code>fixed-rate</code> attributes.
If combined with either <code>cron</code> or a <code>trigger</code> reference attribute, it causes a failure.
The minimal supported granularity for a <code>PeriodicTrigger</code> is milliseconds.
Therefore, the only available options are milliseconds and seconds.
If this value is not provided, any <code>fixed-delay</code> or <code>fixed-rate</code> value is interpreted as milliseconds.
Basically, this enum provides a convenience for seconds-based interval trigger values.
For hourly, daily, and monthly settings, we recommend using a <code>cron</code> trigger instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Reference to any Spring-configured bean that implements the <code>org.springframework.scheduling.Trigger</code> interface.
However, if this attribute is set, none of the following attributes must be specified: <code>fixed-delay</code>, <code>fixed-rate</code>, <code>cron</code>, and <code>ref</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Allows specifying extra AOP advices to handle additional cross-cutting concerns.
See <a href="#transaction-support">Transaction Support</a> for further information.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>Pollers can be made transactional.
See <a href="#aop-advice-chains">AOP Advice chains</a> for further information.
Optional.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="examples"><a class="anchor" href="#examples"></a>Examples</h5>
<div class="paragraph">
<p>A simple interval-based poller with a 1-second interval can be configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an alternative to using the <code>fixed-rate</code> attribute, you can also use the <code>fixed-delay</code> attribute.</p>
</div>
<div class="paragraph">
<p>For a poller based on a Cron expression, use the <code>cron</code> attribute instead, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller cron="*/10 * * * * MON-FRI"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the input channel is a <code>PollableChannel</code>, the poller configuration is required.
Specifically, as mentioned earlier, the <code>trigger</code> is a required property of the <code>PollingConsumer</code> class.
Therefore, if you omit the <code>poller</code> sub-element for a polling consumer endpoint&#8217;s configuration, an exception may be thrown.
The exception may also be thrown if you attempt to configure a poller on the element that is connected to a non-pollable channel.</p>
</div>
<div class="paragraph">
<p>It is also possible to create top-level pollers, in which case only a <code>ref</code> attribute is required, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller id="weekdayPoller" cron="*/10 * * * * MON-FRI"/&gt;

&lt;int:transformer input-channel="pollable"
    ref="transformer"
    output-channel="output"&gt;
    &lt;int:poller ref="weekdayPoller"/&gt;
&lt;/int:transformer&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ref</code> attribute is allowed only on the inner poller definitions.
Defining this attribute on a top-level poller results in a configuration exception being thrown during initialization of the application context.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="global-default-pollers"><a class="anchor" href="#global-default-pollers"></a>Global Default Pollers</h6>
<div class="paragraph">
<p>To simplify the configuration even further, you can define a global default poller.
A single top-level poller within an <code>ApplicationContext</code> may have the <code>default</code> attribute set to <code>true</code>.
In that case, any endpoint with a <code>PollableChannel</code> for its input channel, that is defined within the same <code>ApplicationContext</code>, and has no explicitly configured <code>poller</code> sub-element uses that default.
The following example shows such a poller and a transformer that uses it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller id="defaultPoller" default="true" max-messages-per-poll="5" fixed-rate="3000"/&gt;

&lt;!-- No &lt;poller/&gt; sub-element is necessary, because there is a default --&gt;
&lt;int:transformer input-channel="pollable"
                 ref="transformer"
                 output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="transaction-support"><a class="anchor" href="#transaction-support"></a>Transaction Support</h6>
<div class="paragraph">
<p>Spring Integration also provides transaction support for the pollers so that each receive-and-forward operation can be performed as an atomic unit of work.
To configure transactions for a poller, add the <code>&lt;transactional/&gt;</code> sub-element.
The following example shows the available attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller fixed-delay="1000"&gt;
    &lt;int:transactional transaction-manager="txManager"
                       propagation="REQUIRED"
                       isolation="REPEATABLE_READ"
                       timeout="10000"
                       read-only="false"/&gt;
&lt;/int:poller&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see <a href="#transaction-poller">Poller Transaction Support</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-chains"><a class="anchor" href="#aop-advice-chains"></a>AOP Advice chains</h5>
<div class="paragraph">
<p>Since Spring transaction support depends on the proxy mechanism with <code>TransactionInterceptor</code> (AOP Advice) handling transactional behavior of the message flow initiated by the poller, you must sometimes provide extra advices to handle other cross cutting behavior associated with the poller.
For that, the <code>poller</code> defines an <code>advice-chain</code>element that lets you add more advices in a class thatimplements the <code>MethodInterceptor</code> interface.
The following example shows how to define an <code>advice-chain</code> for a <code>poller</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator id="advicedSa" input-channel="goodInputWithAdvice" ref="testBean"
		method="good" output-channel="output"&gt;
	&lt;int:poller max-messages-per-poll="1" fixed-rate="10000"&gt;
		 &lt;int:advice-chain&gt;
			&lt;ref bean="adviceA" /&gt;
			&lt;beans:bean class="org.something.SampleAdvice" /&gt;
			&lt;ref bean="txAdvice" /&gt;
		&lt;/int:advice-chain&gt;
	&lt;/int:poller&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information on how to implement the <code>MethodInterceptor</code> interface, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api">AOP sections of the Spring Framework Reference Guide</a>.
An advice chain can also be applied on a poller that does not have any transaction configuration, letting you enhance the behavior of the message flow initiated by the poller.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using an advice chain, the <code>&lt;transactional/&gt;</code> child element cannot be specified.
Instead, declare a <code>&lt;tx:advice/&gt;</code> bean and add it to the <code>&lt;advice-chain/&gt;</code>.
See <a href="#transaction-poller">Poller Transaction Support</a> for complete configuration details.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="taskexecutor-support"><a class="anchor" href="#taskexecutor-support"></a>TaskExecutor Support</h6>
<div class="paragraph">
<p>The polling threads may be executed by any instance of Spring&#8217;s <code>TaskExecutor</code> abstraction.
This enables concurrency for an endpoint or group of endpoints.
As of Spring 3.0, the core Spring Framework has a <code>task</code> namespace, and its <code>&lt;executor/&gt;</code> element supports the creation of a simple thread pool executor.
That element accepts attributes for common concurrency settings, such as pool-size and queue-capacity.
Configuring a thread-pooling executor can make a substantial difference in how the endpoint performs under load.
These settings are available for each endpoint, since the performance of an endpoint is one of the major factors to consider (the other major factor being the expected volume on the channel to which the endpoint subscribes).
To enable concurrency for a polling endpoint that is configured with the XML namespace support, provide the <code>task-executor</code> reference on its <code>&lt;poller/&gt;</code> element and then provide one or more of the properties shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller task-executor="pool" fixed-rate="1000"/&gt;

&lt;task:executor id="pool"
               pool-size="5-25"
               queue-capacity="20"
               keep-alive="120"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not provide a task-executor, the consumer&#8217;s handler is invoked in the caller&#8217;s thread.
Note that the caller is usually the default <code>TaskScheduler</code> (see <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>).
You should also keep in mind that the <code>task-executor</code> attribute can provide a reference to any implementation of Spring&#8217;s <code>TaskExecutor</code> interface by specifying the bean name.
The <code>executor</code> element shown earlier is provided for convenience.</p>
</div>
<div class="paragraph">
<p>As mentioned earlier in the <a href="#endpoint-pollingconsumer">background section for polling consumers</a>, you can also configure a polling consumer in such a way as to emulate event-driven behavior.
With a long <code>receive-timeout</code> and a short <code>interval-trigger</code>, you can ensure a very timely reaction to arriving messages even on a polled message source.
Note that this applies only  to sources that have a blocking wait call with a timeout.
For example, the file poller does not block.
Each receive() call returns immediately and either contains new files or not.
Therefore, even if a poller contains a long <code>receive-timeout</code>, that value would never be used in such a scenario.
On the other hand, when using Spring Integration&#8217;s own queue-based channels, the timeout value does have a chance to participate.
The following example shows how a polling consumer can receive messages nearly instantaneously:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="someQueueChannel"
    output-channel="output"&gt;
    &lt;int:poller receive-timeout="30000" fixed-rate="10"/&gt;

&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using this approach does not carry much overhead, since, internally, it is nothing more then a timed-wait thread, which does not require nearly as much CPU resource usage as (for example) a thrashing, infinite while loop.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="polling-consumer-change-polling-rate"><a class="anchor" href="#polling-consumer-change-polling-rate"></a>10.1.5. Changing Polling Rate at Runtime</h4>
<div class="paragraph">
<p>When configuring a poller with a <code>fixed-delay</code> or a <code>fixed-rate</code> attribute, the default implementation uses a <code>PeriodicTrigger</code> instance.
The <code>PeriodicTrigger</code> is part of the core Spring Framework.
It accepts the interval only as a constructor argument.
Therefore, it cannot be changed at runtime.</p>
</div>
<div class="paragraph">
<p>However, you can define your own implementation of the <code>org.springframework.scheduling.Trigger</code> interface.
You could even use the <code>PeriodicTrigger</code> as a starting point.
Then you can add a setter for the interval (period), or you can even embed your own throttling logic within the trigger itself.
The <code>period</code> property is used with each call to <code>nextExecutionTime</code> to schedule the next poll.
To use this custom trigger within pollers, declare the bean definition of the custom trigger in your application context and inject the dependency into your poller configuration by using the <code>trigger</code> attribute, which references the custom trigger bean instance.
You can now obtain a reference to the trigger bean and change the polling interval between polls.</p>
</div>
<div class="paragraph">
<p>For an example, see the <a href="https://github.com/SpringSource/spring-integration-samples/tree/master/intermediate">Spring Integration Samples</a> project.
It contains a sample called <code>dynamic-poller</code>, which uses a custom trigger and demonstrates the ability to change the polling interval at runtime.</p>
</div>
<div class="paragraph">
<p>The sample provides a custom trigger that implements the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/Trigger.html"><code>org.springframework.scheduling.Trigger</code></a> interface.
The sample&#8217;s trigger is based on Spring&#8217;s <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/support/PeriodicTrigger.html"><code>PeriodicTrigger</code></a> implementation.
However, the fields of the custom trigger are not final, and the properties have explicit getters and setters, letting you dynamically change the polling period at runtime.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to note, though, that because the Trigger method is <code>nextExecutionTime()</code>, any changes to a dynamic trigger do not take effect until the next poll, based on the existing configuration.
It is not possible to force a trigger to fire before its currently configured next execution time.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="payload-type-conversion"><a class="anchor" href="#payload-type-conversion"></a>10.1.6. Payload Type Conversion</h4>
<div class="paragraph">
<p>Throughout this reference manual, you can also see specific configuration and implementation examples of various endpoints that accept a message orany arbitrary <code>Object</code> as an input parameter.
In the case of an <code>Object</code>, such a parameter is mapped toa message payload or part of the payload or header (when using the Spring Expression Language).
However, the type of input parameter of the endpoint method sometimes does not match the type of the payload or its part.
In this scenario, we need to perform type conversion.
Spring Integration provides a convenient way for registering type converters (by using the Spring <code>ConversionService</code>) within its own instance of a conversion service bean named <code>integrationConversionService</code>.
That bean is automatically created as soon as the first converter is defined by using the Spring Integration infrastructure.
To register a converter, you can implement <code>org.springframework.core.convert.converter.Converter</code>, <code>org.springframework.core.convert.converter.GenericConverter</code>, or <code>org.springframework.core.convert.converter.ConverterFactory</code>.</p>
</div>
<div class="paragraph">
<p>The <code>Converter</code> implementation is the simplest and converts from a single type to another.
For more sophistication, such as converting to a class hierarchy, you can implement a <code>GenericConverter</code> and possibly a <code>ConditionalConverter</code>.
These give you complete access to the <code>from</code> and <code>to</code> type descriptors, enabling complex conversions.
For example, if you have an abstract class called <code>Something</code> that is the target of your conversion (parameter type, channel data type, and so on), you have two concrete implementations called <code>Thing1</code> and <code>Thing</code>, and you wish to convert to one or the other based on the input type, the <code>GenericConverter</code> would be a good fit.
For more information, see the Javadoc for these interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html">org.springframework.core.convert.converter.Converter</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/package-summary.html">org.springframework.core.convert.converter.GenericConverter</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterFactory.html">org.springframework.core.convert.converter.ConverterFactory</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you have implemented your converter, you can register it with convenient namespace support, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:converter ref="sampleConverter"/&gt;

&lt;bean id="sampleConverter" class="foo.bar.TestConverter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can use an inner bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:converter&gt;
    &lt;bean class="o.s.i.config.xml.ConverterParserTests$TestConverter3"/&gt;
&lt;/int:converter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 4.0, you can use annotations to create the preceding configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@IntegrationConverter
public class TestConverter implements Converter&lt;Boolean, Number&gt; {

	public Number convert(Boolean source) {
		return source ? 1 : 0;
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternately, you can use the <code>@Configuration</code> annotation, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class ContextConfiguration {

	@Bean
	@IntegrationConverter
	public SerializingConverter serializingConverter() {
		return new SerializingConverter();
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When configuring an application context, the Spring Framework lets you add a <code>conversionService</code> bean (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-Spring-config">Configuring a ConversionService</a> chapter).
This service is used, when needed, to perform appropriate conversions during bean creation and configuration.</p>
</div>
<div class="paragraph">
<p>In contrast, the <code>integrationConversionService</code> is used for runtime conversions.
These uses are quite different.
Converters that are intended for use when wiring bean constructor arguments and properties may produce unintended results if used at runtime for Spring Integration expression evaluation against messages within data type channels, payload type transformers, and so on.</p>
</div>
<div class="paragraph">
<p>However, if you do want to use the Spring <code>conversionService</code> as the Spring Integration <code>integrationConversionService</code>, you can configure an alias in the application context, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;alias name="conversionService" alias="integrationConversionService"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the converters provided by the <code>conversionService</code> are available for Spring Integration runtime conversion.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="content-type-conversion"><a class="anchor" href="#content-type-conversion"></a>10.1.7. Content Type Conversion</h4>
<div class="paragraph">
<p>Starting with version 5.0, by default, the method invocation mechanism is based on the <code>org.springframework.messaging.handler.invocation.InvocableHandlerMethod</code> infrastructure.
Its <code>HandlerMethodArgumentResolver</code> implementations (such as <code>PayloadArgumentResolver</code> and <code>MessageMethodArgumentResolver</code>) can use the <code>MessageConverter</code> abstraction to convert an incoming <code>payload</code> to the target method argument type.
The conversion can be based on the <code>contentType</code> message header.
For this purpose, Spring Integration provides the <code>ConfigurableCompositeMessageConverter</code>, which delegates to a list of registered converters to be invoked until one of them returns a non-null result.
By default, this converter provides (in strict order):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/support/converter/MappingJackson2MessageConverter.html"><code>MappingJackson2MessageConverter</code></a> if the Jackson processor is present on the classpath</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/ByteArrayMessageConverter.html"><code>ByteArrayMessageConverter</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/docs/current/api//org/springframework/integration/support/converter/ObjectStringMessageConverter.html"><code>ObjectStringMessageConverter</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/GenericMessageConverter.html"><code>GenericMessageConverter</code></a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See the Javadoc (linked in the preceding list) for more information about their purpose and appropriate <code>contentType</code> values for conversion.
The <code>ConfigurableCompositeMessageConverter</code> is used because it can be be supplied with any other <code>MessageConverter</code> implementations, including or excluding the previously mentioned default converters.
It can also be registered as an appropriate bean in the application context, overriding the default converter, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean(name = IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME)
public ConfigurableCompositeMessageConverter compositeMessageConverter() {
    List&lt;MessageConverter&gt; converters =
        Arrays.asList(new MarshallingMessageConverter(jaxb2Marshaller()),
                 new JavaSerializationMessageConverter());
    return new ConfigurableCompositeMessageConverter(converters);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Those two new converters are registered in the composite before the defaults.
You can also not use a <code>ConfigurableCompositeMessageConverter</code> but provide your own <code>MessageConverter</code> by registering a bean with the name, <code>integrationArgumentResolverMessageConverter</code> (by setting the <code>IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME</code> property).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>MessageConverter</code>-based (including <code>contentType</code> header) conversion is not available when using SpEL method invocation.
In this case, only the regular class-to-class conversion mentioned above in the <a href="#payload-type-conversion">Payload Type Conversion</a> is available.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="async-polling"><a class="anchor" href="#async-polling"></a>10.1.8. Asynchronous Polling</h4>
<div class="paragraph">
<p>If you want the polling to be asynchronous, a poller can optionally specify a <code>task-executor</code> attribute that points to an existing instance of any <code>TaskExecutor</code> bean (Spring 3.0 provides a convenient namespace configuration through the <code>task</code> namespace).
However, there are certain things you must understand when configuring a poller with a <code>TaskExecutor</code>.</p>
</div>
<div class="paragraph">
<p>The problem is that there are two configurations in place, the poller and the <code>TaskExecutor</code>.
They must be in tunewith each other.
Otherwise, you might end up creating an artificial memory leak.</p>
</div>
<div class="paragraph">
<p>Consider the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="publishChannel"&gt;
    &lt;int:queue /&gt;
&lt;/int:channel&gt;

&lt;int:service-activator input-channel="publishChannel" ref="myService"&gt;
	&lt;int:poller receive-timeout="5000"task-executor="taskExecutor" fixed-rate="50" /&gt;
&lt;/int:service-activator&gt;

&lt;task:executor id="taskExecutor" pool-size="20" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration demonstrates an out-of-tune configuration.</p>
</div>
<div class="paragraph">
<p>By default, the task executor has an unbounded task queue.
The poller keeps scheduling new tasks even though all the threads are blocked, waiting for either a new message to arrive or the timeout to expire.
Given that there are 20 threads executing tasks with a five-second timeout, they aree executed at a rate of 4 per second.
However, new tasks are being scheduled at a rate of 20 per second, so the internal queue in the task executor grows at a rate of 16 per second (while the process is idle), so we have a memory leak.</p>
</div>
<div class="paragraph">
<p>One of the ways to handle this is to set the <code>queue-capacity</code> attribute of the task executor.
Even 0 is a reasonable value.
You can also manage it by specifying what to do with messages that can not be queued by setting the <code>rejection-policy</code> attribute of the Task Executor (for example, to <code>DISCARD</code>).
In other words, there are certain details you must understand when configuring <code>TaskExecutor</code>.
See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html">&#8220;Task Execution and Scheduling&#8221;</a> in the Spring reference manual for more detail on the subject.</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoint-inner"><a class="anchor" href="#endpoint-inner"></a>10.1.9. Endpoint Inner Beans</h4>
<div class="paragraph">
<p>Many endpoints are composite beans.
This includes all consumers and all polled inbound channel adapters.
Consumers (polled or event-driven) delegate to a <code>MessageHandler</code>.
Polled adapters obtain messages by delegating to a <code>MessageSource</code>.
Often, it is useful to obtain a reference to the delegate bean, perhaps to change configuration at runtime or for testing.
These beans can be obtained from the <code>ApplicationContext</code> with well known names.
<code>MessageHandler</code> instances are registered with the application context with bean IDs similar to <code>someConsumer.handler</code> (where 'consumer' is the value of the endpoint&#8217;s <code>id</code> attribute).
<code>MessageSource</code> instances are registered with bean IDs similar to <code>somePolledAdapter.source</code>, where 'somePolledAdapter' is the ID of the adapter.</p>
</div>
<div class="paragraph">
<p>The preceding only applies to the framework component itself.
You can instead use an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator id="exampleServiceActivator" input-channel="inChannel"
            output-channel = "outChannel" method="foo"&gt;
    &lt;beans:bean class="org.foo.ExampleServiceActivator"/&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The bean is treated like any inner bean declared and is not registered with the application context.
If you wish to access this bean in some other manner, declare it at the top level with an <code>id</code> and use the <code>ref</code> attribute instead.
See the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-inner-beans">Spring Documentation</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="endpoint-roles"><a class="anchor" href="#endpoint-roles"></a>10.2. Endpoint Roles</h3>
<div class="paragraph">
<p>Starting with version 4.2, endpoints can be assigned to roles.
Roles let endpoints be started and stopped as a group.
This is particularly useful when using leadership election, where a set of endpoints can be started or stopped when leadership is granted or revoked, respectively.
For this purpose the framework registers a <code>SmartLifecycleRoleController</code> bean in the application context with the name <code>IntegrationContextUtils.INTEGRATION_LIFECYCLE_ROLE_CONTROLLER</code>.
Whenever it is necessary to control lifecycles, this bean can be injected or <code>@Autowired</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="com.some.project.SomeLifecycleControl"&gt;
    &lt;property name="roleController" ref="integrationLifecycleRoleController"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can assign endpoints to roles using XML, Java configuration, or programmatically.
The following example shows how to configure endpoint roles with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="ica" channel="someChannel" expression="'foo'" role="cluster"
        auto-startup="false"&gt;
    &lt;int:poller fixed-rate="60000" /&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles for a bean created in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "sendAsyncChannel", autoStartup="false")
@Role("cluster")
public MessageHandler sendAsyncHandler() {
    return // some MessageHandler
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles on a method in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Payload("#args[0].toLowerCase()")
@Role("cluster")
public String handle(String payload) {
    return payload.toUpperCase();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles by using the <code>SmartLifecycleRoleController</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private SmartLifecycleRoleController roleController;
...
    this.roleController.addSmartLifeCycleToRole("cluster", someEndpoint);
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure endpoint roles by using an <code>IntegrationFlow</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntegrationFlow flow -&gt; flow
        .handle(..., e -&gt; e.role("cluster"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each of these adds the endpoint to the <code>cluster</code> role.</p>
</div>
<div class="paragraph">
<p>Invoking <code>roleController.startLifecyclesInRole("cluster")</code> and the corresponding <code>stop&#8230;&#8203;</code> method starts and stops the endpoints.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any object that implements <code>SmartLifecycle</code> can be programmatically added&#8201;&#8212;&#8201;not just endpoints.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>SmartLifecycleRoleController</code> implements <code>ApplicationListener&lt;AbstractLeaderEvent&gt;</code> and it automatically starts and stops its configured <code>SmartLifecycle</code> objects when leadership is granted or revoked (when some bean publishes <code>OnGrantedEvent</code> or <code>OnRevokedEvent</code>, respectively).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using leadership election to start and stop components, it is important to set the <code>auto-startup</code> XML attribute (<code>autoStartup</code> bean property) to <code>false</code> so that the application context does not start the components during context initialization.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3.8, the <code>SmartLifecycleRoleController</code> provides several status methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Collection&lt;String&gt; getRoles() <i class="conum" data-value="1"></i><b>(1)</b>

public boolean allEndpointsRunning(String role) <i class="conum" data-value="2"></i><b>(2)</b>

public boolean noEndpointsRunning(String role) <i class="conum" data-value="3"></i><b>(3)</b>

public Map&lt;String, Boolean&gt; getEndpointsRunningStatus(String role) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a list of the roles being managed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>true</code> if all endpoints in the role are running.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns <code>true</code> if none of the endpoints in the role are running.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returns a map of <code>component name : running status</code>.
The component name is usually the bean name.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="leadership-event-handling"><a class="anchor" href="#leadership-event-handling"></a>10.3. Leadership Event Handling</h3>
<div class="paragraph">
<p>Groups of endpoints can be started and stopped based on leadership being granted or revoked, respectively.
This is useful in clustered scenarios where shared resources must be consumed by only a single instance.
An example of this is a file inbound channel adapter that is polling a shared directory.
(See <a href="#file-reading">Reading Files</a>).</p>
</div>
<div class="paragraph">
<p>To participate in a leader election and be notified when elected leader, when leadership is revoked, or on failure to acquire the resources to become leader, an application creates a component in the application context called a &#8220;leader initiator&#8221;.
Normally, a leader initiator is a <code>SmartLifecycle</code>, so it starts (optionally) when the context starts and then publishes notifications when leadership changes.
You can also receive failure notifications by setting the <code>publishFailedEvents</code> to <code>true</code> (starting with version 5.0), for cases when you want take a specific action if a failure occurs.
By convention, you should provide a <code>Candidate</code> that receives the callbacks.
You can also revoke the leadership through a <code>Context</code> object provided by the framework.
Your code can also listen for <code>o.s.i.leader.event.AbstractLeaderEvent</code> instances (the super class of <code>OnGrantedEvent</code> and <code>OnRevokedEvent</code>) and respond accordingly (for instance, by using a <code>SmartLifecycleRoleController</code>).
The events contain a reference to the <code>Context</code> object.
The following listing shows the definition of the <code>Context</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Context {

	boolean isLeader();

	void yield();

	String getRole();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0.6, the context provides a reference to the candidate&#8217;s role.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides a basic implementation of a leader initiator that is based on the <code>LockRegistry</code> abstraction.
To use it, you need to create an instance as a bean, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public LockRegistryLeaderInitiator leaderInitiator(LockRegistry locks) {
    return new LockRegistryLeaderInitiator(locks);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the lock registry is implemented correctly, there is only ever at most one leader.
If the lock registry also provides locks that throw exceptions (ideally, <code>InterruptedException</code>) when they expire or are broken, the duration of the leaderless periods can be as short as is allowed by the inherent latency in the lock implementation.
By default, the <code>busyWaitMillis</code> property adds some additional latency to prevent CPU starvation in the (more usual) case that the locks are imperfect and you only know they expired when you try to obtain one again.</p>
</div>
<div class="paragraph">
<p>See <a href="#zk-leadership">Zookeeper Leadership Event Handling</a> for more information about leadership election and events that use Zookeeper.</p>
</div>
</div>
<div class="sect2">
<h3 id="gateway"><a class="anchor" href="#gateway"></a>10.4. Messaging Gateways</h3>
<div class="paragraph">
<p>A gateway hides the messaging API provided by Spring Integration.
It lets your application&#8217;s business logic be unaware of the Spring Integration API.
By using a generic Gateway, your code interacts with only a simple interface.</p>
</div>
<div class="sect3">
<h4 id="gateway-proxy"><a class="anchor" href="#gateway-proxy"></a>10.4.1. Enter the <code>GatewayProxyFactoryBean</code></h4>
<div class="paragraph">
<p>As mentioned earlier, it would be great to have no dependency on the Spring Integration API&#8201;&#8212;&#8201;including the gateway class.
For that reason, Spring Integration provides the <code>GatewayProxyFactoryBean</code>, which generates a proxy for any interface and internally invokes the gateway methods shown below.
By using dependency injection, you can then expose the interface to your business methods.</p>
</div>
<div class="paragraph">
<p>The following example shows an interface that can be used to interact with Spring Integration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.cafeteria;

public interface Cafe {

    void placeOrder(Order order);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gateway-namespace"><a class="anchor" href="#gateway-namespace"></a>10.4.2. Gateway XML Namespace Support</h4>
<div class="paragraph">
<p>Namespace support is also provided.
It lets you configure an interface as a service, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="cafeService"
         service-interface="org.cafeteria.Cafe"
         default-request-channel="requestChannel"
         default-reply-timeout="10000"
         default-reply-channel="replyChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With this configuration defined, the <code>cafeService</code> can now be injected into other beans, and the code that invokes the methods on that proxied instance of the <code>Cafe</code> interface has no awareness of the Spring Integration API.
The general approach is similar to that of Spring Remoting (RMI, HttpInvoker, and so on).
See the <a href="#samples">&#8220;Samples&#8221;</a> Appendix for an example that uses the <code>gateway</code> element (in the Cafe demo).</p>
</div>
<div class="paragraph">
<p>The defaults in the preceding configuration are applied to all methods on the gateway interface.
If a reply timeout is not specified, the calling thread waits indefinitely for a reply.
See <a href="#gateway-no-response">Gateway Behavior When No response Arrives</a>.</p>
</div>
<div class="paragraph">
<p>The defaults can be overridden for individual methods.
See <a href="#gateway-configuration-annotations">Gateway Configuration with Annotations and XML</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-default-reply-channel"><a class="anchor" href="#gateway-default-reply-channel"></a>10.4.3. Setting the Default Reply Channel</h4>
<div class="paragraph">
<p>Typically, you need not specify the <code>default-reply-channel</code>, since a Gateway auto-creates a temporary, anonymous reply channel, where it listens for the reply.
However, some cases may prompt you to define a <code>default-reply-channel</code> (or <code>reply-channel</code> with adapter gateways, such as HTTP, JMS, and others).</p>
</div>
<div class="paragraph">
<p>For some background, we briefly discuss some of the inner workings of the gateway.
A gateway creates a temporary point-to-point reply channel.
It is anonymous and is added to the message headers with the name, <code>replyChannel</code>.
When providing an explicit <code>default-reply-channel</code> (<code>reply-channel</code> with remote adapter gateways), you can point to a publish-subscribe channel, which is so named because you can add more than one subscriber to it.
Internally, Spring Integration creates a bridge between the temporary <code>replyChannel</code> and the explicitly defined <code>default-reply-channel</code>.</p>
</div>
<div class="paragraph">
<p>Suppose you want your reply to go not only to the gateway but also to some other consumer.
In this case, you want two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A named channel to which you can subscribe</p>
</li>
<li>
<p>That channel to be a publish-subscribe-channel</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default strategy used by the gateway does not satisfy those needs, because the reply channel added to the header is anonymous and point-to-point.
This means that no other subscriber can get a handle to it and, even if it could, the channel has point-to-point behavior such that only one subscriber would get the message.
By defining a <code>default-reply-channel</code> you can point to a channel of your choosing.
In this case, that is a <code>publish-subscribe-channel</code>.
The gateway creates a bridge from it to the temporary, anonymous reply channel that is stored in the header.</p>
</div>
<div class="paragraph">
<p>You might also want to explicitly provide a reply channel for monitoring or auditing through an interceptor (for example, <a href="#channel-wiretap">wiretap</a>).
To configure a channel interceptor, you need a named channel.</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-configuration-annotations"><a class="anchor" href="#gateway-configuration-annotations"></a>10.4.4. Gateway Configuration with Annotations and XML</h4>
<div class="paragraph">
<p>Consider the following example, which expands on the previous <code>Cafe</code> interface example by adding a <code>@Gateway</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Cafe {

    @Gateway(requestChannel="orders")
    void placeOrder(Order order);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@Header</code> annotation lets you add values that are interpreted as message headers, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface FileWriter {

    @Gateway(requestChannel="filesOut")
    void write(byte[] content, @Header(FileHeaders.FILENAME) String filename);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you prefer the XML approach to configuring gateway methods, you can add <code>method</code> elements to the gateway configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="myGateway" service-interface="org.foo.bar.TestGateway"
      default-request-channel="inputC"&gt;
  &lt;int:default-header name="calledMethod" expression="#gatewayMethod.name"/&gt;
  &lt;int:method name="echo" request-channel="inputA" reply-timeout="2" request-timeout="200"/&gt;
  &lt;int:method name="echoUpperCase" request-channel="inputB"/&gt;
  &lt;int:method name="echoViaDefault"/&gt;
&lt;/int:gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use XML to provide individual headers for each method invocation.
This could be useful if the headers you want to set are static in nature and you do not want to embed them in the gateway&#8217;s method signature by using <code>@Header</code> annotations.
For example, in the loan broker example, we want to influence how aggregation of the loan quotes is done, based on what type of request was initiated (single quote or all quotes).
Determining the type of the request by evaluating which gateway method was invoked, although possible, would violate the separation of concerns paradigm (the method is a Java artifact).
However, expressing your intention (meta information) in message headers is natural in a messaging architecture.
The following example shows how to add a different message header for each of two methods:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="loanBrokerGateway"
         service-interface="org.springframework.integration.loanbroker.LoanBrokerGateway"&gt;
  &lt;int:method name="getLoanQuote" request-channel="loanBrokerPreProcessingChannel"&gt;
    &lt;int:header name="RESPONSE_TYPE" value="BEST"/&gt;
  &lt;/int:method&gt;
  &lt;int:method name="getAllLoanQuotes" request-channel="loanBrokerPreProcessingChannel"&gt;
    &lt;int:header name="RESPONSE_TYPE" value="ALL"/&gt;
  &lt;/int:method&gt;
&lt;/int:gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example a different value is set for the 'RESPONSE_TYPE' header, based on the gateway&#8217;s method.</p>
</div>
<div class="sect4">
<h5 id="expressions-and-global-headers"><a class="anchor" href="#expressions-and-global-headers"></a>Expressions and &#8220;Global&#8221; Headers</h5>
<div class="paragraph">
<p>The <code>&lt;header/&gt;</code> element supports <code>expression</code> as an alternative to <code>value</code>.
The SpEL expression is evaluated to determine the value of the header.
There is no <code>#root</code> object, but the following variables are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>#args: An <code>Object[]</code> containing the method arguments</p>
</li>
<li>
<p>#gatewayMethod: The object (derived from <code>java.reflect.Method</code>) that represents the method in the <code>service-interface</code> that was invoked.
A header containing this variable can be used later in the flow (for example, for routing).
For example, if you wish to route on the simple method name, you might add a header with the following expression: <code>#gatewayMethod.name</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>java.reflect.Method</code> is not serializable.
A header with an expression of <code>#gatewayMethod</code> is lost if you later serialize the message.
Consequently, you may wish to use <code>#gatewayMethod.name</code> or <code>#gatewayMethod.toString()</code> in those cases.
The <code>toString()</code> method provides a <code>String</code> representation of the method, including parameter and return types.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since version 3.0, <code>&lt;default-header/&gt;</code> elements can be defined to add headers to all the messages produced by the gateway, regardless of the method invoked.
Specific headers defined for a method take precedence over default headers.
Specific headers defined for a method here override any <code>@Header</code> annotations in the service interface.
However, default headers do NOT override any <code>@Header</code> annotations in the service interface.</p>
</div>
<div class="paragraph">
<p>The gateway now also supports a <code>default-payload-expression</code>, which is applied for all methods (unless overridden).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gateway-mapping"><a class="anchor" href="#gateway-mapping"></a>10.4.5. Mapping Method Arguments to a Message</h4>
<div class="paragraph">
<p>Using the configuration techniques in the previous section allows control of how method arguments are mapped to message elements (payload and headers).
When no explicit configuration is used, certain conventions are used to perform the mapping.
In some cases, these conventions cannot determine which argument is the payload and which should be mapped to headers.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String send1(Object thing1, Map thing2);

public String send2(Map thing1, Map thing2);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the first case, the convention is to map the first argument to the payload (as long as it is not a <code>Map</code>) and the contents of the second argument become headers.</p>
</div>
<div class="paragraph">
<p>In the second case (or the first when the argument for parameter <code>thing1</code> is a <code>Map</code>), the framework cannot determine which argument should be the payload.
Consequently, mapping fails.
This can generally be resolved using a <code>payload-expression</code>, a <code>@Payload</code> annotation, or a <code>@Headers</code> annotation.</p>
</div>
<div class="paragraph">
<p>Alternatively (and whenever the conventions break down), you can take the entire responsibility for mapping the method calls to messages.
To do so, implement an <code>MethodArgsMessageMapper</code> and provide it to the <code>&lt;gateway/&gt;</code> by using the <code>mapper</code> attribute.
The mapper maps a <code>MethodArgsHolder</code>, which is a simple class that wraps the <code>java.reflect.Method</code> instance and an <code>Object[]</code> containing the arguments.
When providing a custom mapper, the <code>default-payload-expression</code> attribute and <code>&lt;default-header/&gt;</code> elements are not allowed on the gateway.
Similarly, the <code>payload-expression</code> attribute and <code>&lt;header/&gt;</code> elements are not allowed on any <code>&lt;method/&gt;</code> elements.</p>
</div>
<div class="sect4">
<h5 id="mapping-method-arguments"><a class="anchor" href="#mapping-method-arguments"></a>Mapping Method Arguments</h5>
<div class="paragraph">
<p>The following examples show how method arguments can be mapped to the message and shows some examples of invalid configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MyGateway {

    void payloadAndHeaderMapWithoutAnnotations(String s, Map&lt;String, Object&gt; map);

    void payloadAndHeaderMapWithAnnotations(@Payload String s, @Headers Map&lt;String, Object&gt; map);

    void headerValuesAndPayloadWithAnnotations(@Header("k1") String x, @Payload String s, @Header("k2") String y);

    void mapOnly(Map&lt;String, Object&gt; map); // the payload is the map and no custom headers are added

    void twoMapsAndOneAnnotatedWithPayload(@Payload Map&lt;String, Object&gt; payload, Map&lt;String, Object&gt; headers);

    @Payload("#args[0] + #args[1] + '!'")
    void payloadAnnotationAtMethodLevel(String a, String b);

    @Payload("@someBean.exclaim(#args[0])")
    void payloadAnnotationAtMethodLevelUsingBeanResolver(String s);

    void payloadAnnotationWithExpression(@Payload("toUpperCase()") String s);

    void payloadAnnotationWithExpressionUsingBeanResolver(@Payload("@someBean.sum(#this)") String s); //  <i class="conum" data-value="1"></i><b>(1)</b>

    // invalid
    void twoMapsWithoutAnnotations(Map&lt;String, Object&gt; m1, Map&lt;String, Object&gt; m2);

    // invalid
    void twoPayloads(@Payload String s1, @Payload String s2);

    // invalid
    void payloadAndHeaderAnnotationsOnSameParameter(@Payload @Header("x") String s);

    // invalid
    void payloadAndHeadersAnnotationsOnSameParameter(@Payload @Headers Map&lt;String, Object&gt; map);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note that, in this example, the SpEL variable, <code>#this</code>, refers to the argument&#8201;&#8212;&#8201;in this case, the value of <code>s</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The XML equivalent looks a little different, since there is no <code>#this</code> context for the method argument.
However, expressions can refer to method arguments by using the <code>#args</code> variable, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="myGateway" service-interface="org.something.MyGateway"&gt;
  &lt;int:method name="send1" payload-expression="#args[0] + 'thing2'"/&gt;
  &lt;int:method name="send2" payload-expression="@someBean.sum(#args[0])"/&gt;
  &lt;int:method name="send3" payload-expression="#method"/&gt;
  &lt;int:method name="send4"&gt;
    &lt;int:header name="thing1" expression="#args[2].toUpperCase()"/&gt;
  &lt;/int:method&gt;
&lt;/int:gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="messaging-gateway-annotation"><a class="anchor" href="#messaging-gateway-annotation"></a>10.4.6. <code>@MessagingGateway</code> Annotation</h4>
<div class="paragraph">
<p>Starting with version 4.0, gateway service interfaces can be marked with a <code>@MessagingGateway</code> annotation instead of requiring the definition of a <code>&lt;gateway /&gt;</code> xml element for configuration.
The following pair of examples compares the two approaches for configuring the same gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="myGateway" service-interface="org.something.TestGateway"
      default-request-channel="inputC"&gt;
  &lt;int:default-header name="calledMethod" expression="#gatewayMethod.name"/&gt;
  &lt;int:method name="echo" request-channel="inputA" reply-timeout="2" request-timeout="200"/&gt;
  &lt;int:method name="echoUpperCase" request-channel="inputB"&gt;
    &lt;int:header name="thing1" value="thing2"/&gt;
  &lt;/int:method&gt;
  &lt;int:method name="echoViaDefault"/&gt;
&lt;/int:gateway&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway(name = "myGateway", defaultRequestChannel = "inputC",
		  defaultHeaders = @GatewayHeader(name = "calledMethod",
		                           expression="#gatewayMethod.name"))
public interface TestGateway {

   @Gateway(requestChannel = "inputA", replyTimeout = 2, requestTimeout = 200)
   String echo(String payload);

   @Gateway(requestChannel = "inputB", headers = @GatewayHeader(name = "thing1", value="thing2"))
   String echoUpperCase(String payload);

   String echoViaDefault(String payload);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Similarly to the XML version, when Spring Integration discovers these annotations during a component scan, it creates the <code>proxy</code> implementation with its messaging infrastructure.
To perform this scan and register the <code>BeanDefinition</code> in the application context, add the <code>@IntegrationComponentScan</code> annotation to a <code>@Configuration</code> class.
The standard <code>@ComponentScan</code> infrastructure does not deal with interfaces.
Consequently, we introduced the custom <code>@IntegrationComponentScan</code> logic  to fine the <code>@MessagingGateway</code> annotation on the interfaces and register <code>GatewayProxyFactoryBean</code> instances for them.
See also <a href="#annotations">Annotation Support</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Along with the <code>@MessagingGateway</code> annotation you can mark a service interface with the <code>@Profile</code> annotation to avoid the bean creation, if such a profile is not active.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you have no XML configuration, the <code>@EnableIntegration</code> annotation is required on at least one <code>@Configuration</code> class.
See <a href="#configuration-enable-integration">Configuration and <code>@EnableIntegration</code></a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="gateway-calling-no-argument-methods"><a class="anchor" href="#gateway-calling-no-argument-methods"></a>10.4.7. Invoking No-Argument Methods</h4>
<div class="paragraph">
<p>When invoking methods on a Gateway interface that do not have any arguments, the default behavior is to receive a <code>Message</code> from a <code>PollableChannel</code>.</p>
</div>
<div class="paragraph">
<p>Sometimes, however, you may want to trigger no-argument methods so that you can interact with other components downstream that do not require user-provided parameters, such as triggering no-argument SQL calls or stored procedures.</p>
</div>
<div class="paragraph">
<p>To achieve send-and-receive semantics, you must provide a payload.
To generate a payload, method parameters on the interface are not necessary.
You can either use the <code>@Payload</code> annotation or the <code>payload-expression</code> attribute in XML on the <code>method</code> element.
The following list includes a few examples of what the payloads could be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a literal string</p>
</li>
<li>
<p>#gatewayMethod.name</p>
</li>
<li>
<p>new java.util.Date()</p>
</li>
<li>
<p>@someBean.someMethod()'s return value</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@Payload</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">public interface Cafe {

    @Payload("new java.util.Date()")
    List&lt;Order&gt; retrieveOpenOrders();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a method has no argument and no return value but does contain a payload expression, it is treated as a send-only operation.</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-error-handling"><a class="anchor" href="#gateway-error-handling"></a>10.4.8. Error Handling</h4>
<div class="paragraph">
<p>The gateway invocation can result in errors.
By default, any error that occurs downstream is re-thrown &#8220;as is&#8221; upon the gateway&#8217;s method invocation.
For example, consider the following simple flow:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>gateway -&gt; service-activator</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the service invoked by the service activator throws a <code>MyException</code> (for example), the framework wraps it in a <code>MessagingException</code> and attaches the message passed to the service activator in the <code>failedMessage</code> property.
Consequently, any logging performed by the framework has full the context of the failure.
By default, when the exception is caught by the gateway, the <code>MyException</code> is unwrapped and thrown to the caller.
You can configure a <code>throws</code> clause on the gateway method declaration to match the particular exception type in the cause chain.
For example, if you want to catch a whole <code>MessagingException</code> with all the messaging information of the reason of downstream error, you should have a gateway method similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MyGateway {

    void performProcess() throws MessagingException;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since we encourage POJO programming, you may not want to expose the caller to messaging infrastructure.</p>
</div>
<div class="paragraph">
<p>If your gateway method does not have a <code>throws</code> clause, the gateway traverses the cause tree, looking for a <code>RuntimeException</code> that is not a <code>MessagingException</code>.
If none is found, the framework throws the <code>MessagingException</code>.
If the <code>MyException</code> in the preceding discussion has a cause of <code>SomeOtherException</code> and your method <code>throws SomeOtherException</code>, the gateway further unwraps that and throws it to the caller.</p>
</div>
<div class="paragraph">
<p>When a gateway is declared with no <code>service-interface</code>, an internal framework interface <code>RequestReplyExchanger</code> is used.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface RequestReplyExchanger {

	Message&lt;?&gt; exchange(Message&lt;?&gt; request) throws MessagingException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before version 5.0, this <code>exchange</code> method did not have a <code>throws</code> clause and, as a result, the exception was unwrapped.
If you use this interface and want to restore the previous unwrap behavior, use a custom <code>service-interface</code> instead or access the <code>cause</code> of the  <code>MessagingException</code> yourself.</p>
</div>
<div class="paragraph">
<p>However, you may want to log the error rather than propagating it or you may want to treat an exception as a valid reply (by mapping it to a message that conforms to some "error message" contract that the caller understands).
To accomplish this, the gateway provides support for a message channel dedicated to the errors by including support for the <code>error-channel</code> attribute.
In the following example, a 'transformer' creates a reply <code>Message</code> from the <code>Exception</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="sampleGateway"
    default-request-channel="gatewayChannel"
    service-interface="foo.bar.SimpleGateway"
    error-channel="exceptionTransformationChannel"/&gt;

&lt;int:transformer input-channel="exceptionTransformationChannel"
        ref="exceptionTransformer" method="createErrorResponse"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>exceptionTransformer</code> could be a simple POJO that knows how to create the expected error response objects.
That becomes the payload that is sent back to the caller.
You could do many more elaborate things in such an &#8220;error flow&#8221;, if necessary.
It might involve routers (including Spring Integration&#8217;s <code>ErrorMessageExceptionTypeRouter</code>), filters, and so on.
Most of the time, a simple 'transformer' should be sufficient, however.</p>
</div>
<div class="paragraph">
<p>Alternatively, you might want to only log the exception (or send it somewhere asynchronously).
If you provide a one-way flow, nothing would be sent back to the caller.
If you want to completely suppress exceptions, you can provide a reference to the global <code>nullChannel</code> (essentially a <code>/dev/null</code> approach).
Finally, as mentioned above, if no <code>error-channel</code> is defined, then the exceptions propagate as usual.</p>
</div>
<div class="paragraph">
<p>When you use the <code>@MessagingGateway</code> annotation (see <code><a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a></code>), you can use use the <code>errorChannel</code> attribute.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, when you use a gateway method with a <code>void</code> return type (one-way flow), the <code>error-channel</code> reference (if provided) is populated in the standard <code>errorChannel</code> header of each sent message.
This feature allows a downstream asynchronous flow, based on the standard <code>ExecutorChannel</code> configuration (or a <code>QueueChannel</code>), to override a default global <code>errorChannel</code> exceptions sending behavior.
Previously you had to manually specify an <code>errorChannel</code> header with the <code>@GatewayHeader</code> annotation or the <code>&lt;header&gt;</code> element.
The <code>error-channel</code> property was ignored for <code>void</code> methods with an asynchronous flow.
Instead, error messages were sent to the default <code>errorChannel</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Exposing the messaging system through simple POJI Gateways  provides benefits, but &#8220;hiding&#8221; the reality of the underlying messaging system does come at a price, so there are certain things you should consider.
We want our Java method to return as quickly as possible and not hang for an indefinite amount of time while the caller is waiting on it to return (whether void, a return value, or a thrown Exception).
When regular methods are used as a proxies in front of the messaging system, we have to take into account the potentially asynchronous nature of the underlying messaging.
This means that there might be a chance that a message that was initiated by a gateway could be dropped by a filter and never reach a component that is responsible for producing a reply.
Some service activator method might result in an exception, thus providing no reply (as we do not generate null messages).
In other words, multiple scenarios can cause a reply message to never come.
That is perfectly natural in messaging systems.
However, think about the implication on the gateway method.The gateway&#8217;s method input argumentswere incorporated into a message and sent downstream.
The reply message would be converted to a return value of the gateway&#8217;s method.
So you might want to ensure that, for each gateway call, there is always a reply message.
Otherwise, your gateway method might never return and hang indefinitely.
One way to handle this situation is by using an asynchronous gateway (explained later in this section).
Another way of handling it is to explicitly set the <code>reply-timeout</code> attribute.
That way, the gateway does not hang any longer than the time specified by the <code>reply-timeout</code> and returns 'null' if that timeout does elapse.
Finally, you might want to consider setting downstream flags, such as 'requires-reply', on a service-activator or 'throw-exceptions-on-rejection' on a filter.These options are discussed in more detail in the final section of this chapter.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the downstream flow returns an <code>ErrorMessage</code>, its <code>payload</code> (a <code>Throwable</code>) is treated as a regular downstream error.
If there is an <code>error-channel</code> configured, it is sent to the error flow.
Otherwise the payload is thrown to the caller of the gateway.
Similarly, if the error flow on the <code>error-channel</code> returns an <code>ErrorMessage</code>, its payload is thrown to the caller.
The same applies to any message with a <code>Throwable</code> payload.
This can be useful in asynchronous situations when when you need to propagate an <code>Exception</code> directly to the caller.
To do so, you can either return an <code>Exception</code> (as the <code>reply</code> from some service) or throw it.
Generally, even with an asynchronous flow, the framework takes care of propagating an exception thrown by the downstream flow back to the gateway.
The <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/tcp-client-server-multiplex">TCP Client-Server Multiplex</a> sample demonstrates both techniques to return the exception to the caller.
It emulates a socket IO error to the waiting thread by using an <code>aggregator</code> with <code>group-timeout</code> (see <a href="#agg-and-group-to">Aggregator and Group Timeout</a>) and a <code>MessagingTimeoutException</code> reply on the discard flow.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="gateway-timeouts"><a class="anchor" href="#gateway-timeouts"></a>10.4.9. Gateway Timeouts</h4>
<div class="paragraph">
<p>Gateways have two timeout properties: <code>requestTimeout</code> and <code>replyTimeout</code>.
The request timeout applies only if the channel can block (for example, a bounded <code>QueueChannel</code> that is full).
The <code>replyTimeout</code> value is how long the gateway waits for a reply or returns <code>null</code>.
It defaults to infinity.</p>
</div>
<div class="paragraph">
<p>The timeouts can be set as defaults for all methods on the gateway (<code>defaultRequestTimeout</code> and <code>defaultReplyTimeout</code>) or on the <code>MessagingGateway</code> interface annotation.
Individual methods can override these defaults (in <code>&lt;method/&gt;</code> child elements) or on the <code>@Gateway</code> annotation.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the timeouts can be defined as expressions, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Gateway(payloadExpression = "#args[0]", requestChannel = "someChannel",
        requestTimeoutExpression = "#args[1]", replyTimeoutExpression = "#args[2]")
String lateReply(String payload, long requestTimeout, long replyTimeout);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The evaluation context has a <code>BeanResolver</code> (use <code>@someBean</code> to reference other beans), and the <code>#args</code> array variable is available.</p>
</div>
<div class="paragraph">
<p>When configuring with XML, the timeout attributes can be a long value or a SpEL expression, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;method name="someMethod" request-channel="someRequestChannel"
                      payload-expression="#args[0]"
                      request-timeout="1000"
                      reply-timeout="#args[1]"&gt;
&lt;/method&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="async-gateway"><a class="anchor" href="#async-gateway"></a>10.4.10. Asynchronous Gateway</h4>
<div class="paragraph">
<p>As a pattern, the messaging gateway offers a nice way to hide messaging-specific code while still exposing the full capabilities of the messaging system.
As <a href="#gateway-proxy">described earlier</a>, the <code>GatewayProxyFactoryBean</code> provides a convenient way to expose a proxy over a service-interface giving you POJO-based access to a messaging system (based on objects in your own domain, primitives/Strings, or other objects).
However, when a gateway is exposed through simple POJO methods that return values, it implies that, for each request message (generated when the method is invoked), there must be a reply message (generated when the method has returned).
Since messaging systems are naturally asynchronous, you may not always be able to guarantee the contract where &#8220;for each request, there will always be be a reply&#8221;.Spring Integration 2.0 introduced support for an asynchronous gateway, which offers a convenient way to initiate flows when you may not know if a reply is expected or how long it takes for replies to arrive.</p>
</div>
<div class="paragraph">
<p>To handle these types of scenarios, Spring Integration uses <code>java.util.concurrent.Future</code> instances to support an asynchronous gateway.</p>
</div>
<div class="paragraph">
<p>From the XML configuration, nothing changes, and you still define asynchronous gateway the same way as you define a regular gateway, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="mathService"
     service-interface="org.springframework.integration.sample.gateway.futures.MathServiceGateway"
     default-request-channel="requestChannel"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the gateway interface (a service interface) is a little different, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MathServiceGateway {

  Future&lt;Integer&gt; multiplyByTwo(int i);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the preceding example shows, the return type for the gateway method is a <code>Future</code>.
When <code>GatewayProxyFactoryBean</code> sees that the return type of the gateway method is a <code>Future</code>, it immediately switches to the asynchronous mode by using an <code>AsyncTaskExecutor</code>.
That is the extent of the differences.
The call to such a method always returns immediately with a <code>Future</code> instance.
Then you can interact with the <code>Future</code> at your own pace to get the result, cancel, and so on.
Also, as with any other use of <code>Future</code> instances, calling <code>get()</code> may reveal a timeout, an execution exception, and so on.
The following example shows how to use a <code>Future</code> that returns from an asynchronous gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MathServiceGateway mathService = ac.getBean("mathService", MathServiceGateway.class);
Future&lt;Integer&gt; result = mathService.multiplyByTwo(number);
// do something else here since the reply might take a moment
int finalResult = result.get(1000, TimeUnit.SECONDS);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For a more detailed example, see the <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/async-gateway">async-gateway</a> sample in the Spring Integration samples.</p>
</div>
<div class="sect4">
<h5 id="listenablefuture"><a class="anchor" href="#listenablefuture"></a><code>ListenableFuture</code></h5>
<div class="paragraph">
<p>Starting with version 4.1, asynchronous gateway methods can also return <code>ListenableFuture</code> (introduced in Spring Framework 4.0).
These return types let you provide a callback, which is invoked when the result is available (or an exception occurs).
When the gateway detects this return type and the <a href="#gateway-asynctaskexecutor">task executor</a> is an <code>AsyncListenableTaskExecutor</code>, the executor&#8217;s <code>submitListenable()</code> method is invoked.
The following example shows how to use a <code>ListenableFuture</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ListenableFuture&lt;String&gt; result = this.asyncGateway.async("something");
result.addCallback(new ListenableFutureCallback&lt;String&gt;() {

    @Override
    public void onSuccess(String result) {
        ...
    }

    @Override
    public void onFailure(Throwable t) {
        ...
    }
});</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gateway-asynctaskexecutor"><a class="anchor" href="#gateway-asynctaskexecutor"></a><code>AsyncTaskExecutor</code></h5>
<div class="paragraph">
<p>By default, the <code>GatewayProxyFactoryBean</code> uses <code>org.springframework.core.task.SimpleAsyncTaskExecutor</code> when submitting internal <code>AsyncInvocationTask</code> instances for any gateway method whose return type is a <code>Future</code>.
However, the <code>async-executor</code> attribute in the <code>&lt;gateway/&gt;</code> element&#8217;s configuration lets you provide a reference to any implementation of <code>java.util.concurrent.Executor</code> available within the Spring application context.</p>
</div>
<div class="paragraph">
<p>The (default) <code>SimpleAsyncTaskExecutor</code> supports both <code>Future</code> and <code>ListenableFuture</code> return types, returning <code>FutureTask</code> or <code>ListenableFutureTask</code> respectively.
See <a href="#gw-completable-future"><code>CompletableFuture</code></a>.
Even though there is a default executor, it is often useful to provide an external one so that you can identify its threads in logs (when using XML, the thread name is based on the executor&#8217;s bean name), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AsyncTaskExecutor exec() {
    SimpleAsyncTaskExecutor simpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor();
    simpleAsyncTaskExecutor.setThreadNamePrefix("exec-");
    return simpleAsyncTaskExecutor;
}

@MessagingGateway(asyncExecutor = "exec")
public interface ExecGateway {

    @Gateway(requestChannel = "gatewayChannel")
    Future&lt;?&gt; doAsync(String foo);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you wish to return a different <code>Future</code> implementation, you can provide a custom executor or disable the executor altogether and return the <code>Future</code> in the reply message payload from the downstream flow.
To disable the executor, set it to <code>null</code> in the <code>GatewayProxyFactoryBean</code> (by using <code>setAsyncTaskExecutor(null)</code>).
When configuring the gateway with XML, use <code>async-executor=""</code>.
When configuring by using the <code>@MessagingGateway</code> annotation, use code similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway(asyncExecutor = AnnotationConstants.NULL)
public interface NoExecGateway {

    @Gateway(requestChannel = "gatewayChannel")
    Future&lt;?&gt; doAsync(String foo);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the return type is a specific concrete <code>Future</code> implementation or some other sub-interface that is not supported by the configured executor, the flow runs on the caller&#8217;s thread and the flow must return the required type in the reply message payload.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="gw-completable-future"><a class="anchor" href="#gw-completable-future"></a><code>CompletableFuture</code></h5>
<div class="paragraph">
<p>Starting with version 4.2, gateway methods can now return <code>CompletableFuture&lt;?&gt;</code>.
There are two modes of operation when returning this type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When an async executor is provided and the return type is exactly <code>CompletableFuture</code> (not a subclass), the framework runs the task on the executor and immediately returns a <code>CompletableFuture</code> to the caller.
<code>CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code> is used to create the future.</p>
</li>
<li>
<p>When the async executor is explicitly set to <code>null</code> and the return type is <code>CompletableFuture</code> or the return type is a subclass of <code>CompletableFuture</code>, the flow is invoked on the caller&#8217;s thread.
In this scenario, the downstream flow is expected to return a <code>CompletableFuture</code> of the appropriate type.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="usage-scenarios"><a class="anchor" href="#usage-scenarios"></a>Usage Scenarios</h6>
<div class="paragraph">
<p>In the following scenario, the caller thread returns immediately with a <code>CompletableFuture&lt;Invoice&gt;</code>, which is completed when the downstream flow replies to the gateway (with an <code>Invoice</code> object).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture&lt;Invoice&gt; order(Order order);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway service-interface="something.Service" default-request-channel="orders" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following  scenario, the caller thread returns with a <code>CompletableFuture&lt;Invoice&gt;</code> when the downstream flow provides it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture&lt;Invoice&gt; order(Order order);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway service-interface="foo.Service" default-request-channel="orders"
    async-executor="" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following scenario, the caller thread returns with a <code>CompletableFuture&lt;Invoice&gt;</code> when the downstream flow provides it as the payload of the reply to the gateway.
Some other process must complete the future when the invoice is ready.
If <code>DEBUG</code> logging is enabled, a log entry is emitted, indicating that the async executor cannot be used for this scenario.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MyCompletableFuture&lt;Invoice&gt; order(Order order);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway service-interface="foo.Service" default-request-channel="orders" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>CompletableFuture</code> instances can be used to perform additional manipulation on the reply, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture&lt;String&gt; process(String data);

...

CompletableFuture result = process("foo")
    .thenApply(t -&gt; t.toUpperCase());

...

String out = result.get(10, TimeUnit.SECONDS);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reactor-mono"><a class="anchor" href="#reactor-mono"></a>Reactor <code>Mono</code></h5>
<div class="paragraph">
<p>Starting with version 5.0, the <code>GatewayProxyFactoryBean</code> allows the use of <a href="https://projectreactor.io/">Project Reactor</a> with gateway interface methods, using a <a href="https://github.com/reactor/reactor-core"><code>Mono&lt;T&gt;</code></a> return type.
The internal <code>AsyncInvocationTask</code> is wrapped in a <code>Mono.fromCallable()</code>.</p>
</div>
<div class="paragraph">
<p>A <code>Mono</code> can be used to retrieve the result later (similar to a <code>Future&lt;?&gt;</code>), or you can consume from it with the dispatcher by invoking your <code>Consumer</code> when the result is returned to the gateway.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>Mono</code> is not immediately flushed by the framework.
Consequently, the underlying message flow is not started before the gateway method returns (as it is with a <code>Future&lt;?&gt;</code> <code>Executor</code> task).
The flow starts when the <code>Mono</code> is subscribed to.
Alternatively, the <code>Mono</code> (being a <code>Composable</code>) might be a part of Reactor stream, when the <code>subscribe()</code> is related to the entire <code>Flux</code>.
The following example shows how to create a gateway with Project Reactor:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway
public static interface TestGateway {

	@Gateway(requestChannel = "promiseChannel")
	Mono&lt;Integer&gt; multiply(Integer value);

	}

	    ...

	@ServiceActivator(inputChannel = "promiseChannel")
	public Integer multiply(Integer value) {
			return value * 2;
	}

		...

    Flux.just("1", "2", "3", "4", "5")
            .map(Integer::parseInt)
            .flatMap(this.testGateway::multiply)
            .collectList()
            .subscribe(integers -&gt; ...);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another example that uses Project Reactor is a simple callback scenario, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;Invoice&gt; mono = service.process(myOrder);

mono.subscribe(invoice -&gt; handleInvoice(invoice));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The calling thread continues, with <code>handleInvoice()</code> being called when the flow completes.</p>
</div>
</div>
<div class="sect4">
<h5 id="downstream-flows-returning-an-asynchronous-type"><a class="anchor" href="#downstream-flows-returning-an-asynchronous-type"></a>Downstream Flows Returning an Asynchronous Type</h5>
<div class="paragraph">
<p>As mentioned in the <code>ListenableFuture</code> section above, if you wish some downstream component to return a message with an async payload (<code>Future</code>, <code>Mono</code>, and others), you must explicitly set the async executor to <code>null</code> (or <code>""</code> when using XML configuration).
The flow is then invoked on the caller thread and the result can be retrieved later.</p>
</div>
</div>
<div class="sect4">
<h5 id="void-return-type"><a class="anchor" href="#void-return-type"></a><code>void</code> Return Type</h5>
<div class="paragraph">
<p>Unlike the return types mentioned earlier, when the method return type is <code>void</code>, the framework cannot implicitly determine that you wish the downstream flow to run asynchronously, with the caller thread returning immediately.
In this case, you must annotate the interface method with <code>@Async</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway
public interface MyGateway {

    @Gateway(requestChannel = "sendAsyncChannel")
    @Async
    void sendAsync(String payload);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike the <code>Future&lt;?&gt;</code> return types, there is no way to inform the caller if some exception is thrown by the flow, unless some custom <code>TaskExecutor</code> (such as an <code>ErrorHandlingTaskExecutor</code>) is associated with the <code>@Async</code> annotation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gateway-no-response"><a class="anchor" href="#gateway-no-response"></a>10.4.11. Gateway Behavior When No response Arrives</h4>
<div class="paragraph">
<p>As <a href="#gateway-proxy">explained earlier</a>, the gateway provides a convenient way of interacting with a messaging system through POJO method invocations.
However, a typical method invocation, which is generally expected to always return (even with an Exception), might not always map one-to-one to message exchanges (for example, a reply message might not arrive&#8201;&#8212;&#8201;the equivalent to a method not returning).</p>
</div>
<div class="paragraph">
<p>The rest of this section covers various scenarios and how to make the gateway behave more predictably.
Certain attributes can be configured to make synchronous gateway behavior more predictable, but some of them might not always work as you might expect.
One of them is <code>reply-timeout</code> (at the method level or <code>default-reply-timeout</code> at the gateway level).
We examine the <code>reply-timeout</code> attribute to see how it can and cannot influence the behavior of the synchronous gateway in various scenarios.
We examine a single-threaded scenario (all components downstream are connected through a direct channel) and multi-threaded scenarios (for example,somewhere downstream you may have a pollable or executor channel that breaks the single-thread boundary).</p>
</div>
<div class="sect4">
<h5 id="long-running-process-downstream"><a class="anchor" href="#long-running-process-downstream"></a>Long-running Process Downstream</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Sync Gateway, single-threaded</dt>
<dd>
<p>If a component downstream is still running (perhaps because of an infinite loop or a slow service), setting a <code>reply-timeout</code> has no effect, and the gateway method call does not return until the downstream service exits (by returning or throwing an exception).</p>
</dd>
<dt class="hdlist1">SyncGateway, multi-threaded</dt>
<dd>
<p>If a component downstream is still running (perhaps because of an infinite loop or a slow service) in a multi-threaded message flow, setting the <code>reply-timeout</code> has an effect by allowing gateway method invocation to return once the timeout has been reached, because the <code>GatewayProxyFactoryBean</code> polls on the reply channel, waiting for a message until the timeout expires.
However, if the timeout has been reached before the actual reply was produced, it could result in a 'null' return from the gateway method.
You should understand that the reply message (if produced) is sent to a reply channel after the gateway method invocation might have returned, so you must be aware of that and design your flow with it in mind.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="downstream-component-returns-null"><a class="anchor" href="#downstream-component-returns-null"></a>Downstream Component Returns 'null'</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;single-threaded</dt>
<dd>
<p>If a component downstream returns 'null' and no <code>reply-timeout</code> has been configured, the gateway method call hangs indefinitely, unless a <code>reply-timeout</code> has been configured or the <code>requires-reply</code> attribute has been set on the downstream component (for example, a service activator) that might return 'null'.
In this case, an exception would be thrown and propagated to the gateway.</p>
</dd>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</dt>
<dd>
<p>The behavior is the same as the previous case.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="downstream-component-return-signature-is-void-while-gateway-method-signature-is-non-void"><a class="anchor" href="#downstream-component-return-signature-is-void-while-gateway-method-signature-is-non-void"></a>Downstream Component Return Signature is 'void' While Gateway Method Signature Is Non-void</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;single-threaded</dt>
<dd>
<p>If a component downstream returns 'void' and no <code>reply-timeout</code> has been configured, the gateway method call hangs indefinitely unless a <code>reply-timeout</code> has been configured.</p>
</dd>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</dt>
<dd>
<p>The behavior is the same as the previous case.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="downstream-component-results-in-runtime-exception"><a class="anchor" href="#downstream-component-results-in-runtime-exception"></a>Downstream Component Results in Runtime Exception</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;single-threaded</dt>
<dd>
<p>If a component downstream throws a runtime exception, the exception is propagated through an error message back to the gateway and re-thrown.</p>
</dd>
<dt class="hdlist1">Sync Gateway&#8201;&#8212;&#8201;multi-threaded</dt>
<dd>
<p>The behavior is the same as the previous case.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You should understand that, by default, <code>reply-timeout</code> is unbounded.
Consequently, if you do not explicitly set the <code>reply-timeout</code>, your gateway method invocation might hang indefinitely.
So, to make sure you analyze your flow and if there is even a remote possibility of one of these scenarios to occur, you should set the <code>reply-timeout</code> attribute to a "'safe'" value.
Even better, you can set the <code>requires-reply</code> attribute of the downstream component to 'true' to ensure a timely response, as produced by the throwing of an exception as soon as that downstream component returns null internally.
However you should also realize that there are some scenarios (see <a href="#long-running-process-downstream">the first one</a>) where <code>reply-timeout</code> does not help.
That means it is also important to analyze your message flow and decide when to use a synchronous gateway rather than an asynchrnous gateway.
As <a href="#async-gateway">described earlier</a>, the latter case is a matter of defining gateway methods that return <code>Future</code> instances.
Then you are guaranteed to receive that return value, and you have more granular control over the results of the invocation.
Also, when dealing with a router, you should remember that setting the <code>resolution-required</code> attribute to 'true' results in an exception thrown by the router if it can not resolve a particular channel.
Likewise, when dealing with a Filter, you can set the <code>throw-exception-on-rejection</code> attribute.
In both of these cases, the resulting flow behaves like it contain a service activator with the 'requires-reply' attribute.
In other words, it helps to ensure a timely response from the gateway method invocation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>reply-timeout</code> is unbounded for <code>&lt;gateway/&gt;</code> elements (created by the <code>GatewayProxyFactoryBean</code>).
Inbound gateways for external integration (WS, HTTP, and so on) share many characteristics and attributes with these gateways.
However, for those inbound gateways, the default <code>reply-timeout</code> is 1000 milliseconds (one second).
If a downstream asynchronous hand-off is made to another thread, you may need to increase this attribute to allow enough time for the flow to complete before the gateway times out.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You should understand that the timer starts when the thread returns to the gateway&#8201;&#8212;&#8201;that is, when the flow completes or a message is handed off to another thread.
At that time, the calling thread starts waiting for the reply.
If the flow was completely synchronous, the reply is immediately available.
For asynchronous flows, the thread waits for up to this time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#java-dsl-gateway"><code>IntegrationFlow</code> as Gateway</a> in the Java DSL chapter for options to define gateways through <code>IntegrationFlows</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="service-activator"><a class="anchor" href="#service-activator"></a>10.5. Service Activator</h3>
<div class="paragraph">
<p>The service activator is the endpoint type for connecting any Spring-managed object to an input channel so that it may play the role of a service.
If the service produces output, it may also be connected to an output channel.
Alternatively, an output-producing service may be located at the end of a processing pipeline or message flow, in which case the inbound message&#8217;s <code>replyChannel</code> header can be used.
This is the default behavior if no output channel is defined.
As with most of the configuration options described here, the same behavior actually applies for most of the other components.</p>
</div>
<div class="sect3">
<h4 id="service-activator-namespace"><a class="anchor" href="#service-activator-namespace"></a>10.5.1. Configuring Service Activator</h4>
<div class="paragraph">
<p>To create a service activator, use the 'service-activator' element with the 'input-channel' and 'ref' attributes, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="exampleChannel" ref="exampleHandler"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration selects all the methods from the <code>exampleHandler</code> that meet one of the messaging requirements, which are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>annotated with <code>@ServiceActivator</code></p>
</li>
<li>
<p>is <code>public</code></p>
</li>
<li>
<p>not return <code>void</code> if <code>requiresReply == true</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The target method for invocation at runtime is selected for each request message by their <code>payload</code> type or as a fallback to the <code>Message&lt;?&gt;</code> type if such a method is present on target class.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, one service method can be marked with the <code>@org.springframework.integration.annotation.Default</code> as a fallback for all non-matching cases.
This can be useful when using <a href="#content-type-conversion">content-type conversion</a> with the target method being invoked after conversion.</p>
</div>
<div class="paragraph">
<p>To delegate to an explicitly defined method of any object, you can add the <code>method</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="exampleChannel" ref="somePojo" method="someMethod"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In either case, when the service method returns a non-null value, the endpoint tries to send the reply message to an appropriate reply channel.
To determine the reply channel, it first checks whether an <code>output-channel</code> was provided in the endpoint configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="exampleChannel" output-channel="replyChannel"
                       ref="somePojo" method="someMethod"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the method returns a result and no <code>output-channel</code> is defined, the framework then checks the request message&#8217;s <code>replyChannel</code> header value.
If that value is available, it then checks its type.
If it is a <code>MessageChannel</code>, the reply message is sent to that channel.
If it is a <code>String</code>, the endpoint tries to resolve the channel name to a channel instance.
If the channel cannot be resolved, a <code>DestinationResolutionException</code> is thrown.
It it can be resolved, the message is sent there.
If the request message does not have a <code>replyChannel</code> header and the <code>reply</code> object is a <code>Message</code>, its <code>replyChannel</code> header is consulted for a target destination.
This is the technique used for request-reply messaging in Spring Integration, and it is also an example of the return address pattern.</p>
</div>
<div class="paragraph">
<p>If your method returns a result and you want to discard it and end the flow, you should configure the <code>output-channel</code> to send to a <code>NullChannel</code>.
For convenience, the framework registers one with the name, <code>nullChannel</code>.
See <a href="#channel-special-channels">Special Channels</a> for more information.</p>
</div>
<div class="paragraph">
<p>The service activator is one of those components that is not required to produce a reply message.
If your method returns <code>null</code> or has a <code>void</code> return type, the service activator exits after the method invocation, without any signals.
This behavior can be controlled by the <code>AbstractReplyProducingMessageHandler.requiresReply</code> option, which is also exposed as <code>requires-reply</code> when configuring with the XML namespace.
If the flag is set to <code>true</code> and the method returns null, a <code>ReplyRequiredException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The argument in the service method could be either a message or an arbitrary type.
If the latter, then it is assumed to be a message payload, which is extracted from the message and injected into the service method.
We generally recommend this approach, as it follows and promotes a POJO model when working with Spring Integration.
Arguments may also have <code>@Header</code> or <code>@Headers</code> annotations, as described in <a href="#annotations">Annotation Support</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The service method is not required to have any arguments, which means you can implement event-style service activators (where all you care about is an invocation of the service method) and not worry about the contents of the message.
Think of it as a null JMS message.
An example use case for such an implementation is a simple counter or monitor of messages deposited on the input channel.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.1, the framework correctly converts message properties (<code>payload</code> and <code>headers</code>) to the Java 8 <code>Optional</code> POJO method parameters, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBean {
    public String computeValue(Optional&lt;String&gt; payload,
               @Header(value="foo", required=false) String foo1,
               @Header(value="foo") Optional&lt;String&gt; foo2) {
        if (payload.isPresent()) {
            String value = payload.get();
            ...
        }
        else {
           ...
       }
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We generally recommend using a <code>ref</code> attribute if the custom service activator handler implementation can be reused in other <code>&lt;service-activator&gt;</code> definitions.
However, if the custom service activator handler implementation is only used within a single definition of the <code>&lt;service-activator&gt;</code>, you can provide an inner bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator id="exampleServiceActivator" input-channel="inChannel"
            output-channel = "outChannel" method="someMethod"&gt;
    &lt;beans:bean class="org.something.ExampleServiceActivator"/&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using both the <code>ref</code> attribute and an inner handler definition in the same <code>&lt;service-activator&gt;</code> configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If the <code>ref</code> attribute references a bean that extends <code>AbstractMessageProducingHandler</code> (such as handlers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.
In this case, each <code>ref</code> must be to a separate bean instance (or a <code>prototype</code>-scoped bean) or use the inner <code>&lt;bean/&gt;</code> configuration type.
If you inadvertently reference the same message handler from multiple beans, you get a configuration exception.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="service-activators-and-the-spring-expression-language-spel"><a class="anchor" href="#service-activators-and-the-spring-expression-language-spel"></a>Service Activators and the Spring Expression Language (SpEL)</h5>
<div class="paragraph">
<p>Since Spring Integration 2.0, service activators can also benefit from <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions">SpEL</a>.</p>
</div>
<div class="paragraph">
<p>For example, you can invoke any bean method without pointing to the bean in a <code>ref</code> attribute or including it as an inner bean definition, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="in" output-channel="out"
	expression="@accountService.processAccount(payload, headers.accountId)"/&gt;

	&lt;bean id="accountService" class="thing1.thing2.Account"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, instead of injecting 'accountService' by using a <code>ref</code> or as an inner bean, we use SpEL&#8217;s <code>@beanId</code> notation and invoke a method that takes a type compatible with the message payload.
We also pass a header value.
Any valid SpEL expression can be evaluated against any content in the message.
For simple scenarios, your service activators need not reference a bean if all logic can be encapsulated in such an expression, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="in" output-channel="out" expression="payload * 2"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, our service logic is to multiply the payload value by two.
SpEL lets us handle it relatively easily.</p>
</div>
<div class="paragraph">
<p>See <a href="#java-dsl-handle">Service Activators and the <code>.handle()</code> method</a> in the Java DSL chapter for more information about configuring service activator.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="async-service-activator"><a class="anchor" href="#async-service-activator"></a>10.5.2. Asynchronous Service Activator</h4>
<div class="paragraph">
<p>The service activator is invoked by the calling thread.
This is an upstream thread if the input channel is a <code>SubscribableChannel</code> or a poller thread for a <code>PollableChannel</code>.
If the service returns a <code>ListenableFuture&lt;?&gt;</code>, the default action is to send that as the payload of the message sent to the output (or reply) channel.
Starting with version 4.3, you can now set the <code>async</code> attribute to <code>true</code> (by using <code>setAsync(true)</code> when using Java configuration).
If the service returns a <code>ListenableFuture&lt;?&gt;</code> when this the <code>async</code> attribute is set to <code>true</code>, the calling thread is released immediately and the reply message is sent on the thread (from within your service) that completes the future.
This is particularly advantageous for long-running services that use a <code>PollableChannel</code>, because the poller thread is released to perform other services within the framework.</p>
</div>
<div class="paragraph">
<p>If the service completes the future with an <code>Exception</code>, normal error processing occurs.
An <code>ErrorMessage</code> is sent to the <code>errorChannel</code> message header, if present.
Otherwise, an <code>ErrorMessage</code> is sent to the default <code>errorChannel</code> (if available).</p>
</div>
</div>
<div class="sect3">
<h4 id="service-activator-return-type"><a class="anchor" href="#service-activator-return-type"></a>10.5.3. Service Activator and Method Return Type</h4>
<div class="paragraph">
<p>The service method can return any type which becomes reply message payload.
In this case a new <code>Message&lt;?&gt;</code> object is created and all the headers from a request message are copied.
This works the same way for most Spring Integration <code>MessageHandler</code> implementations, when interaction is based on a POJO method invocation.</p>
</div>
<div class="paragraph">
<p>A complete <code>Message&lt;?&gt;</code> object can also be returned from the method.
However keep in mind that, unlike <a href="#transformer">transformers</a>, for a Service Activator this message will be modified by copying the headers from the request message if they are not already present in the returned message.
So, if your method parameter is a <code>Message&lt;?&gt;</code> and you copy some, but not all, existing headers in your service method, they will reappear in the reply message.
It is not a Service Activator responsibility to remove headers from a reply message and, pursuing the loosely-coupled principle, it is better to add a <code>HeaderFilter</code> in the integration flow.
Alternatively, a Transformer can be used instead of a Service Activator but, in that case, when returning a full <code>Message&lt;?&gt;</code> the method is completely responsible for the message, including copying request message headers (if needed).
You must ensure that important framework headers (e.g. <code>replyChannel</code>, <code>errorChannel</code>), if present, have to be preserved.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delayer"><a class="anchor" href="#delayer"></a>10.6. Delayer</h3>
<div class="paragraph">
<p>A delayer is a simple endpoint that lets a message flow be delayed by a certain interval.
When a message is delayed, the original sender does not block.
Instead, the delayed messages are scheduled with an instance of <code>org.springframework.scheduling.TaskScheduler</code> to be sent to the output channel after the delay has passed.
This approach is scalable even for rather long delays, since it does not result in a large number of blocked sender threads.
On the contrary, in the typical case, a thread pool is used for the actual execution of releasing the messages.
This section contains several examples of configuring a delayer.</p>
</div>
<div class="sect3">
<h4 id="delayer-namespace"><a class="anchor" href="#delayer-namespace"></a>10.6.1. Configuring a Delayer</h4>
<div class="paragraph">
<p>The <code>&lt;delayer&gt;</code> element is used to delay the message flow between two message channels.
As with the other endpoints, you can provide the 'input-channel' and 'output-channel' attributes, but the delayer also has 'default-delay' and 'expression' attributes (and the 'expression' element) that determine the number of milliseconds by which each message should be delayed.
The following example delays all messages by three seconds:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:delayer id="delayer" input-channel="input"
             default-delay="3000" output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to determine the delay for each message, you can also provide the SpEL expression by using the 'expression' attribute, as the following expression shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:delayer id="delayer" input-channel="input" output-channel="output"
             default-delay="3000" expression="headers['delay']"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the three-second delay applies only when the expression evaluates to null for a given inbound message.
If you want to apply a delay only to messages that have a valid result of the expression evaluation, you can use a 'default-delay' of <code>0</code> (the default).
For any message that has a delay of <code>0</code> (or less), the message is sent immediately, on the calling thread.</p>
</div>
<div class="paragraph">
<p>The following example shows the Java configuration equivalent of the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "input")
@Bean
public DelayHandler delayer() {
    DelayHandler handler = new DelayHandler("delayer.messageGroupId");
    handler.setDefaultDelay(3_000L);
    handler.setDelayExpressionString("headers['delay']");
    handler.setOutputChannelName("output");
    return handler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Java DSL equivalent of the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow() {
    return IntegrationFlows.from("input")
            .delay("delayer.messageGroupId", d -&gt; d
                    .defaultDelay(3_000L)
                    .delayExpression("headers['delay']"))
            .channel("output")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The XML parser uses a message group ID of <code>&lt;beanName&gt;.messageGroupId</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The delay handler supports expression evaluation results that represent an interval in milliseconds (any <code>Object</code> whose <code>toString()</code> method produces a value that can be parsed into a <code>Long</code>) as well as <code>java.util.Date</code> instances representing an absolute time.
In the first case, the milliseconds are counted from the current time (for example
a value of <code>5000</code> would delay the message for at least five seconds from the time it is received by the delayer).
With a <code>Date</code> instance, the message is not released until the time represented by that <code>Date</code> object.
A value that equates to a non-positive delay or a Date in the past results in no delay.
Instead, it is sent directly to the output channel on the original sender&#8217;s thread.
If the expression evaluation result is not a <code>Date</code> and can not be parsed as a <code>Long</code>, the default delay (if any&#8201;&#8212;&#8201;the default is <code>0</code>) is applied.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The expression evaluation may throw an evaluation exception for various reasons, including an invalid expression or other conditions.
By default, such exceptions are ignored (though logged at the DEBUG level) and the delayer falls back to the default delay (if any).
You can modify this behavior by setting the <code>ignore-expression-failures</code> attribute.
By default, this attribute is set to <code>true</code> and the delayer behavior is as described earlier.
However, if you wish to not ignore expression evaluation exceptions and throw them to the delayer&#8217;s caller, set the <code>ignore-expression-failures</code> attribute to <code>false</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In the preceding example, the delay expression is specified as <code>headers['delay']</code>.
This is the SpEL <code>Indexer</code> syntax to access a <code>Map</code> element (<code>MessageHeaders</code> implements <code>Map</code>).
It invokes: <code>headers.get("delay")</code>.
For simple map element names (that do not contain '.') you can also use the SpEL &#8220;dot accessor&#8221; syntax, where the header expression shown earlier can be specified as <code>headers.delay</code>.
However, different results are achieved if the header is missing.
In the first case, the expression evaluates to <code>null</code>.
The second results in something similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> org.springframework.expression.spel.SpelEvaluationException: EL1008E:(pos 8):
		   Field or property 'delay' cannot be found on object of type 'org.springframework.messaging.MessageHeaders'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Consequently, if there is a possibility of the header being omitted and you want to fall back to the default delay, it is generally more efficient (and recommended) to use the indexer syntax instead of dot property accessor syntax, because detecting the null is faster than catching an exception.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The delayer delegates to an instance of Spring&#8217;s <code>TaskScheduler</code> abstraction.
The default scheduler used by the delayer is the <code>ThreadPoolTaskScheduler</code> instance provided by Spring Integration on startup.
See <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>.
If you want to delegate to a different scheduler, you can provide a reference through the delayer element&#8217;s 'scheduler' attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:delayer id="delayer" input-channel="input" output-channel="output"
    expression="headers.delay"
    scheduler="exampleTaskScheduler"/&gt;

&lt;task:scheduler id="exampleTaskScheduler" pool-size="3"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you configure an external <code>ThreadPoolTaskScheduler</code>, you can set <code>waitForTasksToCompleteOnShutdown = true</code> on this property.
It allows successful completion of 'delay' tasks that are already in the execution state (releasing the message) when the application is shutdown.
Before Spring Integration 2.2, this property was available on the <code>&lt;delayer&gt;</code> element, because <code>DelayHandler</code> could create its own scheduler on the background.
Since 2.2, the delayer requires an external scheduler instance and <code>waitForTasksToCompleteOnShutdown</code> was deleted.
You should use the scheduler&#8217;s own configuration.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>ThreadPoolTaskScheduler</code> has a property <code>errorHandler</code>, which can be injected with some implementation of <code>org.springframework.util.ErrorHandler</code>.
This handler allows processing an <code>Exception</code> from the thread of the scheduled task sending the delayed message.
By default, it uses an <code>org.springframework.scheduling.support.TaskUtils$LoggingErrorHandler</code>, and you can see a stack trace in the logs.
You might want to consider using an <code>org.springframework.integration.channel.MessagePublishingErrorHandler</code>, which sends an <code>ErrorMessage</code> into an <code>error-channel</code>, either from the failed message&#8217;s header or into the default <code>error-channel</code>.
This error handling is performed after a transaction rolls back (if present).
See <a href="#delayer-release-failures">Release Failures</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="delayer-message-store"><a class="anchor" href="#delayer-message-store"></a>10.6.2. Delayer and a Message Store</h4>
<div class="paragraph">
<p>The <code>DelayHandler</code> persists delayed messages into the message group in the provided <code>MessageStore</code>.
(The 'groupId' is based on the required 'id' attribute of the <code>&lt;delayer&gt;</code> element.)
A delayed message is removed from the <code>MessageStore</code> by the scheduled task immediately before the <code>DelayHandler</code> sends the message to the <code>output-channel</code>.
If the provided <code>MessageStore</code> is persistent (such as <code>JdbcMessageStore</code>), it provides the ability to not lose messages on the application shutdown.
After application startup, the <code>DelayHandler</code> reads messages from its message group in the <code>MessageStore</code> and reschedules them with a delay based on the original arrival time of the message (if the delay is numeric).
For messages where the delay header was a <code>Date</code>, that <code>Date</code> is used when rescheduling.
If a delayed message remains in the <code>MessageStore</code> more than its 'delay', it is sent immediately after startup.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;delayer&gt;</code> can be enriched with either of two mutually exclusive elements: <code>&lt;transactional&gt;</code> and <code>&lt;advice-chain&gt;</code>.
The <code>List</code> of these AOP advices is applied to the proxied internal <code>DelayHandler.ReleaseMessageHandler</code>, which has the responsibility to release the message, after the delay, on a <code>Thread</code> of the scheduled task.
It might be used, for example, when the downstream message flow throws an exception and the transaction of the <code>ReleaseMessageHandler</code> is rolled back.
In this case, the delayed message remains in the persistent <code>MessageStore</code>.
You can use any custom <code>org.aopalliance.aop.Advice</code> implementation within the <code>&lt;advice-chain&gt;</code>.
The <code>&lt;transactional&gt;</code> element defines a simple advice chain that has only the transactional advice.
The following example shows an <code>advice-chain</code> within a <code>&lt;delayer&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:delayer id="delayer" input-channel="input" output-channel="output"
    expression="headers.delay"
    message-store="jdbcMessageStore"&gt;
    &lt;int:advice-chain&gt;
        &lt;beans:ref bean="customAdviceBean"/&gt;
        &lt;tx:advice&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name="*" read-only="true"/&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
    &lt;/int:advice-chain&gt;
&lt;/int:delayer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DelayHandler</code> can be exported as a JMX <code>MBean</code> with managed operations (<code>getDelayedMessageCount</code> and <code>reschedulePersistedMessages</code>), which allows the rescheduling of delayed persisted messages at runtime&#8201;&#8212;&#8201;for example, if the <code>TaskScheduler</code> has previously been stopped.
These operations can be invoked through a <code>Control Bus</code> command, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;String&gt; delayerReschedulingMessage =
    MessageBuilder.withPayload("@'delayer.handler'.reschedulePersistedMessages()").build();
    controlBusChannel.send(delayerReschedulingMessage);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information regarding the message store, JMX, and the control bus, see <a href="#system-management-chapter">System Management</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="delayer-release-failures"><a class="anchor" href="#delayer-release-failures"></a>10.6.3. Release Failures</h4>
<div class="paragraph">
<p>Starting with version 5.0.8, there are two new properties on the delayer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>maxAttempts</code> (default 5)</p>
</li>
<li>
<p><code>retryDelay</code> (default 1 second)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a message is released, if the downstream flow fails, the release will be attempted after the <code>retryDelay</code>.
If the <code>maxAttempts</code> is reached, the message is discarded (unless the release is transactional, in which case the message will remain in the store, but will no longer be scheduled for release, until the application is restarted, or the <code>reschedulePersistedMessages()</code> method is invoked, as discussed above).</p>
</div>
<div class="paragraph">
<p>In addition, you can configure a <code>delayedMessageErrorChannel</code>; when a release fails, an <code>ErrorMessage</code> is sent to that channel with the exception as the payload and has the <code>originalMessage</code> property.
The <code>ErrorMessage</code> contains a header <code>IntegrationMessageHeaderAccessor.DELIVERY_ATTEMPT</code> containing the current count.</p>
</div>
<div class="paragraph">
<p>If the error flow consumes the error message and exits normally, no further action is taken; if the release is transactional, the transaction will commit and the message deleted from the store.
If the error flow throws an exception, the release will be retried up to <code>maxAttempts</code> as discussed above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scripting"><a class="anchor" href="#scripting"></a>10.7. Scripting Support</h3>
<div class="paragraph">
<p>Spring Integration 2.1 added support for the <a href="https://jcp.org/aboutJava/communityprocess/pr/jsr223/">JSR223 Scripting for Java specification</a>, introduced in Java version 6.
It lets you use scripts written in any supported language (including Ruby, JRuby, Javascript, and Groovy) to provide the logic for various integration components, similar to the way the Spring Expression Language (SpEL) is used in Spring Integration.
For more information about JSR223, see the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/prog_guide/api.html">documentation</a>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-scripting&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-scripting:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition you need to add a script engine implementation, e.g. JRuby, Jython.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Note that this feature requires Java 6 or higher.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to use a JVM scripting language, a JSR223 implementation for that language must be included in your class path.
Java 6 natively supports Javascript.
The <a href="http://www.groovy-lang.org/">Groovy</a> and <a href="https://www.jruby.org">JRuby</a> projects provide JSR233 support in their standard distributions.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Various JSR223 language implementations have been developed by third parties.
A particular implementation&#8217;s compatibility with Spring Integration depends on how well it conforms to the specification and the implementer&#8217;s interpretation of the specification.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you plan to use Groovy as your scripting language, we recommended you use <a href="#groovy">Spring-Integration&#8217;s Groovy Support</a> as it offers additional features specific to Groovy.
However, this section is relevant as well.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="scripting-config"><a class="anchor" href="#scripting-config"></a>10.7.1. Script Configuration</h4>
<div class="paragraph">
<p>Depending on the complexity of your integration requirements, scripts may be provided inline as CDATA in XML configurationor as a reference to a Spring resource that contains the script.
To enable scripting support, Spring Integration defines a <code>ScriptExecutingMessageProcessor</code>,which binds the message payload to a variable named <code>payload</code> and the message headers to a <code>headers</code> variable, both accessible within the script execution context.
All you need to do is write a script that uses these variables.
The following pair of examples show sample configurations that create filters:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Filter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="referencedScriptInput"&gt;
   &lt;int-script:script lang="ruby" location="some/path/to/ruby/script/RubyFilterTests.rb"/&gt;
&lt;/int:filter&gt;

&lt;int:filter input-channel="inlineScriptInput"&gt;
     &lt;int-script:script lang="groovy"&gt;
     &lt;![CDATA[
     return payload == 'good'
   ]]&gt;
  &lt;/int-script:script&gt;
&lt;/int:filter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding examples show, the script can be included inline or can be included by reference to a resource location (by using the <code>location</code> attribute).
Additionally, the <code>lang</code> attribute corresponds to the language name (or its JSR223 alias)</p>
</div>
<div class="paragraph">
<p>Other Spring Integration endpoint elements that support scripting include <code>router</code>, <code>service-activator</code>, <code>transformer</code>, and <code>splitter</code>.
The scripting configuration in each case would be identical to the above (besides the endpoint element).</p>
</div>
<div class="paragraph">
<p>Another useful feature of scripting support is the ability to update (reload) scripts without having to restart the application context.
To do so, specify the <code>refresh-check-delay</code> attribute on the <code>script</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-script:scriptlocation="..." refresh-check-delay="5000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the script location is checked for updates every 5 seconds.
If the script is updated, any invocation that occurs later than 5 seconds since the update results in running the new script.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-script:scriptlocation="..." refresh-check-delay="0"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the context is updated with any script modifications as soon as such modification occurs, providing a simple mechanism for 'real-time' configuration.
Any negative value means the script is not reloaded after initialization of the application context.
This is the default behavior.
The following example shows a script that never updates:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-script:scriptlocation="..." refresh-check-delay="-1"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Inline scripts can not be reloaded.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="scripting-script-variable-bindings"><a class="anchor" href="#scripting-script-variable-bindings"></a>Script Variable Bindings</h5>
<div class="paragraph">
<p>Variable bindings are required to enable the script to reference variables externally provided to the script&#8217;s execution context.
By default, <code>payload</code> and <code>headers</code> are used as binding variables.
You can bind additional variables to a script by using <code>&lt;variable&gt;</code> elements, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;script:script lang="js" location="foo/bar/MyScript.js"&gt;
    &lt;script:variable name="foo" value="thing1"/&gt;
    &lt;script:variable name="bar" value="thing2"/&gt;
    &lt;script:variable name="date" ref="date"/&gt;
&lt;/script:script&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As shown in the preceding example, you can bind a script variable either to a scalar value or to a Spring bean reference.
Note that <code>payload</code> and <code>headers</code> are still included as binding variables.</p>
</div>
<div class="paragraph">
<p>With Spring Integration 3.0, in addition to the <code>variable</code> element, the <code>variables</code> attribute has been introduced.
This attribute and the <code>variable</code> elements are not mutually exclusive, and you can combine them within one <code>script</code> component.
However, variables must be unique, regardless of where they are defined.
Also, since Spring Integration 3.0, variable bindings are allowed for inline scripts, too, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;service-activator input-channel="input"&gt;
    &lt;script:script lang="ruby" variables="thing1=THING1, date-ref=dateBean"&gt;
        &lt;script:variable name="thing2" ref="thing2Bean"/&gt;
        &lt;script:variable name="thing3" value="thing2"/&gt;
        &lt;![CDATA[
            payload.foo = thing1
            payload.date = date
            payload.bar = thing2
            payload.baz = thing3
            payload
        ]]&gt;
    &lt;/script:script&gt;
&lt;/service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows a combination of an inline script, a <code>variable</code> element, and a <code>variables</code> attribute.
The <code>variables</code> attribute contains a comma-separated value, where each segment contains an '=' separated pair of the variable and its value.
The variable name can be suffixed with <code>-ref</code>, as in the <code>date-ref</code> variable in the preceding example.
That means that the binding variable has the name, <code>date</code>, but the value is a reference to the <code>dateBean</code> bean from the application context.
This may be useful when using property placeholder configuration or command-line arguments.</p>
</div>
<div class="paragraph">
<p>If you need more control over how variables are generated, you can implement your own Java class that uses the <code>ScriptVariableGenerator</code> strategy, which is defined by the following interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ScriptVariableGenerator {

    Map&lt;String, Object&gt; generateScriptVariables(Message&lt;?&gt; message);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This interface requires you to implement the <code>generateScriptVariables(Message)</code> method.
The message argument lets you access any data available in the message payload and headers, and the return value is the <code>Map</code> of bound variables.
This method is called every time the script is executed for a message.
The following example shows how to provide an implementation of <code>ScriptVariableGenerator</code> and reference it with the <code>script-variable-generator</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-script:script location="foo/bar/MyScript.groovy"
        script-variable-generator="variableGenerator"/&gt;

&lt;bean id="variableGenerator" class="foo.bar.MyScriptVariableGenerator"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If a <code>script-variable-generator</code> is not provided, script components use <code>DefaultScriptVariableGenerator</code>, which merges any provided <code>&lt;variable&gt;</code> elements with <code>payload</code> and <code>headers</code> variables from the <code>Message</code> in its <code>generateScriptVariables(Message)</code> method.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You cannot provide both the <code>script-variable-generator</code> attribute and <code>&lt;variable&gt;</code> element(s).
They are mutually exclusive.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="groovy"><a class="anchor" href="#groovy"></a>10.8. Groovy support</h3>
<div class="paragraph">
<p>In Spring Integration 2.0, we added Groovy support, letting you use the Groovy scripting language to provide the logic for various integration components&#8201;&#8212;&#8201;similar to the way the Spring Expression Language (SpEL) is supported for routing, transformation, and other integration concerns.
For more information about Groovy, see the Groovy documentation, which you can find on the <a href="https://groovy-lang.org/">project website</a>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-groovy&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-groovy:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="groovy-config"><a class="anchor" href="#groovy-config"></a>10.8.1. Groovy Configuration</h4>
<div class="paragraph">
<p>With Spring Integration 2.1, the configuration namespace for the Groovy support is an extension of Spring Integration&#8217;s scripting support and shares the core configuration and behavior described in detail in the <a href="#scripting">Scripting Support</a> section.
Even though Groovy scripts are well supported by generic scripting support, the Groovy support provides the <code>Groovy</code> configuration namespace, which is backed by the Spring Framework&#8217;s <code>org.springframework.scripting.groovy.GroovyScriptFactory</code> and related components, offering extended capabilities for using Groovy.
The following listing shows two sample configurations:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Filter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="referencedScriptInput"&gt;
   &lt;int-groovy:script location="some/path/to/groovy/file/GroovyFilterTests.groovy"/&gt;
&lt;/int:filter&gt;

&lt;int:filter input-channel="inlineScriptInput"&gt;
     &lt;int-groovy:script&gt;&lt;![CDATA[
     return payload == 'good'
   ]]&gt;&lt;/int-groovy:script&gt;
&lt;/int:filter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding examples show, the configuration looks identical to the general scripting support configuration.
The only difference is the use of the Groovy namespace, as indicated by the <code>int-groovy</code> namespace prefix.
Also note that the <code>lang</code> attribute on the <code>&lt;script&gt;</code> tag is not valid in this namespace.</p>
</div>
</div>
<div class="sect3">
<h4 id="groovy-object-customization"><a class="anchor" href="#groovy-object-customization"></a>10.8.2. Groovy Object Customization</h4>
<div class="paragraph">
<p>If you need to customize the Groovy object itself (beyond setting variables) you can reference a bean that implements <code>GroovyObjectCustomizer</code> by using the <code>customizer</code> attribute.
For example, this might be useful if you want to implement a domain-specific language (DSL) by modifying the <code>MetaClass</code> and registering functions to be available within the script.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="groovyChannel"&gt;
    &lt;int-groovy:script location="somewhere/SomeScript.groovy" customizer="groovyCustomizer"/&gt;
&lt;/int:service-activator&gt;

&lt;beans:bean id="groovyCustomizer" class="org.something.MyGroovyObjectCustomizer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Setting a custom <code>GroovyObjectCustomizer</code> is not mutually exclusive with <code>&lt;variable&gt;</code> elements or the <code>script-variable-generator</code> attribute.
It can also be provided when defining an inline script.</p>
</div>
<div class="paragraph">
<p>Spring Integration 3.0 introduced the <code>variables</code> attribute, which works in conjunction with the <code>variable</code> element.
Also, groovy scripts have the ability to resolve a variable to a bean in the <code>BeanFactory</code>, if a binding variable was not provided with the name.
The following example shows how to use a variable (<code>entityManager</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-groovy:script&gt;
    &lt;![CDATA[
        entityManager.persist(payload)
        payload
    ]]&gt;
&lt;/int-groovy:script&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>entityManager</code> must be an appropriate bean in the application context.</p>
</div>
<div class="paragraph">
<p>For more information regarding the <code>&lt;variable&gt;</code> element, the <code>variables</code> attribute, and the <code>script-variable-generator</code> attribute, see  <a href="#scripting-script-variable-bindings">Script Variable Bindings</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="groovy-script-compiler-customization"><a class="anchor" href="#groovy-script-compiler-customization"></a>10.8.3. Groovy Script Compiler Customization</h4>
<div class="paragraph">
<p>The <code>@CompileStatic</code> hint is the most popular Groovy compiler customization option.
It can be used on the class or method level.
For more information, see the Groovy <a href="https://groovy-lang.org/metaprogramming.html#section-typechecked">Reference Manual</a> and, specifically, <a href="https://groovy-lang.org/metaprogramming.html#xform-CompileStatic">@CompileStatic</a>.
To utilize this feature for short scripts (in integration scenarios), we are forced to change simple scripts to more Java-like code.
Consider the following <code>&lt;filter&gt;</code> script:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">headers.type == 'good'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding script becomes the following method in Spring Integration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@groovy.transform.CompileStatic
String filter(Map headers) {
	headers.type == 'good'
}

filter(headers)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With that, the <code>filter()</code> method is transformed and compiled to static Java code, bypassing the Groovy
dynamic phases of invocation, such as <code>getProperty()</code> factories and <code>CallSite</code> proxies.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can configure the Spring Integration Groovy components with the <code>compile-static</code> <code>boolean</code> option, specifying that <code>ASTTransformationCustomizer</code> for <code>@CompileStatic</code> should be added to the internal <code>CompilerConfiguration</code>.
With that in place, you can omit the method declaration with <code>@CompileStatic</code> in our script code and still get compiled
plain Java code.
In this case, the preceding script can be short but still needs to be a little more verbose than interpreted script, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">binding.variables.headers.type == 'good'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You must access the <code>headers</code> and <code>payload</code> (or any other) variables through the <code>groovy.lang.Script</code> <code>binding</code> property because, with <code>@CompileStatic</code>, we do not have the  dynamic <code>GroovyObject.getProperty()</code> capability.</p>
</div>
<div class="paragraph">
<p>In addition, we introduced the <code>compiler-configuration</code> bean reference.
With this attribute, you can provide any other required Groovy compiler customizations, such as <code>ImportCustomizer</code>.
For more information about this feature, see the Groovy Documentation for <a href="https://melix.github.io/blog/2011/05/12/customizing_groovy_compilation_process.html">advanced compiler configuration</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using <code>compilerConfiguration</code> does not automatically add an <code>ASTTransformationCustomizer</code> for the <code>@CompileStatic</code> annotation, and it overrides the <code>compileStatic</code> option.
If you still need <code>CompileStatic</code>, you should manually add a <code>new ASTTransformationCustomizer(CompileStatic.class)</code> into the <code>CompilationCustomizers</code> of that custom <code>compilerConfiguration</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Groovy compiler customization does not have any effect on the <code>refresh-check-delay</code> option, and reloadable scripts can be statically compiled, too.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="groovy-control-bus"><a class="anchor" href="#groovy-control-bus"></a>10.8.4. Control Bus</h4>
<div class="paragraph">
<p>As described in (<a href="https://www.enterpriseintegrationpatterns.com/ControlBus.html">Enterprise Integration Patterns</a>), the idea behind the control bus is that you can use the same messaging system for monitoring and managing the components within the framework as is used for &#8220;application-level&#8221; messaging.
In Spring Integration, we build upon the adapters described earlier so that you can send Messages as a means of invoking exposed operations.
One option for those operations is Groovy scripts.
The following example configures a Groovy script for the control bus:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-groovy:control-bus input-channel="operationChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The control bus has an input channel that can be accessed to invoke operations on the beans in the application context.</p>
</div>
<div class="paragraph">
<p>The Groovy control bus runs messages on the input channel as Groovy scripts.
It takes a message, compiles the body to a script, customizes it with a <code>GroovyObjectCustomizer</code>, and runs it.
The control bus' <code>MessageProcessor</code> exposes all beans in the application context that are annotated with <code>@ManagedResource</code> and implement Spring&#8217;s <code>Lifecycle</code> interface or extend Spring&#8217;s <code>CustomizableThreadCreator</code> base class (for example, several of the <code>TaskExecutor</code> and <code>TaskScheduler</code> implementations).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Be careful about using managed beans with custom scopes (such as 'request') in the Control Bus' command scripts, especially inside an asynchronous message flow.
If <code>MessageProcessor</code> of the control bus cannot expose a bean from the application context, you may end up with some <code>BeansException</code> during the command script&#8217;s run.
For example, if a custom scope&#8217;s context is not established, the attempt to get a bean within that scope triggers a <code>BeanCreationException</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to further customize the Groovy objects, you can also provide a reference to a bean that implements <code>GroovyObjectCustomizer</code> through the <code>customizer</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-groovy:control-bus input-channel="input"
        output-channel="output"
        customizer="groovyCustomizer"/&gt;

&lt;beans:bean id="groovyCustomizer" class="org.foo.MyGroovyObjectCustomizer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-handler-advice-chain"><a class="anchor" href="#message-handler-advice-chain"></a>10.9. Adding Behavior to Endpoints</h3>
<div class="paragraph">
<p>Prior to Spring Integration 2.2, you could add behavior to an entire Integration flow by adding an AOP Advice to a poller&#8217;s <code>&lt;advice-chain/&gt;</code> element.
However, suppose you want to retry, say, just a REST Web Service call, and not any downstream endpoints.</p>
</div>
<div class="paragraph">
<p>For example, consider the following flow:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>inbound-adapter-&gt;poller-&gt;http-gateway1-&gt;http-gateway2-&gt;jdbc-outbound-adapter</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you configure some retry-logic into an advice chain on the poller and the call to <code>http-gateway2</code> failed because of a network glitch, the retry causes both <code>http-gateway1</code> and <code>http-gateway2</code> to be called a second time.
Similarly, after a transient failure in the jdbc-outbound-adapter, both HTTP gateways are called a second time before again calling the <code>jdbc-outbound-adapter</code>.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.2 adds the ability to add behavior to individual endpoints.
This is achieved by the addition of the <code>&lt;request-handler-advice-chain/&gt;</code> element to many endpoints.
The following example shows how to the <code>&lt;request-handler-advice-chain/&gt;</code> element within an <code>outbound-gateway</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="withAdvice"
    url-expression="'http://localhost/test1'"
    request-channel="requests"
    reply-channel="nextChannel"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;ref bean="myRetryAdvice" /&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int-http:outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>myRetryAdvice</code> is applied only locally to this gateway and does not apply to further actions taken downstream after the reply is sent to <code>nextChannel</code>.
The scope of the advice is limited to the endpoint itself.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>At this time, you cannot advise an entire <code>&lt;chain/&gt;</code> of endpoints.
The schema does not allow a <code>&lt;request-handler-advice-chain&gt;</code> as a child element of the chain itself.</p>
</div>
<div class="paragraph">
<p>However, a <code>&lt;request-handler-advice-chain&gt;</code> can be added to individual reply-producing endpoints within a <code>&lt;chain&gt;</code> element.
An exception is that, in a chain that produces no reply, because the last element in the chain is an <code>outbound-channel-adapter</code>, that last element cannot be advised.
If you need to advise such an element, it must be moved outside of the chain (with the <code>output-channel</code> of the chain being the <code>input-channel</code> of the adapter).
The adapter can then be advised as usual.
For chains that produce a reply, every child element can be advised.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="advice-classes"><a class="anchor" href="#advice-classes"></a>10.9.1. Provided Advice Classes</h4>
<div class="paragraph">
<p>In addition to providing the general mechanism to apply AOP advice classes, Spring Integration provides three standard advice classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestHandlerRetryAdvice</code> (described in <a href="#retry-advice">Retry Advice</a>)</p>
</li>
<li>
<p><code>RequestHandlerCircuitBreakerAdvice</code> (described in <a href="#circuit-breaker-advice">Circuit Breaker Advice</a>)</p>
</li>
<li>
<p><code>ExpressionEvaluatingRequestHandlerAdvice</code> (described in <a href="#expression-advice">Expression Evaluating Advice</a>)</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="retry-advice"><a class="anchor" href="#retry-advice"></a>Retry Advice</h5>
<div class="paragraph">
<p>The retry advice (<code>o.s.i.handler.advice.RequestHandlerRetryAdvice</code>) leverages the rich retry mechanisms provided by the <a href="https://github.com/spring-projects/spring-retry">Spring Retry</a> project.
The core component of <code>spring-retry</code> is the <code>RetryTemplate</code>, which allows configuration of sophisticated retry scenarios, including <code>RetryPolicy</code> and <code>BackoffPolicy</code> strategies (with a number of implementations) as well as a <code>RecoveryCallback</code> strategy to determine the action to take when retries are exhausted.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Stateless Retry</dt>
<dd>
<p>Stateless retry is the case where the retry activity is handled entirely within the advice.
The thread pauses (if configured to do so) and retries the action.</p>
</dd>
<dt class="hdlist1">Stateful Retry</dt>
<dd>
<p>Stateful retry is the case where the retry state is managed within the advice but where an exception is thrown and the caller resubmits the request.
An example for stateful retry is when we want the message originator (for example,JMS) to be responsible for resubmitting, rather than performing it on the current thread.
Stateful retry needs some mechanism to detect a retried submission.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For more information on <code>spring-retry</code>, see <a href="https://docs.spring.io/spring-integration/api/">the project&#8217;s Javadoc</a> and the reference documentation for <a href="https://docs.spring.io/spring-batch/reference/html/retry.html">Spring Batch</a>, where <code>spring-retry</code> originated.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The default back off behavior is to not back off.
Retries are attempted immediately.
Using a back off policy that causes threads to pause between attempts may cause performance issues, including excessive memory use and thread starvation.
In high-volume environments, back off policies should be used with caution.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="retry-config"><a class="anchor" href="#retry-config"></a>Configuring the Retry Advice</h6>
<div class="paragraph">
<p>The examples in this section use the following <code>&lt;service-activator&gt;</code> that always throws an exception:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FailingService {

    public void service(String message) {
        throw new RuntimeException("error");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Simple Stateless Retry</dt>
<dd>
<p>The default <code>RetryTemplate</code> has a <code>SimpleRetryPolicy</code> which tries three times.
There is no <code>BackOffPolicy</code>, so the three attempts are made back-to-back-to-back with no delay between attempts.
There is no <code>RecoveryCallback</code>, so the result is to throw the exception to the caller after the final failed retry occurs.
In a Spring Integration environment, this final exception might be handled by using an <code>error-channel</code> on the inbound endpoint.
The following example uses <code>RetryTemplate</code> and shows its <code>DEBUG</code> output:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean class="o.s.i.handler.advice.RequestHandlerRetryAdvice"/&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Simple Stateless Retry with Recovery</dt>
<dd>
<p>The following example adds a <code>RecoveryCallback</code> to the preceding example and uses an <code>ErrorMessageSendingRecoverer</code> to send an <code>ErrorMessage</code> to a channel:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean class="o.s.i.handler.advice.RequestHandlerRetryAdvice"&gt;
            &lt;property name="recoveryCallback"&gt;
                &lt;bean class="o.s.i.handler.advice.ErrorMessageSendingRecoverer"&gt;
                    &lt;constructor-arg ref="myErrorChannel" /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int:int:service-activator&gt;

DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
DEBUG [task-scheduler-2]Retry: count=0
DEBUG [task-scheduler-2]Checking for rethrow: count=1
DEBUG [task-scheduler-2]Retry: count=1
DEBUG [task-scheduler-2]Checking for rethrow: count=2
DEBUG [task-scheduler-2]Retry: count=2
DEBUG [task-scheduler-2]Checking for rethrow: count=3
DEBUG [task-scheduler-2]Retry failed last attempt: count=3
DEBUG [task-scheduler-2]Sending ErrorMessage :failedMessage:[Payload=...]</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Stateless Retry with Customized Policies, and Recovery</dt>
<dd>
<p>For more sophistication, we can provide the advice with a customized <code>RetryTemplate</code>.
This example continues to use the <code>SimpleRetryPolicy</code> but increases the attempts to four.
It also adds an <code>ExponentialBackoffPolicy</code> where the first retry waits one second, the second waits five seconds and the third waits 25 (for four attempts in all).
The following listing shows the example and its <code>DEBUG</code> output:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean class="o.s.i.handler.advice.RequestHandlerRetryAdvice"&gt;
            &lt;property name="recoveryCallback"&gt;
                &lt;bean class="o.s.i.handler.advice.ErrorMessageSendingRecoverer"&gt;
                    &lt;constructor-arg ref="myErrorChannel" /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name="retryTemplate" ref="retryTemplate" /&gt;
        &lt;/bean&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;

&lt;bean id="retryTemplate" class="org.springframework.retry.support.RetryTemplate"&gt;
    &lt;property name="retryPolicy"&gt;
        &lt;bean class="org.springframework.retry.policy.SimpleRetryPolicy"&gt;
            &lt;property name="maxAttempts" value="4" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="backOffPolicy"&gt;
        &lt;bean class="org.springframework.retry.backoff.ExponentialBackOffPolicy"&gt;
            &lt;property name="initialInterval" value="1000" /&gt;
            &lt;property name="multiplier" value="5.0" /&gt;
            &lt;property name="maxInterval" value="60000" /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

27.058 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
27.071 DEBUG [task-scheduler-1]Retry: count=0
27.080 DEBUG [task-scheduler-1]Sleeping for 1000
28.081 DEBUG [task-scheduler-1]Checking for rethrow: count=1
28.081 DEBUG [task-scheduler-1]Retry: count=1
28.081 DEBUG [task-scheduler-1]Sleeping for 5000
33.082 DEBUG [task-scheduler-1]Checking for rethrow: count=2
33.082 DEBUG [task-scheduler-1]Retry: count=2
33.083 DEBUG [task-scheduler-1]Sleeping for 25000
58.083 DEBUG [task-scheduler-1]Checking for rethrow: count=3
58.083 DEBUG [task-scheduler-1]Retry: count=3
58.084 DEBUG [task-scheduler-1]Checking for rethrow: count=4
58.084 DEBUG [task-scheduler-1]Retry failed last attempt: count=4
58.086 DEBUG [task-scheduler-1]Sending ErrorMessage :failedMessage:[Payload=...]</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Namespace Support for Stateless Retry</dt>
<dd>
<p>Starting with version 4.0, the preceding configuration can be greatly simplified, thanks to the namespace support for the retry advice, as the following example shows:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean ref="retrier" /&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;

&lt;int:handler-retry-advice id="retrier" max-attempts="4" recovery-channel="myErrorChannel"&gt;
    &lt;int:exponential-back-off initial="1000" multiplier="5.0" maximum="60000" /&gt;
&lt;/int:handler-retry-advice&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the advice is defined as a top-level bean so that it can be used in multiple <code>request-handler-advice-chain</code> instances.
You can also define the advice directly within the chain, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;int:retry-advice id="retrier" max-attempts="4" recovery-channel="myErrorChannel"&gt;
            &lt;int:exponential-back-off initial="1000" multiplier="5.0" maximum="60000" /&gt;
        &lt;/int:retry-advice&gt;
    &lt;/request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A <code>&lt;handler-retry-advice&gt;</code> can have a <code>&lt;fixed-back-off&gt;</code> or <code>&lt;exponential-back-off&gt;</code> child element or have no child element.
A <code>&lt;handler-retry-advice&gt;</code> with no child element uses no back off.
If there is no <code>recovery-channel</code>, the exception is thrown when retries are exhausted.
The namespace can only be used with stateless retry.</p>
</div>
<div class="paragraph">
<p>For more complex environments (custom policies etc), use normal <code>&lt;bean&gt;</code> definitions.</p>
</div>
</dd>
<dt class="hdlist1">Simple Stateful Retry with Recovery</dt>
<dd>
<p>To make retry stateful, we need to provide the advice with a <code>RetryStateGenerator</code> implementation.
This class is used to identify a message as being a resubmission so that the <code>RetryTemplate</code> can determine the current state of retry for this message.
The framework provides a <code>SpelExpressionRetryStateGenerator</code>, which determines the message identifier by using a SpEL expression.
This example again uses the default policies (three attempts with no back off).
As with stateless retry, these policies can be customized.
The following listing shows the example and its <code>DEBUG</code> output:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean class="o.s.i.handler.advice.RequestHandlerRetryAdvice"&gt;
            &lt;property name="retryStateGenerator"&gt;
                &lt;bean class="o.s.i.handler.advice.SpelExpressionRetryStateGenerator"&gt;
                    &lt;constructor-arg value="headers['jms_messageId']" /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name="recoveryCallback"&gt;
                &lt;bean class="o.s.i.handler.advice.ErrorMessageSendingRecoverer"&gt;
                    &lt;constructor-arg ref="myErrorChannel" /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/int:request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;

24.351 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
24.368 DEBUG [Container#0-1]Retry: count=0
24.387 DEBUG [Container#0-1]Checking for rethrow: count=1
24.387 DEBUG [Container#0-1]Rethrow in retry for policy: count=1
24.387 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
24.391 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
25.412 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
25.412 DEBUG [Container#0-1]Retry: count=1
25.413 DEBUG [Container#0-1]Checking for rethrow: count=2
25.413 DEBUG [Container#0-1]Rethrow in retry for policy: count=2
25.413 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
25.414 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
26.418 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
26.418 DEBUG [Container#0-1]Retry: count=2
26.419 DEBUG [Container#0-1]Checking for rethrow: count=3
26.419 DEBUG [Container#0-1]Rethrow in retry for policy: count=3
26.419 WARN  [Container#0-1]failure occurred in gateway sendAndReceive
org.springframework.integration.MessagingException: Failed to invoke handler
...
Caused by: java.lang.RuntimeException: foo
...
26.420 DEBUG [Container#0-1]Initiating transaction rollback on application exception
...
27.425 DEBUG [Container#0-1]preSend on channel 'input', message: [Payload=...]
27.426 DEBUG [Container#0-1]Retry failed last attempt: count=3
27.426 DEBUG [Container#0-1]Sending ErrorMessage :failedMessage:[Payload=...]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you compare the preceding example with the stateless examples, you can see that, with stateful retry, the exception is thrown to the caller on each failure.</p>
</div>
</dd>
<dt class="hdlist1">Exception Classification for Retry</dt>
<dd>
<p>Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.
The default configuration retries for all exceptions and the exception classifier looks at the top-level exception.
If you configure it to, say, retry only on <code>MyException</code> and your application throws a <code>SomeOtherException</code> where the cause is a <code>MyException</code>, retry does not occur.</p>
<div class="paragraph">
<p>Since Spring Retry 1.0.3, the <code>BinaryExceptionClassifier</code> has a property called <code>traverseCauses</code> (the default is <code>false</code>).
When <code>true</code>, it traverses exception causes until it finds a match or runs out of causes to traverse.</p>
</div>
<div class="paragraph">
<p>To use this classifier for retry, use a <code>SimpleRetryPolicy</code> created with the constructor that takes the max attempts, the <code>Map</code> of <code>Exception</code> objects, and the <code>traverseCauses</code> boolean.
Then you can inject this policy into the <code>RetryTemplate</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="circuit-breaker-advice"><a class="anchor" href="#circuit-breaker-advice"></a>Circuit Breaker Advice</h5>
<div class="paragraph">
<p>The general idea of the circuit breaker pattern is that, if a service is not currently available, do not waste time (and resources) trying to use it.
The <code>o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice</code> implements this pattern.
When the circuit breaker is in the closed state, the endpoint attempts to invoke the service.
The circuit breaker goes to the open state if a certain number of consecutive attempts fail.
When it is in the open state, new requests &#8220;fail fast&#8221; and no attempt is made to invoke the service until some time has expired.</p>
</div>
<div class="paragraph">
<p>When that time has expired, the circuit breaker is set to the half-open state.
When in this state, if even a single attempt fails, the breaker immediately goes to the open state.
If the attempt succeeds, the breaker goes to the closed state, in which case it does not go to the open state again until the configured number of consecutive failures again occur.
Any successful attempt resets the state to zero failures for the purpose of determining when the breaker might go to the open state again.</p>
</div>
<div class="paragraph">
<p>Typically, this advice might be used for external services, where it might take some time to fail (such as a timeout attempting to make a network connection).</p>
</div>
<div class="paragraph">
<p>The <code>RequestHandlerCircuitBreakerAdvice</code> has two properties: <code>threshold</code> and <code>halfOpenAfter</code>.
The <code>threshold</code> property represents the number of consecutive failures that need to occur before the breaker goes open.
It defaults to <code>5</code>.
The <code>halfOpenAfter</code> property represents the time after the last failure that the breaker waits before attempting another request.
The default is 1000 milliseconds.</p>
</div>
<div class="paragraph">
<p>The following example configures a circuit breaker and shows its <code>DEBUG</code> and <code>ERROR</code> output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="input" ref="failer" method="service"&gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;bean class="o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice"&gt;
            &lt;property name="threshold" value="2" /&gt;
            &lt;property name="halfOpenAfter" value="12000" /&gt;
        &lt;/bean&gt;
    &lt;/int:request-handler-advice-chain&gt;
&lt;/int:service-activator&gt;

05.617 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]
05.638 ERROR [task-scheduler-1]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
10.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
10.600 ERROR [task-scheduler-2]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
15.598 DEBUG [task-scheduler-3]preSend on channel 'input', message: [Payload=...]
15.599 ERROR [task-scheduler-3]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
20.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]
20.598 ERROR [task-scheduler-2]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator
...
25.598 DEBUG [task-scheduler-5]preSend on channel 'input', message: [Payload=...]
25.601 ERROR [task-scheduler-5]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo
...
30.598 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=foo...]
30.599 ERROR [task-scheduler-1]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the threshold is set to <code>2</code> and <code>halfOpenAfter</code> is set to <code>12</code> seconds.
A new request arrives every 5 seconds.
The first two attempts invoked the service.
The third and fourth failed with an exception indicating that the circuit breaker is open.
The fifth request was attempted because the request was 15 seconds after the last failure.
The sixth attempt fails immediately because the breaker immediately went to open.</p>
</div>
</div>
<div class="sect4">
<h5 id="expression-advice"><a class="anchor" href="#expression-advice"></a>Expression Evaluating Advice</h5>
<div class="paragraph">
<p>The final supplied advice class is the <code>o.s.i.handler.advice.ExpressionEvaluatingRequestHandlerAdvice</code>.
This advice is more general than the other two advices.
It provides a mechanism to evaluate an expression on the original inbound message sent to the endpoint.
Separate expressions are available to be evaluated, after either success or failure.
Optionally, a message containing the evaluation result, together with the input message, can be sent to a message channel.</p>
</div>
<div class="paragraph">
<p>A typical use case for this advice might be with an <code>&lt;ftp:outbound-channel-adapter/&gt;</code>, perhaps to move the file to one directory if the transfer was successful or to another directory if it fails:</p>
</div>
<div class="paragraph">
<p>The advice has properties to set an expression when successful, an expression for failures, and corresponding channels for each.
For the successful case, the message sent to the <code>successChannel</code> is an <code>AdviceMessage</code>, with the payload being the result of the expression evaluation.
An additional property, called <code>inputMessage</code>, contains the original message sent to the handler.
A message sent to the <code>failureChannel</code> (when the handler throws an exception) is an <code>ErrorMessage</code> with a payload of <code>MessageHandlingExpressionEvaluatingAdviceException</code>.
Like all <code>MessagingException</code> instances, this payload has <code>failedMessage</code> and <code>cause</code> properties, as well as an additional property called <code>evaluationResult</code>, which contains the result of the expression evaluation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 5.1.3, if channels are configured, but expressions are not provided, the default expression is used to evaluate to the <code>payload</code> of the message.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an exception is thrown in the scope of the advice, by default, that exception is thrown to the caller after any <code>failureExpression</code> is evaluated.
If you wish to suppress throwing the exception, set the <code>trapException</code> property to <code>true</code>.
The following advice shows how to configure an advice with Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class EerhaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(EerhaApplication.class, args);
        MessageChannel in = context.getBean("advised.input", MessageChannel.class);
        in.send(new GenericMessage&lt;&gt;("good"));
        in.send(new GenericMessage&lt;&gt;("bad"));
        context.close();
    }

    @Bean
    public IntegrationFlow advised() {
        return f -&gt; f.handle((GenericHandler&lt;String&gt;) (payload, headers) -&gt; {
            if (payload.equals("good")) {
                return null;
            }
            else {
                throw new RuntimeException("some failure");
            }
        }, c -&gt; c.advice(expressionAdvice()));
    }

    @Bean
    public Advice expressionAdvice() {
        ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();
        advice.setSuccessChannelName("success.input");
        advice.setOnSuccessExpressionString("payload + ' was successful'");
        advice.setFailureChannelName("failure.input");
        advice.setOnFailureExpressionString(
                "payload + ' was bad, with reason: ' + #exception.cause.message");
        advice.setTrapException(true);
        return advice;
    }

    @Bean
    public IntegrationFlow success() {
        return f -&gt; f.handle(System.out::println);
    }

    @Bean
    public IntegrationFlow failure() {
        return f -&gt; f.handle(System.out::println);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-advice"><a class="anchor" href="#custom-advice"></a>10.9.2. Custom Advice Classes</h4>
<div class="paragraph">
<p>In addition to the provided advice classes <a href="#advice-classes">described earlier</a>, you can implement your own advice classes.
While you can provide any implementation of <code>org.aopalliance.aop.Advice</code> (usually <code>org.aopalliance.intercept.MethodInterceptor</code>), we generally recommend that you subclass <code>o.s.i.handler.advice.AbstractRequestHandlerAdvice</code>.
This has the benefit of avoiding the writing of low-level aspect-oriented programming code as well as providing a starting point that is specifically tailored for use in this environment.</p>
</div>
<div class="paragraph">
<p>Subclasses need to implement the <code>doInvoke()`</code> method, the definition of which follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Subclasses implement this method to apply behavior to the {@link MessageHandler} callback.execute()
 * invokes the handler method and returns its result, or null).
 * @param callback Subclasses invoke the execute() method on this interface to invoke the handler method.
 * @param target The target handler.
 * @param message The message that will be sent to the handler.
 * @return the result after invoking the {@link MessageHandler}.
 * @throws Exception
 */
protected abstract Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) throws Exception;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The callback parameter is a convenience to avoid subclasses that deal with AOP directly.
Invoking the <code>callback.execute()</code> method invokes the message handler.</p>
</div>
<div class="paragraph">
<p>The <code>target</code> parameter is provided for those subclasses that need to maintain state for a specific handler, perhaps by maintaining that state in a <code>Map</code> keyed by the target.
This feature allows the same advice to be applied to multiple handlers.
The <code>RequestHandlerCircuitBreakerAdvice</code> uses advice this to keep circuit breaker state for each handler.</p>
</div>
<div class="paragraph">
<p>The <code>message</code> parameter is the message sent to the handler.
While the advice cannot modify the message before invoking the handler, it can modify the payload (if it has mutable properties).
Typically, an advice would use the message for logging or to send a copy of the message somewhere before or after invoking the handler.</p>
</div>
<div class="paragraph">
<p>The return value would normally be the value returned by <code>callback.execute()</code>.
However, the advice does have the ability to modify the return value.
Note that only <code>AbstractReplyProducingMessageHandler</code> instances return values.
The following example shows a custom advice class that extends <code>AbstractRequestHandlerAdvice</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyAdvice extends AbstractRequestHandlerAdvice {

    @Override
    protected Object doInvoke(ExecutionCallback callback, Object target, Message&lt;?&gt; message) throws Exception {
        // add code before the invocation
        Object result = callback.execute();
        // add code after the invocation
        return result;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In addition to the <code>execute()</code> method, <code>ExecutionCallback</code> provides an additional method: <code>cloneAndExecute()</code>.
This method must be used in cases where the invocation might be called multiple times within a single execution of <code>doInvoke()</code>, such as in the <code>RequestHandlerRetryAdvice</code>.
This is required because the Spring AOP <code>org.springframework.aop.framework.ReflectiveMethodInvocation</code> object maintains state by keeping track of which advice in a chain was last invoked.
This state must be reset for each call.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/framework/ReflectiveMethodInvocation.html">ReflectiveMethodInvocation</a> Javadoc.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="other-advice"><a class="anchor" href="#other-advice"></a>10.9.3. Other Advice Chain Elements</h4>
<div class="paragraph">
<p>While the abstract class mentioned above is a convenience, you can add any <code>Advice</code>, including a transaction advice, to the chain.</p>
</div>
</div>
<div class="sect3">
<h4 id="handle-message-advice"><a class="anchor" href="#handle-message-advice"></a>10.9.4. Handling Message Advice</h4>
<div class="paragraph">
<p>As discussed in <a href="#message-handler-advice-chain">the introduction to this section</a>, advice objects in a request handler advice chain are applied to just the current endpoint, not the downstream flow (if any).
For <code>MessageHandler</code> objects that produce a reply (such as those that extend <code>AbstractReplyProducingMessageHandler</code>), the advice is applied to an internal method: <code>handleRequestMessage()</code> (called from <code>MessageHandler.handleMessage()</code>).
For other message handlers, the advice is applied to <code>MessageHandler.handleMessage()</code>.</p>
</div>
<div class="paragraph">
<p>There are some circumstances where, even if a message handler is an <code>AbstractReplyProducingMessageHandler</code>, the advice must be applied to the <code>handleMessage</code> method.
For example, the <a href="#idempotent-receiver">idempotent receiver</a> might return <code>null</code>, which would cause an exception if the handler&#8217;s <code>replyRequired</code> property is set to <code>true</code>.
Another example is the <code>BoundRabbitChannelAdvice</code>&#8201;&#8212;&#8201;see <a href="#amqp-strict-ordering">Strict Message Ordering</a>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.1, a new <code>HandleMessageAdvice</code> interface and its base implementation (<code>AbstractHandleMessageAdvice</code>) have been introduced.
<code>Advice</code> objects that implement <code>HandleMessageAdvice</code> are always applied to the <code>handleMessage()</code> method, regardless of the handler type.</p>
</div>
<div class="paragraph">
<p>It is important to understand that <code>HandleMessageAdvice</code> implementations (such as <a href="#idempotent-receiver">idempotent receiver</a>), when applied to a handlers that return responses, are dissociated from the <code>adviceChain</code> and properly applied to the <code>MessageHandler.handleMessage()</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because of this disassociation, the advice chain order is not honored.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;some-reply-producing-endpoint ... &gt;
    &lt;int:request-handler-advice-chain&gt;
        &lt;tx:advice ... /&gt;
        &lt;bean ref="myHandleMessageAdvice" /&gt;
    &lt;/int:request-handler-advice-chain&gt;
&lt;/some-reply-producing-endpoint&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>&lt;tx:advice&gt;</code> is applied to the <code>AbstractReplyProducingMessageHandler.handleRequestMessage()</code>.
However, <code>myHandleMessageAdvice</code> is applied for to <code>MessageHandler.handleMessage()</code>.
Therefore, it is invoked <strong>before</strong> the <code>&lt;tx:advice&gt;</code>.
To retain the order, you should follow the standard <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html">Spring AOP</a> configuration approach and use an endpoint <code>id</code> together with the <code>.handler</code> suffix to obtain the target <code>MessageHandler</code> bean.
Note that, in that case, the entire downstream flow is within the transaction scope.</p>
</div>
<div class="paragraph">
<p>In the case of a <code>MessageHandler</code> that does not return a response, the advice chain order is retained.</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-handle-message-advice"><a class="anchor" href="#tx-handle-message-advice"></a>10.9.5. Transaction Support</h4>
<div class="paragraph">
<p>Starting with version 5.0, a new <code>TransactionHandleMessageAdvice</code> has been introduced to make the whole downstream flow transactional, thanks to the <code>HandleMessageAdvice</code> implementation.
When a regular <code>TransactionInterceptor</code> is used in the <code>&lt;request-handler-advice-chain&gt;</code> element (for example, through configuring <code>&lt;tx:advice&gt;</code>), a started transaction is only applied only for an internal <code>AbstractReplyProducingMessageHandler.handleRequestMessage()</code> and is not propagated to the downstream flow.</p>
</div>
<div class="paragraph">
<p>To simplify XML configuration, along with the <code>&lt;request-handler-advice-chain&gt;</code>, a <code>&lt;transactional&gt;</code> element has been added to all <code>&lt;outbound-gateway&gt;</code> and <code>&lt;service-activator&gt;</code> and related components.
The following example shows <code>&lt;transactional&gt;</code> in use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-rmi:outbound-gateway remote-channel="foo" host="localhost"
    request-channel="good" reply-channel="reply" port="#{@port}"&gt;
        &lt;int-rmi:transactional/&gt;
&lt;/int-rmi:outbound-gateway&gt;

&lt;bean id="transactionManager" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="org.springframework.transaction.PlatformTransactionManager"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are familiar with the <a href="#jpa">JPA integration components</a>, such a configuration is not new, but now we can start a transaction from any point in our flow&#8201;&#8212;&#8201;not only from the <code>&lt;poller&gt;</code> or a message-driven channel adapter such as <a href="#jms-message-driven-channel-adapter">JMS</a>.</p>
</div>
<div class="paragraph">
<p>Java configuration can be simplified by using the <code>TransactionInterceptorBuilder</code>, and the result bean name can be used in the <a href="#annotations">messaging annotations</a> <code>adviceChain</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConcurrentMetadataStore store() {
    return new SimpleMetadataStore(hazelcastInstance()
                       .getMap("idempotentReceiverMetadataStore"));
}

@Bean
public IdempotentReceiverInterceptor idempotentReceiverInterceptor() {
    return new IdempotentReceiverInterceptor(
            new MetadataStoreSelector(
                    message -&gt; message.getPayload().toString(),
                    message -&gt; message.getPayload().toString().toUpperCase(), store()));
}

@Bean
public TransactionInterceptor transactionInterceptor() {
    return new TransactionInterceptorBuilder(true)
                .transactionManager(this.transactionManager)
                .isolation(Isolation.READ_COMMITTED)
                .propagation(Propagation.REQUIRES_NEW)
                .build();
}

@Bean
@org.springframework.integration.annotation.Transformer(inputChannel = "input",
         outputChannel = "output",
         adviceChain = { "idempotentReceiverInterceptor",
                 "transactionInterceptor" })
public Transformer transformer() {
    return message -&gt; message;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>true</code> parameter on the <code>TransactionInterceptorBuilder</code> constructor.
It causes the creation of a <code>TransactionHandleMessageAdvice</code>, not a regular <code>TransactionInterceptor</code>.</p>
</div>
<div class="paragraph">
<p>Java DSL supports an <code>Advice</code> through the <code>.transactional()</code> options on the endpoint configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow updatingGatewayFlow() {
    return f -&gt; f
        .handle(Jpa.updatingGateway(this.entityManagerFactory),
                e -&gt; e.transactional(true))
        .channel(c -&gt; c.queue("persistResults"));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advising-filters"><a class="anchor" href="#advising-filters"></a>10.9.6. Advising Filters</h4>
<div class="paragraph">
<p>There is an additional consideration when advising <code>Filter</code> advices.
By default, any discard actions (when the filter returns <code>false</code>) are performed within the scope of the advice chain.
This could include all the flow downstream of the discard channel.
So, for example, if an element downstream of the discard channel throws an exception and there is a retry advice, the process is retried.
Also, if <code>throwExceptionOnRejection</code> is set to <code>true</code> (the exception is thrown within the scope of the advice).</p>
</div>
<div class="paragraph">
<p>Setting <code>discard-within-advice</code> to <code>false</code> modifies this behavior and the discard (or exception) occurs after the advice chain is called.</p>
</div>
</div>
<div class="sect3">
<h4 id="advising-with-annotations"><a class="anchor" href="#advising-with-annotations"></a>10.9.7. Advising Endpoints Using Annotations</h4>
<div class="paragraph">
<p>When configuring certain endpoints by using annotations (<code>@Filter</code>, <code>@ServiceActivator</code>, <code>@Splitter</code>, and <code>@Transformer</code>), you can supply a bean name for the advice chain in the <code>adviceChain</code> attribute.
In addition, the <code>@Filter</code> annotation also has the <code>discardWithinAdvice</code> attribute, which can be used to configure the discard behavior, as discussed in <a href="#advising-filters">Advising Filters</a>.
The following example causes the discard to be performed after the advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessageEndpoint
public class MyAdvisedFilter {

    @Filter(inputChannel="input", outputChannel="output",
            adviceChain="adviceChain", discardWithinAdvice="false")
    public boolean filter(String s) {
        return s.contains("good");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advice-order"><a class="anchor" href="#advice-order"></a>10.9.8. Ordering Advices within an Advice Chain</h4>
<div class="paragraph">
<p>Advice classes are &#8220;around&#8221; advices and are applied in a nested fashion.
The first advice is the outermost, while the last advice is the innermost (that is, closest to the handler being advised).
It is important to put the advice classes in the correct order to achieve the functionality you desire.</p>
</div>
<div class="paragraph">
<p>For example, suppose you want to add a retry advice and a transaction advice.
You may want to place the retry advice advice first, followed by the transaction advice.
Consequently, each retry is performed in a new transaction.
On the other hand, if you want all the attempts and any recovery operations (in the retry <code>RecoveryCallback</code>) to be scoped within the transaction, you could put the transaction advice first.</p>
</div>
</div>
<div class="sect3">
<h4 id="advised-handler-properties"><a class="anchor" href="#advised-handler-properties"></a>10.9.9. Advised Handler Properties</h4>
<div class="paragraph">
<p>Sometimes, it is useful to access handler properties from within the advice.
For example, most handlers implement <code>NamedComponent</code> to let you access the component name.</p>
</div>
<div class="paragraph">
<p>The target object can be accessed through the <code>target</code> argument (when subclassing <code>AbstractRequestHandlerAdvice</code>) or
<code>invocation.getThis()</code> (when implementing <code>org.aopalliance.intercept.MethodInterceptor</code>).</p>
</div>
<div class="paragraph">
<p>When the entire handler is advised (such as when the handler does not produce replies or the advice implements <code>HandleMessageAdvice</code>), you can cast the target object to an interface, such as <code>NamedComponent</code>, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String componentName = ((NamedComponent) target).getComponentName();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you implement <code>MethodInterceptor</code> directly, you could cast the target object as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String componentName = ((NamedComponent) invocation.getThis()).getComponentName();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When only the <code>handleRequestMessage()</code> method is advised (in a reply-producing handler), you need to access the
full handler, which is an <code>AbstractReplyProducingMessageHandler</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AbstractReplyProducingMessageHandler handler =
    ((AbstractReplyProducingMessageHandler.RequestHandler) target).getAdvisedHandler();

String componentName = handler.getComponentName();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="idempotent-receiver"><a class="anchor" href="#idempotent-receiver"></a>10.9.10. Idempotent Receiver Enterprise Integration Pattern</h4>
<div class="paragraph">
<p>Starting with version 4.1, Spring Integration provides an implementation of the <a href="https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html">Idempotent Receiver</a> Enterprise Integration Pattern.
It is a functional pattern and the whole idempotency logic should be implemented in the application.
However, to simplify the decision-making, the <code>IdempotentReceiverInterceptor</code> component is provided.
This is an AOP <code>Advice</code> that is applied to the <code>MessageHandler.handleMessage()</code> method and that can <code>filter</code> a request message or mark it as a <code>duplicate</code>, according to its configuration.</p>
</div>
<div class="paragraph">
<p>Previously, you could have implemented this pattern by using a custom <code>MessageSelector</code> in a <code>&lt;filter/&gt;</code> (see <a href="#filter">Filter</a>), for example.
However, since this pattern really defines the behavior of an endpoint rather than being an endpoint itself, the idempotent receiver implementation does not provide an endpoint component.
Rather, it is applied to endpoints declared in the application.</p>
</div>
<div class="paragraph">
<p>The logic of the <code>IdempotentReceiverInterceptor</code> is based on the provided <code>MessageSelector</code> and, if the message is not accepted by that selector, it is enriched with the <code>duplicateMessage</code> header set to <code>true</code>.
The target <code>MessageHandler</code> (or downstream flow) can consult this header to implement the correct idempotency logic.
If the <code>IdempotentReceiverInterceptor</code> is configured with a <code>discardChannel</code> or <code>throwExceptionOnRejection = true</code>, the duplicate message is not sent to the target <code>MessageHandler.handleMessage()</code>.
Rather, it is discarded.
If you want to discard (do nothing with) the duplicate message, the <code>discardChannel</code> should be configured with a <code>NullChannel</code>, such as the default <code>nullChannel</code> bean.</p>
</div>
<div class="paragraph">
<p>To maintain state between messages and provide the ability to compare messages for the idempotency, we provide the <code>MetadataStoreSelector</code>.
It accepts a <code>MessageProcessor</code> implementation (which creates a lookup key based on the <code>Message</code>) and an optional <code>ConcurrentMetadataStore</code> (<a href="#metadata-store">Metadata Store</a>).
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/selector/MetadataStoreSelector.html"><code>MetadataStoreSelector</code> Javadoc</a> for more information.
You can also customize the <code>value</code> for <code>ConcurrentMetadataStore</code> by using an additional <code>MessageProcessor</code>.
By default, <code>MetadataStoreSelector</code> uses the <code>timestamp</code> message header.</p>
</div>
<div class="paragraph">
<p>For convenience, the <code>MetadataStoreSelector</code> options are configurable directly on the <code>&lt;idempotent-receiver&gt;</code> component.
The following listing shows all the possible attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;idempotent-receiver
        id=""  <i class="conum" data-value="1"></i><b>(1)</b>
        endpoint=""  <i class="conum" data-value="2"></i><b>(2)</b>
        selector=""  <i class="conum" data-value="3"></i><b>(3)</b>
        discard-channel=""  <i class="conum" data-value="4"></i><b>(4)</b>
        metadata-store=""  <i class="conum" data-value="5"></i><b>(5)</b>
        key-strategy=""  <i class="conum" data-value="6"></i><b>(6)</b>
        key-expression=""  <i class="conum" data-value="7"></i><b>(7)</b>
        value-strategy=""  <i class="conum" data-value="8"></i><b>(8)</b>
        value-expression=""  <i class="conum" data-value="9"></i><b>(9)</b>
        throw-exception-on-rejection="" /&gt;  <i class="conum" data-value="10"></i><b>(10)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The ID of the <code>IdempotentReceiverInterceptor</code> bean.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Consumer endpoint name(s) or pattern(s) to which this interceptor is applied.
Separate names (patterns) with commas (<code>,</code>), such as <code>endpoint="aaa, bbb*, <strong>ccc, *ddd</strong>, eee*fff"</code>.
Endpoint bean names matching these patterns are then used to retrieve the target endpoint&#8217;s <code>MessageHandler</code> bean (using its <code>.handler</code> suffix), and the <code>IdempotentReceiverInterceptor</code> is applied to those beans.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A <code>MessageSelector</code> bean reference.
Mutually exclusive with <code>metadata-store</code> and <code>key-strategy (key-expression)</code>.
When <code>selector</code> is not provided, one of <code>key-strategy</code> or <code>key-strategy-expression</code> is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Identifies the channel to which to send a message when the <code>IdempotentReceiverInterceptor</code> does not accept it.
When omitted, duplicate messages are forwarded to the handler with a <code>duplicateMessage</code> header.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A <code>ConcurrentMetadataStore</code> reference.
Used by the underlying <code>MetadataStoreSelector</code>.
Mutually exclusive with <code>selector</code>.
Optional.
The default <code>MetadataStoreSelector</code> uses an internal <code>SimpleMetadataStore</code> that does not maintain state across application executions.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A <code>MessageProcessor</code> reference.
Used by the underlying <code>MetadataStoreSelector</code>.
Evaluates an <code>idempotentKey</code> from the request message.
Mutually exclusive with <code>selector</code> and <code>key-expression</code>.
When a <code>selector</code> is not provided, one of <code>key-strategy</code> or <code>key-strategy-expression</code> is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A SpEL expression to populate an <code>ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code>MetadataStoreSelector</code>.
Evaluates an <code>idempotentKey</code> by using the request message as the evaluation context root object.
Mutually exclusive with <code>selector</code> and <code>key-strategy</code>.
When a <code>selector</code> is not provided, one of <code>key-strategy</code> or <code>key-strategy-expression</code> is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>A <code>MessageProcessor</code> reference.
Used by the underlying <code>MetadataStoreSelector</code>.
Evaluates a <code>value</code> for the <code>idempotentKey</code> from the request message.
Mutually exclusive with <code>selector</code> and <code>value-expression</code>.
By default, the 'MetadataStoreSelector' uses the 'timestamp' message header as the Metadata 'value'.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>A SpEL expression to populate an <code>ExpressionEvaluatingMessageProcessor</code>.
Used by the underlying <code>MetadataStoreSelector</code>.
Evaluates a <code>value</code> for the <code>idempotentKey</code> by using the request message as the evaluation context root object.
Mutually exclusive with <code>selector</code> and <code>value-strategy</code>.
By default, the 'MetadataStoreSelector' uses the 'timestamp' message header as the metadata 'value'.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Whether to throw an exception if the <code>IdempotentReceiverInterceptor</code> rejects the message.
Defaults to <code>false</code>.
It is applied regardless of whether or not a <code>discard-channel</code> is provided.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>For Java configuration, Spring Integration provides the method-level <code>@IdempotentReceiver</code> annotation.
It is used to mark a <code>method</code> that has a messaging annotation (<code>@ServiceActivator</code>, <code>@Router, and others) to specify which `IdempotentReceiverInterceptor</code> objects are applied to this endpoint.
The following example shows how to use the <code>@IdempotentReceiver</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IdempotentReceiverInterceptor idempotentReceiverInterceptor() {
   return new IdempotentReceiverInterceptor(new MetadataStoreSelector(m -&gt;
                                                    m.getHeaders().get(INVOICE_NBR_HEADER)));
}

@Bean
@ServiceActivator(inputChannel = "input", outputChannel = "output")
@IdempotentReceiver("idempotentReceiverInterceptor")
public MessageHandler myService() {
    ....
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use the Java DSL, you can add the interceptor to the endpoint&#8217;s advice chain, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow() {
    ...
        .handle("someBean", "someMethod",
            e -&gt; e.advice(idempotentReceiverInterceptor()))
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>IdempotentReceiverInterceptor</code> is designed only for the <code>MessageHandler.handleMessage(Message&lt;?&gt;)</code> method.
Starting with version 4.3.1, it implements <code>HandleMessageAdvice</code>, with the <code>AbstractHandleMessageAdvice</code> as a base class, for better dissociation.
See <a href="#handle-message-advice">Handling Message Advice</a> for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="logging-channel-adapter"><a class="anchor" href="#logging-channel-adapter"></a>10.10. Logging Channel Adapter</h3>
<div class="paragraph">
<p>The <code>&lt;logging-channel-adapter&gt;</code> is often used in conjunction with a wire tap, as discussed in <a href="#channel-wiretap">Wire Tap</a>.
However, it can also be used as the ultimate consumer of any flow.
For example, consider a flow that ends with a <code>&lt;service-activator&gt;</code> that returns a result, but you wish to discard that result.
To do that, you could send the result to <code>NullChannel</code>.
Alternatively, you can route it to an <code>INFO</code> level <code>&lt;logging-channel-adapter&gt;</code>.
That way, you can see the discarded message when logging at <code>INFO</code> level but not see it when logging at (for example) the <code>WARN</code> level.
With a <code>NullChannel</code>, you would see only the discarded message when logging at the <code>DEBUG</code> level.
The following listing shows all the possible attributes for the <code>logging-channel-adapter</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:logging-channel-adapter
    channel="" <i class="conum" data-value="1"></i><b>(1)</b>
    level="INFO" <i class="conum" data-value="2"></i><b>(2)</b>
    expression="" <i class="conum" data-value="3"></i><b>(3)</b>
    log-full-message="false" <i class="conum" data-value="4"></i><b>(4)</b>
    logger-name="" /&gt; <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The channel connecting the logging adapter to an upstream component.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The logging level at which messages sent to this adapter will be logged.
Default: <code>INFO</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A SpEL expression representing exactly what parts of the message are logged.
Default: <code>payload</code>&#8201;&#8212;&#8201;only the payload is logged.
if <code>log-full-message</code> is specified, this attribute cannot be specified.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>When <code>true</code>, the entire message (including headers) is logged.
Default: <code>false</code>&#8201;&#8212;&#8201;only the payload is logged.
This attribute cannot be specified if <code>expression</code> is specified.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specifies the <code>name</code> of the logger (known as <code>category</code> in <code>log4j</code>).
Used to identify log messages created by this adapter.
This enables setting the log name (in the logging subsystem) for individual adapters.
By default, all adapters log under the following name: <code>org.springframework.integration.handler.LoggingHandler</code>.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-java-configuration"><a class="anchor" href="#using-java-configuration"></a>10.10.1. Using Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of configuring the <code>LoggingHandler</code> by using Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class LoggingJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
             new SpringApplicationBuilder(LoggingJavaApplication.class)
                    .web(false)
                    .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         gateway.sendToLogger("foo");
    }

    @Bean
    @ServiceActivator(inputChannel = "logChannel")
    public LoggingHandler logging() {
        LoggingHandler adapter = new LoggingHandler(LoggingHandler.Level.DEBUG);
        adapter.setLoggerName("TEST_LOGGER");
        adapter.setLogExpressionString("headers.id + ': ' + payload");
        return adapter;
    }

    @MessagingGateway(defaultRequestChannel = "logChannel")
    public interface MyGateway {

        void sendToLogger(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl"><a class="anchor" href="#configuring-with-the-java-dsl"></a>10.10.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of configuring the logging channel adapter by using the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class LoggingJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
             new SpringApplicationBuilder(LoggingJavaApplication.class)
                    .web(false)
                    .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         gateway.sendToLogger("foo");
    }

    @Bean
    public IntegrationFlow loggingFlow() {
        return IntegrationFlows.from(MyGateway.class)
                     .log(LoggingHandler.Level.DEBUG, "TEST_LOGGER",
                           m -&gt; m.getHeaders().getId() + ": " + m.getPayload());
    }

    @MessagingGateway
    public interface MyGateway {

        void sendToLogger(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="functions-support"><a class="anchor" href="#functions-support"></a>10.11. <code>java.util.function</code> Interfaces Support</h3>
<div class="paragraph">
<p>Starting with version 5.1, Spring Integration provides direct support for interfaces in the <code>java.util.function</code> package.
All messaging endpoints, (Service Activator, Transformer, Filter, etc.) can now refer to <code>Function</code> (or <code>Consumer</code>) beans.
The <a href="#annotations">Messaging Annotations</a> can be applied directly on these beans similar to regular <code>MessageHandler</code> definitions.
For example if you have this <code>Function</code> bean definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class FunctionConfiguration {

    @Bean
    public Function&lt;String, String&gt; functionAsService() {
        return String::toUpperCase;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use it as a simple reference in an XML configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;service-activator input-channel="processorViaFunctionChannel" ref="functionAsService"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When we configure our flow with Messaging Annotations, the code is straightforward:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel = "functionServiceChannel")
public Function&lt;String, String&gt; functionAsService() {
    return String::toUpperCase;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the function returns an array, <code>Collection</code> (essentially, any <code>Iterable</code>), <code>Stream</code> or Reactor <code>Flux</code>, <code>@Splitter</code> can be used on such a bean to perform iteration over the result content.</p>
</div>
<div class="paragraph">
<p>The <code>java.util.function.Consumer</code> interface can be used for an <code>&lt;int:outbound-channel-adapter&gt;</code> or, together with the <code>@ServiceActivator</code> annotation, to perform the final step of a flow:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "messageConsumerServiceChannel")
public Consumer&lt;Message&lt;?&gt;&gt; messageConsumerAsService() {
    // Has to be an anonymous class for proper type inference
    return new Consumer&lt;Message&lt;?&gt;&gt;() {

        @Override
        public void accept(Message&lt;?&gt; e) {
            collector().add(e);
        }

    };
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also, pay attention to the comment in the code snippet above: if you would like to deal with the whole message in your <code>Function</code>/<code>Consumer</code> you cannot use a lambda definition.
Because of Java type erasure we cannot determine the target type for the <code>apply()/accept()</code> method call.</p>
</div>
<div class="paragraph">
<p>The <code>java.util.function.Supplier</code> interface can simply be used together with the <code>@InboundChannelAdapter</code> annotation, or as a <code>ref</code> in an <code>&lt;int:inbound-channel-adapter&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@InboundChannelAdapter(value = "inputChannel", poller = @Poller(fixedDelay = "1000"))
public Supplier&lt;String&gt; pojoSupplier() {
    return () -&gt; "foo";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With the Java DSL we just need to use a reference to the function bean in the endpoint definitions.
Meanwhile an implementation of the <code>Supplier</code> interface can be used as regular <code>MessageSource</code> definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Function&lt;String, String&gt; toUpperCaseFunction() {
    return String::toUpperCase;
}

@Bean
public Supplier&lt;String&gt; stringSupplier() {
    return () -&gt; "foo";
}

@Bean
public IntegrationFlow supplierFlow() {
    return IntegrationFlows.from(stringSupplier())
                .transform(toUpperCaseFunction())
                .channel("suppliedChannel")
                .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This function support is useful when used together with the <a href="https://cloud.spring.io/spring-cloud-function/">Spring Cloud Function</a> framework, where we have a function catalog and can refer to its member functions from an integration flow definition.</p>
</div>
<div class="sect3">
<h4 id="kotlin-functions-support"><a class="anchor" href="#kotlin-functions-support"></a>10.11.1. Kotlin Lambdas</h4>
<div class="paragraph">
<p>The Framework also has been improved to support Kotlin lambdas for functions so now you can use a combination of the Kotlin language and Spring Integration flow definitions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel = "functionServiceChannel")
fun kotlinFunction(): (String) -&gt; String {
    return { it.toUpperCase() }
}

@Bean
@ServiceActivator(inputChannel = "messageConsumerServiceChannel")
fun kotlinConsumer(): (Message&lt;Any&gt;) -&gt; Unit {
    return { print(it) }
}

@Bean
@InboundChannelAdapter(value = "counterChannel",
        poller = [Poller(fixedRate = "10", maxMessagesPerPoll = "1")])
fun kotlinSupplier(): () -&gt; String {
    return { "baz" }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="java-dsl"><a class="anchor" href="#java-dsl"></a>11. Java DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Integration Java configuration and DSL provides a set of convenient builders and a fluent API that lets you configure Spring Integration message flows from Spring <code>@Configuration</code> classes.</p>
</div>
<div class="paragraph">
<p>The Java DSL for Spring Integration is essentially a facade for Spring Integration.
The DSL provides a simple way to embed Spring Integration Message Flows into your application by using the fluent <code>Builder</code> pattern together with existing Java configuration from Spring Framework and Spring Integration.
We also use and support lambdas (available with Java 8) to further simplify Java configuration.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">cafe</a> offers a good example of using the DSL.</p>
</div>
<div class="paragraph">
<p>The DSL is  presented by the <code>IntegrationFlows</code> factory for the <code>IntegrationFlowBuilder</code>.
This produces the <code>IntegrationFlow</code> component, which should be registered as a Spring bean (by using the <code>@Bean</code> annotation).
The builder pattern is used to express arbitrarily complex structures as a hierarchy of methods that can accept lambdas as arguments.</p>
</div>
<div class="paragraph">
<p>The <code>IntegrationFlowBuilder</code> only collects integration components (<code>MessageChannel</code> instances, <code>AbstractEndpoint</code> instances, and so on) in the <code>IntegrationFlow</code> bean for further parsing and registration of concrete beans in the application context by the <code>IntegrationFlowBeanPostProcessor</code>.</p>
</div>
<div class="paragraph">
<p>The Java DSL uses Spring Integration classes directly and bypasses any XML generation and parsing.
However, the DSL offers more than syntactic sugar on top of XML.
One of its most compelling features is the ability to define inline lambdas to implement endpoint logic, eliminating the need for external classes to implement custom logic.
In some sense, Spring Integration&#8217;s support for the Spring Expression Language (SpEL) and inline scripting address this, but lambdas are easier and much more powerful.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use Java Configuration for Spring Integration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class MyConfiguration {

    @Bean
    public AtomicInteger integerSource() {
        return new AtomicInteger();
    }

    @Bean
    public IntegrationFlow myFlow() {
        return IntegrationFlows.from(integerSource::getAndIncrement,
                                         c -&gt; c.poller(Pollers.fixedRate(100)))
                    .channel("inputChannel")
                    .filter((Integer p) -&gt; p &gt; 0)
                    .transform(Object::toString)
                    .channel(MessageChannels.queue())
                    .get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding configuration example is that it creates, after <code>ApplicationContext</code> start up, Spring Integration endpoints and message channels.
Java configuration can be used both to replace and augment XML configuration.
You need not replace all of your existing XML configuration to use Java configuration.</p>
</div>
<div class="sect2">
<h3 id="java-dsl-basics"><a class="anchor" href="#java-dsl-basics"></a>11.1. DSL Basics</h3>
<div class="paragraph">
<p>The <code>org.springframework.integration.dsl</code> package contains the <code>IntegrationFlowBuilder</code> API mentioned earlier and a number of <code>IntegrationComponentSpec</code> implementations, which are also builders and provide the fluent API to configure concrete endpoints.
The <code>IntegrationFlowBuilder</code> infrastructure provides common <a href="https://www.enterpriseintegrationpatterns.com/">enterprise integration patterns</a> (EIP) for message-based applications, such as channels, endpoints, pollers, and channel interceptors.</p>
</div>
<div class="paragraph">
<p>Endpoints are expressed as verbs in the DSL to improve readability.
The following list includes the common DSL method names and the associated EIP endpoint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>transform &#8594; <code>Transformer</code></p>
</li>
<li>
<p>filter &#8594; <code>Filter</code></p>
</li>
<li>
<p>handle &#8594; <code>ServiceActivator</code></p>
</li>
<li>
<p>split &#8594; <code>Splitter</code></p>
</li>
<li>
<p>aggregate &#8594; <code>Aggregator</code></p>
</li>
<li>
<p>route &#8594; <code>Router</code></p>
</li>
<li>
<p>bridge &#8594; <code>Bridge</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Conceptually, integration processes are constructed by composing these endpoints into one or more message flows.
Note that EIP does not formally define the term 'message flow', but it is useful to think of it as a unit of work that uses well known messaging patterns.
The DSL provides an <code>IntegrationFlow</code> component to define a composition of channels and endpoints between them, but now <code>IntegrationFlow</code> plays only the configuration role to populate real beans in the application context and is not used at runtime.
The following example uses the <code>IntegrationFlows</code> factory to define an <code>IntegrationFlow</code> bean by using EIP-methods from <code>IntegrationFlowBuilder</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
            .&lt;String, Integer&gt;transform(Integer::parseInt)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>transform</code> method accepts a lambda as an endpoint argument to operate on the message payload.
The real argument of this method is <code>GenericTransformer&lt;S, T&gt;</code>.
Consequently, any of the provided transformers  (<code>ObjectToJsonTransformer</code>, <code>FileToStringTransformer</code>, and other) can be used here.</p>
</div>
<div class="paragraph">
<p>Under the covers, <code>IntegrationFlowBuilder</code> recognizes the <code>MessageHandler</code> and the endpoint for it, with <code>MessageTransformingHandler</code> and <code>ConsumerEndpointFactoryBean</code>, respectively.
Consider another example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow myFlow() {
    return IntegrationFlows.from("input")
                .filter("World"::equals)
                .transform("Hello "::concat)
                .handle(System.out::println)
                .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example composes a sequence of <code>Filter &#8594; Transformer &#8594; Service Activator</code>.
The flow is "'one way'".
That is, it does not provide a reply message but only prints the payload to STDOUT.
The endpoints are automatically wired together by using direct channels.</p>
</div>
<div id="java-dsl-class-cast" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Lambdas And <code>Message&lt;?&gt;</code> Arguments</div>
<div class="paragraph">
<p>When using lambdas in EIP methods, the "input" argument is generally the message payload.
If you wish to access the entire message, use one of the overloaded methods that take a <code>Class&lt;?&gt;</code> as the first parameter.
For example, this won&#8217;t work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.&lt;Message&lt;?&gt;, Foo&gt;transform(m -&gt; newFooFromMessage(m))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will fail at runtime with a <code>ClassCastException</code> because the lambda doesn&#8217;t retain the argument type and the framework will attempt to cast the payload to a <code>Message&lt;?&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Instead, use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.(Message.class, m -&gt; newFooFromMessage(m))</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="bean-definitions-override" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Bean Definitions override</div>
<div class="paragraph">
<p>The Java DSL can register beans for the object defined in-line in the flow definition, as well as can reuse existing, injected beans.
In case of the same bean name defined for in-line object and existing bean definition, a <code>BeanDefinitionOverrideException</code> is thrown indicating that such a configuration is wrong.
However when you deal with <code>prototype</code> beans, there is no way to detect from the integration flow processor an existing bean definition because every time we call a <code>prototype</code> bean from the <code>BeanFactory</code> we get a new instance.
This way a provided instance is used in the <code>IntegrationFlow</code> as is without any bean registration and any possible check against existing <code>prototype</code> bean definition.
However <code>BeanFactory.initializeBean()</code> is called for this object if it has an explicit <code>id</code> and bean definition for this name is in <code>prototype</code> scope.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-channels"><a class="anchor" href="#java-dsl-channels"></a>11.2. Message Channels</h3>
<div class="paragraph">
<p>In addition to the <code>IntegrationFlowBuilder</code> with EIP methods, the Java DSL provides a fluent API to configure <code>MessageChannel</code> instances.
For this purpose the <code>MessageChannels</code> builder factory is provided.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MessageChannel priorityChannel() {
    return MessageChannels.priority(this.mongoDbChannelMessageStore, "priorityGroup")
                        .interceptor(wireTap())
                        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The same <code>MessageChannels</code> builder factory can be used in the <code>channel()</code> EIP method from <code>IntegrationFlowBuilder</code> to wire endpoints, similar to wiring an <code>input-channel</code>/<code>output-channel</code> pair in the XML configuration.
By default, endpoints are wired with <code>DirectChannel</code> instances where the bean name is based on the following pattern: <code>[IntegrationFlow.beanName].channel#[channelNameIndex]</code>.
This rule is also applied for unnamed channels produced by inline <code>MessageChannels</code> builder factory usage.
However all <code>MessageChannels</code> methods have a variant that is aware of the <code>channelId</code> that you can use to set the bean names for <code>MessageChannel</code> instances.
The <code>MessageChannel</code> references and <code>beanName</code> can be used as bean-method invocations.
The following example shows the possible ways to use the <code>channel()</code> EIP method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MessageChannel queueChannel() {
    return MessageChannels.queue().get();
}

@Bean
public MessageChannel publishSubscribe() {
    return MessageChannels.publishSubscribe().get();
}

@Bean
public IntegrationFlow channelFlow() {
    return IntegrationFlows.from("input")
                .fixedSubscriberChannel()
                .channel("queueChannel")
                .channel(publishSubscribe())
                .channel(MessageChannels.executor("executorChannel", this.taskExecutor))
                .channel("output")
                .get();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>from("input")</code> means "'find and use the <code>MessageChannel</code> with the "input" id, or create one'".</p>
</li>
<li>
<p><code>fixedSubscriberChannel()</code> produces an instance of <code>FixedSubscriberChannel</code> and registers it with a name of <code>channelFlow.channel#0</code>.</p>
</li>
<li>
<p><code>channel("queueChannel")</code> works the same way but uses an existing <code>queueChannel</code> bean.</p>
</li>
<li>
<p><code>channel(publishSubscribe())</code> is the bean-method reference.</p>
</li>
<li>
<p><code>channel(MessageChannels.executor("executorChannel", this.taskExecutor))</code> is the <code>IntegrationFlowBuilder</code> that exposes <code>IntegrationComponentSpec</code> to the <code>ExecutorChannel</code> and registers it as <code>executorChannel</code>.</p>
</li>
<li>
<p><code>channel("output")</code> registers the <code>DirectChannel</code> bean with <code>output</code> as its name, as long as no beans with this name already exist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note: The preceding <code>IntegrationFlow</code> definition is valid, and all of its channels are applied to endpoints with <code>BridgeHandler</code> instances.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Be careful to use the same inline channel definition through <code>MessageChannels</code> factory from different <code>IntegrationFlow</code> instances.
Even if the DSL parser registers non-existent objects as beans, it cannot determine the same object (<code>MessageChannel</code>) from different <code>IntegrationFlow</code> containers.
The following example is wrong:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow startFlow() {
    return IntegrationFlows.from("input")
                .transform(...)
                .channel(MessageChannels.queue("queueChannel"))
                .get();
}

@Bean
public IntegrationFlow endFlow() {
    return IntegrationFlows.from(MessageChannels.queue("queueChannel"))
                .handle(...)
                .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of that bad example is the following exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Caused by: java.lang.IllegalStateException:
Could not register object [queueChannel] under bean name 'queueChannel':
     there is already object [queueChannel] bound
	    at o.s.b.f.s.DefaultSingletonBeanRegistry.registerSingleton(DefaultSingletonBeanRegistry.java:129)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make it work, you need to declare <code>@Bean</code> for that channel and use its bean method from different <code>IntegrationFlow</code> instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-pollers"><a class="anchor" href="#java-dsl-pollers"></a>11.3. Pollers</h3>
<div class="paragraph">
<p>Spring Integration also provides a fluent API that lets you configure <code>PollerMetadata</code> for <code>AbstractPollingEndpoint</code> implementations.
You can use the <code>Pollers</code> builder factory to configure common bean definitions or those created from <code>IntegrationFlowBuilder</code> EIP methods, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean(name = PollerMetadata.DEFAULT_POLLER)
public PollerSpec poller() {
    return Pollers.fixedRate(500)
        .errorChannel("myErrors");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Pollers.html"><code>Pollers</code></a> and <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/PollerSpec.html"><code>PollerSpec</code></a> in the Javadoc for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you use the DSL to construct a <code>PollerSpec</code> as a <code>@Bean</code>, do not call the <code>get()</code> method in the bean definition.
The <code>PollerSpec</code> is a <code>FactoryBean</code> that generates the <code>PollerMetadata</code> object from the specification and initializes all of its properties.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-endpoints"><a class="anchor" href="#java-dsl-endpoints"></a>11.4. DSL and Endpoint Configuration</h3>
<div class="paragraph">
<p>All <code>IntegrationFlowBuilder</code> EIP methods have a variant that applies the lambda parameter to provide options for <code>AbstractEndpoint</code> instances: <code>SmartLifecycle</code>, <code>PollerMetadata</code>, <code>request-handler-advice-chain</code>, and others.
Each of them has generic arguments, so it lets you configure an endpoint and even its <code>MessageHandler</code> in the context, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow2() {
    return IntegrationFlows.from(this.inputChannel)
                .transform(new PayloadSerializingTransformer(),
                       c -&gt; c.autoStartup(false).id("payloadSerializingTransformer"))
                .transform((Integer p) -&gt; p * 2, c -&gt; c.advice(this.expressionAdvice()))
                .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In addition, the <code>EndpointSpec</code> provides an <code>id()</code> method to let you register an endpoint bean with a given bean name, rather than a generated one.</p>
</div>
<div class="paragraph">
<p>If the <code>MessageHandler</code> is referenced as a bean, then any existing <code>adviceChain</code> configuration will be overridden if the <code>.advice()</code> method is present in the DSL definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public TcpOutboundGateway tcpOut() {
    TcpOutboundGateway gateway = new TcpOutboundGateway();
    gateway.setConnectionFactory(cf());
    gateway.setAdviceChain(Collections.singletonList(fooAdvice()));
    return gateway;
}

@Bean
public IntegrationFlow clientTcpFlow() {
    return f -&gt; f
        .handle(tcpOut(), e -&gt; e.advice(testAdvice()))
        .transform(Transformers.objectToString());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is they are not merged, only the <code>testAdvice()</code> bean is used in this case.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-transformers"><a class="anchor" href="#java-dsl-transformers"></a>11.5. Transformers</h3>
<div class="paragraph">
<p>The DSL API provides a convenient, fluent <code>Transformers</code> factory to be used as inline target object definition within the <code>.transform()</code> EIP method.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow transformFlow() {
    return IntegrationFlows.from("input")
            .transform(Transformers.fromJson(MyPojo.class))
            .transform(Transformers.serializer())
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It avoids inconvenient coding using setters and makes the flow definition more straightforward.
Note that you can use <code>Transformers</code> to declare target <code>Transformer</code> instances as <code>@Bean</code> instances and, again, use them from <code>IntegrationFlow</code> definition as bean methods.
Nevertheless, the DSL parser takes care of bean declarations for inline objects, if they are not yet defined as beans.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Transformers.html">Transformers</a> in the Javadoc for more information and supported factory methods.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-inbound-adapters"><a class="anchor" href="#java-dsl-inbound-adapters"></a>11.6. Inbound Channel Adapters</h3>
<div class="paragraph">
<p>Typically, message flows start from an inbound channel adapter (such as <code>&lt;int-jdbc:inbound-channel-adapter&gt;</code>).
The adapter is configured with <code>&lt;poller&gt;</code>, and it asks a <code>MessageSource&lt;?&gt;</code> to periodically produce messages.
Java DSL allows for starting <code>IntegrationFlow</code> from a <code>MessageSource&lt;?&gt;</code>, too.
For this purpose, the <code>IntegrationFlows</code> builder factory provides an overloaded <code>IntegrationFlows.from(MessageSource&lt;?&gt; messageSource)</code> method.
You can configure the <code>MessageSource&lt;?&gt;</code> as a bean and provide it as an argument for that method.
The second parameter of <code>IntegrationFlows.from()</code> is a <code>Consumer&lt;SourcePollingChannelAdapterSpec&gt;</code> lambda that lets you provide options (such as <code>PollerMetadata</code> or <code>SmartLifecycle</code>) for the <code>SourcePollingChannelAdapter</code>.
The following example shows how to use the fluent API and a lambda to create an <code>IntegrationFlow</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MessageSource&lt;Object&gt; jdbcMessageSource() {
    return new JdbcPollingChannelAdapter(this.dataSource, "SELECT * FROM something");
}

@Bean
public IntegrationFlow pollingFlow() {
    return IntegrationFlows.from(jdbcMessageSource(),
                c -&gt; c.poller(Pollers.fixedRate(100).maxMessagesPerPoll(1)))
            .transform(Transformers.toJson())
            .channel("furtherProcessChannel")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For those cases that have no requirements to build <code>Message</code> objects directly, you can use the <code>IntegrationFlows.from()</code> variant that is based on the <code>java.util.function.Supplier</code> .
The result of the <code>Supplier.get()</code> is automatically wrapped in a <code>Message</code> (if it is not already a <code>Message</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-routers"><a class="anchor" href="#java-dsl-routers"></a>11.7. Message Routers</h3>
<div class="paragraph">
<p>Spring Integration natively provides specialized router types, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HeaderValueRouter</code></p>
</li>
<li>
<p><code>PayloadTypeRouter</code></p>
</li>
<li>
<p><code>ExceptionTypeRouter</code></p>
</li>
<li>
<p><code>RecipientListRouter</code></p>
</li>
<li>
<p><code>XPathRouter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As with many other DSL <code>IntegrationFlowBuilder</code> EIP methods, the <code>route()</code> method can apply any <code>AbstractMessageRouter</code> implementation or, for convenience, a <code>String</code> as a SpEL expression or a <code>ref</code>-<code>method</code> pair.
In addition, you can configure <code>route()</code> with a lambda and use a lambda for a <code>Consumer&lt;RouterSpec&lt;MethodInvokingRouter&gt;&gt;</code>.
The fluent API also provides <code>AbstractMappingMessageRouter</code> options such as <code>channelMapping(String key, String channelName)</code> pairs, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routeFlow() {
    return IntegrationFlows.from("routerInput")
            .&lt;Integer, Boolean&gt;route(p -&gt; p % 2 == 0,
                    m -&gt; m.suffix("Channel")
                            .channelMapping("true", "even")
                            .channelMapping("false", "odd")
            )
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a simple expression-based router:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routeFlow() {
    return IntegrationFlows.from("routerInput")
            .route("headers['destChannel']")
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>routeToRecipients()</code> method takes a <code>Consumer&lt;RecipientListRouterSpec&gt;</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow recipientListFlow() {
    return IntegrationFlows.from("recipientListInput")
            .&lt;String, String&gt;transform(p -&gt; p.replaceFirst("Payload", ""))
                        .routeToRecipients(r -&gt; r
                .recipient("thing1-channel", "'thing1' == payload")
                .recipient("thing2-channel", m -&gt;
                    m.getHeaders().containsKey("recipient")
                        &amp;&amp; (boolean) m.getHeaders().get("recipient"))
                .recipientFlow("'thing1' == payload or 'thing2' == payload or 'thing3' == payload",
                    f -&gt; f.&lt;String, String&gt;transform(String::toUpperCase)
                        .channel(c -&gt; c.queue("recipientListSubFlow1Result")))
                .recipientFlow((String p) -&gt; p.startsWith("thing3"),
                    f -&gt; f.transform("Hello "::concat)
                        .channel(c -&gt; c.queue("recipientListSubFlow2Result")))
                .recipientFlow(new FunctionExpression&lt;Message&lt;?&gt;&gt;(m -&gt;
                                             "thing3".equals(m.getPayload())),
                    f -&gt; f.channel(c -&gt; c.queue("recipientListSubFlow3Result")))
                .defaultOutputToParentFlow())
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>.defaultOutputToParentFlow()</code> of the <code>.routeToRecipients()</code> definition lets you set the router&#8217;s <code>defaultOutput</code> as a gateway to continue a process for the unmatched messages in the main flow.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-splitters"><a class="anchor" href="#java-dsl-splitters"></a>11.8. Splitters</h3>
<div class="paragraph">
<p>To create a splitter, use the <code>split()</code> EIP method.
By default, if the payload is an <code>Iterable</code>, an <code>Iterator</code>, an <code>Array</code>, a <code>Stream</code>, or a reactive <code>Publisher</code>, the <code>split()</code> method outputs each item as an individual message.
It accepts a lambda, a SpEL expression, or any <code>AbstractMessageSplitter</code> implementation.
Alternatively, you can use it without parameters to provide the <code>DefaultMessageSplitter</code>.
The following example shows how to use the <code>split()</code> method by providing a lambda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow splitFlow() {
    return IntegrationFlows.from("splitInput")
              .split(s -&gt;
                      s.applySequence(false).get().getT2().setDelimiters(","))
              .channel(MessageChannels.executor(this.taskExecutor()))
              .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example creates a splitter that splits a message containing a comma-delimited <code>String</code>.
Note: The <code>getT2()</code> method comes from a <code>Tuple</code> <code>Collection</code>, which is the result of <code>EndpointSpec.get()</code>, and represents a pair of <code>ConsumerEndpointFactoryBean</code> and <code>DefaultMessageSplitter</code> for the preceding example.</p>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-aggregators"><a class="anchor" href="#java-dsl-aggregators"></a>11.9. Aggregators and Resequencers</h3>
<div class="paragraph">
<p>An <code>Aggregator</code> is conceptually the opposite of a <code>Splitter</code>.
It aggregates a sequence of individual messages into a single message and is necessarily more complex.
By default, an aggregator returns a message that contains a collection of payloads from incoming messages.
The same rules are applied for the <code>Resequencer</code>.
The following example shows a canonical example of the splitter-aggregator pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow splitAggregateFlow() {
    return IntegrationFlows.from("splitAggregateInput")
            .split()
            .channel(MessageChannels.executor(this.taskExecutor()))
            .resequence()
            .aggregate()
            .get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>split()</code> method splits the list into individual messages and sends them to the <code>ExecutorChannel</code>.
The <code>resequence()</code> method reorders messages by sequence details found in the message headers.
The <code>aggregate()</code> method collects those messages.</p>
</div>
<div class="paragraph">
<p>However, you can change the default behavior by specifying a release strategy and correlation strategy, among other things.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.aggregate(a -&gt;
        a.correlationStrategy(m -&gt; m.getHeaders().get("myCorrelationKey"))
            .releaseStrategy(g -&gt; g.size() &gt; 10)
            .messageStore(messageStore()))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example correlates messages that have <code>myCorrelationKey</code> headers and releases the messages once at least ten have been accumulated.</p>
</div>
<div class="paragraph">
<p>Similar lambda configurations are provided for the <code>resequence()</code> EIP method.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-handle"><a class="anchor" href="#java-dsl-handle"></a>11.10. Service Activators and the <code>.handle()</code> method</h3>
<div class="paragraph">
<p>The <code>.handle()</code> EIP method&#8217;s goal is to invoke any <code>MessageHandler</code> implementation or any method on some POJO.
Another option is to define an &#8220;activity&#8221; by using lambda expressions.
Consequently, we introduced a generic <code>GenericHandler&lt;P&gt;</code> functional interface.
Its <code>handle</code> method requires two arguments: <code>P payload</code> and <code>MessageHeaders headers</code> (starting with version 5.1).
Having that, we can define a flow as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow myFlow() {
    return IntegrationFlows.from("flow3Input")
        .&lt;Integer&gt;handle((p, h) -&gt; p * 2)
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example doubles any integer it receives.</p>
</div>
<div class="paragraph">
<p>However, one main goal of Spring Integration is <code>loose coupling</code>, through runtime type conversion from message payload to the target arguments of the message handler.
Since Java does not support generic type resolution for lambda classes, we introduced a workaround with an additional <code>payloadType</code> argument for the most EIP methods and <code>LambdaMessageProcessor</code>.
Doing so delegates the hard conversion work to Spring&#8217;s <code>ConversionService</code>, which uses the provided <code>type</code> and the requested message to target method arguments.
The following example shows what the resulting <code>IntegrationFlow</code> might look like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
            .&lt;byte[], String&gt;transform(p - &gt; new String(p, "UTF-8"))
            .handle(Integer.class, (p, h) -&gt; p * 2)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We also can register some <code>BytesToIntegerConverter</code> within <code>ConversionService</code> to get rid of that additional <code>.transform()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@IntegrationConverter
public BytesToIntegerConverter bytesToIntegerConverter() {
   return new BytesToIntegerConverter();
}

@Bean
public IntegrationFlow integerFlow() {
    return IntegrationFlows.from("input")
             .handle(Integer.class, (p, h) -&gt; p * 2)
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also see <a href="#java-dsl-class-cast">Lambdas And <code>Message&lt;?&gt;</code> Arguments</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-log"><a class="anchor" href="#java-dsl-log"></a>11.11. Operator log()</h3>
<div class="paragraph">
<p>For convenience, to log the message journey through the Spring Integration flow (<code>&lt;logging-channel-adapter&gt;</code>), a <code>log()</code> operator is presented.
Internally, it is represented by the <code>WireTap</code> <code>ChannelInterceptor</code> with a <code>LoggingHandler</code> as its subscriber.
It is responsible for logging the incoming message into the next endpoint or the current channel.
The following example shows how to use <code>LoggingHandler</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.filter(...)
.log(LoggingHandler.Level.ERROR, "test.category", m -&gt; m.getHeaders().getId())
.route(...)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, an <code>id</code> header is logged at the <code>ERROR</code> level onto <code>test.category</code> only for messages that passed the filter and before routing.</p>
</div>
<div class="paragraph">
<p>When this operator is used at the end of a flow, it is a one-way handler and the flow ends.
To make it as a reply-producing flow, you can either use a simple <code>bridge()</code> after the <code>log()</code> or,  starting with version 5.1, you can use a <code>logAndReply()</code> operator instead.
<code>logAndReply</code> can only be used at the end of a flow.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-wiretap"><a class="anchor" href="#java-dsl-wiretap"></a>11.12. <code>MessageChannelSpec.wireTap()</code></h3>
<div class="paragraph">
<p>Spring Integration includes a <code>.wireTap()</code> fluent API <code>MessageChannelSpec</code> builders.
The following example shows how to use the <code>wireTap</code> method to log input:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public QueueChannelSpec myChannel() {
    return MessageChannels.queue()
            .wireTap("loggingFlow.input");
}

@Bean
public IntegrationFlow loggingFlow() {
    return f -&gt; f.log();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the <code>MessageChannel</code> is an instance of <code>ChannelInterceptorAware</code>, the <code>log()</code> or <code>wireTap()</code> operators are applied to the current <code>MessageChannel</code>.
Otherwise, an intermediate <code>DirectChannel</code> is injected into the flow for the currently configured endpoint.
In the following example, the <code>WireTap</code> interceptor is added to <code>myChannel</code> directly, because <code>DirectChannel</code> implements <code>ChannelInterceptorAware</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
MessageChannel myChannel() {
    return new DirectChannel();
}

...
    .channel(myChannel())
    .log()
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the current <code>MessageChannel</code> does not implement <code>ChannelInterceptorAware</code>, an implicit <code>DirectChannel</code> and <code>BridgeHandler</code> are injected into the <code>IntegrationFlow</code>, and the <code>WireTap</code> is added to this new <code>DirectChannel</code>.
The following example does not have any channel declaration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.handle(...)
.log()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example (and any time no channel has been declared), an implicit <code>DirectChannel</code> is injected in the current position of the <code>IntegrationFlow</code> and used as an output channel for the currently configured <code>ServiceActivatingHandler</code> (from the <code>.handle()</code>, <a href="#java-dsl-handle">described earlier</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-flows"><a class="anchor" href="#java-dsl-flows"></a>11.13. Working With Message Flows</h3>
<div class="paragraph">
<p><code>IntegrationFlowBuilder</code> provides a top-level API to produce integration components wired to message flows.
When your integration may be accomplished with a single flow (which is often the case), this is convenient.
Alternately <code>IntegrationFlow</code> instances can be joined via <code>MessageChannel</code> instances.</p>
</div>
<div class="paragraph">
<p>By default, <code>MessageFlow</code> behaves as a &#8220;chain&#8221; in Spring Integration parlance.
That is, the endpoints are automatically and implicitly wired by <code>DirectChannel</code> instances.
The message flow is not actually constructed as a chain, which offers much more flexibility.
For example, you may send a message to any component within the flow, if you know its <code>inputChannel</code> name (that is, if you explicitly define it).
You may also reference externally defined channels within a flow to allow the use of channel adapters (to enable remote transport protocols, file I/O, and so on), instead of direct channels.
As such, the DSL does not support the Spring Integration <code>chain</code> element, because it does not add much value in this case.</p>
</div>
<div class="paragraph">
<p>Since the Spring Integration Java DSL produces the same bean definition model as any other configuration options and is based on the existing Spring Framework <code>@Configuration</code> infrastructure, it can be used together with XML definitions and wired with Spring Integration messaging annotation configuration.</p>
</div>
<div class="paragraph">
<p>You can also define direct <code>IntegrationFlow</code> instances by using a lambda.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow lambdaFlow() {
    return f -&gt; f.filter("World"::equals)
                   .transform("Hello "::concat)
                   .handle(System.out::println);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of this definition is the same set of integration components that are wired with an implicit direct channel.
The only limitation here is that this flow is started with a named direct channel - <code>lambdaFlow.input</code>.
Also, a Lambda flow cannot start from <code>MessageSource</code> or <code>MessageProducer</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, this kind of <code>IntegrationFlow</code> is wrapped to the proxy to expose lifecycle control and provide access to the <code>inputChannel</code> of the internally associated <code>StandardIntegrationFlow</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0.6, the generated bean names for the components in an <code>IntegrationFlow</code> include the flow bean followed by a dot (<code>.</code>) as a prefix.
For example, the <code>ConsumerEndpointFactoryBean</code> for the <code>.transform("Hello "::concat)</code> in the preceding sample results in a bean name of <code>lambdaFlow.o.s.i.config.ConsumerEndpointFactoryBean#0</code>.
(The <code>o.s.i</code> is a shortened from <code>org.springframework.integration</code> to fit on the page.)
The <code>Transformer</code> implementation bean for that endpoint  has a bean name of <code>lambdaFlow.transformer#0</code> (starting with version 5.1), where instead of a fully qualified name of the <code>MethodInvokingTransformer</code> class, its component type is used.
The same pattern is applied for all the <code>NamedComponent</code> s when the bean name has to be generated within the flow.
These generated bean names are prepended with the flow ID for purposes such as parsing logs or grouping components together in some analysis tool, as well as to avoid a race condition when we concurrently register integration flows at runtime.
See <a href="#java-dsl-runtime-flows">Dynamic and Runtime Integration Flows</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-function-expression"><a class="anchor" href="#java-dsl-function-expression"></a>11.14. <code>FunctionExpression</code></h3>
<div class="paragraph">
<p>We introduced the <code>FunctionExpression</code> class (an implementation of SpEL&#8217;s <code>Expression</code> interface) to let us use lambdas and <code>generics</code>.
The <code>Function&lt;T, R&gt;</code> option is provided for the DSL components, along with an <code>expression</code> option, when there is the implicit <code>Strategy</code> variant from Core Spring Integration.
The following example shows how to use a function expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.enrich(e -&gt; e.requestChannel("enrichChannel")
            .requestPayload(Message::getPayload)
            .propertyFunction("date", m -&gt; new Date()))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>FunctionExpression</code> also supports runtime type conversion, as is done in <code>SpelExpression</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-subflows"><a class="anchor" href="#java-dsl-subflows"></a>11.15. Sub-flows support</h3>
<div class="paragraph">
<p>Some of <code>if&#8230;&#8203;else</code> and <code>publish-subscribe</code> components provide the ability to specify their logic or mapping by using sub-flows.
The simplest sample is <code>.publishSubscribeChannel()</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow subscribersFlow() {
    return flow -&gt; flow
            .publishSubscribeChannel(Executors.newCachedThreadPool(), s -&gt; s
                    .subscribe(f -&gt; f
                            .&lt;Integer&gt;handle((p, h) -&gt; p / 2)
                            .channel(c -&gt; c.queue("subscriber1Results")))
                    .subscribe(f -&gt; f
                            .&lt;Integer&gt;handle((p, h) -&gt; p * 2)
                            .channel(c -&gt; c.queue("subscriber2Results"))))
            .&lt;Integer&gt;handle((p, h) -&gt; p * 3)
            .channel(c -&gt; c.queue("subscriber3Results"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can achieve the same result with separate <code>IntegrationFlow</code> <code>@Bean</code> definitions, but we hope you find the sub-flow style of logic composition useful.
We find that it results in shorter (and so more readable) code.</p>
</div>
<div class="paragraph">
<p>A similar <code>publish-subscribe</code> sub-flow composition provides the <code>.routeToRecipients()</code> method.</p>
</div>
<div class="paragraph">
<p>Another example is using <code>.discardFlow()</code> instead of <code>.discardChannel()</code> on the <code>.filter()</code> method.</p>
</div>
<div class="paragraph">
<p>The <code>.route()</code> deserves special attention.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow routeFlow() {
    return f -&gt; f
            .&lt;Integer, Boolean&gt;route(p -&gt; p % 2 == 0,
                    m -&gt; m.channelMapping("true", "evenChannel")
                            .subFlowMapping("false", sf -&gt;
                                    sf.&lt;Integer&gt;handle((p, h) -&gt; p * 3)))
            .transform(Object::toString)
            .channel(c -&gt; c.queue("oddChannel"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>.channelMapping()</code> continues to work as it does in regular <code>Router</code> mapping, but the <code>.subFlowMapping()</code> tied that sub-flow to the main flow.
In other words, any router&#8217;s sub-flow returns to the main flow after <code>.route()</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sometimes, you need to refer to an existing <code>IntegrationFlow</code> <code>@Bean</code> from the <code>.subFlowMapping()</code>.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow splitRouteAggregate() {
    return f -&gt; f
            .split()
            .&lt;Integer, Boolean&gt;route(o -&gt; o % 2 == 0,
                    m -&gt; m
                            .subFlowMapping(true, oddFlow())
                            .subFlowMapping(false, sf -&gt; sf.gateway(evenFlow())))
            .aggregate();
}

@Bean
public IntegrationFlow oddFlow() {
    return f -&gt; f.handle(m -&gt; System.out.println("odd"));
}

@Bean
public IntegrationFlow evenFlow() {
    return f -&gt; f.handle((p, h) -&gt; "even");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><br>
In this case, when you need to receive a reply from such a sub-flow and continue the main flow, this <code>IntegrationFlow</code> bean reference (or its input channel) has to be wrapped with a <code>.gateway()</code> as shown in the preceding example.
The <code>oddFlow()</code> reference in the preceding example is not wrapped to the <code>.gateway()</code>.
Therefore, we do not expect a reply from this routing branch.
Otherwise, you end up with an exception similar to the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Caused by: org.springframework.beans.factory.BeanCreationException:
    The 'currentComponent' (org.springframework.integration.router.MethodInvokingRouter@7965a51c)
    is a one-way 'MessageHandler' and it isn't appropriate to configure 'outputChannel'.
    This is the end of the integration flow.</pre>
</div>
</div>
<div class="paragraph">
<p>When you configure a sub-flow as a lambda, the framework handles the request-reply interaction with the sub-flow and a gateway is not needed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sub-flows can be nested to any depth, but we do not recommend doing so.
In fact, even in the router case, adding complex sub-flows within a flow would quickly begin to look like a plate of spaghetti and be difficult for a human to parse.</p>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-protocol-adapters"><a class="anchor" href="#java-dsl-protocol-adapters"></a>11.16. Using Protocol Adapters</h3>
<div class="paragraph">
<p>All of the examples shown so far illustrate how the DSL supports a messaging architecture by using the Spring Integration programming model.
However, we have yet to do any real integration.
Doing so requires access to remote resources over HTTP, JMS, AMQP, TCP, JDBC, FTP, SMTP, and so on or access to the local file system.
Spring Integration supports all of these and more.
Ideally, the DSL should offer first class support for all of them, but it is a daunting task to implement all of these and keep up as new adapters are added to Spring Integration.
So the expectation is that the DSL is continually catching up with Spring Integration.</p>
</div>
<div class="paragraph">
<p>Consequently, we provide the high-level API to seamlessly define protocol-specific messaging.
We do so with the factory and builder patterns and with lambdas.
You can think of the factory classes as &#8220;Namespace Factories&#8221;, because they play the same role as the XML namespace for components from the concrete protocol-specific Spring Integration modules.
Currently, Spring Integration Java DSL supports the <code>Amqp</code>, <code>Feed</code>, <code>Jms</code>, <code>Files</code>, <code>(S)Ftp</code>, <code>Http</code>, <code>JPA</code>, <code>MongoDb</code>,  <code>TCP/UDP</code>, <code>Mail</code>, <code>WebFlux</code>, and <code>Scripts</code> namespace factories.
The following example shows how to use three of them (<code>Amqp</code>, <code>Jms</code>, and <code>Mail</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow amqpFlow() {
    return IntegrationFlows.from(Amqp.inboundGateway(this.rabbitConnectionFactory, queue()))
            .transform("hello "::concat)
            .transform(String.class, String::toUpperCase)
            .get();
}

@Bean
public IntegrationFlow jmsOutboundGatewayFlow() {
    return IntegrationFlows.from("jmsOutboundGatewayChannel")
            .handle(Jms.outboundGateway(this.jmsConnectionFactory)
                        .replyContainer(c -&gt;
                                    c.concurrentConsumers(3)
                                            .sessionTransacted(true))
                        .requestDestination("jmsPipelineTest"))
            .get();
}

@Bean
public IntegrationFlow sendMailFlow() {
    return IntegrationFlows.from("sendMailChannel")
            .handle(Mail.outboundAdapter("localhost")
                            .port(smtpPort)
                            .credentials("user", "pw")
                            .protocol("smtp")
                            .javaMailProperties(p -&gt; p.put("mail.debug", "true")),
                    e -&gt; e.id("sendMailEndpoint"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows how to use the &#8220;namespace factories&#8221; as inline adapters declarations.
However, you can use them from <code>@Bean</code> definitions to make the <code>IntegrationFlow</code> method chain more readable.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We are soliciting community feedback on these namespace factories before we spend effort on others.
We also appreciate any input into prioritization for which adapters and gateways we should support next.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find more Java DSL samples in the protocol-specific chapters throughout this reference manual.</p>
</div>
<div class="paragraph">
<p>All other protocol channel adapters may be configured as generic beans and wired to the <code>IntegrationFlow</code>, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public QueueChannelSpec wrongMessagesChannel() {
    return MessageChannels
            .queue()
            .wireTap("wrongMessagesWireTapChannel");
}

@Bean
public IntegrationFlow xpathFlow(MessageChannel wrongMessagesChannel) {
    return IntegrationFlows.from("inputChannel")
            .filter(new StringValueTestXPathMessageSelector("namespace-uri(/*)", "my:namespace"),
                    e -&gt; e.discardChannel(wrongMessagesChannel))
            .log(LoggingHandler.Level.ERROR, "test.category", m -&gt; m.getHeaders().getId())
            .route(xpathRouter(wrongMessagesChannel))
            .get();
}

@Bean
public AbstractMappingMessageRouter xpathRouter(MessageChannel wrongMessagesChannel) {
    XPathRouter router = new XPathRouter("local-name(/*)");
    router.setEvaluateAsString(true);
    router.setResolutionRequired(false);
    router.setDefaultOutputChannel(wrongMessagesChannel);
    router.setChannelMapping("Tags", "splittingChannel");
    router.setChannelMapping("Tag", "receivedChannel");
    return router;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-flow-adapter"><a class="anchor" href="#java-dsl-flow-adapter"></a>11.17. <code>IntegrationFlowAdapter</code></h3>
<div class="paragraph">
<p>The <code>IntegrationFlow</code> interface can be implemented directly and specified as a component for scanning, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyFlow implements IntegrationFlow {

    @Override
    public void configure(IntegrationFlowDefinition&lt;?&gt; f) {
        f.&lt;String, String&gt;transform(String::toUpperCase);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is picked up by the <code>IntegrationFlowBeanPostProcessor</code> and correctly parsed and registered in the application context.</p>
</div>
<div class="paragraph">
<p>For convenience and to gain the benefits of loosely coupled architecture, we provide the <code>IntegrationFlowAdapter</code> base class implementation.
It requires a <code>buildFlow()</code> method implementation to produce an <code>IntegrationFlowDefinition</code> by using one of <code>from()</code> methods, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyFlowAdapter extends IntegrationFlowAdapter {

    private final AtomicBoolean invoked = new AtomicBoolean();

    public Date nextExecutionTime(TriggerContext triggerContext) {
          return this.invoked.getAndSet(true) ? null : new Date();
    }

    @Override
    protected IntegrationFlowDefinition&lt;?&gt; buildFlow() {
        return from(this, "messageSource",
                      e -&gt; e.poller(p -&gt; p.trigger(this::nextExecutionTime)))
                 .split(this)
                 .transform(this)
                 .aggregate(a -&gt; a.processor(this, null), null)
                 .enrichHeaders(Collections.singletonMap("thing1", "THING1"))
                 .filter(this)
                 .handle(this)
                 .channel(c -&gt; c.queue("myFlowAdapterOutput"));
    }

    public String messageSource() {
         return "T,H,I,N,G,2";
    }

    @Splitter
    public String[] split(String payload) {
         return StringUtils.commaDelimitedListToStringArray(payload);
    }

    @Transformer
    public String transform(String payload) {
         return payload.toLowerCase();
    }

    @Aggregator
    public String aggregate(List&lt;String&gt; payloads) {
           return payloads.stream().collect(Collectors.joining());
    }

    @Filter
    public boolean filter(@Header Optional&lt;String&gt; thing1) {
            return thing1.isPresent();
    }

    @ServiceActivator
    public String handle(String payload, @Header String thing1) {
           return payload + ":" + thing1;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-runtime-flows"><a class="anchor" href="#java-dsl-runtime-flows"></a>11.18. Dynamic and Runtime Integration Flows</h3>
<div class="paragraph">
<p><code>IntegrationFlow</code> and all its dependent components can be registered at runtime.
Before version 5.0, we used the <code>BeanFactory.registerSingleton()</code> hook.
Starting in the Spring Framework <code>5.0</code>, we use the <code>instanceSupplier</code> hook for programmatic <code>BeanDefinition</code> registration.
The following example shows how to programmatically register a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BeanDefinition beanDefinition =
         BeanDefinitionBuilder.genericBeanDefinition((Class&lt;Object&gt;) bean.getClass(), () -&gt; bean)
               .getRawBeanDefinition();

((BeanDefinitionRegistry) this.beanFactory).registerBeanDefinition(beanName, beanDefinition);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that, in the preceding example, the <code>instanceSupplier</code> hook is the last parameter to the <code>genericBeanDefinition</code> method, provided by a lambda in this case.</p>
</div>
<div class="paragraph">
<p>All the necessary bean initialization and lifecycle is done automatically, as it is with the standard context configuration bean definitions.</p>
</div>
<div class="paragraph">
<p>To simplify the development experience, Spring Integration introduced <code>IntegrationFlowContext</code> to register and manage <code>IntegrationFlow</code> instances at runtime, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private AbstractServerConnectionFactory server1;

@Autowired
private IntegrationFlowContext flowContext;

...

@Test
public void testTcpGateways() {
    TestingUtilities.waitListening(this.server1, null);

    IntegrationFlow flow = f -&gt; f
            .handle(Tcp.outboundGateway(Tcp.netClient("localhost", this.server1.getPort())
                    .serializer(TcpCodecs.crlf())
                    .deserializer(TcpCodecs.lengthHeader1())
                    .id("client1"))
                .remoteTimeout(m -&gt; 5000))
            .transform(Transformers.objectToString());

    IntegrationFlowRegistration theFlow = this.flowContext.registration(flow).register();
    assertThat(theFlow.getMessagingTemplate().convertSendAndReceive("foo", String.class), equalTo("FOO"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is useful when we have multiple configuration options and have to create several instances of similar flows.
To do so, we can iterate our options and create and register <code>IntegrationFlow</code> instances within a loop.
Another variant is when our source of data is not Spring-based and we must create it on the fly.
Such a sample is Reactive Streams event source, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Message&lt;?&gt;&gt; messageFlux =
    Flux.just("1,2,3,4")
        .map(v -&gt; v.split(","))
        .flatMapIterable(Arrays::asList)
        .map(Integer::parseInt)
        .map(GenericMessage&lt;Integer&gt;::new);

QueueChannel resultChannel = new QueueChannel();

IntegrationFlow integrationFlow =
    IntegrationFlows.from(messageFlux)
        .&lt;Integer, Integer&gt;transform(p -&gt; p * 2)
        .channel(resultChannel)
        .get();

this.integrationFlowContext.registration(integrationFlow)
            .register();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>IntegrationFlowRegistrationBuilder</code> (as a result of the <code>IntegrationFlowContext.registration()</code>) can be used to specify a bean name for the <code>IntegrationFlow</code> to register, to control its <code>autoStartup</code>, and to register, non-Spring Integration beans.
Usually, those additional beans are connection factories (AMQP, JMS, (S)FTP, TCP/UDP, and others.), serializers and deserializers, or any other required support components.</p>
</div>
<div class="paragraph">
<p>You can use the <code>IntegrationFlowRegistration.destroy()</code> callback to remove a dynamically registered <code>IntegrationFlow</code> and all its dependent beans when you no longer need them.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/context/IntegrationFlowContext.html"><code>IntegrationFlowContext</code> Javadoc</a> for more information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 5.0.6, all generated bean names in an <code>IntegrationFlow</code> definition are prepended with the flow ID as a prefix.
We recommend always specifying an explicit flow ID.
Otherwise, a synchronization barrier is initiated in the <code>IntegrationFlowContext</code>, to generate the bean name for the <code>IntegrationFlow</code> and register its beans.
We synchronize on these two operations to avoid a race condition when the same generated bean name may be used for different <code>IntegrationFlow</code> instances.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, starting with version 5.0.6, the registration builder API has a new method: <code>useFlowIdAsPrefix()</code>.
This is useful if you wish to declare multiple instances of the same flow and avoid bean name collisions when components in the flows have the same ID, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private void registerFlows() {
    IntegrationFlowRegistration flow1 =
              this.flowContext.registration(buildFlow(1234))
                    .id("tcp1")
                    .useFlowIdAsPrefix()
                    .register();

    IntegrationFlowRegistration flow2 =
              this.flowContext.registration(buildFlow(1235))
                    .id("tcp2")
                    .useFlowIdAsPrefix()
                    .register();
}

private IntegrationFlow buildFlow(int port) {
    return f -&gt; f
            .handle(Tcp.outboundGateway(Tcp.netClient("localhost", port)
                    .serializer(TcpCodecs.crlf())
                    .deserializer(TcpCodecs.lengthHeader1())
                    .id("client"))
                .remoteTimeout(m -&gt; 5000))
            .transform(Transformers.objectToString());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the message handler for the first flow can be referenced with bean a name of <code>tcp1.client.handler</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An <code>id</code> attribute is required when you usE <code>useFlowIdAsPrefix()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-gateway"><a class="anchor" href="#java-dsl-gateway"></a>11.19. <code>IntegrationFlow</code> as Gateway</h3>
<div class="paragraph">
<p>The <code>IntegrationFlow</code> can start from the service interface that provides a <code>GatewayProxyFactoryBean</code> component, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ControlBusGateway {

    void send(String command);
}

...

@Bean
public IntegrationFlow controlBusFlow() {
    return IntegrationFlows.from(ControlBusGateway.class)
            .controlBus()
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All the proxy for interface methods are supplied with the channel to send messages to the next integration component in the <code>IntegrationFlow</code>.
You can mark the service interface with the <code>@MessagingGateway</code> annotation and mark the methods with the <code>@Gateway</code> annotations.
Nevertheless, the <code>requestChannel</code> is ignored and overridden with that internal channel for the next component in the <code>IntegrationFlow</code>.
Otherwise, creating such a configuration by using <code>IntegrationFlow</code> does not make sense.</p>
</div>
<div class="paragraph">
<p>By default a <code>GatewayProxyFactoryBean</code> gets a conventional bean name, such as <code>[FLOW_BEAN_NAME.gateway]</code>.
You can change that ID by using the <code>@MessagingGateway.name()</code> attribute or the overloaded <code>from(Class&lt;?&gt; serviceInterface, String beanName)</code> factory method.</p>
</div>
<div class="paragraph">
<p>With Java 8, you can even create an integration fateway with the <code>java.util.function</code> interfaces, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow errorRecovererFlow() {
    return IntegrationFlows.from(Function.class, "errorRecovererFunction")
            .handle((GenericHandler&lt;?&gt;) (p, h) -&gt; {
                throw new RuntimeException("intentional");
            }, e -&gt; e.advice(retryAdvice()))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That <code>errorRecovererFlow</code> can be used as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
@Qualifier("errorRecovererFunction")
private Function&lt;String, String&gt; errorRecovererFlowGateway;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="system-management-chapter"><a class="anchor" href="#system-management-chapter"></a>12. System Management</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="metrics-management"><a class="anchor" href="#metrics-management"></a>12.1. Metrics and Management</h3>
<div class="paragraph">
<p>This section describes how to capture metrics for Spring Integration.
In recent versions, we have relied more on Micrometer (see <a href="https://micrometer.io" class="bare">micrometer.io</a>), and we plan to use Micrometer even more in future releases.</p>
</div>
<div class="sect3">
<h4 id="configuring-metrics-capture"><a class="anchor" href="#configuring-metrics-capture"></a>12.1.1. Configuring Metrics Capture</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Prior to version 4.2, metrics were only available when JMX was enabled.
See <a href="#jmx">JMX Support</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable <code>MessageSource</code>, <code>MessageChannel</code>, and <code>MessageHandler</code> metrics, add an <code>&lt;int:management/&gt;</code> bean to the application context (in XML) or annotate one of your <code>@Configuration</code> classes with <code>@EnableIntegrationManagement</code> (in Java).
<code>MessageSource</code> instances maintain only counts, <code>MessageChannel</code> instances and <code>MessageHandler</code> instances maintain duration statistics in addition to counts.
See <a href="#mgmt-channel-features"><code>MessageChannel</code> Metric Features</a> and <a href="#mgmt-handler-features">MessageHandler Metric Features</a>, later in this chapter.</p>
</div>
<div class="paragraph">
<p>Doing so causes the automatic registration of the <code>IntegrationManagementConfigurer</code> bean in the application context.
Only one such bean can exist in the context, and, if registered manually via a <code>&lt;bean/&gt;</code> definition, it must have the bean name set to <code>integrationManagementConfigurer</code>.
This bean applies its configuration to beans after all beans in the context have been instantiated.</p>
</div>
<div class="paragraph">
<p>In addition to metrics, you can control debug logging in the main message flow.
In very high volume applications, even calls to <code>isDebugEnabled()</code> can be quite expensive with some logging subsystems.
You can disable all such logging to avoid this overhead.
Exception logging (debug or otherwise) is not affected by this setting.</p>
</div>
<div class="paragraph">
<p>The following listing shows the available options for controlling logging:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:management
    default-logging-enabled="true" <i class="conum" data-value="1"></i><b>(1)</b>
    default-counts-enabled="false" <i class="conum" data-value="2"></i><b>(2)</b>
    default-stats-enabled="false" <i class="conum" data-value="3"></i><b>(3)</b>
    counts-enabled-patterns="foo, !baz, ba*" <i class="conum" data-value="4"></i><b>(4)</b>
    stats-enabled-patterns="fiz, buz" <i class="conum" data-value="5"></i><b>(5)</b>
    metrics-factory="myMetricsFactory" /&gt; <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
@EnableIntegrationManagement(
    defaultLoggingEnabled = "true", <i class="conum" data-value="1"></i><b>(1)</b>
    defaultCountsEnabled = "false", <i class="conum" data-value="2"></i><b>(2)</b>
    defaultStatsEnabled = "false", <i class="conum" data-value="3"></i><b>(3)</b>
    countsEnabled = { "foo", "${count.patterns}" }, <i class="conum" data-value="4"></i><b>(4)</b>
    statsEnabled = { "qux", "!*" }, <i class="conum" data-value="5"></i><b>(5)</b>
    MetricsFactory = "myMetricsFactory") <i class="conum" data-value="6"></i><b>(6)</b>
public static class ContextConfiguration {
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set to <code>false</code> to disable all logging in the main message flow, regardless of the log system category settings.
Set to 'true' to enable debug logging (if also enabled by the logging subsystem).
Only applied if you have not explicitly configured the setting in a bean definition.
The default is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Enable or disable count metrics for components that do not match one of the patterns in &lt;4&gt;.
Only applied if you have not explicitly configured the setting in a bean definition.
The default is <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Enable or disable statistical metrics for components that do not match one of the patterns in &lt;5&gt;.
Only applied if you have not explicitly configured the setting in a bean definition.
The default is 'false'.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A comma-delimited list of patterns for beans for which counts should be enabled.
You can negate the pattern with <code>!</code>.
First match (positive or negative) wins.
In the unlikely event that you have a bean name starting with <code>!</code>, escape the <code>!</code> in the pattern.
For example, <code>\!something</code> positively matches a bean named <code>!something</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A comma-delimited list of patterns for beans for which statistical metrics should be enabled.
You can negate the pattern\ with <code>!</code>.
First match (positive or negative) wins.
In the unlikely event that you have a bean name starting with <code>!</code>, escape the <code>!</code> in the pattern.
<code>\!something</code> positively matches a bean named <code>!something</code>.
The collection of statistics implies the collection of counts.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A reference to a <code>MetricsFactory</code>.
See <a href="#mgmt-metrics-factory">Metrics Factory</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>At runtime, counts and statistics can be obtained by calling <code>getChannelMetrics</code>, <code>getHandlerMetrics</code> and <code>getSourceMetrics</code> (all from the <code>IntegrationManagementConfigurer</code> class), which return <code>MessageChannelMetrics</code>, <code>MessageHandlerMetrics</code>, and <code>MessageSourceMetrics</code>, respectively.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> for complete information about these classes.</p>
</div>
<div class="paragraph">
<p>When JMX is enabled (see <a href="#jmx">JMX Support</a>), <code>IntegrationMBeanExporter</code> also exposes these metrics.</p>
</div>
<div class="paragraph">
<p>IMPORTANT:
<code>defaultLoggingEnabled</code>, <code>defaultCountsEnabled</code>, and <code>defaultStatsEnabled</code> are applied only if you have not explicitly configured the corresponding setting in a bean definition.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0.2, the framework automatically detects whether the application context has a single <code>MetricsFactory</code> bean and, if so, uses it instead of the default metrics factory.</p>
</div>
</div>
<div class="sect3">
<h4 id="micrometer-integration"><a class="anchor" href="#micrometer-integration"></a>12.1.2. Micrometer Integration</h4>
<div class="paragraph">
<p>Starting with version 5.0.3, the presence of a <a href="https://micrometer.io/">Micrometer</a> <code>MeterRegistry</code> in the application context triggers support for Micrometer metrics in addition to the built-in metrics (note that built-in metrics will be removed in a future release).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Micrometer was first supported in version 5.0.2, but changes were made to the Micrometer <code>Meters</code> in version 5.0.3 to make them more suitable for use in dimensional systems.
Further changes were made in 5.0.4.
If you use Micrometer, a minimum of version 5.0.4 is recommended, since some of the changes in 5.0.4 were breaking API changes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use Micrometer, add one of the <code>MeterRegistry</code> beans to the application context.
If the <code>IntegrationManagementConfigurer</code> detects exactly one <code>MeterRegistry</code> bean, it configures a <code>MicrometerMetricsCaptor</code> bean with a name of <code>integrationMicrometerMetricsCaptor</code>.</p>
</div>
<div class="paragraph">
<p>For each <code>MessageHandler</code> and <code>MessageChannel</code>, timers are registered.
For each <code>MessageSource</code>, a counter is registered.</p>
</div>
<div class="paragraph">
<p>This only applies to objects that extend <code>AbstractMessageHandler</code>, <code>AbstractMessageChannel</code>, and <code>AbstractMessageSource</code> (which is the case for most framework components).</p>
</div>
<div class="paragraph">
<p>With Micrometer metrics, the <code>statsEnabled</code> flag has no effect, since statistics capture is delegated to Micrometer.
The <code>countsEnabled</code> flag controls whether the Micrometer <code>Meter</code> instances are updated when processing each message.</p>
</div>
<div class="paragraph">
<p>The <code>Timer</code> Meters for send operations on message channels have the following names or tags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: <code>spring.integration.send</code></p>
</li>
<li>
<p><code>tag</code>: <code>type:channel</code></p>
</li>
<li>
<p><code>tag</code>: <code>name:&lt;componentName&gt;</code></p>
</li>
<li>
<p><code>tag</code>: <code>result:(success|failure)</code></p>
</li>
<li>
<p><code>tag</code>: <code>exception:(none|exception simple class name)</code></p>
</li>
<li>
<p><code>description</code>: <code>Send processing time</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(A <code>failure</code> result with a <code>none</code> exception means the channel&#8217;s <code>send()</code> operation returned <code>false</code>.)</p>
</div>
<div class="paragraph">
<p>The <code>Counter</code> Meters for receive operations on pollable message channels have the following names or tags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: <code>spring.integration.receive</code></p>
</li>
<li>
<p><code>tag</code>: <code>type:channel</code></p>
</li>
<li>
<p><code>tag</code>: <code>name:&lt;componentName&gt;</code></p>
</li>
<li>
<p><code>tag</code>: <code>result:(success|failure)</code></p>
</li>
<li>
<p><code>tag</code>: <code>exception:(none|exception simple class name)</code></p>
</li>
<li>
<p><code>description</code>: <code>Messages received</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Timer</code> Meters for operations on message handlers have the following names or tags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: <code>spring.integration.send</code></p>
</li>
<li>
<p><code>tag</code>: <code>type:handler</code></p>
</li>
<li>
<p><code>tag</code>: <code>name:&lt;componentName&gt;</code></p>
</li>
<li>
<p><code>tag</code>: <code>result:(success|failure)</code></p>
</li>
<li>
<p><code>tag</code>: <code>exception:(none|exception simple class name)</code></p>
</li>
<li>
<p><code>description</code>: <code>Send processing time</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Counter</code> meters for message sources have the following names/tags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: <code>spring.integration.receive</code></p>
</li>
<li>
<p><code>tag</code>: <code>type:source</code></p>
</li>
<li>
<p><code>tag</code>: <code>name:&lt;componentName&gt;</code></p>
</li>
<li>
<p><code>tag</code>: <code>result:success</code></p>
</li>
<li>
<p><code>tag</code>: <code>exception:none</code></p>
</li>
<li>
<p><code>description</code>: <code>Messages received</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, there are three <code>Gauge</code> Meters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.integration.channels</code>: The number of <code>MessageChannels</code> in the application.</p>
</li>
<li>
<p><code>spring.integration.handlers</code>: The number of <code>MessageHandlers</code> in the application.</p>
</li>
<li>
<p><code>spring.integration.sources</code>: The number of <code>MessageSources</code> in the application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is possible to customize the names and tags of <code>Meters</code> created by integration components by providing a subclass of <code>MicrometerMetricsCaptor</code>.
The <a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-core/src/test/java/org/springframework/integration/support/management/micrometer/MicrometerCustomMetricsTests.java">MicrometerCustomMetricsTests</a> test case shows a simple example of how to do that.
You can also further customize the meters by overloading the <code>build()</code> methods on builder subclasses.</p>
</div>
</div>
<div class="sect3">
<h4 id="mgmt-channel-features"><a class="anchor" href="#mgmt-channel-features"></a>12.1.3. <code>MessageChannel</code> Metric Features</h4>
<div class="paragraph">
<p>These legacy metrics will be removed in a future release.
See <a href="#micrometer-integration">Micrometer Integration</a>.</p>
</div>
<div class="paragraph">
<p>Message channels report metrics according to their concrete type.
If you are looking at a <code>DirectChannel</code>, you see statistics for the send operation.
If it is a <code>QueueChannel</code>, you also see statistics for the receive operation as well as the count of messages that are currently buffered by this <code>QueueChannel</code>.
In both cases, some metrics are simple counters (message count and error count), and some are estimates of averages of interesting quantities.
The algorithms used to calculate these estimates are described briefly in the following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. MessageChannel Metrics</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Metric Type</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple incrementer.
Increases by one when an event occurs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Error Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple incrementer.
Increases by one when an send results in an error.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Duration (method execution time in milliseconds)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exponential moving average with decay factor (ten by default).
Average of the method execution time over roughly the last ten (by default) measurements.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Rate (number of operations per second)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse of Exponential moving average of the interval between events with decay in time (lapsing over 60 seconds by default) and per measurement (last ten events by default).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error Rate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Error Rate (number of errors per second)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse of exponential moving average of the interval between error events with decay in time (lapsing over 60 seconds by default) and per measurement (last ten events by default).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ratio</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send Success Ratio (ratio of successful to total sends)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Estimate the success ratio as the exponential moving average of the series composed of values (1 for success and 0 for failure, decaying as per the rate measurement over time and events by default).
The error ratio is: 1 - success ratio.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mgmt-handler-features"><a class="anchor" href="#mgmt-handler-features"></a>12.1.4. MessageHandler Metric Features</h4>
<div class="paragraph">
<p>These legacy metrics will be removed in a future release.
See <a href="#micrometer-integration">Micrometer Integration</a>.</p>
</div>
<div class="paragraph">
<p>The following table shows the statistics maintained for message handlers.
Some metrics are simple counters (message count and error count), and one is an estimate of averages of send duration.
The algorithms used to calculate these estimates are described briefly in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. MessageHandlerMetrics</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Metric Type</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handle Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple incrementer.
Increases by one when an event occurs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handler Error Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple incrementer.
Increases by one when an invocation results in an error.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handler Active Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the number of currently active threads currently invoking the handler (or any downstream synchronous flow).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handle Duration (method execution time in milliseconds)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exponential moving average with decay factor (ten by default).
Average of the method execution time over roughly the last ten (default) measurements.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mgmt-statistics"><a class="anchor" href="#mgmt-statistics"></a>12.1.5. Time-Based Average Estimates</h4>
<div class="paragraph">
<p>A feature of the time-based average estimates is that they decay with time if no new measurements arrive.
To help interpret the behavior over time, the time (in seconds) since the last measurement is also exposed as a metric.</p>
</div>
<div class="paragraph">
<p>There are two basic exponential models: decay per measurement (appropriate for duration and anything where the number of measurements is part of the metric) and decay per time unit (more suitable for rate measurements where the time in between measurements is part of the metric).
Both models depend on the fact that <code>S(n) = sum(i=0,i=n) w(i) x(i)</code> has a special form when <code>w(i) = r^i</code>, with <code>r=constant</code>: <code>S(n) = x(n) + r S(n-1)</code> (so you only have to store <code>S(n-1)</code> (not the whole series <code>x(i)</code>) to generate a new metric estimate from the last measurement).
The algorithms used in the duration metrics use <code>r=exp(-1/M)</code> with <code>M=10</code>.
The net effect is that the estimate, <code>S(n)</code>, is more heavily weighted to recent measurements and is composed roughly of the last <code>M</code> measurements.
So <code>M</code> is the &#8220;window&#8221; or lapse rate of the estimate.
For the vanilla moving average, <code>i</code> is a counter over the number of measurements.
For the rate, we interpret <code>i</code> as the elapsed time or a combination of elapsed time and a counter (so the metric estimate contains contributions roughly from the last <code>M</code> measurements and the last <code>T</code> seconds).</p>
</div>
</div>
<div class="sect3">
<h4 id="mgmt-metrics-factory"><a class="anchor" href="#mgmt-metrics-factory"></a>12.1.6. Metrics Factory</h4>
<div class="paragraph">
<p>A strategy interface <code>MetricsFactory</code> has been introduced to let you provide custom channel metrics for your <code>MessageChannel</code> instances and <code>MessageHandler</code> instances.
By default, a <code>DefaultMetricsFactory</code> provides a default implementation of <code>MessageChannelMetrics</code> and <code>MessageHandlerMetrics</code>, <a href="#configuring-metrics-capture">described earlier</a>.
To override the default <code>MetricsFactory</code>, configure it as <a href="#configuring-metrics-capture">described earlier</a>, by providing a reference to your <code>MetricsFactory</code> bean instance.
You can either customize the default implementations, as described in the next section, or provide completely different
implementations by extending <code>AbstractMessageChannelMetrics</code> or <code>AbstractMessageHandlerMetrics</code>.</p>
</div>
<div class="paragraph">
<p>See also <a href="#micrometer-integration">Micrometer Integration</a>.</p>
</div>
<div class="paragraph">
<p>In addition to the default metrics factory <a href="#configuring-metrics-capture">described earlier</a>, the framework provides the <code>AggregatingMetricsFactory</code>.
This factory creates <code>AggregatingMessageChannelMetrics</code> and <code>AggregatingMessageHandlerMetrics</code> instances.
In very high volume scenarios, the cost of capturing statistics can be prohibitive (the time to make two calls to the system and
store the data for each message).
The aggregating metrics aggregate the response time over a sample of messages.
This can save significant CPU time.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The statistics are likely to be skewed if messages arrive in bursts.
These metrics are intended for use with high, constant-volume, message rates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to define an aggregrating metrics factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="aggregatingMetricsFactory"
            class="org.springframework.integration.support.management.AggregatingMetricsFactory"&gt;
    &lt;constructor-arg value="1000" /&gt; &lt;!-- sample size --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration aggregates the duration over 1000 messages.
Counts (send and error) are maintained per-message, but the statistics are per 1000 messages.</p>
</div>
<div class="sect4">
<h5 id="customizing-the-default-channel-and-handler-statistics"><a class="anchor" href="#customizing-the-default-channel-and-handler-statistics"></a>Customizing the Default Channel and Handler Statistics</h5>
<div class="paragraph">
<p>See <a href="#mgmt-statistics">Time-Based Average Estimates</a> and the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> for the <code>ExponentialMovingAverage*</code> classes for more information about these values.</p>
</div>
<div class="paragraph">
<p>By default, the <code>DefaultMessageChannelMetrics</code> and <code>DefaultMessageHandlerMetrics</code> use a &#8220;window&#8221; of ten measurements,
a rate period of one second (meaning rate per second) and a decay lapse period of one minute.</p>
</div>
<div class="paragraph">
<p>If you wish to override these defaults, you can provide a custom <code>MetricsFactory</code> that returns appropriately configured
metrics and provide a reference to it in the MBean exporter, as <a href="#mgmt-metrics-factory">described earlier</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class CustomMetrics implements MetricsFactory {

    @Override
    public AbstractMessageChannelMetrics createChannelMetrics(String name) {
        return new DefaultMessageChannelMetrics(name,
                new ExponentialMovingAverage(20, 1000000.),
                new ExponentialMovingAverageRate(2000, 120000, 30, true),
                new ExponentialMovingAverageRatio(130000, 40, true),
                new ExponentialMovingAverageRate(3000, 140000, 50, true));
    }

    @Override
    public AbstractMessageHandlerMetrics createHandlerMetrics(String name) {
        return new DefaultMessageHandlerMetrics(name, new ExponentialMovingAverage(20, 1000000.));
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="advanced-customization"><a class="anchor" href="#advanced-customization"></a>Advanced Customization</h5>
<div class="paragraph">
<p>The customizations described earlier are wholesale and apply to all appropriate beans exported by the MBean exporter.
This is the extent of customization available when you use XML configuration.</p>
</div>
<div class="paragraph">
<p>Individual beans can be provided with different implementations using by Java <code>@Configuration</code> or programmatically at
runtime (after the application context has been refreshed) by invoking the <code>configureMetrics</code> methods on
<code>AbstractMessageChannel</code> and <code>AbstractMessageHandler</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="performance-improvement"><a class="anchor" href="#performance-improvement"></a>Performance Improvement</h5>
<div class="paragraph">
<p>Previously, the time-based metrics (see <a href="#mgmt-statistics">Time-Based Average Estimates</a>) were calculated in real time.
The statistics are now calculated when retrieved instead.
This resulted in a significant performance improvement, at the expense of a small amount of additional memory for each statistic.
As <a href="#configuring-metrics-capture">discussed earlier</a>, you can disable the statistics altogether while retaining the MBean that allows the invocation of <code>Lifecycle</code> methods.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx"><a class="anchor" href="#jmx"></a>12.2. JMX Support</h3>
<div class="paragraph">
<p>Spring Integration provides channel Adapters for receiving and publishing JMX Notifications.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-jmx&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-jmx:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>An inbound channel adapter allows for polling JMX MBean attribute values, and an outbound channel adapter allows for invoking JMX MBean operations.</p>
</div>
<div class="sect3">
<h4 id="jmx-notification-listening-channel-adapter"><a class="anchor" href="#jmx-notification-listening-channel-adapter"></a>12.2.1. Notification-listening Channel Adapter</h4>
<div class="paragraph">
<p>The notification-listening channel adapter requires a JMX <code>ObjectName</code> for the MBean that publishes notifications to which this listener should be registered.
A very simple configuration might resemble the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:notification-listening-channel-adapter id="adapter"
    channel="channel"
    object-name="example.domain:name=publisher"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>notification-listening-channel-adapter</code> registers with an <code>MBeanServer</code> at startup, and the default bean name is <code>mbeanServer</code>, which happens to be the same bean name generated when using Spring&#8217;s <code>&lt;context:mbean-server/&gt;</code> element.
If you need to use a different name, be sure to include the <code>mbean-server</code> attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The adapter can also accept a reference to a <code>NotificationFilter</code> and a &#8220;handback&#8221; object to provide some context that is passed back with each notification.
Both of those attributes are optional.
Extending the preceding example to include those attributes as well as an explicit <code>MBeanServer</code> bean name produces the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:notification-listening-channel-adapter id="adapter"
    channel="channel"
    mbean-server="someServer"
    object-name="example.domain:name=somePublisher"
    notification-filter="notificationFilter"
    handback="myHandback"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The _Notification-listening channel adapter is event-driven and registered with the <code>MBeanServer</code> directly.
It does not require any poller configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For this component only, the <code>object-name</code> attribute can contain an object name pattern (for example,
"org.something:type=MyType,name=*").
In that case, the adapter receives notifications from all MBeans with object names that match the pattern.
In addition, the <code>object-name</code> attribute can contain a SpEL reference to a <code>&lt;util:list&gt;</code> of object name patterns, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jmx:notification-listening-channel-adapter id="manyNotificationsAdapter"
    channel="manyNotificationsChannel"
    object-name="#{patterns}"/&gt;

&lt;util:list id="patterns"&gt;
    &lt;value&gt;org.foo:type=Foo,name=*&lt;/value&gt;
    &lt;value&gt;org.foo:type=Bar,name=*&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The names of the located MBean(s) are logged when DEBUG level logging is enabled.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jmx-notification-publishing-channel-adapter"><a class="anchor" href="#jmx-notification-publishing-channel-adapter"></a>12.2.2. Notification-publishing Channel Adapter</h4>
<div class="paragraph">
<p>The notification-publishing channel adapter is relatively simple.
It requires only a JMX object name in its configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;context:mbean-export/&gt;

&lt;int-jmx:notification-publishing-channel-adapter id="adapter"
    channel="channel"
    object-name="example.domain:name=publisher"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It also requires that an <code>MBeanExporter</code> be present in the context.
That is why the <code>&lt;context:mbean-export/&gt;</code> element is also shown in the preceding example.</p>
</div>
<div class="paragraph">
<p>When messages are sent to the channel for this adapter, the notification is created from the message content.
If the payload is a <code>String</code>, it is passed as the <code>message</code> text for the notification.
Any other payload type is passed as the <code>userData</code> of the notification.</p>
</div>
<div class="paragraph">
<p>JMX notifications also have a <code>type</code>, and it should be a dot-delimited <code>String</code>.
There are two ways to provide the <code>type</code>.
Precedence is always given to a message header value associated with the <code>JmxHeaders.NOTIFICATION_TYPE</code> key.
Alternatively, you can provide a fallback <code>default-notification-type</code> attribute in the configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;context:mbean-export/&gt;

&lt;int-jmx:notification-publishing-channel-adapter id="adapter"
    channel="channel"
    object-name="example.domain:name=publisher"
    default-notification-type="some.default.type"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-attribute-polling-channel-adapter"><a class="anchor" href="#jmx-attribute-polling-channel-adapter"></a>12.2.3. Attribute-polling Channel Adapter</h4>
<div class="paragraph">
<p>The attribute-polling channel adapter is useful when you need to periodically check on some value that is available through an MBean as a managed attribute.
You can configured the poller in the same way as any other polling adapter in Spring Integration (or you can rely on the default poller).
The <code>object-name</code> and the <code>attribute-name</code> are required.
An MBeanServer reference is also required.
However, by default, it automatically checks for a bean named <code>mbeanServer</code>, same as the notification-listening channel adapter <a href="#jmx-notification-listening-channel-adapter">described earlier</a>.
The following example shows how to configure an attribute-polling channel adapter with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:attribute-polling-channel-adapter id="adapter"
    channel="channel"
    object-name="example.domain:name=someService"
    attribute-name="InvocationCount"&gt;
        &lt;int:poller max-messages-per-poll="1" fixed-rate="5000"/&gt;
&lt;/int-jmx:attribute-polling-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tree-polling-channel-adapter"><a class="anchor" href="#tree-polling-channel-adapter"></a>12.2.4. Tree-polling Channel Adapter</h4>
<div class="paragraph">
<p>The tree-polling channel adapter queries the JMX MBean tree and sends a message with a payload that is the graph of objects that matches the query.
By default, the MBeans are mapped to primitives and simple objects, such as <code>Map</code>, <code>List</code>, and arrays.
Doing so permits simple transformation to (for example) JSON.
An MBeanServer reference is also required.
However, by default, it automatically checks for a bean named <code>mbeanServer</code>, same as the notification-listening channel adapter <a href="#jmx-notification-listening-channel-adapter">described earlier</a>.
The following example shows how to configure an tree-polling channel adapter with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:tree-polling-channel-adapter id="adapter"
    channel="channel"
    query-name="example.domain:type=*"&gt;
        &lt;int:poller max-messages-per-poll="1" fixed-rate="5000"/&gt;
&lt;/int-jmx:tree-polling-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example includes all of the attributes on the selected MBeans.
You can filter the attributes by providing an <code>MBeanObjectConverter</code> that has an appropriate filter configured.
You can provide the converter as a reference to a bean definition by using the <code>converter</code> attribute, or you can use an inner <code>&lt;bean/&gt;</code> definition.
Spring Integration provides a <code>DefaultMBeanObjectConverter</code> that can take a <code>MBeanAttributeFilter</code> in its constructor argument.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides two standard filters.
The <code>NamedFieldsMBeanAttributeFilter</code> lets you specify a list of attributes to include.
The <code>NotNamedFieldsMBeanAttributeFilter</code> lets you specify a list of attributes to exclude.
You can also implement your own filter.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-operation-invoking-channel-adapter"><a class="anchor" href="#jmx-operation-invoking-channel-adapter"></a>12.2.5. Operation-invoking Channel Adapter</h4>
<div class="paragraph">
<p>The operation-invoking channel adapter enables message-driven invocation of any managed operation exposed by an MBean.
Each invocation requires the operation name to be invoked and the object name of the target MBean.
Both of these must be explicitly provided by adapter configuration, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:operation-invoking-channel-adapter id="adapter"
    object-name="example.domain:name=TestBean"
    operation-name="ping"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Then the adapter only needs to be able to discover the <code>mbeanServer</code> bean.
If a different bean name is required, then provide the <code>mbean-server</code> attribute with a reference.</p>
</div>
<div class="paragraph">
<p>The payload of the message is mapped to the parameters of the operation, if any.
A <code>Map</code>-typed payload with <code>String</code> keys is treated as name/value pairs, whereas a <code>List</code> or array is passed as a simple argument list (with no explicit parameter names).
If the operation requires a single parameter value, the payload can represent that single value.
Also, if the operation requires no parameters, the payload would be ignored.</p>
</div>
<div class="paragraph">
<p>If you want to expose a channel for a single common operation to be invoked by messages that need not contain headers, that last option works well.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-operation-invoking-outbound-gateway"><a class="anchor" href="#jmx-operation-invoking-outbound-gateway"></a>12.2.6. Operation-invoking Outbound Gateway</h4>
<div class="paragraph">
<p>Similarly to the operation-invoking channel adapter, Spring Integration also provides an operation-invoking outbound gateway, which you can use when dealing with non-void operations when a return value is required.
The return value is sent as the message payload to the <code>reply-channel</code> specified by the gateway.
The following example shows how to configure an operation-invoking outbound gateway with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:operation-invoking-outbound-gateway request-channel="requestChannel"
   reply-channel="replyChannel"
   object-name="o.s.i.jmx.config:type=TestBean,name=testBeanGateway"
   operation-name="testWithReturn"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not provide the <code>reply-channel</code> attribute, the reply message is sent to the channel identified by the <code>IntegrationMessageHeaderAccessor.REPLY_CHANNEL</code> header.
That header is typically auto-created by the entry point into a message flow, such as any gateway component.
However, if the message flow was started by manually creating a Spring Integration message and sending it directly to a channel, you must specify the message header explicitly or use the <code>reply-channel</code> attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-mbean-exporter"><a class="anchor" href="#jmx-mbean-exporter"></a>12.2.7. MBean Exporter</h4>
<div class="paragraph">
<p>Spring Integration components may  themselvesbe exposed as MBeans when the <code>IntegrationMBeanExporter</code> is configured.
To create an instance of the <code>IntegrationMBeanExporter</code>, define a bean and provide a reference to an <code>MBeanServer</code> and a domain name (if desired).
You can leave out the domain, in which case the default domain is <code>org.springframework.integration</code>.
The following example shows how to declare an instance of an <code>IntegrationMBeanExporter</code> and an associated <code>MBeanServer</code> instance:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jmx:mbean-export id="integrationMBeanExporter"
            default-domain="my.company.domain" server="mbeanServer"/&gt;

&lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
    &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MBean exporter is orthogonal to the one provided in Spring core.
It registers message channels and message handlers but does not register itself.
You can expose the exporter itself (and certain other components in Spring Integration) by using the standard <code>&lt;context:mbean-export/&gt;</code> tag.
The exporter has some metrics attached to it&#8201;&#8212;&#8201;for instance, a count of the number of active handlers and the number of queued messages.</p>
</div>
<div class="paragraph">
<p>It also has a useful operation, as discussed in <a href="#jmx-mbean-shutdown">Orderly Shutdown Managed Operation</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Integration 4.0 introduced the <code>@EnableIntegrationMBeanExport</code> annotation to allow for convenient configuration of a default <code>integrationMbeanExporter</code> bean of type <code>IntegrationMBeanExporter</code> with several useful options at the <code>@Configuration</code> class level.
The following example shows how to configure this bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
@EnableIntegrationMBeanExport(server = "mbeanServer", managedComponents = "input")
public class ContextConfiguration {

	@Bean
	public MBeanServerFactoryBean mbeanServer() {
		return new MBeanServerFactoryBean();
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to provide more options or have several <code>IntegrationMBeanExporter</code> beans (such as
for different MBean Servers or to avoid conflicts with the standard Spring <code>MBeanExporter</code>&#8201;&#8212;&#8201;such as through
<code>@EnableMBeanExport</code>), you can configure an <code>IntegrationMBeanExporter</code> as a generic bean.</p>
</div>
<div class="sect4">
<h5 id="jmx-mbean-features"><a class="anchor" href="#jmx-mbean-features"></a>MBean Object Names</h5>
<div class="paragraph">
<p>All the <code>MessageChannel</code>, <code>MessageHandler</code>, and <code>MessageSource</code> instances in the application are wrapped by the MBean exporter to provide management and monitoring features.
The generated JMX object names for each component type are listed in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. MBean Object Names</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component Type</th>
<th class="tableblock halign-left valign-top">Object Name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MessageChannel</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `o.s.i:type=MessageChannel,name=&lt;channelName&gt;`</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MessageSource</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `o.s.i:type=MessageSource,name=&lt;channelName&gt;,bean=&lt;source&gt;`</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MessageHandler</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre> `o.s.i:type=MessageSource,name=&lt;channelName&gt;,bean=&lt;source&gt;`</pre></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>bean</code> attribute in the object names for sources and handlers takes one of the values in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. bean ObjectName Part</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean Value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">endpoint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The bean name of the enclosing endpoint (for example <code>&lt;service-activator&gt;</code>), if there is one</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">anonymous</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An indication that the enclosing endpoint did not have a user-specified bean name, so the JMX name is the input channel name.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">internal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For well known Spring Integration default components</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">handler/source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None of the above.
Fall back to the <code>toString()</code> method of the object being monitored (handler or source)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can append custom elements to the object name by providing a reference to a <code>Properties</code> object in the <code>object-name-static-properties</code> attribute.</p>
</div>
<div class="paragraph">
<p>Also, since Spring Integration 3.0, you can use a custom <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jmx/export/naming/ObjectNamingStrategy.html"><code>ObjectNamingStrategy</code></a> by setting the <code>object-naming-strategy</code> attribute.
Doing so permits greater control over the naming of the MBeans, such as grouping all integration MBeans under an 'Integration' type.
The following example shows one possible custom naming strategy implementation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Namer implements ObjectNamingStrategy {

	private final ObjectNamingStrategy realNamer = new KeyNamingStrategy();
	@Override
	public ObjectName getObjectName(Object managedBean, String beanKey) throws MalformedObjectNameException {
		String actualBeanKey = beanKey.replace("type=", "type=Integration,componentType=");
		return realNamer.getObjectName(managedBean, actualBeanKey);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>beanKey</code> argument is a <code>String</code> that contain the standard object name, beginning with the <code>default-domain</code> and including any additional static properties.
The preceding example moves the standard <code>type</code> part to <code>componentType</code> and sets the <code>type</code> to 'Integration', enabling selection of all Integration MBeans in one query:`"my.domain:type=Integration,*`.
Doing so also groups the beans under one tree entry under the domain in such tools as VisualVM.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default naming strategy is a <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jmx/export/naming/MetadataNamingStrategy.html"><code>MetadataNamingStrategy</code></a>.
The exporter propagates the <code>default-domain</code> to that object to let it generate a fallback object name if parsing of the bean key fails.
If your custom naming strategy is a <code>MetadataNamingStrategy</code> (or a subclass of it), the exporter does not propagate the <code>default-domain</code>.
You must configure it on your strategy bean.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1; any bean names (represented by the <code>name</code> key in the object name) will be quoted if they contain any characters that are not allowed in a Java identifier (or period <code>.</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="jmx-42-improvements"><a class="anchor" href="#jmx-42-improvements"></a>JMX Improvements</h5>
<div class="paragraph">
<p>Version 4.2 introduced some important improvements, representing a fairly major overhaul to the JMX support in the framework.
These resulted in a significant performance improvement of the JMX statistics collection and much more control thereof.
However, it has some implications for user code in a few specific (uncommon) situations.
These changes are detailed below, with a caution where necessary.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Metrics Capture</dt>
<dd>
<p>Previously, <code>MessageSource</code>, <code>MessageChannel</code>, and <code>MessageHandler</code> metrics were captured by wrapping the object in a JDK dynamic proxy to intercept appropriate method calls and capture the statistics.
The proxy was added when an integration MBean exporter was declared in the context.</p>
<div class="paragraph">
<p>Now, the statistics are captured by the beans themselves.
See <a href="#metrics-management">Metrics and Management</a> for more information.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This change means that you no longer automatically get an MBean or statistics for custom <code>MessageHandler</code> implementations, unless those custom handlers extend <code>AbstractMessageHandler</code>.
The simplest way to resolve this is to extend <code>AbstractMessageHandler</code>.
If you cannot do so, another work around is to implement the <code>MessageHandlerMetrics</code> interface.
For convenience, a <code>DefaultMessageHandlerMetrics</code> is provided to capture and report statistics.
You should invoke the <code>beforeHandle</code> and <code>afterHandle</code> at the appropriate times.
Your <code>MessageHandlerMetrics</code> methods can then delegate to this object to obtain each statistic.
Similarly, <code>MessageSource</code> implementations must extend <code>AbstractMessageSource</code> or implement <code>MessageSourceMetrics</code>.
Message sources capture only a count, so there is no provided convenience class.
You should maintain the count in an <code>AtomicLong</code> field.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The removal of the proxy has two additional benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stack traces in exceptions are reduced (when JMX is enabled) because the proxy is not on the stack</p>
</li>
<li>
<p>Cases where two MBeans were exported for the same bean now only export a single MBean with consolidated attributes and operations (see the MBean consolidation bullet, later).</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Resolution</dt>
<dd>
<p><code>System.nanoTime()</code> (rather than <code>System.currentTimeMillis()</code>) is now used to capture times .
This may provide more accuracy on some JVMs, espcially when you expect durations of less than one millisecond.</p>
</dd>
<dt class="hdlist1">Setting Initial Statistics Collection State</dt>
<dd>
<p>Previously, when JMX was enabled, all sources, channels, and handlers captured statistics.
You can now control whether the statistics are enabled on an individual component.
Further, you can capture simple counts on <code>MessageChannel</code> instances and <code>MessageHandler</code> instances instead of capturing the complete time-based statistics.
This can have significant performance implications, because you can selectively configure where you need detailed statistics and enable and disable collection at runtime.</p>
<div class="paragraph">
<p>See <a href="#metrics-management">Metrics and Management</a>.</p>
</div>
</dd>
<dt class="hdlist1">@IntegrationManagedResource</dt>
<dd>
<p>Similar to the <code>@ManagedResource</code> annotation, the <code>@IntegrationManagedResource</code> marks a class as being eligible to be exported as an MBean.
However, it is exported only if the application context has an <code>IntegrationMBeanExporter</code>.</p>
<div class="paragraph">
<p>Certain Spring Integration classes (in the <code>org.springframework.integration</code>) package) that were previously annotated with`@ManagedResource` are now annotated with both <code>@ManagedResource</code> and <code>@IntegrationManagedResource</code>.
This is for backwards compatibility (see the next item).
Such MBeans are exported by any context <code>MBeanServer</code> or by an <code>IntegrationMBeanExporter</code> (but not both&#8201;&#8212;&#8201;if both exporters are present, the bean is exported by the integration exporter if the bean matches a <code>managed-components</code> pattern).</p>
</div>
</dd>
<dt class="hdlist1">Consolidated MBeans</dt>
<dd>
<p>Certain classes within the framework (mapping routers, for example) have additional attributes and operations over and above those provided by metrics and <code>Lifecycle</code>.
We use a <code>Router</code> as an example here.</p>
<div class="paragraph">
<p>Previously, beans of these types were exported as two distinct MBeans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The metrics MBean (with an object name such as <code>intDomain:type=MessageHandler,name=myRouter,bean=endpoint</code>).
This MBean had metrics attributes and metrics/Lifecycle operations.</p>
</li>
<li>
<p>A second MBean (with an object name such as <code>ctxDomain:name=org.springframework.integration.config.</code> <code>RouterFactoryBean#0</code>,type=MethodInvokingRouter`) was exported with the channel mappings attribute and operations.</p>
<div class="paragraph">
<p>Now the attributes and operations are consolidated into a single MBean.
The object name depends on the exporter.
If exported by the integration MBean exporter, the object name is, for example: <code>intDomain:type=MessageHandler,name=myRouter,bean=endpoint</code>.
If exported by another exporter, the object name is, for example: <code>ctxDomain:name=org.springframework.integration.config.</code> <code>RouterFactoryBean#0,type=MethodInvokingRouter</code>.
There is no difference between these MBeans (aside from the object name), except that the statistics are not enabled (the attributes are <code>0</code>) by exporters other than the integration exporter.
You can enable statistics at runtime by using the JMX operations.
When exported by the integration MBean exporter, the initial state can be managed as described earlier.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If you currently use the second MBean to change, for example, channel mappings and you use the integration MBean exporter, note that the object name has changed because of the MBean consolidation.
There is no change if you are not using the integration MBean exporter.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">MBean Exporter Bean Name Patterns</dt>
<dd>
<p>Previously, the <code>managed-components</code> patterns were inclusive only.
If a bean name matched one of the patterns, it would be included.
Now, the pattern can be negated by prefixing it with <code>!</code>.
For example, <code>!thing*, things</code> matches all bean names that do not start with <code>thing</code> except <code>things</code>.
Patterns are evaluated left to right.
The first match (positive or negative) wins, and then no further patterns are applied.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The addition of this syntax to the pattern causes one possible (although perhaps unlikely) problem.
If you have a bean named <code>"!thing"</code> and you included a pattern of <code>!thing</code> in your MBean exporter&#8217;s <code>managed-components</code> patterns, it no longer matches; the pattern now matches all beans not named <code>thing</code>.
In this case, you can escape the <code>!</code> in the pattern with <code>\</code>.
The <code>\!thing</code> pattern matches a bean named <code>!thing</code>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">IntegrationMBeanExporter changes</dt>
<dd>
<p>The <code>IntegrationMBeanExporter</code> no longer implements <code>SmartLifecycle</code>.
This means that <code>start()</code> and <code>stop()</code> operations are no longer available to registerand unregister MBeans.
The MBeans are now registered during context initialization and unregistered when the context is destroyed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="jmx-mbean-shutdown"><a class="anchor" href="#jmx-mbean-shutdown"></a>Orderly Shutdown Managed Operation</h5>
<div class="paragraph">
<p>The MBean exporter provides a JMX operation to shut down the application in an orderly manner, intended for use before terminating the JVM.
The following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void stopActiveComponents(long howLong)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Its use and operation are described in <a href="#jmx-shutdown">Orderly Shutdown</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-history"><a class="anchor" href="#message-history"></a>12.3. Message History</h3>
<div class="paragraph">
<p>The key benefit of a messaging architecture is loose coupling such that participating components do not maintain any awareness about one another.
This fact alone makes an application extremely flexible, letting you change components without affecting the rest of the flow, change messaging routes, change message consuming styles (polling versus event driven), and so on.
However, this unassuming style of architecture could prove to be difficult when things go wrong.
When debugging, you probably want as much information (its origin, the channels it has traversed, and other details) about the message as you can get.</p>
</div>
<div class="paragraph">
<p>Message history is one of those patterns that helps by giving you an option to maintain some level of awareness of a message path either for debugging purposes or for maintaining an audit trail.
Spring integration provides a simple way to configure your message flows to maintain the message history by adding a header to the message and updating that header every time a message passes through a tracked component.</p>
</div>
<div class="sect3">
<h4 id="message-history-config"><a class="anchor" href="#message-history-config"></a>12.3.1. Message History Configuration</h4>
<div class="paragraph">
<p>To enable message history, you need only define the <code>message-history</code> element in your configuration, as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:message-history/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now every named component (component that has an 'id' defined) is tracked.
The framework sets the 'history' header in your message.
Its value a <code>List&lt;Properties&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following configuration example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gatewayid="sampleGateway"
    service-interface="org.springframework.integration.history.sample.SampleGateway"
    default-request-channel="bridgeInChannel"/&gt;

&lt;int:chainid="sampleChain"input-channel="chainChannel"output-channel="filterChannel"&gt;
  &lt;int:header-enricher&gt;
    &lt;int:headername="baz"value="baz"/&gt;
  &lt;/int:header-enricher&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration produces a simple message history structure, with output similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">[{name=sampleGateway, type=gateway, timestamp=1283281668091},
 {name=sampleChain, type=chain, timestamp=1283281668094}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get access to message history, you need only access the <code>MessageHistory</code> header.
The folloiwng example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Iterator&lt;Properties&gt; historyIterator =
    message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class).iterator();
assertTrue(historyIterator.hasNext());
Properties gatewayHistory = historyIterator.next();
assertEquals("sampleGateway", gatewayHistory.get("name"));
assertTrue(historyIterator.hasNext());
Properties chainHistory = historyIterator.next();
assertEquals("sampleChain", chainHistory.get("name"));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You might not want to track all of the components.
To limit the history to certain components based on their names, you can provide the <code>tracked-components</code> attribute and specify a comma-delimited list of component names and patterns that match the components you want to track.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:message-history tracked-components="*Gateway, sample*, aName"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, message history is maintained only for the components that end with 'Gateway', start with 'sample', or match the name, 'aName', exactly.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.0, you can also use the <code>@EnableMessageHistory</code> annotation in a <code>@Configuration</code> class.
In addition, the <code>MessageHistoryConfigurer</code> bean is now exposed as a JMX MBean by the <code>IntegrationMBeanExporter</code> (see <a href="#jmx-mbean-exporter">MBean Exporter</a>), letting you change the patterns at runtime.
Note, however, that the bean must be stopped (turning off message history) in order to change the patterns.
This feature might be useful to temporarily turn on history to analyze a system.
The MBean&#8217;s object name is <code>&lt;domain&gt;:name=messageHistoryConfigurer,type=MessageHistoryConfigurer</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If multiple beans (declared by <code>@EnableMessageHistory</code> and <code>&lt;message-history/&gt;</code>) exist, they must all have identical component name patterns (when trimmed and sorted).
Do not use a generic <code>&lt;bean/&gt;</code> definition for the <code>MessageHistoryConfigurer</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By definition, the message history header is immutable (you cannot re-write history).
Therefore, when writing message history values, the components either create new messages (when the component is an origin) or they copy the history from a request message, modifying it and setting the new list on a reply message.
In either case, the values can be appended even if the message itself is crossing thread boundaries.
That means that the history values can greatly simplify debugging in an asynchronous message flow.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-store"><a class="anchor" href="#message-store"></a>12.4. Message Store</h3>
<div class="paragraph">
<p>The <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a> (EIP) book identifies several patterns that have the ability to buffer messages.
For example, an aggregator buffers messages until they can be released, and a <code>QueueChannel</code> buffers messages until consumers explicitly receive those messages from that channel.
Because of the failures that can occur at any point within your message flow, EIP components that buffer messages also introduce a point where messages could be lost.</p>
</div>
<div class="paragraph">
<p>To mitigate the risk of losing messages, EIP defines the <a href="https://www.enterpriseintegrationpatterns.com/MessageStore.html">message store</a> pattern, which lets EIP components store messages, typically in some type of persistent store (such as an RDBMS).</p>
</div>
<div class="paragraph">
<p>Spring Integration provides support for the message store pattern by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Defining an <code>org.springframework.integration.store.MessageStore</code> strategy interface</p>
</li>
<li>
<p>Providing several implementations of this interface</p>
</li>
<li>
<p>Exposing a <code>message-store</code> attribute on all components that have the capability to buffer messages so that you can inject any instance that implements the <code>MessageStore</code> interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Details on how to configure a specific message store implementation and how to inject a <code>MessageStore</code> implementation into a specific buffering component are described throughout the manual (see the specific component, such as <a href="#channel-configuration-queuechannel">QueueChannel</a>, <a href="#aggregator">Aggregator</a>, <a href="#delayer">Delayer</a>, and others).
The following pair of examples show how to add a reference to a message store for a <code>QueueChannel</code> and for an aggregator:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. QueueChannel</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="myQueueChannel"&gt;
    &lt;int:queue message-store="refToMessageStore"/&gt;
&lt;int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 5. Aggregator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:aggregator  message-store="refToMessageStore"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, messages are stored in-memory by using <code>o.s.i.store.SimpleMessageStore</code>, an implementation of <code>MessageStore</code>.
That might be fine for development or simple low-volume environments where the potential loss of non-persistent messages is not a concern.
However, the typical production application needs a more robust option, not only to mitigate the risk of message loss but also to avoid potential out-of-memory errors.
Therefore, we also provide <code>MessageStore</code> implementations for a variety of data-stores.
The following is a complete list of supported implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-message-store">JDBC Message Store</a>: Uses an RDBMS to store messages</p>
</li>
<li>
<p><a href="#redis-message-store">Redis Message Store</a>: Uses a Redis key/value datastore to store messages</p>
</li>
<li>
<p><a href="#mongodb-message-store">MongoDB Message Store</a>: Uses a MongoDB document store to store messages</p>
</li>
<li>
<p><a href="#gemfire-message-store">Gemfire Message Store</a>: Uses a Gemfire distributed cache to store messages</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>However, be aware of some limitations while using persistent implementations of the <code>MessageStore</code>.</p>
</div>
<div class="paragraph">
<p>The Message data (payload and headers) is serialized and deserialized by using different serialization strategies, depending on the implementation of the <code>MessageStore</code>.
For example, when using <code>JdbcMessageStore</code>, only <code>Serializable</code> data is persisted by default.
In this case, non-Serializable headers are removed before serialization occurs.
Also, be aware of the protocol-specific headers that are injected by transport adapters (such as FTP, HTTP, JMS, and others).
For example, <code>&lt;http:inbound-channel-adapter/&gt;</code> maps HTTP headers into message headers, and one of them is an <code>ArrayList</code> of non-serializable <code>org.springframework.http.MediaType</code> instances.
However, you can inject your own implementation of the <code>Serializer</code> and <code>Deserializer</code> strategy interfaces into some <code>MessageStore</code> implementations (such as <code>JdbcMessageStore</code>) to change the behavior of serialization and deserialization.</p>
</div>
<div class="paragraph">
<p>Pay special attention to the headers that represent certain types of data.
For example, if one of the headers contains an instance of some Spring bean, upon deserialization, you may end up with a different instance of that bean, which directly affects some of the implicit headers created by the framework (such as <code>REPLY_CHANNEL</code> or <code>ERROR_CHANNEL</code>).
Currently, they are not serializable, but, even if they were, the deserialized channel would not represent the expected instance.</p>
</div>
<div class="paragraph">
<p>Beginning with Spring Integration version 3.0, you can resolve this issue with a header enricher configured to replace these headers with a name after registering the channel with the <code>HeaderChannelRegistry</code>.</p>
</div>
<div class="paragraph">
<p>Also, consider what happens when you configure a message-flow as follows: gateway &#8594; queue-channel (backed by a persistent Message Store) &#8594; service-activator.
That gateway creates a temporary reply channel, which is lost by the time the service-activator&#8217;s poller reads from the queue.
Again, you can use the header enricher to replace the headers with a <code>String</code> representation.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#header-enricher">Header Enricher</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Integration 4.0 introduced two new interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ChannelMessageStore</code>: To implement operations specific for <code>QueueChannel</code> instances</p>
</li>
<li>
<p><code>PriorityCapableChannelMessageStore</code>: To mark <code>MessageStore</code> implementations to be used for <code>PriorityChannel</code> instances and to provide priority order for persisted messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The real behavior depends on the implementation.
The framework provides the following implementations, which can be used as a persistent <code>MessageStore</code> for <code>QueueChannel</code> and <code>PriorityChannel</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#redis-cms">Redis Channel Message Stores</a></p>
</li>
<li>
<p><a href="#mongodb-priority-channel-message-store">MongoDB Channel Message Store</a></p>
</li>
<li>
<p><a href="#jdbc-message-store-channels">Backing Message Channels</a></p>
</li>
</ul>
</div>
<div id="sms-caution" class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Caution about <code>SimpleMessageStore</code></div>
<div class="paragraph">
<p>Starting with version 4.1, the <code>SimpleMessageStore</code> no longer copies the message group when calling <code>getMessageGroup()</code>.
For large message groups, this was a significant performance problem.
4.0.1 introduced a boolean <code>copyOnGet</code> property that lets you control this behavior.
When used internally by the aggregator, this property was set to <code>false</code> to improve performance.
It is now <code>false</code> by default.</p>
</div>
<div class="paragraph">
<p>Users accessing the group store outside of components such as aggregators now get a direct reference to the group being used by the aggregator instead of a copy.
Manipulation of the group outside of the aggregator may cause unpredictable results.</p>
</div>
<div class="paragraph">
<p>For this reason, you should either not perform such manipulation or set the <code>copyOnGet</code> property to <code>true</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="message-group-factory"><a class="anchor" href="#message-group-factory"></a>12.4.1. Using <code>MessageGroupFactory</code></h4>
<div class="paragraph">
<p>Starting with version 4.3, some <code>MessageGroupStore</code> implementations can be injected with a custom
<code>MessageGroupFactory</code> strategy to create and customize the <code>MessageGroup</code> instances used by the <code>MessageGroupStore</code>.
This defaults to a <code>SimpleMessageGroupFactory</code>, which produces <code>SimpleMessageGroup</code> instances based on the <code>GroupType.HASH_SET</code>
(<code>LinkedHashSet</code>) internal collection.
Other possible options are <code>SYNCHRONISED_SET</code> and <code>BLOCKING_QUEUE</code>, where the last one can be used to reinstate the
previous <code>SimpleMessageGroup</code> behavior.
Also the <code>PERSISTENT</code> option is available.
See the next section for more information.
Starting with version 5.0.1, the <code>LIST</code> option is also available for when the order and uniqueness of messages in the group does not matter.</p>
</div>
</div>
<div class="sect3">
<h4 id="lazy-load-message-group"><a class="anchor" href="#lazy-load-message-group"></a>12.4.2. Persistent <code>MessageGroupStore</code> and Lazy-load</h4>
<div class="paragraph">
<p>Starting with version 4.3, all persistent <code>MessageGroupStore</code> instances retrieve <code>MessageGroup</code> instances and their <code>messages</code>
from the store in the lazy-load manner.
In most cases, it is useful for the correlation <code>MessageHandler</code> instances (see <a href="#aggregator">Aggregator</a> and <a href="#resequencer">Resequencer</a>),
when it would add overhead to load entire the <code>MessageGroup</code> from the store on each correlation operation.</p>
</div>
<div class="paragraph">
<p>You can use the <code>AbstractMessageGroupStore.setLazyLoadMessageGroups(false)</code> option to switch off the lazy-load behavior from the configuration.</p>
</div>
<div class="paragraph">
<p>Our performance tests for lazy-load on MongoDB <code>MessageStore</code> (<a href="#mongodb-message-store">MongoDB Message Store</a>) and
<code>&lt;aggregator&gt;</code> (<a href="#aggregator">Aggregator</a>)
use a custom <code>release-strategy</code> similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:aggregator input-channel="inputChannel"
                output-channel="outputChannel"
                message-store="mongoStore"
                release-strategy-expression="size() == 1000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It produces results similar to the following for 1000 simple messages:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>...
StopWatch 'Lazy-Load Performance': running time (millis) = 38918
-----------------------------------------
ms     %     Task name
-----------------------------------------
02652  007%  Lazy-Load
36266  093%  Eager
...</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="metadata-store"><a class="anchor" href="#metadata-store"></a>12.5. Metadata Store</h3>
<div class="paragraph">
<p>Many external systems, services, or resources are not transactional (Twitter, RSS, file systems, and so on), and there is no any ability to mark the data as read.
Also, sometimes, you may need to implement the Enterprise Integration Pattern <a href="https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html">idempotent receiver</a> in some integration solutions.
To achieve this goal and store some previous state of the endpoint before the next interaction with external system or to deal with the next message, Spring Integration provides the metadata store component as an an implementation of the <code>org.springframework.integration.metadata.MetadataStore</code> interface with a general key-value contract.</p>
</div>
<div class="paragraph">
<p>The metadata store is designed to store various types of generic metadata (for example, the published date of the last feed entry that has been processed) to help components such as the feed adapter deal with duplicates.
If a component is not directly provided with a reference to a <code>MetadataStore</code>, the algorithm for locating a metadata store is as follows: First, look for a bean with a <code>metadataStore</code> ID in the application context.
If one is found, use it.
Otherwise, create a new instance of <code>SimpleMetadataStore</code>, which is an in-memory implementation that persists only metadata within the lifecycle of the currently running application context.
This means that, upon restart, you may end up with duplicate entries.</p>
</div>
<div class="paragraph">
<p>If you need to persist metadata between application context restarts, the framework provides the following persistent <code>MetadataStores</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PropertiesPersistingMetadataStore</code></p>
</li>
<li>
<p><a href="#gemfire-metadata-store">Gemfire Metadata Store</a></p>
</li>
<li>
<p><a href="#jdbc-metadata-store">JDBC Metadata Store</a></p>
</li>
<li>
<p><a href="#mongodb-metadata-store">MongoDB Metadata Store</a></p>
</li>
<li>
<p><a href="#redis-metadata-store">Redis Metadata Store</a></p>
</li>
<li>
<p><a href="#zk-metadata-store">Zookeeper Metadata Store</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>PropertiesPersistingMetadataStore</code> is backed by a properties file and a <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/PropertiesPersister.html"><code>PropertiesPersister</code></a>.</p>
</div>
<div class="paragraph">
<p>By default, it persists only the state when the application context is closed normally.
It implements <code>Flushable</code> so that you can persist the state at will, by invoking <code>flush()</code>.
The following example shows how to configure a 'PropertiesPersistingMetadataStore' with XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="metadataStore"
    class="org.springframework.integration.metadata.PropertiesPersistingMetadataStore"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can provide your own implementation of the <code>MetadataStore</code> interface (for example,
<code>JdbcMetadataStore</code>) and configure it as a bean in the application context.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.0, <code>SimpleMetadataStore</code>, <code>PropertiesPersistingMetadataStore</code>, and <code>RedisMetadataStore</code> implement <code>ConcurrentMetadataStore</code>.
These provide for atomic updates and can be used across multiple component or application instances.</p>
</div>
<div class="sect3">
<h4 id="idempotent-receiver-pattern"><a class="anchor" href="#idempotent-receiver-pattern"></a>12.5.1. Idempotent Receiver and Metadata Store</h4>
<div class="paragraph">
<p>The metadata store is useful for implementing the EIP <a href="https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html">idempotent receiver</a> pattern when there is need to filter an incoming message if it has already been processed and you can discard it or perform some other logic on discarding.
The following configuration shows an example of how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:filter input-channel="serviceChannel"
			output-channel="idempotentServiceChannel"
			discard-channel="discardChannel"
			expression="@metadataStore.get(headers.businessKey) == null"/&gt;

&lt;int:publish-subscribe-channel id="idempotentServiceChannel"/&gt;

&lt;int:outbound-channel-adapter channel="idempotentServiceChannel"
                              expression="@metadataStore.put(headers.businessKey, '')"/&gt;

&lt;int:service-activator input-channel="idempotentServiceChannel" ref="service"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>value</code> of the idempotent entry may be an expiration date, after which that entry should be removed from metadata store by some scheduled reaper.</p>
</div>
<div class="paragraph">
<p>See also <a href="#idempotent-receiver">Idempotent Receiver Enterprise Integration Pattern</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="metadatastore-listener"><a class="anchor" href="#metadatastore-listener"></a>12.5.2. <code>MetadataStoreListener</code></h4>
<div class="paragraph">
<p>Some metadata stores (currently only zookeeper) support registering a listener to receive events when items change, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MetadataStoreListener {

	void onAdd(String key, String value);

	void onRemove(String key, String oldValue);

	void onUpdate(String key, String newValue);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/metadata/MetadataStoreListenerAdapter.html">Javadoc</a> for more information.
The <code>MetadataStoreListenerAdapter</code> can be subclassed if you are interested only in a subset of events.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="control-bus"><a class="anchor" href="#control-bus"></a>12.6. Control Bus</h3>
<div class="paragraph">
<p>As described in the <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a> (EIP) book, the idea behind the control bus is that the same messaging system can be used for monitoring and managing the components within the framework as is used for &#8220;application-level&#8221; messaging.
In Spring Integration, we build upon the adapters described above so that you can send messages as a means of invoking exposed operations.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a control bus with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:control-bus input-channel="operationChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The control bus has an input channel that can be accessed for invoking operations on the beans in the application context.
It also has all the common properties of a service activating endpoint.
For example, you can specify an output channel if the result of the operation has a return value that you want to send on to a downstream channel.</p>
</div>
<div class="paragraph">
<p>The control bus runs messages on the input channel as Spring Expression Language (SpEL) expressions.
It takes a message, compiles the body to an expression, adds some context, and then runs it.
The default context supports any method that has been annotated with <code>@ManagedAttribute</code> or <code>@ManagedOperation</code>.
It also supports the methods on Spring&#8217;s <code>Lifecycle</code> interface, and it supports methods that are used to configure several of Spring&#8217;s <code>TaskExecutor</code> and <code>TaskScheduler</code> implementations.
The simplest way to ensure that your own methods are available to the control bus is to use the <code>@ManagedAttribute</code> or <code>@ManagedOperation</code> annotations.
Since those annotations are also used for exposing methods to a JMX MBean registry, they offer a convenient by-product: Often, the same types of operations you want to expose to the control bus are reasonable for exposing through JMX).
Resolution of any particular instance within the application context is achieved in the typical SpEL syntax.
To do so, provide the bean name with the SpEL prefix for beans (<code>@</code>).
For example, to execute a method on a Spring Bean, a client could send a message to the operation channel as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message operation = MessageBuilder.withPayload("@myServiceBean.shutdown()").build();
operationChannel.send(operation)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The root of the context for the expression is the <code>Message</code> itself, so you also have access to the <code>payload</code> and <code>headers</code> as variables within your expression.
This is consistent with all the other expression support in Spring Integration endpoints.</p>
</div>
<div class="paragraph">
<p>With Java annotations, you can configured the control bus as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "operationChannel")
public ExpressionControlBusFactoryBean controlBus() {
    return new ExpressionControlBusFactoryBean();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can configure Java DSL flow definitions as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow controlBusFlow() {
    return IntegrationFlows.from("controlBus")
              .controlBus()
              .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you prefer to use lambdas with automatic <code>DirectChannel</code> creation, you can create a control bus as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow controlBus() {
    return IntegrationFlowDefinition::controlBus;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, the channel is named <code>controlBus.input</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jmx-shutdown"><a class="anchor" href="#jmx-shutdown"></a>12.7. Orderly Shutdown</h3>
<div class="paragraph">
<p>As described in "<a href="#jmx-mbean-exporter">MBean Exporter</a>", the MBean exporter provides a JMX operation called <code>stopActiveComponents</code>, which is used to stop the application in an orderly manner.
The operation has a single <code>Long</code> parameter.
The parameter indicates how long (in milliseconds) the operation waits to allow in-flight messages to complete.
The operation works as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Call <code>beforeShutdown()</code> on all beans that implement <code>OrderlyShutdownCapable</code>.</p>
<div class="paragraph">
<p>Doing so lets such components prepare for shutdown.
Examples of components that implement this interface and what they do with this call include JMS and AMQP message-driven adapters that stop their listener containers, TCP server connection factories that stop accepting new connections (while keeping existing connections open), TCP inbound endpoints that drop (log) any new messages received, and HTTP inbound endpoints that return <code>503 - Service Unavailable</code> for any new requests.</p>
</div>
</li>
<li>
<p>Stop any active channels, such as JMS- or AMQP-backed channels.</p>
</li>
<li>
<p>Stop all <code>MessageSource</code> instances.</p>
</li>
<li>
<p>Stop all inbound <code>MessageProducer</code> s (that are not <code>OrderlyShutdownCapable</code>).</p>
</li>
<li>
<p>Wait for any remaining time left, as defined by the value of the <code>Long</code> parameter passed in to the operation.</p>
<div class="paragraph">
<p>Doing so lets any in-flight messages complete their journeys.
It is therefore important to select an appropriate timeout when invoking this operation.</p>
</div>
</li>
<li>
<p>Call <code>afterShutdown()</code> on all <code>OrderlyShutdownCapable</code> components.</p>
<div class="paragraph">
<p>Doing so lets such components perform final shutdown tasks (closing all open sockets, for example).</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>As discussed in <a href="#jmx-mbean-shutdown">Orderly Shutdown Managed Operation</a>, this operation can be invoked by using JMX.
If you wish to programmatically invoke the method, you need to inject or otherwise get a reference to the <code>IntegrationMBeanExporter</code>.
If no <code>id</code> attribute is provided on the <code>&lt;int-jmx:mbean-export/&gt;</code> definition, the bean has a generated name.
This name contains a random component to avoid <code>ObjectName</code> collisions if multiple Spring Integration contexts exist in the same JVM (<code>MBeanServer</code>).</p>
</div>
<div class="paragraph">
<p>For this reason, if you wish to invoke the method programmatically, we recommend that you provide the exporter with an <code>id</code> attribute so that you can easily access it in the application context.</p>
</div>
<div class="paragraph">
<p>Finally, the operation can be invoked by using the <code>&lt;control-bus&gt;</code> element.
See the <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/monitoring">monitoring Spring Integration sample application</a> for details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The algorithm described earlier was improved in version 4.1.
Previously, all task executors and schedulers were stopped.
This could cause mid-flow messages in <code>QueueChannel</code> instances to remain.
Now the shutdown leaves pollers running, to let these messages be drained and processed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="integration-graph"><a class="anchor" href="#integration-graph"></a>12.8. Integration Graph</h3>
<div class="paragraph">
<p>Starting with version 4.3, Spring Integration provides access to an application&#8217;s runtime object model, which can, optionally, include component metrics.
It is exposed as a graph, which may be used to visualize the current state of the integration application.
The <code>o.s.i.support.management.graph</code> package contains all the required classes to collect, build, and render the runtime state of Spring Integration components as a single tree-like <code>Graph</code> object.
The <code>IntegrationGraphServer</code> should be declared as a bean to build, retrieve, and refresh the <code>Graph</code> object.
The resulting <code>Graph</code> object can be serialized to any format, although JSON is flexible and convenient to parse and represent on the client side.
A Spring Integration application with only the default components would expose a graph as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "contentDescriptor": {
    "providerVersion": "4.3.0.RELEASE",
    "providerFormatVersion": 1.0,
    "provider": "spring-integration",
    "name": "myApplication"
  },
  "nodes": [
    {
      "nodeId": 1,
      "name": "nullChannel",
      "stats": null,
      "componentType": "channel"
    },
    {
      "nodeId": 2,
      "name": "errorChannel",
      "stats": null,
      "componentType": "publish-subscribe-channel"
    },
    {
      "nodeId": 3,
      "name": "_org.springframework.integration.errorLogger",
      "stats": {
        "duration": {
          "count": 0,
          "min": 0.0,
          "max": 0.0,
          "mean": 0.0,
          "standardDeviation": 0.0,
          "countLong": 0
        },
        "errorCount": 0,
        "standardDeviationDuration": 0.0,
        "countsEnabled": true,
        "statsEnabled": true,
        "loggingEnabled": false,
        "handleCount": 0,
        "meanDuration": 0.0,
        "maxDuration": 0.0,
        "minDuration": 0.0,
        "activeCount": 0
      },
      "componentType": "logging-channel-adapter",
      "output": null,
      "input": "errorChannel"
    }
  ],
  "links": [
    {
      "from": 2,
      "to": 3,
      "type": "input"
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the graph consists of three top-level elements.</p>
</div>
<div class="paragraph">
<p>The <code>contentDescriptor</code> graph element contains general information about the application providing the data.
The <code>name</code> can be customized on the <code>IntegrationGraphServer</code> bean or in the <code>spring.application.name</code> application context environment property.
Other properties are provided by the framework and let you distinguish a similar model from other sources.</p>
</div>
<div class="paragraph">
<p>The <code>links</code> graph element represents connections between nodes from the <code>nodes</code> graph element and, therefore, between integration components in the source Spring Integration application.
For example, from a <code>MessageChannel</code> to an <code>EventDrivenConsumer</code> with some <code>MessageHandler</code>
or from an <code>AbstractReplyProducingMessageHandler</code> to a <code>MessageChannel</code>.
For convenience and to let you determine a link&#8217;s purpose, the model includes the <code>type</code> attribute.
The possible types are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>input</code>: Identifies the direction from <code>MessageChannel</code> to the endpoint, <code>inputChannel</code>, or <code>requestChannel</code> property</p>
</li>
<li>
<p><code>output</code>: The direction from the <code>MessageHandler</code>, <code>MessageProducer</code>, or <code>SourcePollingChannelAdapter</code> to the <code>MessageChannel</code> through an <code>outputChannel</code> or <code>replyChannel</code> property</p>
</li>
<li>
<p><code>error</code>: From <code>MessageHandler</code> on <code>PollingConsumer</code> or <code>MessageProducer</code> or <code>SourcePollingChannelAdapter</code> to the <code>MessageChannel</code> through an <code>errorChannel</code> property;</p>
</li>
<li>
<p><code>discard</code>: From <code>DiscardingMessageHandler</code> (such as <code>MessageFilter</code>) to the <code>MessageChannel</code> through an <code>errorChannel</code> property.</p>
</li>
<li>
<p><code>route</code>: From <code>AbstractMappingMessageRouter</code> (such as <code>HeaderValueRouter</code>) to the <code>MessageChannel</code>.
Similar to <code>output</code> but determined at run-time.
May be a configured channel mapping or a dynamically resolved channel.
Routers typically retain only up to 100 dynamic routes for this purpose, but you can modify this value by setting the <code>dynamicChannelLimit</code> property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The information from this element can be used by a visualization tool to render connections between nodes from the <code>nodes</code> graph element, where the <code>from</code> and <code>to</code> numbers represent the value from the <code>nodeId</code> property of the linked nodes.
For example, the <code>link</code> element can be used to determine the proper <code>port</code> on the target node.</p>
</div>
<div class="paragraph">
<p>The following &#8220;text image&#8221; shows the relationships between the types:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>              +---(discard)
              |
         +----o----+
         |         |
         |         |
         |         |
(input)--o         o---(output)
         |         |
         |         |
         |         |
         +----o----+
              |
              +---(error)</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>nodes</code> graph element is perhaps the most interesting, because its elements contain not only the runtime components with their <code>componentType</code> instances and <code>name</code> values but can also optionally contain metrics exposed by the component.
Node elements contain various properties that are generally self-explanatory.
For example, expression-based components include the <code>expression</code> property that contains the primary expression string for the component.
To enable the metrics, add an <code>@EnableIntegrationManagement</code> to a <code>@Configuration</code> class or add an <code>&lt;int:management/&gt;</code> element to your XML configuration.
You can control exactly which components in the framework collect statistics.
See  <a href="#metrics-management">Metrics and Management</a> for complete information.
See the <code>stats</code> attribute from the <code>o.s.i.errorLogger</code> component in the JSON example shown earlier.
In this case, The <code>nullChannel</code> and <code>errorChannel</code> do not provide statistics information, because the configuration for this example was as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
@EnableIntegrationManagement(statsEnabled = "_org.springframework.integration.errorLogger.handler",
      countsEnabled = "!*",
      defaultLoggingEnabled = "false")
public class ManagementConfiguration {

    @Bean
    public IntegrationGraphServer integrationGraphServer() {
        return new IntegrationGraphServer();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>nodeId</code> represents a unique incremental identifier to let you distinguish one component from another.
It is also used in the <code>links</code> element to represent a relationship (connection) of this component to others, if any.
The <code>input</code> and <code>output</code> attributes are for the <code>inputChannel</code> and <code>outputChannel</code> properties of the <code>AbstractEndpoint</code>, <code>MessageHandler</code>, <code>SourcePollingChannelAdapter</code>, or <code>MessageProducerSupport</code>.
See the next section for more information.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>IntegrationGraphServer</code> accepts a <code>Function&lt;NamedComponent, Map&lt;String, Object&gt;&gt; additionalPropertiesCallback</code> for population of additional properties on the <code>IntegrationNode</code> for a particular <code>NamedComponent</code>.
For example you can expose the <code>SmartLifecycle</code> <code>autoStartup</code> and <code>running</code> properties into the target graph:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">server.setAdditionalPropertiesCallback(namedComponent -&gt; {
            Map&lt;String, Object&gt; properties = null;
            if (namedComponent instanceof SmartLifecycle) {
                SmartLifecycle smartLifecycle = (SmartLifecycle) namedComponent;
                properties = new HashMap&lt;&gt;();
                properties.put("auto-startup", smartLifecycle.isAutoStartup());
                properties.put("running", smartLifecycle.isRunning());
            }
            return properties;
        });</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="graph-runtime-model"><a class="anchor" href="#graph-runtime-model"></a>12.8.1. Graph Runtime Model</h4>
<div class="paragraph">
<p>Spring Integration components have various levels of complexity.
For example, any polled <code>MessageSource</code> also has a <code>SourcePollingChannelAdapter</code> and a <code>MessageChannel</code> to which to periodically send messages from the source data.
Other components might be middleware request-reply components (such as <code>JmsOutboundGateway</code>) with a consuming <code>AbstractEndpoint</code> to subscribe to (or poll) the <code>requestChannel</code> (<code>input</code>) for messages, and a <code>replyChannel</code> (<code>output</code>) to produce a reply message to send downstream.
Meanwhile, any <code>MessageProducerSupport</code> implementation (such as <code>ApplicationEventListeningMessageProducer</code>) wraps some source protocol listening logic and sends messages to the <code>outputChannel</code>.</p>
</div>
<div class="paragraph">
<p>Within the graph, Spring Integration components are represented by using the <code>IntegrationNode</code> class hierarchy, which you can find in the <code>o.s.i.support.management.graph</code> package.
For example, you can use the <code>ErrorCapableDiscardingMessageHandlerNode</code> for the <code>AggregatingMessageHandler</code> (because it has a <code>discardChannel</code> option) and can produce errors when consuming from a <code>PollableChannel</code> by using a <code>PollingConsumer</code>.
Another example is <code>CompositeMessageHandlerNode</code>&#8201;&#8212;&#8201;for a <code>MessageHandlerChain</code> when subscribed to a <code>SubscribableChannel</code> by using an <code>EventDrivenConsumer</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>@MessagingGateway</code> (see <a href="#gateway">Messaging Gateways</a>) provides nodes for each of its method, where the <code>name</code> attribute is based on the gateway&#8217;s bean name and the short method signature.
Consider the following example of a gateway:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway(defaultRequestChannel = "four")
public interface Gate {

	void foo(String foo);

	void foo(Integer foo);

	void bar(String bar);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding gateway produces nodes similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "nodeId" : 10,
  "name" : "gate.bar(class java.lang.String)",
  "stats" : null,
  "componentType" : "gateway",
  "output" : "four",
  "errors" : null
},
{
  "nodeId" : 11,
  "name" : "gate.foo(class java.lang.String)",
  "stats" : null,
  "componentType" : "gateway",
  "output" : "four",
  "errors" : null
},
{
  "nodeId" : 12,
  "name" : "gate.foo(class java.lang.Integer)",
  "stats" : null,
  "componentType" : "gateway",
  "output" : "four",
  "errors" : null
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use this  <code>IntegrationNode</code> hierarchy for parsing the graph model on the client side as well as to understand the general Spring Integration runtime behavior.
See also <a href="#programming-tips">Programming Tips and Tricks</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-graph-controller"><a class="anchor" href="#integration-graph-controller"></a>12.9. Integration Graph Controller</h3>
<div class="paragraph">
<p>If your application is web-based (or built on top of Spring Boot with an embedded web container) and the Spring Integration HTTP or WebFlux module (see <a href="#http">HTTP Support</a> and <a href="#webflux">WebFlux Support</a>, respectively) is present on the classpath, you can use a <code>IntegrationGraphController</code> to expose the <code>IntegrationGraphServer</code> functionality as a REST service.
For this purpose, the <code>@EnableIntegrationGraphController</code> and <code>@Configuration</code> class annotations and the <code>&lt;int-http:graph-controller/&gt;</code> XML element are available in the HTTP module.
Together with the <code>@EnableWebMvc</code> annotation (or <code>&lt;mvc:annotation-driven/&gt;</code> for XML definitions), this configuration registers an <code>IntegrationGraphController</code> <code>@RestController</code> where its <code>@RequestMapping.path</code> can be configured on the <code>@EnableIntegrationGraphController</code> annotation or <code>&lt;int-http:graph-controller/&gt;</code> element.
The default path is <code>/integration</code>.</p>
</div>
<div class="paragraph">
<p>The <code>IntegrationGraphController</code> <code>@RestController</code> provides the following services:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping(name = "getGraph")</code>: To retrieve the state of the Spring Integration components since the last <code>IntegrationGraphServer</code> refresh.
The <code>o.s.i.support.management.graph.Graph</code> is returned as a <code>@ResponseBody</code> of the REST service.</p>
</li>
<li>
<p><code>@GetMapping(path = "/refresh", name = "refreshGraph")</code>: To refresh the current <code>Graph</code> for the actual runtime state and return it as a REST response.
It is not necessary to refresh the graph for metrics.
They are provided in real-time when the graph is retrieved.
Refresh can be called if the application context has been modified since the graph was last retrieved.
In that case, the graph is completely rebuilt.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can set security and cross-origin restrictions for the <code>IntegrationGraphController</code> with the standard configuration options and components provided by the Spring Security and Spring MVC projects.
The following example achieves those goals:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mvc:annotation-driven /&gt;

&lt;mvc:cors&gt;
	&lt;mvc:mapping path="/myIntegration/**"
				 allowed-origins="http://localhost:9090"
				 allowed-methods="GET" /&gt;
&lt;/mvc:cors&gt;

&lt;security:http&gt;
    &lt;security:intercept-url pattern="/myIntegration/**" access="ROLE_ADMIN" /&gt;
&lt;/security:http&gt;


&lt;int-http:graph-controller path="/myIntegration" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to do the same thing with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebMvc // or @EnableWebFlux
@EnableWebSecurity // or @EnableWebFluxSecurity
@EnableIntegration
@EnableIntegrationGraphController(path = "/testIntegration", allowedOrigins="http://localhost:9090")
public class IntegrationConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
	    http
            .authorizeRequests()
               .antMatchers("/testIntegration/**").hasRole("ADMIN")
            // ...
            .formLogin();
    }

    //...

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that, for convenience, the <code>@EnableIntegrationGraphController</code> annotation provides an <code>allowedOrigins</code> attribute.
This provides <code>GET</code> access to the <code>path</code>.
For more sophistication, you can configure the CORS mappings by using standard Spring MVC mechanisms.</p>
</div>
</div>
</div>
</div>
<h1 id="spring-integration-endpoints" class="sect0"><a class="anchor" href="#spring-integration-endpoints"></a>Integration Endpoints</h1>
<div class="openblock partintro">
<div class="content">
<div id="spring-integration-adapters" class="paragraph">
<p>This section covers the various channel adapters and messaging gateways provided by Spring Integration to support message-based communication with external systems.</p>
</div>
<div class="paragraph">
<p>Each system, from AMQP to Zookeeper, has its own integration requirements, and this section covers them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="endpoint-summary"><a class="anchor" href="#endpoint-summary"></a>13. Endpoint Quick Reference Table</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As discussed in the earlier sections, Spring Integration provides a number of endpoints used to interface with external systems, file systems, and others.</p>
</div>
<div class="paragraph">
<p>For transparent dependency management Spring Integration provides a bill-of-materials POM to be imported into the Maven configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
            &lt;artifactId&gt;spring-integration-bom&lt;/artifactId&gt;
            &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To recap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inbound channel adapters are used for one-way integration to bring data into the messaging application.</p>
</li>
<li>
<p>Outbound channel adapters are used for one-way integration to send data out of the messaging application.</p>
</li>
<li>
<p>Inbound gateways are used for a bidirectional integration flow, where some other system invokes the messaging application and receives a reply.</p>
</li>
<li>
<p>Outbound Gateways are used for a bidirectional integration flow, where the messaging application invokes some external service or entity and expects a result.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following table summarizes the various endpoints with quick links to the appropriate chapter.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Endpoint Quick Reference</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Module</th>
<th class="tableblock halign-left valign-top">Inbound Adapter</th>
<th class="tableblock halign-left valign-top">Outbound Adapter</th>
<th class="tableblock halign-left valign-top">Inbound Gateway</th>
<th class="tableblock halign-left valign-top">Outbound Gateway</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>AMQP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#amqp-inbound-channel-adapter">Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#amqp-outbound-channel-adapter">Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#amqp-inbound-gateway">Inbound Gateway</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#amqp-outbound-gateway">Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Events</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#appevent-inbound">Receiving Spring Application Events</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#appevent-outbound">Sending Spring Application Events</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Feed</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#feed-inbound-channel-adapter">Feed Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>File</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#file-reading">Reading Files</a> and <a href="#file-tailing">'tail&#8217;ing Files</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#file-writing">Writing files</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#file-writing">Writing files</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FTP(S)</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#ftp-inbound">FTP Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#ftp-outbound">FTP Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#ftp-outbound-gateway">FTP Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Gemfire</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#gemfire-inbound">Inbound Channel Adapter</a> and <a href="#gemfire-cq">Continuous Query Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#gemfire-outbound">Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>HTTP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#http-namespace">HTTP Namespace Support</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#http-namespace">HTTP Namespace Support</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#http-inbound">Http Inbound Components</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#http-outbound">HTTP Outbound Components</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>JDBC</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jdbc-inbound-channel-adapter">Inbound Channel Adapter</a> and <a href="#stored-procedure-inbound-channel-adapter">Stored Procedure Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a> and <a href="#stored-procedure-outbound-channel-adapter">Stored Procedure Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jdbc-outbound-gateway">Outbound Gateway</a> and <a href="#stored-procedure-outbound-gateway">Stored Procedure Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>JMS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jms-inbound-channel-adapter">Inbound Channel Adapter</a> and <a href="#jms-message-driven-channel-adapter">Message-driven Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jms-outbound-channel-adapter">Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jms-inbound-gateway">Inbound Gateway</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jms-outbound-gateway">Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>JMX</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jmx-notification-listening-channel-adapter">Notification-listening Channel Adapter</a> and <a href="#jmx-attribute-polling-channel-adapter">Attribute-polling Channel Adapter</a> and <a href="#tree-polling-channel-adapter">Tree-polling Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jmx-notification-publishing-channel-adapter">Notification-publishing Channel Adapter</a> and <a href="#jmx-operation-invoking-channel-adapter">Operation-invoking Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jmx-operation-invoking-outbound-gateway">Operation-invoking Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>JPA</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jpa-inbound-channel-adapter">Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jpa-outbound-channel-adapter">Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#jpa-updating-outbound-gateway">Updating Outbound Gateway</a> and <a href="#jpa-retrieving-outbound-gateway">Retrieving Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Mail</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mail-inbound">Mail-receiving Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mail-outbound">Mail-sending Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MongoDB</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mongodb-inbound-channel-adapter">MongoDB Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mongodb-outbound-channel-adapter">MongoDB Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MQTT</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mqtt-inbound">Inbound (Message-driven) Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mqtt-outbound">Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Redis</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis-inbound-channel-adapter">Redis Inbound Channel Adapter</a> and <a href="#redis-queue-inbound-channel-adapter">Redis Queue Inbound Channel Adapter</a> and <a href="#redis-store-inbound-channel-adapter">Redis Store Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis-outbound-channel-adapter">Redis Outbound Channel Adapter</a> and <a href="#redis-queue-outbound-channel-adapter">Redis Queue Outbound Channel Adapter</a> and <a href="#redis-store-outbound-channel-adapter">RedisStore Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis-queue-inbound-gateway">Redis Queue Inbound Gateway</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis-outbound-gateway">Redis Outbound Command Gateway</a> and <a href="#redis-queue-outbound-gateway">Redis Queue Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Resource</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resource-inbound-channel-adapter">Resource Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>RMI</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#rmi-inbound">Inbound RMI</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#rmi-outbound">Outbound RMI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>SFTP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sftp-inbound">SFTP Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sftp-outbound">SFTP Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>STOMP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#stomp-inbound-adapter">STOMP Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#stomp-outbound-adapter">STOMP Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Stream</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#stream-reading">Reading from Streams</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#stream-writing">Writing to Streams</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Syslog</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syslog-inbound-adapter">Syslog Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>TCP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tcp-adapters">TCP Adapters</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tcp-adapters">TCP Adapters</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tcp-gateways">TCP Gateways</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tcp-gateways">TCP Gateways</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>UDP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#udp-adapters">UDP Adapters</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#udp-adapters">UDP Adapters</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Web Services</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#webservices-inbound">Inbound Web Service Gateways</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#webservices-outbound">Outbound Web Service Gateways</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Web Sockets</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#web-socket-inbound-adapter">WebSocket Inbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#web-socket-outbound-adapter">WebSocket Outbound Channel Adapter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>XMPP</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#xmpp-messages">XMPP Messages</a> and <a href="#xmpp-presence">XMPP Presence</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#xmpp-messages">XMPP Messages</a> and <a href="#xmpp-presence">XMPP Presence</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition, as discussed in <a href="#spring-integration-core-messaging">Core Messaging</a>, Spring Integration provides endpoints for interfacing with Plain Old Java Objects (POJOs).
As discussed in <a href="#channel-adapter">Channel Adapter</a>, the <code>&lt;int:inbound-channel-adapter&gt;</code> element lets you poll a Java method for data.
The <code>&lt;int:outbound-channel-adapter&gt;</code> element lets you send data to a <code>void</code> method.
As discussed in <a href="#gateway">Messaging Gateways</a>, the <code>&lt;int:gateway&gt;</code> element lets any Java program invoke a messaging flow.
Each of these works without requiring any source-level dependencies on Spring Integration.
The equivalent of an outbound gateway in this context is using a service activator (see <a href="#service-activator">Service Activator</a>) to invoke a method that returns an <code>Object</code> of some kind.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="amqp"><a class="anchor" href="#amqp"></a>14. AMQP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for receiving and sending messages by using the Advanced Message Queuing Protocol (AMQP).</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-amqp&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-amqp:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following adapters are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#amqp-inbound-channel-adapter">Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#amqp-inbound-gateway">Inbound Gateway</a></p>
</li>
<li>
<p><a href="#amqp-outbound-channel-adapter">Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#amqp-outbound-gateway">Outbound Gateway</a></p>
</li>
<li>
<p><a href="#amqp-async-outbound-gateway">Async Outbound Gateway</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Integration also provides a point-to-point message channel and a publish-subscribe message channel backed by AMQP Exchanges and Queues.</p>
</div>
<div class="paragraph">
<p>To provide AMQP support, Spring Integration relies on (<a href="https://projects.spring.io/spring-amqp">Spring AMQP</a>), which applies core Spring concepts to the development of AMQP-based messaging solutions.
Spring AMQP provides similar semantics to (<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jms.html">Spring JMS</a>).</p>
</div>
<div class="paragraph">
<p>Whereas the provided AMQP Channel Adapters are intended for unidirectional messaging (send or receive) only, Spring Integration also provides inbound and outbound AMQP gateways for request-reply operations.</p>
</div>
<div class="paragraph">
<p>TIP:
You should familiarize yourself with the <a href="https://docs.spring.io/spring-amqp/reference/html/">reference documentation of the Spring AMQP project</a>.
It provides much more in-depth information about Spring&#8217;s integration with AMQP in general and RabbitMQ in particular.</p>
</div>
<div class="sect2">
<h3 id="amqp-inbound-channel-adapter"><a class="anchor" href="#amqp-inbound-channel-adapter"></a>14.1. Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The following listing shows the possible configuration options for an AMQP Inbound Channel Adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:inbound-channel-adapter
                                  id="inboundAmqp"                <i class="conum" data-value="1"></i><b>(1)</b>
                                  channel="inboundChannel"        <i class="conum" data-value="2"></i><b>(2)</b>
                                  queue-names="si.test.queue"     <i class="conum" data-value="3"></i><b>(3)</b>
                                  acknowledge-mode="AUTO"         <i class="conum" data-value="4"></i><b>(4)</b>
                                  advice-chain=""                 <i class="conum" data-value="5"></i><b>(5)</b>
                                  channel-transacted=""           <i class="conum" data-value="6"></i><b>(6)</b>
                                  concurrent-consumers=""         <i class="conum" data-value="7"></i><b>(7)</b>
                                  connection-factory=""           <i class="conum" data-value="8"></i><b>(8)</b>
                                  error-channel=""                <i class="conum" data-value="9"></i><b>(9)</b>
                                  expose-listener-channel=""      <i class="conum" data-value="10"></i><b>(10)</b>
                                  header-mapper=""                <i class="conum" data-value="11"></i><b>(11)</b>
                                  mapped-request-headers=""       <i class="conum" data-value="12"></i><b>(12)</b>
                                  listener-container=""           <i class="conum" data-value="13"></i><b>(13)</b>
                                  message-converter=""            <i class="conum" data-value="14"></i><b>(14)</b>
                                  message-properties-converter="" <i class="conum" data-value="15"></i><b>(15)</b>
                                  phase=""                        <i class="conum" data-value="16"></i><b>(16)</b>
                                  prefetch-count=""               <i class="conum" data-value="17"></i><b>(17)</b>
                                  receive-timeout=""              <i class="conum" data-value="18"></i><b>(18)</b>
                                  recovery-interval=""            <i class="conum" data-value="19"></i><b>(19)</b>
                                  missing-queues-fatal=""         <i class="conum" data-value="20"></i><b>(20)</b>
                                  shutdown-timeout=""             <i class="conum" data-value="21"></i><b>(21)</b>
                                  task-executor=""                <i class="conum" data-value="22"></i><b>(22)</b>
                                  transaction-attribute=""        <i class="conum" data-value="23"></i><b>(23)</b>
                                  transaction-manager=""          <i class="conum" data-value="24"></i><b>(24)</b>
                                  tx-size=""                      <i class="conum" data-value="25"></i><b>(25)</b>
                                  consumers-per-queue /&gt;          <i class="conum" data-value="26"></i><b>(26)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The unique ID for this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which converted messages should be sent.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Names of the AMQP queues (comma-separated list) from which messages should be consumed.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Acknowledge mode for the <code>MessageListenerContainer</code>.
When set to <code>MANUAL</code>, the delivery tag and channel are provided in message headers <code>amqp_deliveryTag</code> and <code>amqp_channel</code>, respectively.
The user application is responsible for acknowledgement.
<code>NONE</code> means no acknowledgements (<code>autoAck</code>).
<code>AUTO</code> means the adapter&#8217;s container acknowledges when the downstream flow completes.
Optional (defaults to AUTO).
See <a href="#amqp-inbound-ack">Inbound Endpoint Acknowledge Mode</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Extra AOP Advices to handle cross-cutting behavior associated with this inbound channel adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Flag to indicate that channels created by this component are transactional.
If true, it tells the framework to use a transactional channel and to end all operations (send or receive) with a commit or rollback, depending on the outcome, with an exception that signals a rollback.
Optional (Defaults to false).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Specify the number of concurrent consumers to create.
The default is <code>1</code>.
We recommend raising the number of concurrent consumers to scale the consumption of messages coming in from a queue.
However, note that any ordering guarantees are lost once multiple consumers are registered.
In general, use one consumer for low-volume queues.
Not allowed when 'consumers-per-queue' is set.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Bean reference to the RabbitMQ <code>ConnectionFactory</code>.
Optional (defaults to 'connectionFactory').</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Message channel to which error messages should be sent.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Whether the listener channel (com.rabbitmq.client.Channel) is exposed to a registered <code>ChannelAwareMessageListener</code>.
Optional (defaults to true).</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>A reference to an <code>AmqpHeaderMapper</code> to use when receiving AMQP Messages.
Optional.
By default, only standard AMQP properties (such as <code>contentType</code>) are copied to Spring Integration <code>MessageHeaders</code>.
Any user-defined headers within the AMQP <code>MessageProperties</code> are NOT copied to the message by the default <code>DefaultAmqpHeaderMapper</code>.
Not allowed if 'request-header-names' is provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Comma-separated list of the names of AMQP Headers to be mapped from the AMQP request into the <code>MessageHeaders</code>.
This can only be provided if the 'header-mapper' reference is not provided.
The values in this list can also be simple patterns to be matched against the header names (such as "*" or "thing1*, thing2" or "*something").</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Reference to the <code>AbstractMessageListenerContainer</code> to use for receiving AMQP Messages.
If this attribute is provided, no other attribute related to the listener container configuration should be provided.
In other words, by setting this reference, you must take full responsibility for the listener container configuration.
The only exception is the <code>MessageListener</code> itself.
Since that is actually the core responsibility of this channel adapter implementation, the referenced listener container must not already have its own <code>MessageListener</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>The <code>MessageConverter</code> to use when receiving AMQP messages.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>The <code>MessagePropertiesConverter</code> to use when receiving AMQP messages.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>Specifies the phase in which the underlying <code>AbstractMessageListenerContainer</code> should be started and stopped.
The startup order proceeds from lowest to highest, and the shutdown order is the reverse of that.
By default, this value is <code>Integer.MAX_VALUE</code>, meaning that this container starts as late as possible and stops as soon as possible.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>Tells the AMQP broker how many messages to send to each consumer in a single request.
Often, you can set this value high to improve throughput.
It should be greater than or equal to the transaction size (see the <code>tx-size</code> attribute, later in this list).
Optional (defaults to <code>1</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>Receive timeout in milliseconds.
Optional (defaults to <code>1000</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="19"></i><b>19</b></td>
<td>Specifies the interval between recovery attempts of the underlying <code>AbstractMessageListenerContainer</code> (in milliseconds).
Optional (defaults to <code>5000</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="20"></i><b>20</b></td>
<td>If 'true' and none of the queues are available on the broker, the container throws a fatal exception during startup and stops if the queues are deleted when the container is running (after making three attempts to passively declare the queues).
If <code>false</code>, the container does not throw an exception and goes into recovery mode, attempting to restart according to the <code>recovery-interval</code>.
Optional (defaults to <code>true</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="21"></i><b>21</b></td>
<td>The time to wait for workers (in milliseconds) after the underlying <code>AbstractMessageListenerContainer</code> is stopped and before the AMQP connection is forced closed.
If any workers are active when the shutdown signal comes, they are allowed to finish processing as long as they can finish within this timeout.
Otherwise, the connection is closed and messages remain unacknowledged (if the channel is transactional).
Optional (defaults to <code>5000</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="22"></i><b>22</b></td>
<td>By default, the underlying <code>AbstractMessageListenerContainer</code> uses a <code>SimpleAsyncTaskExecutor</code> implementation, that fires up a new thread for each task, running it asynchronously.
By default, the number of concurrent threads is unlimited.
Note that this implementation does not reuse threads.
Consider using a thread-pooling <code>TaskExecutor</code> implementation as an alternative.
Optional (defaults to <code>SimpleAsyncTaskExecutor</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="23"></i><b>23</b></td>
<td>By default, the underlying <code>AbstractMessageListenerContainer</code> creates a new instance of the <code>DefaultTransactionAttribute</code> (it takes the EJB approach to rolling back on runtime but not checked exceptions).
Optional (defaults to <code>DefaultTransactionAttribute</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="24"></i><b>24</b></td>
<td>Sets a bean reference to an external <code>PlatformTransactionManager</code> on the underlying <code>AbstractMessageListenerContainer</code>.
The transaction manager works in conjunction with the <code>channel-transacted</code> attribute.
If there is already a transaction in progress when the framework is sending or receiving a message and the <code>channelTransacted</code> flag is <code>true</code>, the commit or rollback of the messaging transaction is deferred until the end of the current transaction.
If the <code>channelTransacted</code> flag is <code>false</code>, no transaction semantics apply to the messaging operation (it is auto-acked).
For further information, see
<a href="https://docs.spring.io/spring-amqp/reference/html/%255Freference.html#%5Ftransactions">Transactions with Spring AMQP</a>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="25"></i><b>25</b></td>
<td>Tells the <code>SimpleMessageListenerContainer</code> how many messages to process in a single transaction (if the channel is transactional).
For best results, it should be less than or equal to the value set in <code>prefetch-count</code>.
Not allowed when 'consumers-per-queue' is set.
Optional (defaults to <code>1</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="26"></i><b>26</b></td>
<td>Indicates that the underlying listener container should be a <code>DirectMessageListenerContainer</code> instead of the default <code>SimpleMessageListenerContainer</code>.
See the <a href="https://docs.spring.io/spring-amqp/reference/html/">Spring AMQP Reference Manual</a> for more information.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">container</div>
<div class="paragraph">
<p>Note that when configuring an external container, you cannot use the Spring AMQP namespace to define the container.
This is because the namespace requires at least one <code>&lt;listener/&gt;</code> element.
In this environment, the listener is internal to the adapter.
For this reason, you must define the container by using a normal Spring <code>&lt;bean/&gt;</code> definition, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="container"
 class="org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
    &lt;property name="queueNames" value="aName.queue" /&gt;
    &lt;property name="defaultRequeueRejected" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Even though the Spring Integration JMS and AMQP support is similar, important differences exist.
The JMS inbound channel adapter is using a <code>JmsDestinationPollingSource</code> under the covers and expects a configured poller.
The AMQP inbound channel adapter uses an <code>AbstractMessageListenerContainer</code> and is message driven.
In that regard, it is more similar to the JMS message-driven channel adapter.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration"><a class="anchor" href="#configuring-with-java-configuration"></a>14.1.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of configuring the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class AmqpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(AmqpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public MessageChannel amqpInputChannel() {
        return new DirectChannel();
    }

    @Bean
    public AmqpInboundChannelAdapter inbound(SimpleMessageListenerContainer listenerContainer,
            @Qualifier("amqpInputChannel") MessageChannel channel) {
        AmqpInboundChannelAdapter adapter = new AmqpInboundChannelAdapter(listenerContainer);
        adapter.setOutputChannel(channel);
        return adapter;
    }

    @Bean
    public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory) {
        SimpleMessageListenerContainer container =
                                   new SimpleMessageListenerContainer(connectionFactory);
        container.setQueueNames("aName");
        container.setConcurrentConsumers(2);
        // ...
        return container;
    }

    @Bean
    @ServiceActivator(inputChannel = "amqpInputChannel")
    public MessageHandler handler() {
        return new MessageHandler() {

            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-2"><a class="anchor" href="#configuring-with-the-java-dsl-2"></a>14.1.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application provides an example of configuring the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class AmqpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(AmqpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow amqpInbound(ConnectionFactory connectionFactory) {
        return IntegrationFlows.from(Amqp.inboundAdapter(connectionFactory, "aName"))
                .handle(m -&gt; System.out.println(m.getPayload()))
                .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="polled-inbound-channel-adapter"><a class="anchor" href="#polled-inbound-channel-adapter"></a>14.2. Polled Inbound Channel Adapter</h3>
<div class="paragraph">
<p>Version 5.0.1 introduced a polled channel adapter, letting you fetch individual messages on demand&#8201;&#8212;&#8201;for example, with a <code>MessageSourcePollingTemplate</code> or a poller.
See <a href="#deferred-acks-message-source">Deferred Acknowledgment Pollable Message Source</a> for more information.</p>
</div>
<div class="paragraph">
<p>It does not currently support XML configuration.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure an <code>AmqpMessageSource</code> with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AmqpMessageSource source(ConnectionFactory connectionFactory) {
    return new AmpqpMessageSource(connectionFactory, "someQueue");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/amqp/inbound/AmqpMessageSource.html">Javadoc</a> for configuration properties.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure an <code>inboundPolledAdapter</code> with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow() {
    return IntegrationFlows.from(Amqp.inboundPolledAdapter(connectionFactory(), DSL_QUEUE),
                    e -&gt; e.poller(Pollers.fixedDelay(1_000)).autoStartup(false))
            .handle(p -&gt; {
                ...
            })
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-inbound-gateway"><a class="anchor" href="#amqp-inbound-gateway"></a>14.3. Inbound Gateway</h3>
<div class="paragraph">
<p>The inbound gateway supports all the attributes on the inbound channel adapter (except that 'channel' is replaced by 'request-channel'), plus some additional attributes.
The following listing shows the available attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:inbound-gateway
                          id="inboundGateway"                <i class="conum" data-value="1"></i><b>(1)</b>
                          request-channel="myRequestChannel" <i class="conum" data-value="2"></i><b>(2)</b>
                          header-mapper=""                   <i class="conum" data-value="3"></i><b>(3)</b>
                          mapped-request-headers=""          <i class="conum" data-value="4"></i><b>(4)</b>
                          mapped-reply-headers=""            <i class="conum" data-value="5"></i><b>(5)</b>
                          reply-channel="myReplyChannel"     <i class="conum" data-value="6"></i><b>(6)</b>
                          reply-timeout="1000"               <i class="conum" data-value="7"></i><b>(7)</b>
                          amqp-template=""                   <i class="conum" data-value="8"></i><b>(8)</b>
                          default-reply-to="" /&gt;             <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The Unique ID for this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which converted messages are sent.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A reference to an <code>AmqpHeaderMapper</code> to use when receiving AMQP Messages.
Optional.
By default, only standard AMQP properties (such as <code>contentType</code>) are copied to and from Spring Integration <code>MessageHeaders</code>.
Any user-defined headers within the AMQP <code>MessageProperties</code> are not copied to or from an AMQP message by the default <code>DefaultAmqpHeaderMapper</code>.
Not allowed if 'request-header-names' or 'reply-header-names' is provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Comma-separated list of names of AMQP Headers to be mapped from the AMQP request into the <code>MessageHeaders</code>.
This attribute can be provided only if the 'header-mapper' reference is not provided.
The values in this list can also be simple patterns to be matched against the header names (e.g. <code>"*"</code> or <code>"thing1*, thing2"</code> or <code>"*thing1"</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Comma-separated list of names of <code>MessageHeaders</code> to be mapped into the AMQP message properties of the AMQP reply message.
All standard Headers (such as <code>contentType</code>) are mapped to AMQP Message Properties, while user-defined headers are mapped to the 'headers' property.
This attribute can only be provided if the 'header-mapper' reference is not provided.
The values in this list can also be simple patterns to be matched against the header names (for example, <code>"*"</code> or <code>"foo*, bar"</code> or <code>"*foo"</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Message Channel where reply Messages are expected.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Sets the <code>receiveTimeout</code> on the underlying <code>o.s.i.core.MessagingTemplate</code> for receiving messages from the reply channel.
If not specified, this property defaults to <code>1000</code> (1 second).
Only applies if the container thread hands off to another thread before the reply is sent.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The customized <code>AmqpTemplate</code> bean reference (to have more control over the reply messages to send).
You can provide an alternative implementation to the <code>RabbitTemplate</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The <code>replyTo</code> <code>o.s.amqp.core.Address</code> to be used when the <code>requestMessage</code> does not have a <code>replyTo</code>
property.
If this option is not specified, no <code>amqp-template</code> is provided, no <code>replyTo</code> property exists in the request message, and
an <code>IllegalStateException</code> is thrown because the reply cannot be routed.
If this option is not specified and an external <code>amqp-template</code> is provided, no exception is thrown.
You must either specify this option or configure a default <code>exchange</code> and <code>routingKey</code> on that template,
if you anticipate cases when no <code>replyTo</code> property exists in the request message.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the note in <a href="#amqp-inbound-channel-adapter">Inbound Channel Adapter</a> about configuring the <code>listener-container</code> attribute.</p>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-2"><a class="anchor" href="#configuring-with-java-configuration-2"></a>14.3.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound gateway with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class AmqpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(AmqpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public MessageChannel amqpInputChannel() {
        return new DirectChannel();
    }

    @Bean
    public AmqpInboundGateway inbound(SimpleMessageListenerContainer listenerContainer,
            @Qualifier("amqpInputChannel") MessageChannel channel) {
        AmqpInboundGateway gateway = new AmqpInboundGateway(listenerContainer);
        gateway.setRequestChannel(channel);
        gateway.setDefaultReplyTo("bar");
        return gateway;
    }

    @Bean
    public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory) {
        SimpleMessageListenerContainer container =
                        new SimpleMessageListenerContainer(connectionFactory);
        container.setQueueNames("foo");
        container.setConcurrentConsumers(2);
        // ...
        return container;
    }

    @Bean
    @ServiceActivator(inputChannel = "amqpInputChannel")
    public MessageHandler handler() {
        return new AbstractReplyProducingMessageHandler() {

            @Override
            protected Object handleRequestMessage(Message&lt;?&gt; requestMessage) {
                return "reply to " + requestMessage.getPayload();
            }

        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-3"><a class="anchor" href="#configuring-with-the-java-dsl-3"></a>14.3.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class AmqpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(AmqpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean // return the upper cased payload
    public IntegrationFlow amqpInboundGateway(ConnectionFactory connectionFactory) {
        return IntegrationFlows.from(Amqp.inboundGateway(connectionFactory, "foo"))
                .transform(String.class, String::toUpperCase)
                .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-inbound-ack"><a class="anchor" href="#amqp-inbound-ack"></a>14.4. Inbound Endpoint Acknowledge Mode</h3>
<div class="paragraph">
<p>By default, the inbound endpoints use the <code>AUTO</code> acknowledge mode, which means the container automatically acknowledges the message when the downstream integration flow completes (or a message is handed off to another thread by using a <code>QueueChannel</code> or <code>ExecutorChannel</code>).
Setting the mode to <code>NONE</code> configures the consumer such that acknowledgments are not used at all (the broker automatically acknowledges the message as soon as it is sent).
Setting the mode to <code>MANUAL</code> lets user code acknowledge the message at some other point during processing.
To support this, with this mode, the endpoints provide the <code>Channel</code> and <code>deliveryTag</code> in the <code>amqp_channel</code> and <code>amqp_deliveryTag</code> headers, respectively.</p>
</div>
<div class="paragraph">
<p>You can perform any valid Rabbit command on the <code>Channel</code> but, generally, only <code>basicAck</code> and <code>basicNack</code> (or <code>basicReject</code>) are used.
In order to not interfere with the operation of the container, you should not retain a reference to the channel and use it only in the context of the current message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since the <code>Channel</code> is a reference to a &#8220;live&#8221; object, it cannot be serialized and is lost if a message is persisted.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how you might use <code>MANUAL</code> acknowledgement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "foo", outputChannel = "bar")
public Object handle(@Payload String payload, @Header(AmqpHeaders.CHANNEL) Channel channel,
        @Header(AmqpHeaders.DELIVERY_TAG) Long deliveryTag) throws Exception {

    // Do some processing

    if (allOK) {
        channel.basicAck(deliveryTag, false);

        // perhaps do some more processing

    }
    else {
        channel.basicNack(deliveryTag, false, true);
    }
    return someResultForDownStreamProcessing;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-outbound-channel-adapter"><a class="anchor" href="#amqp-outbound-channel-adapter"></a>14.5. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The following example shows the available properties for an AMQP outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:outbound-channel-adapter id="outboundAmqp"             <i class="conum" data-value="1"></i><b>(1)</b>
                               channel="outboundChannel"         <i class="conum" data-value="2"></i><b>(2)</b>
                               amqp-template="myAmqpTemplate"    <i class="conum" data-value="3"></i><b>(3)</b>
                               exchange-name=""                  <i class="conum" data-value="4"></i><b>(4)</b>
                               exchange-name-expression=""       <i class="conum" data-value="5"></i><b>(5)</b>
                               order="1"                         <i class="conum" data-value="6"></i><b>(6)</b>
                               routing-key=""                    <i class="conum" data-value="7"></i><b>(7)</b>
                               routing-key-expression=""         <i class="conum" data-value="8"></i><b>(8)</b>
                               default-delivery-mode""           <i class="conum" data-value="9"></i><b>(9)</b>
                               confirm-correlation-expression="" <i class="conum" data-value="10"></i><b>(10)</b>
                               confirm-ack-channel=""            <i class="conum" data-value="11"></i><b>(11)</b>
                               confirm-nack-channel=""           <i class="conum" data-value="12"></i><b>(12)</b>
                               return-channel=""                 <i class="conum" data-value="13"></i><b>(13)</b>
                               error-message-strategy=""         <i class="conum" data-value="14"></i><b>(14)</b>
                               header-mapper=""                  <i class="conum" data-value="15"></i><b>(15)</b>
                               mapped-request-headers=""         <i class="conum" data-value="16"></i><b>(16)</b>
                               lazy-connect="true" /&gt;            <i class="conum" data-value="17"></i><b>(17)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The unique ID for this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which messages should be sent to have them converted and published to an AMQP exchange.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Bean reference to the configured AMQP template.
Optional (defaults to <code>amqpTemplate</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The name of the AMQP exchange to which messages are sent.
If not provided, messages are sent to the default, no-name exchange.
Mutually exclusive with 'exchange-name-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages are sent, with the message as the root object.
If not provided, messages are sent to the default, no-name exchange.
Mutually exclusive with 'exchange-name'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.
Optional (defaults to <code>Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The fixed routing-key to use when sending messages.
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>A SpEL expression that is evaluated to determine the routing key to use when sending messages, with the message as the root object (for example, 'payload.key').
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The default delivery mode for messages: <code>PERSISTENT</code> or <code>NON_PERSISTENT</code>.
Overridden if the <code>header-mapper</code> sets the delivery mode.
If the Spring Integration message header <code>amqp_deliveryMode</code> is present, the <code>DefaultHeaderMapper</code> sets the value.
If this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP <code>MessagePropertiesConverter</code> used by the <code>RabbitTemplate</code>.
If that is not customized at all, the default is <code>PERSISTENT</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>An expression that defines correlation data.
When provided, this configures the underlying AMQP template to receive publisher confirmations.
Requires a dedicated <code>RabbitTemplate</code> and a <code>CachingConnectionFactory</code> with the <code>publisherConfirms</code> property set to <code>true</code>.
When a publisher confirmation is received and correlation data is supplied, it is written to either the <code>confirm-ack-channel</code> or the <code>confirm-nack-channel</code>, depending on the confirmation type.
The payload of the confirmation is the correlation data, as defined by this expression.
The message has an 'amqp_publishConfirm' header set to <code>true</code> (<code>ack</code>) or <code>false</code> (<code>nack</code>).
Examples: <code>headers['myCorrelationData']</code> and <code>payload</code>.
Version 4.1 introduced the <code>amqp_publishConfirmNackCause</code> message header.
It contains the <code>cause</code> of a 'nack' for a publisher confirmation.
Starting with version 4.2, if the expression resolves to a <code>Message&lt;?&gt;</code> instance (such as <code>#this</code>), the message emitted on the <code>ack</code>/<code>nack</code> channel is based on that message, with the additional header(s) added.
Previously, a new message was created with the correlation data as its payload, regardless of type.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The channel to which positive (<code>ack</code>) publisher confirms are sent.
The payload is the correlation data defined by the <code>confirm-correlation-expression</code>.
If the expression is <code>#root</code> or <code>#this</code>, the message is built from the original message, with the <code>amqp_publishConfirm</code> header set to <code>true</code>.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The channel to which negative (<code>nack</code>) publisher confirmations are sent.
The payload is the correlation data defined by the <code>confirm-correlation-expression</code> (if there is no <code>ErrorMessageStrategy</code> configured).
If the expression is <code>#root</code> or <code>#this</code>, the message is built from the original message, with the <code>amqp_publishConfirm</code> header set to <code>false</code>.
When there is an <code>ErrorMessageStrategy</code>, the message is an <code>ErrorMessage</code> with a <code>NackedAmqpMessageException</code> payload.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>The channel to which returned messages are sent.
When provided, the underlying AMQP template is configured to return undeliverable messages to the adapter.
When there is no <code>ErrorMessageStrategy</code> configured, the message is constructed from the data received from AMQP, with the following additional headers: <code>amqp_returnReplyCode</code>, <code>amqp_returnReplyText</code>, <code>amqp_returnExchange</code>, <code>amqp_returnRoutingKey</code>.
When there is an <code>ErrorMessageStrategy</code>, the message is an <code>ErrorMessage</code> with a <code>ReturnedAmqpMessageException</code> payload.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>A reference to an <code>ErrorMessageStrategy</code> implementation used to build <code>ErrorMessage</code> instances when sending returned or negatively acknowledged messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>A reference to an <code>AmqpHeaderMapper</code> to use when sending AMQP Messages.
By default, only standard AMQP properties (such as <code>contentType</code>) are copied to the Spring Integration <code>MessageHeaders</code>.
Any user-defined headers is not copied to the message by the default`DefaultAmqpHeaderMapper`.
Not allowed if 'request-header-names' is provided.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>Comma-separated list of names of AMQP Headers to be mapped from the <code>MessageHeaders</code> to the AMQP Message.
Not allowed if the 'header-mapper' reference is provided.
The values in this list can also be simple patterns to be matched against the header names (e.g. <code>"*"</code> or <code>"thing1*, thing2"</code> or <code>"*thing1"</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>When set to <code>false</code>, the endpoint attempts to connect to the broker during application context initialization.
This allows &#8220;fail fast&#8221; detection of bad configuration but also causes initialization to fail if the broker is down.
When <code>true</code> (the default), the connection is established (if it does not already exist because some other component established it) when the first message is sent.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">return-channel</div>
<div class="paragraph">
<p>Using a <code>return-channel</code> requires a <code>RabbitTemplate</code> with the <code>mandatory</code> property set to <code>true</code> and a <code>CachingConnectionFactory</code> with the <code>publisherReturns</code> property set to <code>true</code>.
When using multiple outbound endpoints with returns, a separate <code>RabbitTemplate</code> is needed for each endpoint.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-3"><a class="anchor" href="#configuring-with-java-configuration-3"></a>14.5.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class AmqpJavaApplication {

    public static void main(String[] args) {
         ConfigurableApplicationContext context =
              new SpringApplicationBuilder(AmqpJavaApplication.class)
                       .web(false)
                       .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         gateway.sendToRabbit("foo");
    }

    @Bean
    @ServiceActivator(inputChannel = "amqpOutboundChannel")
    public AmqpOutboundEndpoint amqpOutbound(AmqpTemplate amqpTemplate) {
        AmqpOutboundEndpoint outbound = new AmqpOutboundEndpoint(amqpTemplate);
        outbound.setRoutingKey("foo"); // default exchange - route to queue 'foo'
        return outbound;
    }

    @Bean
    public MessageChannel amqpOutboundChannel() {
        return new DirectChannel();
    }

    @MessagingGateway(defaultRequestChannel = "amqpOutboundChannel")
    public interface MyGateway {

        void sendToRabbit(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-4"><a class="anchor" href="#configuring-with-the-java-dsl-4"></a>14.5.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class AmqpJavaApplication {

    public static void main(String[] args) {
         ConfigurableApplicationContext context =
                  new SpringApplicationBuilder(AmqpJavaApplication.class)
                          .web(false)
                          .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         gateway.sendToRabbit("foo");
    }

    @Bean
    public IntegrationFlow amqpOutbound(AmqpTemplate amqpTemplate) {
        return IntegrationFlows.from(amqpOutboundChannel())
                .handle(Amqp.outboundAdapter(amqpTemplate)
                            .routingKey("foo")) // default exchange - route to queue 'foo'
                .get();
    }

    @Bean
    public MessageChannel amqpOutboundChannel() {
        return new DirectChannel();
    }

    @MessagingGateway(defaultRequestChannel = "amqpOutboundChannel")
    public interface MyGateway {

        void sendToRabbit(String data);

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-outbound-gateway"><a class="anchor" href="#amqp-outbound-gateway"></a>14.6. Outbound Gateway</h3>
<div class="paragraph">
<p>The following listing shows the possible properties for an AMQP Outbound Gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:outbound-gateway id="inboundGateway"                <i class="conum" data-value="1"></i><b>(1)</b>
                           request-channel="myRequestChannel" <i class="conum" data-value="2"></i><b>(2)</b>
                           amqp-template=""                   <i class="conum" data-value="3"></i><b>(3)</b>
                           exchange-name=""                   <i class="conum" data-value="4"></i><b>(4)</b>
                           exchange-name-expression=""        <i class="conum" data-value="5"></i><b>(5)</b>
                           order="1"                          <i class="conum" data-value="6"></i><b>(6)</b>
                           reply-channel=""                   <i class="conum" data-value="7"></i><b>(7)</b>
                           reply-timeout=""                   <i class="conum" data-value="8"></i><b>(8)</b>
                           requires-reply=""                  <i class="conum" data-value="9"></i><b>(9)</b>
                           routing-key=""                     <i class="conum" data-value="10"></i><b>(10)</b>
                           routing-key-expression=""          <i class="conum" data-value="11"></i><b>(11)</b>
                           default-delivery-mode""            <i class="conum" data-value="12"></i><b>(12)</b>
                           confirm-correlation-expression=""  <i class="conum" data-value="13"></i><b>(13)</b>
                           confirm-ack-channel=""             <i class="conum" data-value="14"></i><b>(14)</b>
                           confirm-nack-channel=""            <i class="conum" data-value="15"></i><b>(15)</b>
                           return-channel=""                  <i class="conum" data-value="16"></i><b>(16)</b>
                           error-message-strategy=""          <i class="conum" data-value="17"></i><b>(17)</b>
                           lazy-connect="true" /&gt;             <i class="conum" data-value="18"></i><b>(18)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The unique ID for this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which messages are sent to have them converted and published to an AMQP exchange.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Bean reference to the configured AMQP template.
Optional (defaults to <code>amqpTemplate</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The name of the AMQP exchange to which messages should be sent.
If not provided, messages are sent to the default, no-name cxchange.
Mutually exclusive with 'exchange-name-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages should be sent, with the message as the root object.
If not provided, messages are sent to the default, no-name exchange.
Mutually exclusive with 'exchange-name'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.
Optional (defaults to <code>Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Message channel to which replies should be sent after being received from an AMQP queue and converted.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The time the gateway waits when sending the reply message to the <code>reply-channel</code>.
This only applies if the <code>reply-channel</code> can block&#8201;&#8212;&#8201;such as a <code>QueueChannel</code> with a capacity limit that is currently full.
Defaults to infinity.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>When <code>true</code>, the gateway throws an exception if no reply message is received within the <code>AmqpTemplate&#8217;s `replyTimeout</code> property.
Defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The <code>routing-key</code> to use when sending messages.
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>A SpEL expression that is evaluated to determine the <code>routing-key</code> to use when sending messages, with the message as the root object (for example, 'payload.key').
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The default delivery mode for messages: <code>PERSISTENT</code> or <code>NON_PERSISTENT</code>.
Overridden if the <code>header-mapper</code> sets the delivery mode.
If the Spring Integration message header <code>amqp_deliveryMode</code> is present, the <code>DefaultHeaderMapper</code> sets the value.
If this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP <code>MessagePropertiesConverter</code> used by the <code>RabbitTemplate</code>.
If that is not customized at all, the default is <code>PERSISTENT</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Since version 4.2.
An expression defining correlation data.
When provided, this configures the underlying AMQP template to receive publisher confirms.
Requires a dedicated <code>RabbitTemplate</code> and a <code>CachingConnectionFactory</code> with the <code>publisherConfirms</code> property set to <code>true</code>.
When a publisher confirm is received and correlation data is supplied, it is written to either the <code>confirm-ack-channel</code> or the <code>confirm-nack-channel</code>, depending on the confirmation type.
The payload of the confirm is the correlation data, as defined by this expression.
The message has a header 'amqp_publishConfirm' set to <code>true</code> (<code>ack</code>) or <code>false</code> (<code>nack</code>).
For <code>nack</code> confirmations, Spring Integration provides an additional header <code>amqp_publishConfirmNackCause</code>.
Examples: <code>headers['myCorrelationData']</code> and <code>payload</code>.
If the expression resolves to a <code>Message&lt;?&gt;</code> instance (such as <code>#this</code>), the message
emitted on the <code>ack</code>/<code>nack</code> channel is based on that message, with the additional headers added.
Previously, a new message was created with the correlation data as its payload, regardless of type.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>The channel to which positive (<code>ack</code>) publisher confirmations are sent.
The payload is the correlation data defined by <code>confirm-correlation-expression</code>.
If the expression is <code>#root</code> or <code>#this</code>, the message is built from the original message, with the <code>amqp_publishConfirm</code> header set to <code>true</code>.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>The channel to which negative (<code>nack</code>) publisher confirmations are sent.
The payload is the correlation data defined by <code>confirm-correlation-expression</code> (if there is no <code>ErrorMessageStrategy</code> configured).
If the expression is <code>#root</code> or <code>#this</code>, the message is built from the original message, with the <code>amqp_publishConfirm</code> header set to <code>false</code>.
When there is an <code>ErrorMessageStrategy</code>, the message is an <code>ErrorMessage</code> with a <code>NackedAmqpMessageException</code> payload.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>The channel to which returned messages are sent.
When provided, the underlying AMQP template is configured to return undeliverable messages to the adapter.
When there is no <code>ErrorMessageStrategy</code> configured, the message is constructed from the data received from AMQP, with the following additional headers: <code>amqp_returnReplyCode</code>, <code>amqp_returnReplyText</code>, <code>amqp_returnExchange</code>, and <code>amqp_returnRoutingKey</code>.
When there is an <code>ErrorMessageStrategy</code>, the message is an <code>ErrorMessage</code> with a <code>ReturnedAmqpMessageException</code> payload.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>A reference to an <code>ErrorMessageStrategy</code> implementation used to build <code>ErrorMessage</code> instances when sending returned or negatively acknowledged messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>When set to <code>false</code>, the endpoint attempts to connect to the broker during application context initialization.
This allows &#8220;fail fast&#8221; detection of bad configuration by logging an error message if the broker is down.
When <code>true</code> (the default), the connection is established (if it does not already exist because some other component established it) when the first message is sent.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">return-channel</div>
<div class="paragraph">
<p>Using a <code>return-channel</code> requires a <code>RabbitTemplate</code> with the <code>mandatory</code> property set to <code>true</code> and a <code>CachingConnectionFactory</code> with the <code>publisherReturns</code> property set to <code>true</code>.
When using multiple outbound endpoints with returns, a separate <code>RabbitTemplate</code> is needed for each endpoint.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The underlying <code>AmqpTemplate</code> has a default <code>replyTimeout</code> of five seconds.
If you require a longer timeout, you must configure it on the <code>template</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-4"><a class="anchor" href="#configuring-with-java-configuration-4"></a>14.6.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class AmqpJavaApplication {

    public static void main(String[] args) {
         ConfigurableApplicationContext context =
                new SpringApplicationBuilder(AmqpJavaApplication.class)
                       .web(false)
                       .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         String reply = gateway.sendToRabbit("foo");
         System.out.println(reply);
    }

    @Bean
    @ServiceActivator(inputChannel = "amqpOutboundChannel")
    public AmqpOutboundEndpoint amqpOutbound(AmqpTemplate amqpTemplate) {
        AmqpOutboundEndpoint outbound = new AmqpOutboundEndpoint(amqpTemplate);
        outbound.setExpectReply(true);
        outbound.setRoutingKey("foo"); // default exchange - route to queue 'foo'
        return outbound;
    }

    @Bean
    public MessageChannel amqpOutboundChannel() {
        return new DirectChannel();
    }

    @MessagingGateway(defaultRequestChannel = "amqpOutboundChannel")
    public interface MyGateway {

        String sendToRabbit(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the only difference between the outbound adapter and outbound gateway configuration is the setting of the
<code>expectReply</code> property.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-5"><a class="anchor" href="#configuring-with-the-java-dsl-5"></a>14.6.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class AmqpJavaApplication {

    public static void main(String[] args) {
         ConfigurableApplicationContext context =
                 new SpringApplicationBuilder(AmqpJavaApplication.class)
                      .web(false)
                      .run(args);
         RabbitTemplate template = context.getBean(RabbitTemplate.class);
         MyGateway gateway = context.getBean(MyGateway.class);
         String reply = gateway.sendToRabbit("foo");
         System.out.println(reply);
    }

    @Bean
    public IntegrationFlow amqpOutbound(AmqpTemplate amqpTemplate) {
        return IntegrationFlows.from(amqpOutboundChannel())
                .handle(Amqp.outboundGateway(amqpTemplate)
                        .routingKey("foo")) // default exchange - route to queue 'foo'
                .get();
    }

    @Bean
    public MessageChannel amqpOutboundChannel() {
        return new DirectChannel();
    }

    @MessagingGateway(defaultRequestChannel = "amqpOutboundChannel")
    public interface MyGateway {

        String sendToRabbit(String data);

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-async-outbound-gateway"><a class="anchor" href="#amqp-async-outbound-gateway"></a>14.7. Asynchronous Outbound Gateway</h3>
<div class="paragraph">
<p>The gateway discussed in the previous section is synchronous, in that the sending thread is suspended until a
reply is received (or a timeout occurs).
Spring Integration version 4.3 added an asynchronous gateway, which uses the <code>AsyncRabbitTemplate</code> from Spring AMQP.
When a message is sent, the thread returns immediately after the send operation completes, and, when the message is received, the reply is sent on the template&#8217;s listener container thread.
This can be useful when the gateway is invoked on a poller thread.
The thread is released and is available for other tasks in the framework.</p>
</div>
<div class="paragraph">
<p>The following listing shows the possible configuration options for an AMQP asynchronous outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:outbound-gateway id="inboundGateway" <i class="conum" data-value="1"></i><b>(1)</b>
                           request-channel="myRequestChannel" <i class="conum" data-value="2"></i><b>(2)</b>
                           async-template="" <i class="conum" data-value="3"></i><b>(3)</b>
                           exchange-name="" <i class="conum" data-value="4"></i><b>(4)</b>
                           exchange-name-expression="" <i class="conum" data-value="5"></i><b>(5)</b>
                           order="1" <i class="conum" data-value="6"></i><b>(6)</b>
                           reply-channel="" <i class="conum" data-value="7"></i><b>(7)</b>
                           reply-timeout="" <i class="conum" data-value="8"></i><b>(8)</b>
                           requires-reply="" <i class="conum" data-value="9"></i><b>(9)</b>
                           routing-key="" <i class="conum" data-value="10"></i><b>(10)</b>
                           routing-key-expression="" <i class="conum" data-value="11"></i><b>(11)</b>
                           default-delivery-mode"" <i class="conum" data-value="12"></i><b>(12)</b>
                           confirm-correlation-expression="" <i class="conum" data-value="13"></i><b>(13)</b>
                           confirm-ack-channel="" <i class="conum" data-value="14"></i><b>(14)</b>
                           confirm-nack-channel="" <i class="conum" data-value="15"></i><b>(15)</b>
                           return-channel="" <i class="conum" data-value="16"></i><b>(16)</b>
                           lazy-connect="true" /&gt; <i class="conum" data-value="17"></i><b>(17)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The unique ID for this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which messages should be sent in order to have them converted and published to an AMQP exchange.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Bean reference to the configured <code>AsyncRabbitTemplate</code>.
Optional (it defaults to <code>asyncRabbitTemplate</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The name of the AMQP exchange to which messages should be sent.
If not provided, messages are sent to the default, no-name exchange.
Mutually exclusive with 'exchange-name-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages are sent, with the message as the root object.
If not provided, messages are sent to the default, no-name exchange.
Mutually exclusive with 'exchange-name'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.
Optional (it defaults to <code>Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Message channel to which replies should be sent after being received from an AMQP queue and converted.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The time the gateway waits when sending the reply message to the <code>reply-channel</code>.
This only applies if the <code>reply-channel</code> can block&#8201;&#8212;&#8201;such as a <code>QueueChannel</code> with a capacity limit that is currently full.
The default is infinity.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>When no reply message is received within the <code>AsyncRabbitTemplate&#8217;s `receiveTimeout</code> property and this setting is <code>true</code>, the gateway sends an error message to the inbound message&#8217;s <code>errorChannel</code> header.
When no reply message is received within the <code>AsyncRabbitTemplate&#8217;s `receiveTimeout</code> property and this setting is <code>false</code>, the gateway sends an error message to the default <code>errorChannel</code> (if available).
It defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The routing-key to use when sending Messages.
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key-expression'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>A SpEL expression that is evaluated to determine the routing-key to use when sending messages,
with the message as the root object (for example, 'payload.key').
By default, this is an empty <code>String</code>.
Mutually exclusive with 'routing-key'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The default delivery mode for messages: <code>PERSISTENT</code> or <code>NON_PERSISTENT</code>.
Overridden if the <code>header-mapper</code> sets the delivery mode.
If the Spring Integration message header (<code>amqp_deliveryMode</code>) is present, the <code>DefaultHeaderMapper</code> sets the value.
If this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP <code>MessagePropertiesConverter</code> used by the <code>RabbitTemplate</code>.
If that is not customized, the default is <code>PERSISTENT</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>An expression that defines correlation data.
When provided, this configures the underlying AMQP template to receive publisher confirmations.
Requires a dedicated <code>RabbitTemplate</code> and a <code>CachingConnectionFactory</code> with its <code>publisherConfirms</code> property set to <code>true</code>.
When a publisher confirmation is received and correlation data is supplied, the confirmation is written to either the <code>confirm-ack-channel</code> or the <code>confirm-nack-channel</code>, depending on the confirmation type.
The payload of the confirmation is the correlation data as defined by this expression, and the message has its 'amqp_publishConfirm' header set to <code>true</code> (<code>ack</code>) or <code>false</code> (<code>nack</code>).
For <code>nack</code> instances, an additional header (<code>amqp_publishConfirmNackCause</code>) is provided.
Examples: <code>headers['myCorrelationData']</code>, <code>payload</code>.
If the expression resolves to a <code>Message&lt;?&gt;</code> instance (such as &#8220;#this&#8221;), the message emitted on the <code>ack</code>/<code>nack</code> channel is based on that message, with the additional headers added.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>The channel to which positive (<code>ack</code>) publisher confirmations are sent.
The payload is the correlation data defined by the <code>confirm-correlation-expression</code>.
Requires the underlying <code>AsyncRabbitTemplate</code> to have its <code>enableConfirms</code> property set to <code>true</code>.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>Since version 4.2.
The channel to which negative (<code>nack</code>) publisher confirmations are sent.
The payload is the correlation data defined by the <code>confirm-correlation-expression</code>.
Requires the underlying <code>AsyncRabbitTemplate</code> to have its <code>enableConfirms</code> property set to <code>true</code>.
Optional (the default is <code>nullChannel</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>The channel to which returned messages are sent.
When provided, the underlying AMQP template is configured to return undeliverable messages to the gateway.
The message is constructed from the data received from AMQP, with the following additional headers: <code>amqp_returnReplyCode</code>, <code>amqp_returnReplyText</code>, <code>amqp_returnExchange</code>, and <code>amqp_returnRoutingKey</code>.
Requires the underlying <code>AsyncRabbitTemplate</code> to have its <code>mandatory</code> property set to <code>true</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>When set to <code>false</code>, the endpoint tries to connect to the broker during application context initialization.
Doing so allows &#8220;fail fast&#8221; detection of bad configuration, by logging an error message if the broker is down.
When <code>true</code> (the default), the connection is established (if it does not already exist because some other component established
it) when the first message is sent.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="#async-service-activator">Asynchronous Service Activator</a> for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">RabbitTemplate</div>
<div class="paragraph">
<p>When you use confirmations and returns, we recommend that the <code>RabbitTemplate</code> wired into the <code>AsyncRabbitTemplate</code> be dedicated.
Otherwise, unexpected side-effects may be encountered.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-5"><a class="anchor" href="#configuring-with-java-configuration-5"></a>14.7.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following configuration shows an example of how to configure the outbound gateway with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class AmqpAsyncConfig {

    @Bean
    @ServiceActivator(inputChannel = "amqpOutboundChannel")
    public AsyncAmqpOutboundGateway amqpOutbound(AmqpTemplate asyncTemplate) {
        AsyncAmqpOutboundGateway outbound = new AsyncAmqpOutboundGateway(asyncTemplate);
        outbound.setRoutingKey("foo"); // default exchange - route to queue 'foo'
        return outbound;
    }

    @Bean
    public AsyncRabbitTemplate asyncTemplate(RabbitTemplate rabbitTemplate,
                     SimpleMessageListenerContainer replyContainer) {
        return new AsyncRabbitTemplate(rabbitTemplate, replyContainer);
    }

    @Bean
    public SimpleMessageListenerContainer replyContainer() {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(ccf);
        container.setQueueNames("asyncRQ1");
        return container;
    }

    @Bean
    public MessageChannel amqpOutboundChannel() {
        return new DirectChannel();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-6"><a class="anchor" href="#configuring-with-the-java-dsl-6"></a>14.7.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class AmqpAsyncApplication {

    public static void main(String[] args) {
         ConfigurableApplicationContext context =
                 new SpringApplicationBuilder(AmqpAsyncApplication.class)
                      .web(false)
                      .run(args);
         MyGateway gateway = context.getBean(MyGateway.class);
         String reply = gateway.sendToRabbit("foo");
         System.out.println(reply);
    }

    @Bean
    public IntegrationFlow asyncAmqpOutbound(AsyncRabbitTemplate asyncRabbitTemplate) {
        return f -&gt; f
                .handle(Amqp.asyncOutboundGateway(asyncRabbitTemplate)
                        .routingKey("foo")); // default exchange - route to queue 'foo'
    }

    @MessagingGateway(defaultRequestChannel = "asyncAmqpOutbound.input")
    public interface MyGateway {

        String sendToRabbit(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-conversion-inbound"><a class="anchor" href="#amqp-conversion-inbound"></a>14.8. Inbound Message Conversion</h3>
<div class="paragraph">
<p>Inbound messages, arriving at the channel adapter or gateway, are converted to the <code>spring-messaging</code> <code>Message&lt;?&gt;</code> payload using a message converter.
By default, a <code>SimpleMessageConverter</code> is used, which handles java serialization and text.
Headers are mapped using the <code>DefaultHeaderMapper.inboundMapper()</code> by default.
If a conversion error occurs, and there is no error channel defined, the exception is thrown to the container and handled by the listener container&#8217;s error handler.
The default error handler treats conversion errors as fatal and the message will be rejected (and routed to a dead-letter exchange, if the queue is so configured).
If an error channel is defined, the <code>ErrorMessage</code> payload is a <code>ListenerExecutionFailedException</code> with properties <code>failedMessage</code> (the Spring AMQP message that could not be converted) and the <code>cause</code>.
If the container <code>AcknowledgeMode</code> is <code>AUTO</code> (the default) and the error flow consumes the error without throwing an exception, the original message will be acknowledged.
If the error flow throws an exception, the exception type, in conjunction with the container&#8217;s error handler, will determine whether or not the message is requeued.
If the container is configured with <code>AcknowledgeMode.MANUAL</code>, the payload is a <code>ManualAckListenerExecutionFailedException</code> with additional properties <code>channel</code> and <code>deliveryTag</code>.
This enables the error flow to call <code>basicAck</code> or <code>basicNack</code> (or <code>basicReject</code>) for the message, to control its disposition.</p>
</div>
</div>
<div class="sect2">
<h3 id="content-type-conversion-outbound"><a class="anchor" href="#content-type-conversion-outbound"></a>14.9. Outbound Message Conversion</h3>
<div class="paragraph">
<p>Spring AMQP 1.4 introduced the <code>ContentTypeDelegatingMessageConverter</code>, where the actual converter is selected based
on the incoming content type message property.
This can be used by inbound endpoints.</p>
</div>
<div class="paragraph">
<p>As of Spring Integration version 4.3, you can use the <code>ContentTypeDelegatingMessageConverter</code> on outbound endpoints as well, with the <code>contentType</code> header specifying which converter is used.</p>
</div>
<div class="paragraph">
<p>The following example configures a <code>ContentTypeDelegatingMessageConverter</code>, with the default converter being the <code>SimpleMessageConverter</code> (which handles Java serialization and plain text), together with a JSON converter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;amqp:outbound-channel-adapter id="withContentTypeConverter" channel="ctRequestChannel"
                               exchange-name="someExchange"
                               routing-key="someKey"
                               amqp-template="amqpTemplateContentTypeConverter" /&gt;

&lt;int:channel id="ctRequestChannel"/&gt;

&lt;rabbit:template id="amqpTemplateContentTypeConverter"
        connection-factory="connectionFactory" message-converter="ctConverter" /&gt;

&lt;bean id="ctConverter"
        class="o.s.amqp.support.converter.ContentTypeDelegatingMessageConverter"&gt;
    &lt;property name="delegates"&gt;
        &lt;map&gt;
            &lt;entry key="application/json"&gt;
                &lt;bean class="o.s.amqp.support.converter.Jackson2JsonMessageConverter" /&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Sending a message to <code>ctRequestChannel</code> with the <code>contentType</code> header set to <code>application/json</code> causes the JSON converter to be selected.</p>
</div>
<div class="paragraph">
<p>This applies to both the outbound channel adapter and gateway.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with version 5.0, headers that are added to the <code>MessageProperties</code> of the outbound message are never overwritten by mapped headers (by default).
Previously, this was only the case if the message converter was a <code>ContentTypeDelegatingMessageConverter</code> (in that case, the header was mapped first so that the proper converter could be selected).
For other converters, such as the <code>SimpleMessageConverter</code>, mapped headers overwrote any headers added by the converter.
This caused problems when an outbound message had some leftover <code>contentType</code> headers (perhaps from an inbound channel adapter) and the correct outbound <code>contentType</code> was incorrectly overwritten.
The work-around was to use a header filter to remove the header before sending the message to the outbound endpoint.</p>
</div>
<div class="paragraph">
<p>There are, however, cases where the previous behavior is desired&#8201;&#8212;&#8201;for example, when a <code>String</code> payload that contains JSON, the <code>SimpleMessageConverter</code> is not aware of the content and sets the <code>contentType</code> message property to <code>text/plain</code> but your application would like to override that to <code>application/json</code> by setting the <code>contentType</code> header of the message sent to the outbound endpoint.
The <code>ObjectToJsonTransformer</code> does exactly that (by default).</p>
</div>
<div class="paragraph">
<p>There is now a property called <code>headersMappedLast</code> on the outbound channel adapter and gateway (as well as on AMQP-backed channels).
Setting this to <code>true</code> restores the behavior of overwriting the property added by the converter.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="amqp-user-id"><a class="anchor" href="#amqp-user-id"></a>14.10. Outbound User ID</h3>
<div class="paragraph">
<p>Spring AMQP version 1.6 introduced a mechanism to allow the specification of a default user ID for outbound messages.
It has always been possible to set the <code>AmqpHeaders.USER_ID</code> header, which now takes precedence over the default.
This might be useful to message recipients.
For inbound messages, if the message publisher sets the property, it is made available in the <code>AmqpHeaders.RECEIVED_USER_ID</code> header.
Note that RabbitMQ <a href="https://www.rabbitmq.com/validated-user-id.html">validates that the user ID is the actual user ID for the connection or that the connection allows impersonation</a>.</p>
</div>
<div class="paragraph">
<p>To configure a default user ID for outbound messages, configure it on a <code>RabbitTemplate</code> and configure the outbound adapter or gateway to use that template.
Similarly, to set the user ID property on replies, inject an appropriately configured template into the inbound gateway.
See the <a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#template-user-id">Spring AMQP documentation</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="amqp-delay"><a class="anchor" href="#amqp-delay"></a>14.11. Delayed Message Exchange</h3>
<div class="paragraph">
<p>Spring AMQP supports the <a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#delayed-message-exchange">RabbitMQ Delayed Message Exchange Plugin</a>.
For inbound messages, the <code>x-delay</code> header is mapped to the <code>AmqpHeaders.RECEIVED_DELAY</code> header.
Setting the <code>AMQPHeaders.DELAY</code> header causes the corresponding <code>x-delay</code> header to be set in outbound messages.
You can also specify the <code>delay</code> and <code>delayExpression</code> properties on outbound endpoints (<code>delay-expression</code> when using XML configuration).
These properties take precedence over the <code>AmqpHeaders.DELAY</code> header.</p>
</div>
</div>
<div class="sect2">
<h3 id="amqp-channels"><a class="anchor" href="#amqp-channels"></a>14.12. AMQP-backed Message Channels</h3>
<div class="paragraph">
<p>There are two message channel implementations available.
One is point-to-point, and the other is publish-subscribe.
Both of these channels provide a wide range of configuration attributes for the underlying <code>AmqpTemplate</code> and
<code>SimpleMessageListenerContainer</code> (as shown earlier in this chapter for the channel adapters and gateways).
However, the examples we show here have minimal configuration.
Explore the XML schema to view the available attributes.</p>
</div>
<div class="paragraph">
<p>A point-to-point channel might look like the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:channel id="p2pChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Under the covers, the preceding example causes a <code>Queue</code> named <code>si.p2pChannel</code> to be declared, and this channel sends to that <code>Queue</code> (technically, by sending to the no-name direct exchange with a routing key that matches the name of this <code>Queue</code>).
This channel also registers a consumer on that <code>Queue</code>.
If you want the channel to be &#8220;pollable&#8221; instead of message-driven, provide the <code>message-driven</code> flag with a value of <code>false</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:channel id="p2pPollableChannel"  message-driven="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A publish-subscribe channel might look like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-amqp:publish-subscribe-channel id="pubSubChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Under the covers, the preceding example causes a fanout exchange named <code>si.fanout.pubSubChannel</code> to be declared, and this channel sends to that fanout exchange.
This channel also declares a server-named exclusive, auto-delete, non-durable <code>Queue</code> and binds that to the fanout exchange while registering a consumer on that <code>Queue</code> to receive messages.
There is no &#8220;pollable&#8221; option for a publish-subscribe-channel.
It must be message-driven.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.1, AMQP-backed message channels (in conjunction with <code>channel-transacted</code>) support
<code>template-channel-transacted</code> to separate <code>transactional</code> configuration for the <code>AbstractMessageListenerContainer</code> and
for the <code>RabbitTemplate</code>.
Note that, previously, <code>channel-transacted</code> was <code>true</code> by default.
Now, by default, it is <code>false</code> for the <code>AbstractMessageListenerContainer</code>.</p>
</div>
<div class="paragraph">
<p>Prior to version 4.3, AMQP-backed channels only supported messages with <code>Serializable</code> payloads and headers.
The entire message was converted (serialized) and sent to RabbitMQ.
Now, you can set the <code>extract-payload</code> attribute (or <code>setExtractPayload()</code> when using Java configuration) to <code>true</code>.
When this flag is <code>true</code>, the message payload is converted and the headers are mapped, in a manner similar to when you use channel adapters.
This arrangement lets AMQP-backed channels be used with non-serializable payloads (perhaps with another message converter, such as the <code>Jackson2JsonMessageConverter</code>).
See <a href="#amqp-message-headers">AMQP Message Headers</a> for more about the default mapped headers.
You can modify the mapping by providing custom mappers that use the <code>outbound-header-mapper</code> and <code>inbound-header-mapper</code> attributes.
You can now also specify a <code>default-delivery-mode</code>, which is used to set the delivery mode when there is no <code>amqp_deliveryMode</code> header.
By default, Spring AMQP <code>MessageProperties</code> uses <code>PERSISTENT</code> delivery mode.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As with other persistence-backed channels, AMQP-backed channels are intended to provide message persistence to avoid message loss.
They are not intended to distribute work to other peer applications.
For that purpose, use channel adapters instead.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.0, the pollable channel now blocks the poller thread for the specified <code>receiveTimeout</code> (the default is 1 second).
Previously, unlike other <code>PollableChannel</code> implementations, the thread returned immediately to the scheduler if no message was available, regardless of the receive timeout.
Blocking is a little more expensive than using a <code>basicGet()</code> to retrieve a message (with no timeout), because a consumer has to be created to receive each message.
To restore the previous behavior, set the poller&#8217;s <code>receiveTimeout</code> to 0.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-6"><a class="anchor" href="#configuring-with-java-configuration-6"></a>14.12.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following example shows how to configure the channels with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public AmqpChannelFactoryBean pollable(ConnectionFactory connectionFactory) {
    AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean();
    factoryBean.setConnectionFactory(connectionFactory);
    factoryBean.setQueueName("foo");
    factoryBean.setPubSub(false);
    return factoryBean;
}

@Bean
public AmqpChannelFactoryBean messageDriven(ConnectionFactory connectionFactory) {
    AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean(true);
    factoryBean.setConnectionFactory(connectionFactory);
    factoryBean.setQueueName("bar");
    factoryBean.setPubSub(false);
    return factoryBean;
}

@Bean
public AmqpChannelFactoryBean pubSub(ConnectionFactory connectionFactory) {
    AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean(true);
    factoryBean.setConnectionFactory(connectionFactory);
    factoryBean.setQueueName("baz");
    factoryBean.setPubSub(false);
    return factoryBean;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-7"><a class="anchor" href="#configuring-with-the-java-dsl-7"></a>14.12.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following example shows how to configure the channels with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow pollableInFlow(ConnectionFactory connectionFactory) {
    return IntegrationFlows.from(...)
            ...
            .channel(Amqp.pollableChannel(connectionFactory)
                    .queueName("foo"))
            ...
            .get();
}

@Bean
public IntegrationFlow messageDrivenInFow(ConnectionFactory connectionFactory) {
    return IntegrationFlows.from(...)
            ...
            .channel(Amqp.channel(connectionFactory)
                    .queueName("bar"))
            ...
            .get();
}

@Bean
public IntegrationFlow pubSubInFlow(ConnectionFactory connectionFactory) {
    return IntegrationFlows.from(...)
            ...
            .channel(Amqp.publisSubscribeChannel(connectionFactory)
                    .queueName("baz"))
            ...
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-message-headers"><a class="anchor" href="#amqp-message-headers"></a>14.13. AMQP Message Headers</h3>
<div class="sect3">
<h4 id="overview-2"><a class="anchor" href="#overview-2"></a>14.13.1. Overview</h4>
<div class="paragraph">
<p>The Spring Integration AMQP Adapters automatically map all AMQP properties and headers.
(This is a change from 4.3 - previously, only standard headers were mapped).
By default, these properties are copied to and from Spring Integration <code>MessageHeaders</code> by using the
<a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.html"><code>DefaultAmqpHeaderMapper</code></a>.</p>
</div>
<div class="paragraph">
<p>You can pass in your own implementation of AMQP-specific header mappers, as the adapters have properties to support doing so.</p>
</div>
<div class="paragraph">
<p>Any user-defined headers within the AMQP <a href="https://docs.spring.io/spring-amqp/api/org/springframework/amqp/core/MessageProperties.html"><code>MessageProperties</code></a> are copied to or from an AMQP message, unless explicitly negated by the <code>requestHeaderNames</code> or <code>replyHeaderNames</code> properties of the <code>DefaultAmqpHeaderMapper</code>.
By default, for an outbound mapper, no <code>x-*</code> headers are mapped.
See the <a href="#header-copy-caution">caution</a> that appears later in this section for why.</p>
</div>
<div class="paragraph">
<p>To override the default and revert to the pre-4.3 behavior, use <code>STANDARD_REQUEST_HEADERS</code> and
<code>STANDARD_REPLY_HEADERS</code> in the properties.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When mapping user-defined headers, the values can also contain simple wildcard patterns (such as 'thing*' or <code><strong>thing</code>) to be matched.
<code></strong></code> matches all headers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.1, the <code>AbstractHeaderMapper</code> (a <code>DefaultAmqpHeaderMapper</code> superclass) lets the <code>NON_STANDARD_HEADERS</code> token be configured for the <code>requestHeaderNames</code> and <code>replyHeaderNames</code> properties (in addition to the existing <code>STANDARD_REQUEST_HEADERS</code> and <code>STANDARD_REPLY_HEADERS</code>) to map all user-defined headers.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.amqp.support.AmqpHeaders</code> class identifies the default headers that are used by the
<code>DefaultAmqpHeaderMapper</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>amqp_appId</code></p>
</li>
<li>
<p><code>amqp_clusterId</code></p>
</li>
<li>
<p><code>amqp_contentEncoding</code></p>
</li>
<li>
<p><code>amqp_contentLength</code></p>
</li>
<li>
<p><code>content-type</code> (see <a href="#amqp-content-type">contentType Header</a>)</p>
</li>
<li>
<p><code>amqp_correlationId</code></p>
</li>
<li>
<p><code>amqp_delay</code></p>
</li>
<li>
<p><code>amqp_deliveryMode</code></p>
</li>
<li>
<p><code>amqp_deliveryTag</code></p>
</li>
<li>
<p><code>amqp_expiration</code></p>
</li>
<li>
<p><code>amqp_messageCount</code></p>
</li>
<li>
<p><code>amqp_messageId</code></p>
</li>
<li>
<p><code>amqp_receivedDelay</code></p>
</li>
<li>
<p><code>amqp_receivedDeliveryMode</code></p>
</li>
<li>
<p><code>amqp_receivedExchange</code></p>
</li>
<li>
<p><code>amqp_receivedRoutingKey</code></p>
</li>
<li>
<p><code>amqp_redelivered</code></p>
</li>
<li>
<p><code>amqp_replyTo</code></p>
</li>
<li>
<p><code>amqp_timestamp</code></p>
</li>
<li>
<p><code>amqp_type</code></p>
</li>
<li>
<p><code>amqp_userId</code></p>
</li>
<li>
<p><code>amqp_publishConfirm</code></p>
</li>
<li>
<p><code>amqp_publishConfirmNackCause</code></p>
</li>
<li>
<p><code>amqp_returnReplyCode</code></p>
</li>
<li>
<p><code>amqp_returnReplyText</code></p>
</li>
<li>
<p><code>amqp_returnExchange</code></p>
</li>
<li>
<p><code>amqp_returnRoutingKey</code></p>
</li>
<li>
<p><code>amqp_channel</code></p>
</li>
<li>
<p><code>amqp_consumerTag</code></p>
</li>
<li>
<p><code>amqp_consumerQueue</code></p>
</li>
</ul>
</div>
<div id="header-copy-caution" class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As mentioned earlier in this section, using a header mapping pattern of`<strong>` is a common way to copy all headers.
However, this can have some unexpected side effects, because certain RabbitMQ proprietary properties/headers are also
copied.
For example, when you use <a href="https://www.rabbitmq.com/federated-exchanges.html">federation</a>, the received message may have
a property named <code>x-received-from</code>, which contains the node that sent the message.
If you use the wildcard character <code></strong></code> for the request and reply header mapping on the inbound gateway, this header is copied, which may cause some issues with federation.
This reply message may be federated back to the sending broker, which may think that a message is looping and, as a result, silently drop it.
If you wish to use the convenience of wildcard header mapping, you may need to filter out some headers in the downstream flow.
For example, to avoid copying the <code>x-received-from</code> header back to the reply you can use <code>&lt;int:header-filter &#8230;&#8203; header-names="x-received-from"&gt;</code> before sending the reply to the AMQP inbound gateway.
Alternatively, you can explicitly list those properties that you actually want mapped, instead of using wildcards.
For these reasons, for inbound messages, the mapper (by default) does not map any <code>x-*</code> headers.
It also does not map the <code>deliveryMode</code> to the <code>amqp_deliveryMode</code> header, to avoid propagation of that header from an inbound message to an outbound message.
Instead, this header is mapped to <code>amqp_receivedDeliveryMode</code>, which is not mapped on output.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3, patterns in the header mappings can be negated by preceding the pattern with <code>!</code>.
Negated patterns get priority, so a list such as <code>STANDARD_REQUEST_HEADERS,thing1,ba*,!thing2,!thing3,qux,!thing1</code> does not map <code>thing1</code> (nor <code>thing2</code> nor <code>thing3</code>).
The standard headers plus <code>bad</code> and <code>qux</code> are mapped.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have a user-defined header that begins with <code>!</code> that you do wish to map, you need to escape it with <code>\</code>, as follows: <code>STANDARD_REQUEST_HEADERS,\!myBangHeader</code>.
The header named <code>!myBangHeader</code> is now mapped.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with <em>version 5.1</em>, the <code>DefaultAmqpHeaderMapper</code> will fall back to mapping <code>MessageHeaders.ID</code> and <code>MessageHeaders.TIMESTAMP</code> to <code>MessageProperties.messageId</code> and <code>MessageProperties.timestamp</code> respectively, if the corresponding <code>amqp_messageId</code> or <code>amqp_timestamp</code> headers are not present on outbound messages.
Inbound properties will be mapped to the <code>amqp_*</code> headers as before.
It is useful to populate the <code>messageId</code> property when message consumers are using stateful retry.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="amqp-content-type"><a class="anchor" href="#amqp-content-type"></a>14.13.2. contentType Header</h4>
<div class="paragraph">
<p>Unlike other headers, the <code>AmqpHeaders.CONTENT_TYPE</code> is not prefixed with <code>amqp_</code>; this allows transparent passing of the contentType header across different technologies.
For example an inbound HTTP message sent to a RabbitMQ queue.</p>
</div>
<div class="paragraph">
<p>The <code>contentType</code> header is mapped to Spring AMQP&#8217;s <code>MessageProperties.contentType</code> property and that is subsequently mapped to RabbitMQ&#8217;s <code>content_type</code> property.</p>
</div>
<div class="paragraph">
<p>Prior to <em>version 5.1</em>, this header was also mapped as an entry in the <code>MessageProperties.headers</code> map; this was incorrect and, furthermore, the value could be wrong since the underlying Spring AMQP message converter might have changed the content type.
Such a change would be reflected in the first-class <code>content_type</code> property, but not in the RabbitMQ headers map.
Inbound mapping ignored the headers map value.
<code>contentType</code> is no longer mapped to an entry in the headers map.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-strict-ordering"><a class="anchor" href="#amqp-strict-ordering"></a>14.14. Strict Message Ordering</h3>
<div class="paragraph">
<p>This section describes message ordering for inbound and outbound messages.</p>
</div>
<div class="sect3">
<h4 id="inbound"><a class="anchor" href="#inbound"></a>14.14.1. Inbound</h4>
<div class="paragraph">
<p>If you require strict ordering of inbound messages, you must configure the inbound listener container&#8217;s <code>prefetchCount</code> property to <code>1</code>.
This is because, if a message fails and is redelivered, it arrives after existing prefetched messages.
Since Spring AMQP version 2.0, the <code>prefetchCount</code> defaults to <code>250</code> for improved performance.
Strict ordering requirements come at the cost of decreased performance.</p>
</div>
</div>
<div class="sect3">
<h4 id="outbound"><a class="anchor" href="#outbound"></a>14.14.2. Outbound</h4>
<div class="paragraph">
<p>Consider the following integration flow:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow(RabbitTemplate template) {
    return IntegrationFlows.from(Gateway.class)
            .split(s -&gt; s.delimiters(","))
            .&lt;String, String&gt;transform(String::toUpperCase)
            .handle(Amqp.outboundAdapter(template).routingKey("rk"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Suppose we send messages <code>A</code>, <code>B</code> and <code>C</code> to the gateway.
While it is likely that messages <code>A</code>, <code>B</code>, <code>C</code> are sent in order, there is no guarantee.
This is because the template &#8220;borrows&#8221; a channel from the cache for each send operation, and there is no guarantee that the same channel is used for each message.
One solution is to start a transaction before the splitter, but transactions are expensive in RabbitMQ and can reduce performance several hundred fold.</p>
</div>
<div class="paragraph">
<p>To solve this problem in a more efficient manner, starting with version 5.1, Spring Integration provides the <code>BoundRabbitChannelAdvice</code> which is a <code>HandleMessageAdvice</code>.
See <a href="#handle-message-advice">Handling Message Advice</a>.
When applied before the splitter, it ensures that all downstream operations are performed on the same channel and, optionally, can wait until publisher confirmations for all sent messages are received (if the connection factory is configured for confirmations).
The following example shows how to use <code>BoundRabbitChannelAdvice</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow(RabbitTemplate template) {
    return IntegrationFlows.from(Gateway.class)
            .split(s -&gt; s.delimiters(",")
                    .advice(new BoundRabbitChannelAdvice(template, Duration.ofSeconds(10))))
            .&lt;String, String&gt;transform(String::toUpperCase)
            .handle(Amqp.outboundAdapter(template).routingKey("rk"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the same <code>RabbitTemplate</code> (which implements <code>RabbitOperations</code>) is used in the advice and the outbound adapter.
The advice runs the downstream flow within the template&#8217;s <code>invoke</code> method so that all operations run on the same channel.
If the optional timeout is provided, when the flow completes, the advice calls the <code>waitForConfirmsOrDie</code> method, which throws an exception if the confirmations are not received within the specified time.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
There must be no thread handoffs in the downstream flow (<code>QueueChannel</code>, <code>ExecutorChannel</code>, and others).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="amqp-samples"><a class="anchor" href="#amqp-samples"></a>14.15. AMQP Samples</h3>
<div class="paragraph">
<p>To experiment with the AMQP adapters, check out the samples available in the Spring Integration samples git repository at <a href="https://github.com/spring-projects/spring-integration-samples">https://github.com/SpringSource/spring-integration-samples</a></p>
</div>
<div class="paragraph">
<p>Currently, one sample demonstrates the basic functionality of the Spring Integration AMQP adapter by using an outbound channel adapter and an inbound channel adapter.
As AMQP broker implementation in the sample uses <a href="https://www.rabbitmq.com/">RabbitMQ</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In order to run the example, you need a running instance of RabbitMQ.
A local installation with just the basic defaults suffices.
For detailed RabbitMQ installation procedures, see <a href="https://www.rabbitmq.com/install.html">https://www.rabbitmq.com/install.html</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the sample application is started, enter some text on the command prompt and a message containing that entered text is dispatched to the AMQP queue.
In return, that message is retrieved by Spring Integration and printed to the console.</p>
</div>
<div class="paragraph">
<p>The following image illustrates the basic set of Spring Integration components used in this sample.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-integration-amqp-sample-graph.png" alt="spring integration amqp sample graph">
</div>
<div class="title">Figure 7. The Spring Integration graph of the AMQP sample</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="applicationevent"><a class="anchor" href="#applicationevent"></a>15. Spring <code>ApplicationEvent</code> Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides support for inbound and outbound <code>ApplicationEvents</code>, as defined by the underlying Spring Framework.
For more information about Spring&#8217;s support for events and listeners, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#context-functionality-events">Spring Reference Manual</a>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-event&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-event:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appevent-inbound"><a class="anchor" href="#appevent-inbound"></a>15.1. Receiving Spring Application Events</h3>
<div class="paragraph">
<p>To receive events and send them to a channel, you can define an instance of Spring Integration&#8217;s <code>ApplicationEventListeningMessageProducer</code>.
This class is an implementation of Spring&#8217;s <code>ApplicationListener</code> interface.
By default, it passes all received events as Spring Integration messages.
To limit based on the type of event, you can use the 'eventTypes' property to configure the list of event types that you want to receive.
If a received event has a <code>Message</code> instance as its 'source', that <code>Message</code> is passed as-is.
Otherwise, if a SpEL-based <code>payloadExpression</code> has been provided, that is evaluated against the <code>ApplicationEvent</code> instance.
If the event&#8217;s source is not a <code>Message</code> instance and no <code>payloadExpression</code> has been provided, the <code>ApplicationEvent</code> itself is passed as the payload.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>ApplicationEventListeningMessageProducer</code> implements <code>GenericApplicationListener</code> and can be configured to accept not only <code>ApplicationEvent</code> types but any type for treating payload events (which are also supported since Spring Framework 4.2).
When the accepted event is an instance of <code>PayloadApplicationEvent</code>, its <code>payload</code> is used for the message to send.</p>
</div>
<div class="paragraph">
<p>For convenience, namespace support is provided to configurean <code>ApplicationEventListeningMessageProducer</code> with the <code>inbound-channel-adapter</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-event:inbound-channel-adapter channel="eventChannel"
                                   error-channel="eventErrorChannel"
                                   event-types="example.FooEvent, example.BarEvent, java.util.Date"/&gt;

&lt;int:publish-subscribe-channel id="eventChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, all application context events that match one of the types specified by the 'event-types' (optional) attribute are delivered as Spring Integration messages to the message channel named 'eventChannel'.
If a downstream component throws an exception, a <code>MessagingException</code> that contains the failed message and exception is sent to the channel named 'eventErrorChannel'.
If no <code>error-channel</code> is specified and the downstream channels are synchronous, the exception is propagated to the caller.</p>
</div>
</div>
<div class="sect2">
<h3 id="appevent-outbound"><a class="anchor" href="#appevent-outbound"></a>15.2. Sending Spring Application Events</h3>
<div class="paragraph">
<p>To send Spring <code>ApplicationEvents</code>, create an instance of the <code>ApplicationEventPublishingMessageHandler</code> and register it within an endpoint.
This implementation of the <code>MessageHandler</code> interface also implements Spring&#8217;s <code>ApplicationEventPublisherAware</code> interface and consequently acts as a bridge between Spring Integration messages and <code>ApplicationEvents</code>.</p>
</div>
<div class="paragraph">
<p>For convenience, namespace support is provided to configurean <code>ApplicationEventPublishingMessageHandler</code> with the <code>outbound-channel-adapter</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="eventChannel"/&gt;

&lt;int-event:outbound-channel-adapter channel="eventChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you use a <code>PollableChannel</code> (such as a <code>Queue</code>), you can also provide <code>poller</code> as a child element of the <code>outbound-channel-adapter</code> element.
You can also optionally provide a <code>task-executor</code> reference for that poller.
The following example demonstrates both:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="eventChannel"&gt;
  &lt;int:queue/&gt;
&lt;/int:channel&gt;

&lt;int-event:outbound-channel-adapter channel="eventChannel"&gt;
  &lt;int:poller max-messages-per-poll="1" task-executor="executor" fixed-rate="100"/&gt;
&lt;/int-event:outbound-channel-adapter&gt;

&lt;task:executor id="executor" pool-size="5"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, all messages sent to the 'eventChannel' channel are published as <code>ApplicationEvent</code> instances to any relevant <code>ApplicationListener</code> instances that are registered within the same Spring <code>ApplicationContext</code>.
If the payload of the message is an <code>ApplicationEvent</code>, it is passed as-is.
Otherwise, the message itself is wrapped in a <code>MessagingEvent</code> instance.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, you can configure the <code>ApplicationEventPublishingMessageHandler</code> (<code>&lt;int-event:outbound-channel-adapter&gt;</code>) with the <code>publish-payload</code> boolean attribute to publish to the application context <code>payload</code> as is, instead of wrapping it to a <code>MessagingEvent</code> instance.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="feed"><a class="anchor" href="#feed"></a>16. Feed Adapter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides support for syndication through feed adapters.
The implementation is based on the <a href="https://rometools.github.io/rome/">ROME Framework</a>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-feed&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-feed:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Web syndication is a way to publish material such as news stories, press releases, blog posts, and other items typically available on a website but also made available in a feed format such as RSS or ATOM.</p>
</div>
<div class="paragraph">
<p>Spring integration provides support for web syndication through its 'feed' adapter and provides convenient namespace-based configuration for it.
To configure the 'feed' namespace, include the following elements within the headers of your XML configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">xmlns:int-feed="http://www.springframework.org/schema/integration/feed"
xsi:schemaLocation="http://www.springframework.org/schema/integration/feed
	https://www.springframework.org/schema/integration/feed/spring-integration-feed.xsd"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="feed-inbound-channel-adapter"><a class="anchor" href="#feed-inbound-channel-adapter"></a>16.1. Feed Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The only adapter you really need to provide support for retrieving feeds is an inbound channel adapter.
It lets you subscribe to a particular URL.
The following example shows a possible configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-feed:inbound-channel-adapter id="feedAdapter"
        channel="feedChannel"
        url="https://feeds.bbci.co.uk/news/rss.xml"&gt;
    &lt;int:poller fixed-rate="10000" max-messages-per-poll="100" /&gt;
&lt;/int-feed:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, we are subscribing to a URL identified by the <code>url</code> attribute.</p>
</div>
<div class="paragraph">
<p>As news items are retrieved, they are converted to messages and sent to a channel identified by the <code>channel</code> attribute.
The payload of each message is a <code>com.sun.syndication.feed.synd.SyndEntry</code> instance.
Each one encapsulates various data about a news item (content, dates, authors, and other details).</p>
</div>
<div class="paragraph">
<p>The inbound feed channel adapter is a polling consumer.
That means that you must provide a poller configuration.
However, one important thing you must understand with regard to a feed is that its inner workings are slightly different then most other polling consumers.
When an inbound feed adapter is started, it does the first poll and receives a <code>com.sun.syndication.feed.synd.SyndEntryFeed</code> instance.
That object contains multiple <code>SyndEntry</code> objects.
Each entry is stored in the local entry queue and is released based on the value in the <code>max-messages-per-poll</code> attribute, such that each message contains a single entry.
If, during retrieval of the entries from the entry queue, the queue has become empty, the adapter attempts to update the feed, thereby populating the queue with more entries (<code>SyndEntry</code> instances), if any are available.
Otherwise the next attempt to poll for a feed is determined by the trigger of the poller (every ten seconds in the preceding configuration).</p>
</div>
</div>
<div class="sect2">
<h3 id="duplicate-entries"><a class="anchor" href="#duplicate-entries"></a>16.2. Duplicate Entries</h3>
<div class="paragraph">
<p>Polling for a feed can result in entries that have already been processed (&#8220;I already read that news item, why are you showing it to me again?&#8221;).
Spring Integration provides a convenient mechanism to eliminate the need to worry about duplicate entries.
Each feed entry has a &#8220;published date&#8221; field.
Every time a new <code>Message</code> is generated and sent, Spring Integration stores the value of the latest published date in an instance of the <code>MetadataStore</code> strategy (see <a href="#metadata-store">Metadata Store</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The key used to persist the latest published date is the value of the (required) <code>id</code> attribute of the feed inbound channel adapter component plus the <code>feedUrl</code> (if any) from the adapter&#8217;s configuration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="other-options"><a class="anchor" href="#other-options"></a>16.3. Other Options</h3>
<div class="paragraph">
<p>Starting with version 5.0, the deprecated <code>com.rometools.fetcher.FeedFetcher</code> option has been removed and an overloaded <code>FeedEntryMessageSource</code> constructor for an <code>org.springframework.core.io.Resource</code> is provided.
This is useful when the feed source is not an HTTP endpoint but is any other resource (such as local or remote on FTP).
In the <code>FeedEntryMessageSource</code> logic, such a resource (or provided <code>URL</code>) is parsed by the <code>SyndFeedInput</code> to the <code>SyndFeed</code> object for the processing mentioned earlier.
You can also inject a customized <code>SyndFeedInput</code> (for example, with the <code>allowDoctypes</code> option) instance into the <code>FeedEntryMessageSource</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="feed-java-configuration"><a class="anchor" href="#feed-java-configuration"></a>16.4. Java DSL Configuration</h3>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FeedJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FeedJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Value("org/springframework/integration/feed/sample.rss")
    private Resource feedResource;

    @Bean
    public MetadataStore metadataStore() {
        PropertiesPersistingMetadataStore metadataStore = new PropertiesPersistingMetadataStore();
        metadataStore.setBaseDirectory(tempFolder.getRoot().getAbsolutePath());
        return metadataStore;
    }

    @Bean
    public IntegrationFlow feedFlow() {
        return IntegrationFlows
                .from(Feed.inboundAdapter(this.feedResource, "feedTest")
                                .metadataStore(metadataStore()),
                        e -&gt; e.poller(p -&gt; p.fixedDelay(100)))
                .channel(c -&gt; c.queue("entries"))
                .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="files"><a class="anchor" href="#files"></a>17. File Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration&#8217;s file support extends the Spring Integration core with a dedicated vocabulary to deal with reading, writing, and transforming files.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-file&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-file:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It provides a namespace that enables elements defining channel adapters dedicated to files and support for transformers that can read file contents into strings or byte arrays.</p>
</div>
<div class="paragraph">
<p>This section explains the workings of <code>FileReadingMessageSource</code> and <code>FileWritingMessageHandler</code> and how to configure them as beans.
It also discusses the support for dealing with files through file-specific implementations of <code>Transformer</code>.
Finally, it explains the file-specific namespace.</p>
</div>
<div class="sect2">
<h3 id="file-reading"><a class="anchor" href="#file-reading"></a>17.1. Reading Files</h3>
<div class="paragraph">
<p>A <code>FileReadingMessageSource</code> can be used to consume files from the filesystem.
This is an implementation of <code>MessageSource</code> that creates messages from a file system directory.
The following example shows how to configure a <code>FileReadingMessageSource</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="pollableFileSource"
    class="org.springframework.integration.file.FileReadingMessageSource"
    p:directory="${input.directory}"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To prevent creating messages for certain files, you can supply a <code>FileListFilter</code>.
By default, we use the following filters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IgnoreHiddenFileListFilter</code></p>
</li>
<li>
<p><code>AcceptOnceFileListFilter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>IgnoreHiddenFileListFilter</code> ensures that hidden files are not processed.
Note that the exact definition of hidden is system-dependent.
For example, on UNIX-based systems, a file beginning with a period character is considered to be hidden.
Microsoft Windows, on the other hand, has a dedicated file attribute to indicate hidden files.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Version 4.2 introduced the <code>IgnoreHiddenFileListFilter</code>.
In prior versions, hidden files were included.
With the default configuration, the <code>IgnoreHiddenFileListFilter</code> is triggered first, followed by the <code>AcceptOnceFileListFilter</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>AcceptOnceFileListFilter</code> ensures files are picked up only once from the directory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>AcceptOnceFileListFilter</code> stores its state in memory.
If you wish the state to survive a system restart, you can use the <code>FileSystemPersistentAcceptOnceFileListFilter</code>.
This filter stores the accepted file names in a <code>MetadataStore</code> implementation (see <a href="#metadata-store">Metadata Store</a>).
This filter matches on the filename and modified time.</p>
</div>
<div class="paragraph">
<p>Since version 4.0, this filter requires a <code>ConcurrentMetadataStore</code>.
When used with a shared data store (such as <code>Redis</code> with the <code>RedisMetadataStore</code>), it lets filter keys be shared across multiple application instances or across a network file share being used by multiple servers.</p>
</div>
<div class="paragraph">
<p>Since version 4.1.5, this filter has a new property (<code>flushOnUpdate</code>), which causes it to flush the metadata store on every update (if the store implements <code>Flushable</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example configures a <code>FileReadingMessageSource</code> with a filter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="pollableFileSource"
    class="org.springframework.integration.file.FileReadingMessageSource"
    p:inputDirectory="${input.directory}"
    p:filter-ref="customFilterBean"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A common problem with reading files is that a file may be detected before it is ready (that is, some other process may still be writing the file).
The default <code>AcceptOnceFileListFilter</code> does not prevent this.
In most cases, this can be prevented if the file-writing process renames each file as soon as it is ready for reading.
A <code>filename-pattern</code> or <code>filename-regex</code> filter that accepts only files that are ready (perhaps based on a known suffix), composed with the default <code>AcceptOnceFileListFilter</code>, allows for this situation.
The <code>CompositeFileListFilter</code> enables the composition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="pollableFileSource"
    class="org.springframework.integration.file.FileReadingMessageSource"
    p:inputDirectory="${input.directory}"
    p:filter-ref="compositeFilter"/&gt;

&lt;bean id="compositeFilter"
    class="org.springframework.integration.file.filters.CompositeFileListFilter"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;bean class="o.s.i.file.filters.AcceptOnceFileListFilter"/&gt;
            &lt;bean class="o.s.i.file.filters.RegexPatternFileListFilter"&gt;
                &lt;constructor-arg value="^test.*$"/&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If it is not possible to create the file with a temporary name and rename to the final name, Spring Integration provides another alternative.
Version 4.2 added the <code>LastModifiedFileListFilter</code>.
This filter can be configured with an <code>age</code> property so that only files older than this value are passed by the filter.
The age defaults to 60 seconds, but you should choose an age that is large enough to avoid picking up a file early (due to, say, network glitches).
The following example shows how to configure a <code>LastModifiedFileListFilter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="filter" class="org.springframework.integration.file.filters.LastModifiedFileListFilter"&gt;
    &lt;property name="age" value="120" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.3.7, a <code>ChainFileListFilter</code> (an extension of <code>CompositeFileListFilter</code>) has been introduced to allow scenarios when subsequent filters should only see the result of the previous filter.
(With the <code>CompositeFileListFilter</code>, all filters see all the files, but it passes only files that have passed all filters).
An example of where the new behavior is required is a combination of <code>LastModifiedFileListFilter</code> and <code>AcceptOnceFileListFilter</code>, when we do not wish to accept the file until some amount of time has elapsed.
With the <code>CompositeFileListFilter</code>, since the <code>AcceptOnceFileListFilter</code> sees all the files on the first pass, it does not pass it later when the other filter does.
The <code>CompositeFileListFilter</code> approach is useful when a pattern filter is combined with a custom filter that looks for a secondary file to indicate that file transfer is complete.
The pattern filter might only pass the primary file (such as <code>something.txt</code>) but the &#8220;done&#8221; filter needs to see whether (for example) <code>something.done</code> is present.</p>
</div>
<div class="paragraph">
<p>Say we have files <code>a.txt</code>, <code>a.done</code>, and <code>b.txt</code>.</p>
</div>
<div class="paragraph">
<p>The pattern filter passes only <code>a.txt</code> and <code>b.txt</code>, while the &#8220;done&#8221; filter sees all three files and passes only <code>a.txt</code>.
The final result of the composite filter is that only <code>a.txt</code> is released.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With the <code>ChainFileListFilter</code>, if any filter in the chain returns an empty list, the remaining filters are not invoked.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Version 5.0 introduced an <code>ExpressionFileListFilter</code> to execute SpEL expression against a file as a context evaluation root object.
For this purpose, all the XML components for file handling (local and remote), along with an existing <code>filter</code> attribute, have been supplied with the <code>filter-expression</code> option, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter
        directory="${inputdir}"
        filter-expression="name matches '.text'"
        auto-startup="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Version 5.0.5 introduced the <code>DiscardAwareFileListFilter</code> implementations that have an interest in rejected files.
For this purpose, such a filter implementation should be supplied with a callback through <code>addDiscardCallback(Consumer&lt;File&gt;)</code>.
In the framework, this functionality is used from the <code>FileReadingMessageSource.WatchServiceDirectoryScanner</code>, in combination with <code>LastModifiedFileListFilter</code>.
Unlike the regular <code>DirectoryScanner</code>, the <code>WatchService</code> provides files for processing according to the events on the target file system.
At the moment of polling an internal queue with those files, the <code>LastModifiedFileListFilter</code> may discard them because they are too young relative to its configured <code>age</code>.
Therefore, we lose the file for future possible considerations.
The discard callback hook lets us retain the file in the internal queue so that it is available to be checked against the <code>age</code> in subsequent polls.
The <code>CompositeFileListFilter</code> also implements a <code>DiscardAwareFileListFilter</code> and populates a discard callback to all its <code>DiscardAwareFileListFilter</code> delegates.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since <code>CompositeFileListFilter</code> matches the files against all delegates, the <code>discardCallback</code> may be called several times for the same file.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>FileReadingMessageSource</code> doesn&#8217;t check a directory for existence and doesn&#8217;t create it until its <code>start()</code> is called (typically via wrapping <code>SourcePollingChannelAdapter</code>).
Previously, there was no simple way to prevent an operation system permissions error when referencing the directory, for example from tests, or when permissions are applied later.</p>
</div>
<div class="sect3">
<h4 id="message-headers-2"><a class="anchor" href="#message-headers-2"></a>17.1.1. Message Headers</h4>
<div class="paragraph">
<p>Starting with version 5.0, the <code>FileReadingMessageSource</code> (in addition to the <code>payload</code> as a polled <code>File</code>) populates the following headers to the outbound <code>Message</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileHeaders.FILENAME</code>: The <code>File.getName()</code> of the file to send.
Can be used for subsequent rename or copy logic.</p>
</li>
<li>
<p><code>FileHeaders.ORIGINAL_FILE</code>: The <code>File</code> object itself.
Typically, this header is populated automatically by framework components (such as <a href="#file-splitter">splitters</a> or <a href="#file-transforming">transformers</a>) when we lose the original <code>File</code> object.
However, for consistency and convenience with any other custom use cases, this header can be useful to get access to the original file.</p>
</li>
<li>
<p><code>FileHeaders.RELATIVE_PATH</code>: A new header introduced to represent the part of file path relative to the root directory for the scan.
This header can be useful when the requirement is to restore a source directory hierarchy in the other places.
For this purpose, the <code>DefaultFileNameGenerator</code> (see "`<a href="#file-writing-file-names">Generating File Names</a>) can be configured to use this header.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="directory-scanning-and-polling"><a class="anchor" href="#directory-scanning-and-polling"></a>17.1.2. Directory Scanning and Polling</h4>
<div class="paragraph">
<p>The <code>FileReadingMessageSource</code> does not produce messages for files from the directory immediately.
It uses an internal queue for 'eligible files' returned by the <code>scanner</code>.
The <code>scanEachPoll</code> option is used to ensure that the internal queue is refreshed with the latest input directory content on each poll.
By default (<code>scanEachPoll = false</code>), the <code>FileReadingMessageSource</code> empties its queue before scanning the directory again.
This default behavior is particularly useful to reduce scans of large numbers of files in a directory.
However, in cases where custom ordering is required, it is important to consider the effects of setting this flag to <code>true</code>.
The order in which files are processed may not be as expected.
By default, files in the queue are processed in their natural (<code>path</code>) order.
New files added by a scan, even when the queue already has files, are inserted in the appropriate position to maintain that natural order.
To customize the order, the <code>FileReadingMessageSource</code> can accept a <code>Comparator&lt;File&gt;</code> as a constructor argument.
It is used by the internal (<code>PriorityBlockingQueue</code>) to reorder its content according to the business requirements.
Therefore, to process files in a specific order, you should provide a comparator to the <code>FileReadingMessageSource</code> rather than ordering the list produced by a custom <code>DirectoryScanner</code>.</p>
</div>
<div class="paragraph">
<p>Version 5.0 introduced <code>RecursiveDirectoryScanner</code> to perform file tree visiting.
The implementation is based on the <code>Files.walk(Path start, int maxDepth, FileVisitOption&#8230;&#8203; options)</code> functionality.
The root directory (<code>DirectoryScanner.listFiles(File)</code>) argument is excluded from the result.
All other sub-directories inclusions and exclusions are based on the target <code>FileListFilter</code> implementation.
For example, the <code>SimplePatternFileListFilter</code> filters out directories by default.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/filters/AbstractDirectoryAwareFileListFilter.html"><code>AbstractDirectoryAwareFileListFilter</code></a> and its implementations for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-namespace-support"><a class="anchor" href="#file-namespace-support"></a>17.1.3. Namespace Support</h4>
<div class="paragraph">
<p>The configuration for file reading can be simplified by using the file-specific namespace.
To do so, use the following template:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-file="http://www.springframework.org/schema/integration/file"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/file
    https://www.springframework.org/schema/integration/file/spring-integration-file.xsd"&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Within this namespace, you can reduce the <code>FileReadingMessageSource</code> and wrap it in an inbound Channel Adapter, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="filesIn1"
    directory="file:${input.directory}" prevent-duplicates="true" ignore-hidden="true"/&gt;

&lt;int-file:inbound-channel-adapter id="filesIn2"
    directory="file:${input.directory}"
    filter="customFilterBean" /&gt;

&lt;int-file:inbound-channel-adapter id="filesIn3"
    directory="file:${input.directory}"
    filename-pattern="test*" /&gt;

&lt;int-file:inbound-channel-adapter id="filesIn4"
    directory="file:${input.directory}"
    filename-regex="test[0-9]+\.txt" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first channel adapter example relies on the default <code>FileListFilter</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IgnoreHiddenFileListFilter</code> (do not process hidden files)</p>
</li>
<li>
<p><code>AcceptOnceFileListFilter</code> (prevent duplication)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, you can also leave off the <code>prevent-duplicates</code> and <code>ignore-hidden</code> attributes, as they are <code>true</code> by default.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Integration 4.2 introduced the <code>ignore-hidden</code> attribute.
In prior versions, hidden files were included.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second channel adapter example uses a custom filter, the third uses the <code>filename-pattern</code> attribute to add an <code>AntPathMatcher</code> based filter, and the fourth uses the <code>filename-regex</code> attribute to add a regular expression pattern-based filter to the <code>FileReadingMessageSource</code>.
The <code>filename-pattern</code> and <code>filename-regex</code> attributes are each mutually exclusive with the regular <code>filter</code> reference attribute.
However, you can use the <code>filter</code> attribute to reference an instance of <code>CompositeFileListFilter</code> that combines any number of filters, including one or more pattern-based filters to fit your particular needs.</p>
</div>
<div class="paragraph">
<p>When multiple processes read from the same directory, you may want to lock files to prevent them from being picked up concurrently.
To do so, you can use a <code>FileLocker</code>.
There is a <code>java.nio</code>-based implementation available, but it is also possible to implement your own locking scheme.
The <code>nio</code> locker can be injected as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="filesIn"
    directory="file:${input.directory}" prevent-duplicates="true"&gt;
    &lt;int-file:nio-locker/&gt;
&lt;/int-file:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can configure a custom locker as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="filesIn"
    directory="file:${input.directory}" prevent-duplicates="true"&gt;
    &lt;int-file:locker ref="customLocker"/&gt;
&lt;/int-file:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a file inbound adapter is configured with a locker, it takes responsibility for acquiring a lock before the file is allowed to be received.
It does not assume the responsibility to unlock the file.
If you have processed the file and keep the locks hanging around, you have a memory leak.
If this is a problem, you should call <code>FileLocker.unlock(File file)</code> yourself at the appropriate time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When filtering and locking files is not enough, you might need to control the way files are listed entirely.
To implement this type of requirement, you can use an implementation of <code>DirectoryScanner</code>.
This scanner lets you determine exactly what files are listed in each poll.
This is also the interface that Spring Integration uses internally to wire <code>FileListFilter</code> instances and <code>FileLocker</code> to the <code>FileReadingMessageSource</code>.
You can inject a custom <code>DirectoryScanner</code> into the <code>&lt;int-file:inbound-channel-adapter/&gt;</code> on the <code>scanner</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="filesIn" directory="file:${input.directory}"
     scanner="customDirectoryScanner"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Doing so gives you full freedom to choose the ordering, listing, and locking strategies.</p>
</div>
<div class="paragraph">
<p>It is also important to understand that filters (including <code>patterns</code>, <code>regex</code>, <code>prevent-duplicates</code>, and others) and <code>locker</code> instances are actually used by the <code>scanner</code>.
Any of these attributes set on the adapter are subsequently injected into the internal <code>scanner</code>.
For the case of an external <code>scanner</code>, all filter and locker attributes are prohibited on the <code>FileReadingMessageSource</code>.
They must be specified (if required) on that custom <code>DirectoryScanner</code>.
In other words, if you inject a <code>scanner</code> into the <code>FileReadingMessageSource</code>, you should supply <code>filter</code> and <code>locker</code> on that <code>scanner</code>, not on the <code>FileReadingMessageSource</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, the <code>DefaultDirectoryScanner</code> uses an <code>IgnoreHiddenFileListFilter</code> and an <code>AcceptOnceFileListFilter</code>.
To prevent their use, you can configure your own filter (such as <code>AcceptAllFileListFilter</code>) or even set it to <code>null</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="watch-service-directory-scanner"><a class="anchor" href="#watch-service-directory-scanner"></a>17.1.4. <code>WatchServiceDirectoryScanner</code></h4>
<div class="paragraph">
<p>The <code>FileReadingMessageSource.WatchServiceDirectoryScanner</code> relies on file-system events when new files are added to the directory.
During initialization, the directory is registered to generate events.
The initial file list is also built during initialization.
While walking the directory tree, any subdirectories encountered are also registered to generate events.
On the first poll, the initial file list from walking the directory is returned.
On subsequent polls, files from new creation events are returned.
If a new subdirectory is added, its creation event is used to walk the new subtree to find existing files and register any new subdirectories found.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is an issue with <code>WatchKey</code> when its internal events <code>queue</code> is not drained by the program as quickly as the directory modification events occur.
If the queue size is exceeded, a <code>StandardWatchEventKinds.OVERFLOW</code> is emitted to indicate that some file system events may be lost.
In this case, the root directory is re-scanned completely.
To avoid duplicates, consider using an appropriate <code>FileListFilter</code> (such as the <code>AcceptOnceFileListFilter</code>) or removing files when processing is complete.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>WatchServiceDirectoryScanner</code> can be enabled through the <code>FileReadingMessageSource.use-watch-service</code> option, which is mutually exclusive with the <code>scanner</code> option.
An internal <code>FileReadingMessageSource.WatchServiceDirectoryScanner</code> instance is populated for the provided <code>directory</code>.</p>
</div>
<div class="paragraph">
<p>In addition, now the <code>WatchService</code> polling logic can track the <code>StandardWatchEventKinds.ENTRY_MODIFY</code> and <code>StandardWatchEventKinds.ENTRY_DELETE</code>.</p>
</div>
<div class="paragraph">
<p>If you need to track the modification of existing files as well as new files, you should implement the <code>ENTRY_MODIFY</code> events logic in the <code>FileListFilter</code>.
Otherwise, the files from those events are treated the same way.</p>
</div>
<div class="paragraph">
<p>The <code>ResettableFileListFilter</code> implementations pick up the <code>ENTRY_DELETE</code> events.
Consequently, their files are provided for the <code>remove()</code> operation.
When this event is enabled, filters such as the <code>AcceptOnceFileListFilter</code> have the file removed
As a result, if a file with the same name appears, it passes the filter and is sent as a message.</p>
</div>
<div class="paragraph">
<p>For this purpose, the <code>watch-events</code> property (<code>FileReadingMessageSource.setWatchEvents(WatchEventType&#8230;&#8203; watchEvents)</code>) has been introduced.
(<code>WatchEventType</code> is a public inner enumeration in <code>FileReadingMessageSource</code>.)
With such an option, we can use one downstream flow logic for new files and use some other logic for modified files.
The following example shows how to configure different logic for create and modify events in the same directory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="newFiles"
     directory="${input.directory}"
     use-watch-service="true"/&gt;

&lt;int-file:inbound-channel-adapter id="modifiedFiles"
     directory="${input.directory}"
     use-watch-service="true"
     filter="acceptAllFilter"
     watch-events="MODIFY"/&gt; &lt;!-- The default is CREATE. --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="limiting-memory-consumption"><a class="anchor" href="#limiting-memory-consumption"></a>17.1.5. Limiting Memory Consumption</h4>
<div class="paragraph">
<p>You can use a <code>HeadDirectoryScanner</code> to limit the number of files retained in memory.
This can be useful when scanning large directories.
With XML configuration, this is enabled by setting the <code>queue-size</code> property on the inbound channel adapter.</p>
</div>
<div class="paragraph">
<p>Prior to version 4.2, this setting was incompatible with the use of any other filters.
Any other filters (including <code>prevent-duplicates="true"</code>) overwrote the filter used to limit the size.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The use of a <code>HeadDirectoryScanner</code> is incompatible with an <code>AcceptOnceFileListFilter</code>.
Since all filters are consulted during the poll decision, the <code>AcceptOnceFileListFilter</code> does not know that other filters might be temporarily filtering files.
Even if files that were previously filtered by the <code>HeadDirectoryScanner.HeadFilter</code> are now available, the <code>AcceptOnceFileListFilter</code> filters them.</p>
</div>
<div class="paragraph">
<p>Generally, instead of using an <code>AcceptOnceFileListFilter</code> in this case, you should remove the processed files so that the previously filtered files are available on a future poll.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-7"><a class="anchor" href="#configuring-with-java-configuration-7"></a>17.1.6. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FileReadingJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FileReadingJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public MessageChannel fileInputChannel() {
        return new DirectChannel();
    }

    @Bean
    @InboundChannelAdapter(value = "fileInputChannel", poller = @Poller(fixedDelay = "1000"))
    public MessageSource&lt;File&gt; fileReadingMessageSource() {
         FileReadingMessageSource source = new FileReadingMessageSource();
         source.setDirectory(new File(INBOUND_PATH));
         source.setFilter(new SimplePatternFileListFilter("*.txt"));
         return source;
    }

    @Bean
    @Transformer(inputChannel = "fileInputChannel", outputChannel = "processFileChannel")
    public FileToStringTransformer fileToStringTransformer() {
        return new FileToStringTransformer();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-8"><a class="anchor" href="#configuring-with-the-java-dsl-8"></a>17.1.7. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FileReadingJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FileReadingJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow fileReadingFlow() {
         return IntegrationFlows
                  .from(Files.inboundAdapter(new File(INBOUND_PATH))
                              .patternFilter("*.txt"),
                          e -&gt; e.poller(Pollers.fixedDelay(1000)))
                  .transform(Files.toStringTransformer())
                  .channel("processFileChannel")
                  .get();
        }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="file-tailing"><a class="anchor" href="#file-tailing"></a>17.1.8. 'tail&#8217;ing Files</h4>
<div class="paragraph">
<p>Another popular use case is to get 'lines' from the end (or tail) of a file, capturing new lines when they are added.
Two implementations are provided.
The first, <code>OSDelegatingFileTailingMessageProducer</code>, uses the native <code>tail</code> command (on operating systems that have one).
This is generally the most efficient implementation on those platforms.
For operating systems that do not have a <code>tail</code> command, the second implementation, <code>ApacheCommonsFileTailingMessageProducer</code>, uses the Apache <code>commons-io</code> <code>Tailer</code> class.</p>
</div>
<div class="paragraph">
<p>In both cases, file system events, such as files being unavailable and other events, are published as <code>ApplicationEvent</code> instances by using the normal Spring event publishing mechanism.
Examples of such events include the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[message=tail: cannot open `/tmp/somefile' for reading:
               No such file or directory, file=/tmp/somefile]

[message=tail: `/tmp/somefile' has become accessible, file=/tmp/somefile]

[message=tail: `/tmp/somefile' has become inaccessible:
               No such file or directory, file=/tmp/somefile]

[message=tail: `/tmp/somefile' has appeared;
               following end of new file, file=/tmp/somefile]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The sequence of events shown in the preceding example might occur, for example, when a file is rotated.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, a <code>FileTailingIdleEvent</code> is emitted when there is no data in the file during <code>idleEventInterval</code>.
The following example shows what such an event looks like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[message=Idle timeout, file=/tmp/somefile] [idle time=5438]</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Not all platforms that support a <code>tail</code> command provide these status messages.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Messages emitted from these endpoints have the following headers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FileHeaders.ORIGINAL_FILE</code>: The <code>File</code> object</p>
</li>
<li>
<p><code>FileHeaders.FILENAME</code>: The file name (<code>File.getName()</code>)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In versions prior to version 5.0, the <code>FileHeaders.FILENAME</code> header contained a string representation of the file&#8217;s absolute path.
You can now obtain that string representation by calling <code>getAbsolutePath()</code> on the original file header.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example creates a native adapter with the default options ('-F -n 0', meaning to follow the file name from the current end).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:tail-inbound-channel-adapter id="native"
	channel="input"
	task-executor="exec"
	file="/tmp/foo"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example creates a native adapter with '-F -n +0' options (meaning follow the file name, emitting all existing lines).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:tail-inbound-channel-adapter id="native"
	channel="input"
	native-options="-F -n +0"
	task-executor="exec"
	file-delay=10000
	file="/tmp/foo"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>tail</code> command fails (on some platforms, a missing file causes the <code>tail</code> to fail, even with <code>-F</code> specified), the command is retried every 10 seconds.</p>
</div>
<div class="paragraph">
<p>By default, native adapters capture from standard output and send the content as messages.
They also capture from standard error to raise events.
Starting with version 4.3.6, you can discard the standard error events by setting the <code>enable-status-reader</code> to <code>false</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:tail-inbound-channel-adapter id="native"
	channel="input"
	enable-status-reader="false"
	task-executor="exec"
	file="/tmp/foo"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following example, <code>IdleEventInterval</code> is set to <code>5000</code>, meaning that, if no lines are written for five seconds, <code>FileTailingIdleEvent</code> is triggered every five seconds:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:tail-inbound-channel-adapter id="native"
	channel="input"
	idle-event-interval="5000"
	task-executor="exec"
	file="/tmp/somefile"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This can be useful when you need to stop the adapter.</p>
</div>
<div class="paragraph">
<p>The following example creates an Apache <code>commons-io</code> <code>Tailer</code> adapter that examines the file for new lines every two seconds and checks for existence of a missing file every ten seconds:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:tail-inbound-channel-adapter id="apache"
	channel="input"
	task-executor="exec"
	file="/tmp/bar"
	delay="2000"
	end="false"             <i class="conum" data-value="1"></i><b>(1)</b>
	reopen="true"           <i class="conum" data-value="2"></i><b>(2)</b>
	file-delay="10000"/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The file is tailed from the beginning (<code>end="false"</code>) instead of the end (which is the default).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The file is reopened for each chunk (the default is to keep the file open).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Specifying the <code>delay</code>, <code>end</code> or <code>reopen</code> attributes forces the use of the Apache <code>commons-io</code> adapter and makes the <code>native-options</code> attribute unavailable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="file-incomplete"><a class="anchor" href="#file-incomplete"></a>17.1.9. Dealing With Incomplete Data</h4>
<div class="paragraph">
<p>A common problem in file-transfer scenarios is how to determine that the transfer is complete so that you do not start reading an incomplete file.
A common technique to solve this problem is to write the file with a temporary name and then atomically rename it to the final name.
This technique, together with a filter that masks the temporary file from being picked up by the consumer, provides a robust solution.
This technique is used by Spring Integration components that write files (locally or remotely).
By default, they append <code>.writing</code> to the file name and remove it when the transfer is complete.</p>
</div>
<div class="paragraph">
<p>Another common technique is to write a second &#8220;marker&#8221; file to indicate that the file transfer is complete.
In this scenario, you should not consider <code>somefile.txt</code> (for example) to be available for use until <code>somefile.txt.complete</code> is also present.
Spring Integration version 5.0 introduced new filters to support this mechanism.
Implementations are provided for the file system (<code>FileSystemMarkerFilePresentFileListFilter</code>), <a href="#ftp-incomplete">FTP</a> and <a href="#sftp-incomplete">SFTP</a>.
They are configurable such that the marker file can have any name, although it is usually related to the file being transferred.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/filters/FileSystemMarkerFilePresentFileListFilter.html">Javadoc</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="file-writing"><a class="anchor" href="#file-writing"></a>17.2. Writing files</h3>
<div class="paragraph">
<p>To write messages to the file system, you can use a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileWritingMessageHandler.html"><code>FileWritingMessageHandler</code></a>.
This class can deal with the following payload types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>File</code></p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p>byte array</p>
</li>
<li>
<p><code>InputStream</code> (since <em>version 4.2</em>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a String payload, you can configure the encoding and the charset.</p>
</div>
<div class="paragraph">
<p>To make things easier, you can configure the <code>FileWritingMessageHandler</code> as part of an outbound channel adapter or outbound gateway by using the XML namespace.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can specify the buffer size to use when writing files.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, you can provide a <code>BiConsumer&lt;File, Message&lt;?&gt;&gt;</code> <code>newFileCallback</code> which is triggered if you use <code>FileExistsMode.APPEND</code> or <code>FileExistsMode.APPEND_NO_FLUSH</code> and a new file has to be created.
This callback receives a newly created file and the message which triggered it.
This callback could be used to write a CSV header defined in the message header, for an example.</p>
</div>
<div class="sect3">
<h4 id="file-writing-file-names"><a class="anchor" href="#file-writing-file-names"></a>17.2.1. Generating File Names</h4>
<div class="paragraph">
<p>In its simplest form, the <code>FileWritingMessageHandler</code> requires only a destination directory for writing the files.
The name of the file to be written is determined by the handler&#8217;s <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileNameGenerator.html"><code>FileNameGenerator</code></a>.
The <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/DefaultFileNameGenerator.html">default implementation</a> looks for a message header whose key matches the constant defined as <a href="https://docs.spring.io/spring-integration/api/constant-values.html#org.springframework.integration.file.FileHeaders.FILENAME"><code>FileHeaders.FILENAME</code></a>.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can specify an expression to be evaluated against the message to generate a file name&#8201;&#8212;&#8201;for example, <code>headers['myCustomHeader'] + '.something'</code>.
The expression must evaluate to a <code>String</code>.
For convenience, the <code>DefaultFileNameGenerator</code> also provides the <code>setHeaderName</code> method, letting you explicitly specify the message header whose value is to be used as the filename.</p>
</div>
<div class="paragraph">
<p>Once set up, the <code>DefaultFileNameGenerator</code> employs the following resolution steps to determine the filename for a given message payload:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Evaluate the expression against the message and, if the result is a non-empty <code>String</code>, use it as the filename.</p>
</li>
<li>
<p>Otherwise, if the payload is a <code>java.io.File</code>, use the <code>File</code> object&#8217;s filename.</p>
</li>
<li>
<p>Otherwise, use the message ID appended with .<code>msg</code> as the filename.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When you use the XML namespace support, both the file outbound channel adapter and the file outbound gateway support the following mutually exclusive configuration attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filename-generator</code> (a reference to a <code>FileNameGenerator</code> implementation)</p>
</li>
<li>
<p><code>filename-generator-expression</code> (an expression that evaluates to a <code>String</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While writing files, a temporary file suffix is used (its default is <code>.writing</code>).
It is appended to the filename while the file is being written.
To customize the suffix, you can set the <code>temporary-file-suffix</code> attribute on both the file outbound channel adapter and the file outbound gateway.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the <code>APPEND</code> file <code>mode</code>, the <code>temporary-file-suffix</code> attribute is ignored, since the data is appended to the file directly.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with ,version 4.2.5, the generated file name (as a result of <code>filename-generator</code> or <code>filename-generator-expression</code>
evaluation) can represent a child path together with the target file name.
It is used as a second constructor argument for <code>File(File parent, String child)</code> as before.
However, in the past we did not create (<code>mkdirs()</code>) directories for the child path, assuming only the file name.
This approach is useful for cases when we need to restore the file system tree to match the source directory&#8201;&#8212;&#8201;for example, when unzipping the archive and saving all the files in the target directory in the original order.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-writing-output-directory"><a class="anchor" href="#file-writing-output-directory"></a>17.2.2. Specifying the Output Directory</h4>
<div class="paragraph">
<p>Both, the file outbound channel adapter and the file outbound gateway provide two mutually exclusive configuration attributes for specifying the output directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>directory</code></p>
</li>
<li>
<p><code>directory-expression</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Integration 2.2 introduced the <code>directory-expression</code> attribute.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="using-the-directory-attribute"><a class="anchor" href="#using-the-directory-attribute"></a>Using the <code>directory</code> Attribute</h5>
<div class="paragraph">
<p>When you use the <code>directory</code> attribute, the output directory is set to a fixed value, which is set when the <code>FileWritingMessageHandler</code> is initialized.
If you do not specify this attribute, you must use the <code>directory-expression</code> attribute.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-the-directory-expression-attribute"><a class="anchor" href="#using-the-directory-expression-attribute"></a>Using the <code>directory-expression</code> Attribute</h5>
<div class="paragraph">
<p>If you want to have full SpEL support, you can use the <code>directory-expression</code> attribute.
This attribute accepts a SpEL expression that is evaluated for each message being processed.
Thus, you have full access to a message&#8217;s payload and its headers when you dynamically specify the output file directory.</p>
</div>
<div class="paragraph">
<p>The SpEL expression must resolve to either a <code>String</code> or to <code>java.io.File</code>.
Furthermore, the resulting <code>String</code> or <code>File</code> must point to a directory.
If you do not specify the <code>directory-expression</code> attribute, then you must set the <code>directory</code> attribute.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-the-auto-create-directory-attribute"><a class="anchor" href="#using-the-auto-create-directory-attribute"></a>Using the <code>auto-create-directory</code> Attribute</h5>
<div class="paragraph">
<p>By default, if the destination directory does not exist, the respective destination directory and any non-existing parent directories are  automatically created.
To prevent that behavior, you can set the <code>auto-create-directory</code> attribute to <code>false</code>.
This attribute applies to both the <code>directory</code> and the <code>directory-expression</code> attributes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using the <code>directory</code> attribute and <code>auto-create-directory</code> is <code>false</code>, the following change was made starting with Spring Integration 2.2:</p>
</div>
<div class="paragraph">
<p>Instead of checking for the existence of the destination directory when the adapter is initialized, this check is now performed for each message being processed.</p>
</div>
<div class="paragraph">
<p>Furthermore, if <code>auto-create-directory</code> is <code>true</code> and the directory was deleted between the processing of messages, the directory is re-created for each message being processed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="file-writing-destination-exists"><a class="anchor" href="#file-writing-destination-exists"></a>17.2.3. Dealing with Existing Destination Files</h4>
<div class="paragraph">
<p>When you write files and the destination file already exists, the default behavior is to overwrite that target file.
You can change this behavior by setting the <code>mode</code> attribute on the relevant file outbound components.
The following options exist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REPLACE</code> (Default)</p>
</li>
<li>
<p><code>REPLACE_IF_MODIFIED</code></p>
</li>
<li>
<p><code>APPEND</code></p>
</li>
<li>
<p><code>APPEND_NO_FLUSH</code></p>
</li>
<li>
<p><code>FAIL</code></p>
</li>
<li>
<p><code>IGNORE</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Integration 2.2 introduced the <code>mode</code> attribute and the <code>APPEND</code>, <code>FAIL</code>, and <code>IGNORE</code> options.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>REPLACE</code></dt>
<dd>
<p>If the target file already exists, it is overwritten.
If the <code>mode</code> attribute is not specified, this is the default behavior when writing files.</p>
</dd>
<dt class="hdlist1"><code>REPLACE_IF_MODIFIED</code></dt>
<dd>
<p>If the target file already exists, it is overwritten only if the last modified timestamp differs from that of the source file.
For <code>File</code> payloads, the payload <code>lastModified</code> time is compared to the existing file.
For other payloads, the <code>FileHeaders.SET_MODIFIED</code> (<code>file_setModified</code>) header is compared to the existing file.
If the header is missing or has a value that is not a <code>Number</code>, the file is always replaced.</p>
</dd>
<dt class="hdlist1"><code>APPEND</code></dt>
<dd>
<p>This mode lets you append message content to the existing file instead of creating a new file each time.
Note that this attribute is mutually exclusive with the <code>temporary-file-suffix</code> attribute because, when it appends content to the existing file, the adapter no longer uses a temporary file.
The file is closed after each message.</p>
</dd>
<dt class="hdlist1"><code>APPEND_NO_FLUSH</code></dt>
<dd>
<p>This option has the same semantics as <code>APPEND</code>, but the data is not flushed and the file is not closed after each message.
This can provide a significant performance at the risk of data loss in the event of a failure.
See <a href="#file-flushing">Flushing Files When Using <code>APPEND_NO_FLUSH</code></a> for more information.</p>
</dd>
<dt class="hdlist1"><code>FAIL</code></dt>
<dd>
<p>If the target file exists, a <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/MessageHandlingException.html"><code>MessageHandlingException</code></a> is thrown.</p>
</dd>
<dt class="hdlist1"><code>IGNORE</code></dt>
<dd>
<p>If the target file exists, the message payload is silently ignored.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using a temporary file suffix (the default is <code>.writing</code>), the <code>IGNORE</code> option applies if either the final file name or the temporary file name exists.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="file-flushing"><a class="anchor" href="#file-flushing"></a>17.2.4. Flushing Files When Using <code>APPEND_NO_FLUSH</code></h4>
<div class="paragraph">
<p>The <code>APPEND_NO_FLUSH</code> mode was added in version 4.3.
Using it can improve performance because the file is not closed after each message.
However, this can cause data loss in the event of a failure.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides several flushing strategies to mitigate this data loss:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>flushInterval</code>.
If a file is not written to for this period of time, it is automatically flushed.
This is approximate and may be up to <code>1.33x</code> this time (with an average of <code>1.167x</code>).</p>
</li>
<li>
<p>Send a message containing a regular expression to the message handler&#8217;s <code>trigger</code> method.
Files with absolute path names matching the pattern are flushed.</p>
</li>
<li>
<p>Provide the handler with a custom <code>MessageFlushPredicate</code> implementation to modify the action taken when a message is sent to the <code>trigger</code> method.</p>
</li>
<li>
<p>Invoke one of the handler&#8217;s <code>flushIfNeeded</code> methods by passing in a custom <code>FileWritingMessageHandler.FlushPredicate</code> or <code>FileWritingMessageHandler.MessageFlushPredicate</code> implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The predicates are called for each open file.
See the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> for these interfaces for more information.
Note that, since version 5.0, the predicate methods provide another parameter: the time that the current file was first written to if new or previously closed.</p>
</div>
<div class="paragraph">
<p>When using <code>flushInterval</code>, the interval starts at the last write.
The file is flushed only if it is idle for the interval.
Starting with version 4.3.7, an additional property (<code>flushWhenIdle</code>) can be set to <code>false</code>, meaning that the interval starts with the first write to a previously flushed (or new) file.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-timestamps"><a class="anchor" href="#file-timestamps"></a>17.2.5. File Timestamps</h4>
<div class="paragraph">
<p>By default, the destination file&#8217;s <code>lastModified</code> timestamp is the time when the file was created (except that an in-place rename retains the current timestamp).
Starting with version 4.3, you can now configure <code>preserve-timestamp</code> (or <code>setPreserveTimestamp(true)</code> when using Java configuration).
For <code>File</code> payloads, this transfers the timestamp from the inbound file to the outbound (regardless of whether a copy was required).
For other payloads, if the <code>FileHeaders.SET_MODIFIED</code> header (<code>file_setModified</code>) is present, it is used to set the destination file&#8217;s <code>lastModified</code> timestamp, as long as the header is a <code>Number</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-permissions"><a class="anchor" href="#file-permissions"></a>17.2.6. File Permissions</h4>
<div class="paragraph">
<p>Starting with version 5.0, when writing files to a file system that supports Posix permissions, you can specify those permissions on the outbound channel adapter or gateway.
The property is an integer and is usually supplied in the familiar octal format&#8201;&#8212;&#8201;for example, <code>0640</code>, meaning that the owner has read/write permissions, the group has read-only permission, and others have no access.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-outbound-channel-adapter"><a class="anchor" href="#file-outbound-channel-adapter"></a>17.2.7. File Outbound Channel Adapter</h4>
<div class="paragraph">
<p>The following example configures a file outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:outbound-channel-adapter id="filesOut" directory="${input.directory.property}"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The namespace-based configuration also supports a <code>delete-source-files</code> attribute.
If set to <code>true</code>, it triggers the deletion of the original source files after writing to a destination.
The default value for that flag is <code>false</code>.
The following example shows how to set it to <code>true</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:outbound-channel-adapter id="filesOut"
    directory="${output.directory}"
    delete-source-files="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>delete-source-files</code> attribute has an effect only if the inbound message has a <code>File</code> payload or if the <code>FileHeaders.ORIGINAL_FILE</code> header value contains either the source <code>File</code> instance or a <code>String</code> representing the original file path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>FileWritingMessageHandler</code> supports an <code>append-new-line</code> option.
If set to <code>true</code>, a new line is appended to the file after a message is written.
The default attribute value is <code>false</code>.
The following example shows how to use the <code>append-new-line</code> option:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:outbound-channel-adapter id="newlineAdapter"
	append-new-line="true"
    directory="${output.directory}"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="file-writing-output-gateway"><a class="anchor" href="#file-writing-output-gateway"></a>17.2.8. Outbound Gateway</h4>
<div class="paragraph">
<p>In cases where you want to continue processing messages based on the written file, you can use the <code>outbound-gateway</code> instead.
It plays a role similar to that of the <code>outbound-channel-adapter</code>.
However, after writing the file, it also sends it to the reply channel as the payload of a message.</p>
</div>
<div class="paragraph">
<p>The following example configures an outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:outbound-gateway id="mover" request-channel="moveInput"
    reply-channel="output"
    directory="${output.directory}"
    mode="REPLACE" delete-source-files="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As mentioned earlier, you can also specify the <code>mode</code> attribute, which defines the behavior of how to deal with situations where the destination file already exists.
See <a href="#file-writing-destination-exists">Dealing with Existing Destination Files</a> for further details.
Generally, when using the file outbound gateway, the result file is returned as the message payload on the reply channel.</p>
</div>
<div class="paragraph">
<p>This also applies when specifying the <code>IGNORE</code> mode.
In that case the pre-existing destination file is returned.
If the payload of the request message was a file, you still have access to that original file through the message header.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileHeaders.html">FileHeaders.ORIGINAL_FILE</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The 'outbound-gateway' works well in cases where you want to first move a file and then send it through a processing pipeline.
In such cases, you may connect the file namespace&#8217;s <code>inbound-channel-adapter</code> element to the <code>outbound-gateway</code> and then connect that gateway&#8217;s <code>reply-channel</code> to the beginning of the pipeline.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you have more elaborate requirements or need to support additional payload types as input to be converted to file content, you can extend the <code>FileWritingMessageHandler</code>, but a much better option is to rely on a <a href="#file-transforming"><code>Transformer</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-8"><a class="anchor" href="#configuring-with-java-configuration-8"></a>17.2.9. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class FileWritingJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
                      new SpringApplicationBuilder(FileWritingJavaApplication.class)
                              .web(false)
                              .run(args);
             MyGateway gateway = context.getBean(MyGateway.class);
             gateway.writeToFile("foo.txt", new File(tmpDir.getRoot(), "fileWritingFlow"), "foo");
    }

    @Bean
    @ServiceActivator(inputChannel = "writeToFileChannel")
    public MessageHandler fileWritingMessageHandler() {
         Expression directoryExpression = new SpelExpressionParser().parseExpression("headers.directory");
         FileWritingMessageHandler handler = new FileWritingMessageHandler(directoryExpression);
         handler.setFileExistsMode(FileExistsMode.APPEND);
         return handler;
    }

    @MessagingGateway(defaultRequestChannel = "writeToFileChannel")
    public interface MyGateway {

        void writeToFile(@Header(FileHeaders.FILENAME) String fileName,
                       @Header(FileHeaders.FILENAME) File directory, String data);

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-9"><a class="anchor" href="#configuring-with-the-java-dsl-9"></a>17.2.10. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FileWritingJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
                 new SpringApplicationBuilder(FileWritingJavaApplication.class)
                         .web(false)
                         .run(args);
        MessageChannel fileWritingInput = context.getBean("fileWritingInput", MessageChannel.class);
        fileWritingInput.send(new GenericMessage&lt;&gt;("foo"));
    }

    @Bean
   	public IntegrationFlow fileWritingFlow() {
   	    return IntegrationFlows.from("fileWritingInput")
   		        .enrichHeaders(h -&gt; h.header(FileHeaders.FILENAME, "foo.txt")
   		                  .header("directory", new File(tmpDir.getRoot(), "fileWritingFlow")))
   	            .handle(Files.outboundGateway(m -&gt; m.getHeaders().get("directory")))
   	            .channel(MessageChannels.queue("fileWritingResultChannel"))
   	            .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="file-transforming"><a class="anchor" href="#file-transforming"></a>17.3. File Transformers</h3>
<div class="paragraph">
<p>To transform data read from the file system to objects and the other way around, you need to do some work.
Unlike <code>FileReadingMessageSource</code> and to a lesser extent <code>FileWritingMessageHandler</code>, you probably need your own mechanism to get the job done.
For this, you can implement the <code>Transformer</code> interface.
Alternatively, you can extend the <code>AbstractFilePayloadTransformer</code> for inbound messages.
Spring Integration provides some obvious implementations.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/Transformer.html">Javadoc for the <code>Transformer</code> interface</a> to see which Spring Integration classes implement it.
Similarly, you can check the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/transformer/AbstractFilePayloadTransformer.html">Javadoc for the <code>AbstractFilePayloadTransformer</code> class</a> to see which Spring Integration classes extend it.</p>
</div>
<div class="paragraph">
<p><code>FileToByteArrayTransformer</code> extends <code>AbstractFilePayloadTransformer</code> and transforms a <code>File</code> object into a <code>byte[]</code> by using Spring&#8217;s <code>FileCopyUtils</code>.
It is often better to use a sequence of transformers than to put all transformations in a single class.
In that case the <code>File</code> to <code>byte[]</code> conversion might be a logical first step.</p>
</div>
<div class="paragraph">
<p><code>FileToStringTransformer</code> extends <code>AbstractFilePayloadTransformer</code> convert a <code>File</code> object to a <code>String</code>.
If nothing else, this can be useful for debugging (consider using it with a <a href="#channel-wiretap">wire tap</a>).</p>
</div>
<div class="paragraph">
<p>To configure file-specific transformers, you can use the appropriate elements from the file namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:file-to-bytes-transformer  input-channel="input" output-channel="output"
    delete-files="true"/&gt;

&lt;int-file:file-to-string-transformer input-channel="input" output-channel="output"
    delete-files="true" charset="UTF-8"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>delete-files</code> option signals to the transformer that it should delete the inbound file after the transformation is complete.
This is in no way a replacement for using an <code>AcceptOnceFileListFilter</code> when the <code>FileReadingMessageSource</code> is being used in a multi-threaded environment (such as when you use Spring Integration in general).</p>
</div>
</div>
<div class="sect2">
<h3 id="file-splitter"><a class="anchor" href="#file-splitter"></a>17.4. File Splitter</h3>
<div class="paragraph">
<p>The <code>FileSplitter</code> was added in version 4.1.2, and its namespace support was added in version 4.2.
The <code>FileSplitter</code> splits text files into individual lines, based on <code>BufferedReader.readLine()</code>.
By default, the splitter uses an <code>Iterator</code> to emit lines one at a time as they are read from the file.
Setting the <code>iterator</code> property to <code>false</code> causes it to read all the lines into memory before emitting them as messages.
One use case for this might be if you want to detect I/O errors on the file before sending any messages containing lines.
However, it is only practical for relatively short files.</p>
</div>
<div class="paragraph">
<p>Inbound payloads can be <code>File</code>, <code>String</code> (a <code>File</code> path), <code>InputStream</code>, or <code>Reader</code>.
Other payload types are emitted unchanged.</p>
</div>
<div class="paragraph">
<p>The following listing shows all the possible attributes for <code>&lt;int-file:splitter&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:splitter id="splitter" <i class="conum" data-value="1"></i><b>(1)</b>
    iterator=""                  <i class="conum" data-value="2"></i><b>(2)</b>
    markers=""                   <i class="conum" data-value="3"></i><b>(3)</b>
    markers-json=""              <i class="conum" data-value="4"></i><b>(4)</b>
    apply-sequence=""            <i class="conum" data-value="5"></i><b>(5)</b>
    requires-reply=""            <i class="conum" data-value="6"></i><b>(6)</b>
    charset=""                   <i class="conum" data-value="7"></i><b>(7)</b>
    first-line-as-header=""      <i class="conum" data-value="8"></i><b>(8)</b>
    input-channel=""             <i class="conum" data-value="9"></i><b>(9)</b>
    output-channel=""            <i class="conum" data-value="10"></i><b>(10)</b>
    send-timeout=""              <i class="conum" data-value="11"></i><b>(11)</b>
    auto-startup=""              <i class="conum" data-value="12"></i><b>(12)</b>
    order=""                     <i class="conum" data-value="13"></i><b>(13)</b>
    phase="" /&gt;                  <i class="conum" data-value="14"></i><b>(14)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The bean name of the splitter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set to <code>true</code> (the default) to use an iterator or <code>false</code> to load the file into memory before sending lines.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set to <code>true</code> to emit start-of-file and end-of-file marker messages before and after the file data.
Markers are messages with <code>FileSplitter.FileMarker</code> payloads (with <code>START</code> and <code>END</code> values in the <code>mark</code> property).
You might use markers when sequentially processing files in a downstream flow where some lines are filtered.
They enable the downstream processing to know when a file has been completely processed.
In addition, a <code>file_marker</code> header that contains <code>START</code> or <code>END</code> is added to these messages.
The <code>END</code> marker includes a line count.
If the file is empty, only <code>START</code> and <code>END</code> markers are emitted with <code>0</code> as the <code>lineCount</code>.
The default is <code>false</code>.
When <code>true</code>, <code>apply-sequence</code> is <code>false</code> by default.
See also <code>markers-json</code> (the next attribute).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>When <code>markers</code> is true, set this to <code>true</code> to have the <code>FileMarker</code> objects be converted to a JSON string.
Requires a supported JSON processor library (Jackson or Boon) on the classpath.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Set to <code>false</code> to disable the inclusion of <code>sequenceSize</code> and <code>sequenceNumber</code> headers in messages.
The default is <code>true</code>, unless <code>markers</code> is <code>true</code>.
When <code>true</code> and <code>markers</code> is <code>true</code>, the markers are included in the sequencing.
When <code>true</code> and <code>iterator</code> is <code>true</code>, the <code>sequenceSize</code> header is set to <code>0</code>, because the size is unknown.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Set to <code>true</code> to cause a <code>RequiresReplyException</code> to be thrown if there are no lines in the file.
The default is <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Set the charset name to be used when reading text data into <code>String</code> payloads.
The default is the platform charset.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The header name for the first line to be carried as a header in the messages emitted for the remaining lines.
Since version 5.0.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Set the input channel used to send messages to the splitter.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Set the output channel to which messages are sent.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Set the send timeout.
Only applies if the <code>output-channel</code> can block&#8201;&#8212;&#8201;such as a full <code>QueueChannel</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Set to <code>false</code> to disable automatically starting the splitter when the context is refreshed.
The default is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Set the order of this endpoint if the <code>input-channel</code> is a <code>&lt;publish-subscribe-channel/&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>Set the startup phase for the splitter (used when <code>auto-startup</code> is <code>true</code>).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>FileSplitter</code> also splits any text-based <code>InputStream</code> into lines.
Starting with version 4.3, when used in conjunction with an FTP or SFTP streaming inbound channel adapter or an FTP or SFTP outbound gateway that uses the <code>stream</code> option to retrieve a file, the splitter automatically closes the session that supports the stream when the file is completely consumed
See <a href="#ftp-streaming">FTP Streaming Inbound Channel Adapter</a> and <a href="#sftp-streaming">SFTP Streaming Inbound Channel Adapter</a> as well as <a href="#ftp-outbound-gateway">FTP Outbound Gateway</a> and <a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a> for more information about these facilities.</p>
</div>
<div class="paragraph">
<p>When using Java configuration, an additional constructor is available, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public FileSplitter(boolean iterator, boolean markers, boolean markersJson)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When <code>markersJson</code> is true, the markers are represented as a JSON string, as long as a suitable JSON processor library (such as Jackson or Boon) is on the classpath.</p>
</div>
<div class="paragraph">
<p>Version 5.0 introduced the <code>firstLineAsHeader</code> option to specify that the first line of content is a header (such as column names in a CSV file).
The argument passed to this property is the header name under which the first line is carried as a header in the messages emitted for the remaining lines.
This line is not included in the sequence header (if <code>applySequence</code> is true) nor in the <code>lineCount</code> associated with <code>FileMarker.END</code> .
If a file contains only the header line, the file is treated as empty and, therefore, only <code>FileMarker</code> instances are emitted during splitting (if markers are enabled&#8201;&#8212;&#8201;otherwise, no messages are emitted).
By default (if no header name is set), the first line is considered to be data and becomes the payload of the first emitted message.</p>
</div>
<div class="paragraph">
<p>If you need more complex logic about header extraction from the file content (not first line, not the whole content of the line, not one particular header, and so on), consider using  <a href="#header-enricher">header enricher</a> ahead of the <code>FileSplitter</code>.
Note that the lines that have been moved to the headers might be filtered downstream from the normal content process.</p>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-9"><a class="anchor" href="#configuring-with-java-configuration-9"></a>17.4.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure a file splitter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Splitter(inputChannel="toSplitter")
@Bean
public MessageHandler fileSplitter() {
    FileSplitter splitter = new FileSplitter(true, true);
    splitter.setApplySequence(true);
    splitter.setOutputChannel(outputChannel);
    return splitter;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-10"><a class="anchor" href="#configuring-with-the-java-dsl-10"></a>17.4.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure a file splitter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FileSplitterApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FileSplitterApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow fileSplitterFlow() {
        return IntegrationFlows
            .from(Files.inboundAdapter(tmpDir.getRoot())
                 .filter(new ChainFileListFilter&lt;File&gt;()
                        .addFilter(new AcceptOnceFileListFilter&lt;&gt;())
                        .addFilter(new ExpressionFileListFilter&lt;&gt;(
                             new FunctionExpression&lt;File&gt;(f -&gt; "foo.tmp".equals(f.getName()))))))
            .split(Files.splitter()
                     .markers()
                     .charset(StandardCharsets.US_ASCII)
                     .firstLineAsHeader("fileHeader")
                     .applySequence(true))
            .channel(c -&gt; c.queue("fileSplittingResultChannel"))
            .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ftp"><a class="anchor" href="#ftp"></a>18. FTP/FTPS Adapters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides support for file transfer operations with FTP and FTPS.</p>
</div>
<div class="paragraph">
<p>The File Transfer Protocol (FTP) is a simple network protocol that lets you transfer files between two computers on the Internet.
FTPS stands for &#8220;FTP over SSL&#8221;.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-ftp&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-ftp:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There are two actors when it comes to FTP communication: client and server.
To transfer files with FTP or FTPS, you use a client that initiates a connection to a remote computer that is running an FTP server.
After the connection is established, the client can choose to send or receive copies of files.</p>
</div>
<div class="paragraph">
<p>Spring Integration supports sending and receiving files over FTP or FTPS by providing three client-side endpoints: inbound channel adapter, outbound channel adapter, and outbound gateway.
It also provides convenient namespace-based configuration options for defining these client components.</p>
</div>
<div class="paragraph">
<p>To use the FTP namespace, add the following to the header of your XML file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">xmlns:int-ftp="http://www.springframework.org/schema/integration/ftp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/ftp
    https://www.springframework.org/schema/integration/ftp/spring-integration-ftp.xsd"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-session-factory"><a class="anchor" href="#ftp-session-factory"></a>18.1. FTP Session Factory</h3>
<div class="paragraph">
<p>Spring Integration provides factories you can use to create FTP (or FTPS) sessions.</p>
</div>
<div class="sect3">
<h4 id="default-factories"><a class="anchor" href="#default-factories"></a>18.1.1. Default Factories</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 3.0, sessions are no longer cached by default.
See <a href="#ftp-session-caching">FTP Session Caching</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Before configuring FTP adapters, you must configure an FTP session factory.
You can configure the FTP Session Factory with a regular bean definition where the implementation class is <code>o.s.i.ftp.session.DefaultFtpSessionFactory</code>.
The following example shows a basic configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="ftpClientFactory"
    class="org.springframework.integration.ftp.session.DefaultFtpSessionFactory"&gt;
    &lt;property name="host" value="localhost"/&gt;
    &lt;property name="port" value="22"/&gt;
    &lt;property name="username" value="kermit"/&gt;
    &lt;property name="password" value="frog"/&gt;
    &lt;property name="clientMode" value="0"/&gt;
    &lt;property name="fileType" value="2"/&gt;
    &lt;property name="bufferSize" value="100000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For FTPS connections, you can use <code>o.s.i.ftp.session.DefaultFtpsSessionFactory</code> instead.</p>
</div>
<div class="paragraph">
<p>The following example shows a complete configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="ftpClientFactory"
    class="org.springframework.integration.ftp.session.DefaultFtpsSessionFactory"&gt;
    &lt;property name="host" value="localhost"/&gt;
    &lt;property name="port" value="22"/&gt;
    &lt;property name="username" value="oleg"/&gt;
    &lt;property name="password" value="password"/&gt;
    &lt;property name="clientMode" value="1"/&gt;
    &lt;property name="fileType" value="2"/&gt;
    &lt;property name="useClientMode" value="true"/&gt;
    &lt;property name="cipherSuites" value="a,b.c"/&gt;
    &lt;property name="keyManager" ref="keyManager"/&gt;
    &lt;property name="protocol" value="SSL"/&gt;
    &lt;property name="trustManager" ref="trustManager"/&gt;
    &lt;property name="prot" value="P"/&gt;
    &lt;property name="needClientAuth" value="true"/&gt;
    &lt;property name="authValue" value="oleg"/&gt;
    &lt;property name="sessionCreation" value="true"/&gt;
    &lt;property name="protocols" value="SSL, TLS"/&gt;
    &lt;property name="implicit" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you experience connectivity problems and would like to trace session creation as well as see which sessions are polled, you can enable session tracing by setting the logger to the <code>TRACE</code> level (for example, <code>log4j.category.org.springframework.integration.file=TRACE</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now you need only inject these session factories into your adapters.
The protocol (FTP or FTPS) that an adapter uses depends on the type of session factory that has been injected into the adapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A more practical way to provide values for FTP or FTPS session factories is to use Spring&#8217;s property placeholder support (See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-placeholderconfigurer" class="bare">docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-placeholderconfigurer</a>).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-configuration"><a class="anchor" href="#advanced-configuration"></a>18.2. Advanced Configuration</h3>
<div class="paragraph">
<p><code>DefaultFtpSessionFactory</code> provides an abstraction over the underlying client API, which (since Spring Integration 2.0) is <a href="https://commons.apache.org/net/">Apache Commons Net</a>.
This spares you from the low-level configuration details of the <code>org.apache.commons.net.ftp.FTPClient</code>.
Several common properties are exposed on the session factory (since version 4.0, this now includes <code>connectTimeout</code>, <code>defaultTimeout</code>, and <code>dataTimeout</code>).
However, you sometimes need access to lower level <code>FTPClient</code> configuration to achieve more advanced configuration (such as setting the port range for active mode).
For that purpose, <code>AbstractFtpSessionFactory</code> (the base class for all FTP Session Factories) exposes hooks, in the form of the two post-processing methods shown in the following listing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Will handle additional initialization after client.connect() method was invoked,
 * but before any action on the client has been taken
 */
protected void postProcessClientAfterConnect(T t) throws IOException {
    // NOOP
}
/**
 * Will handle additional initialization before client.connect() method was invoked.
 */
protected void postProcessClientBeforeConnect(T client) throws IOException {
    // NOOP
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, there is no default implementation for these two methods.
However, by extending <code>DefaultFtpSessionFactory</code>, you can override these methods to provide more advanced configuration of the <code>FTPClient</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AdvancedFtpSessionFactory extends DefaultFtpSessionFactory {

    protected void postProcessClientBeforeConnect(FTPClient ftpClient) throws IOException {
       ftpClient.setActivePortRange(4000, 5000);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ftps-and-shared-sslsession"><a class="anchor" href="#ftps-and-shared-sslsession"></a>18.2.1. FTPS and Shared SSLSession</h4>
<div class="paragraph">
<p>When using FTP over SSL or TLS, some servers require the same <code>SSLSession</code> to be used on the control and data connections.
This is to prevent &#8220;stealing&#8221; data connections.
See <a href="https://scarybeastsecurity.blogspot.cz/2009/02/vsftpd-210-released.html" class="bare">scarybeastsecurity.blogspot.cz/2009/02/vsftpd-210-released.html</a> for more information.</p>
</div>
<div class="paragraph">
<p>Currently, the Apache FTPSClient does not support this feature.
See <a href="https://issues.apache.org/jira/browse/NET-408">NET-408</a>.</p>
</div>
<div class="paragraph">
<p>The following solution, courtesy of <a href="https://stackoverflow.com/questions/32398754/how-to-connect-to-ftps-server-with-data-connection-using-same-tls-session">Stack Overflow</a>, uses reflection on the <code>sun.security.ssl.SSLSessionContextImpl</code>, so it may not work on other JVMs.
The stack overflow answer was submitted in 2015, and the solution has been tested by the Spring Integration team recently on JDK 1.8.0_112.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create an FTPS session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public DefaultFtpsSessionFactory sf() {
    DefaultFtpsSessionFactory sf = new DefaultFtpsSessionFactory() {

        @Override
        protected FTPSClient createClientInstance() {
            return new SharedSSLFTPSClient();
        }

    };
    sf.setHost("...");
    sf.setPort(21);
    sf.setUsername("...");
    sf.setPassword("...");
    sf.setNeedClientAuth(true);
    return sf;
}

private static final class SharedSSLFTPSClient extends FTPSClient {

    @Override
    protected void _prepareDataSocket_(final Socket socket) throws IOException {
        if (socket instanceof SSLSocket) {
            // Control socket is SSL
            final SSLSession session = ((SSLSocket) _socket_).getSession();
            final SSLSessionContext context = session.getSessionContext();
            context.setSessionCacheSize(0); // you might want to limit the cache
            try {
                final Field sessionHostPortCache = context.getClass()
                        .getDeclaredField("sessionHostPortCache");
                sessionHostPortCache.setAccessible(true);
                final Object cache = sessionHostPortCache.get(context);
                final Method method = cache.getClass().getDeclaredMethod("put", Object.class,
                        Object.class);
                method.setAccessible(true);
                String key = String.format("%s:%s", socket.getInetAddress().getHostName(),
                        String.valueOf(socket.getPort())).toLowerCase(Locale.ROOT);
                method.invoke(cache, key, session);
                key = String.format("%s:%s", socket.getInetAddress().getHostAddress(),
                        String.valueOf(socket.getPort())).toLowerCase(Locale.ROOT);
                method.invoke(cache, key, session);
            }
            catch (NoSuchFieldException e) {
                // Not running in expected JRE
                logger.warn("No field sessionHostPortCache in SSLSessionContext", e);
            }
            catch (Exception e) {
                // Not running in expected JRE
                logger.warn(e.getMessage());
            }
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-dsf"><a class="anchor" href="#ftp-dsf"></a>18.3. Delegating Session Factory</h3>
<div class="paragraph">
<p>Version 4.2 introduced the <code>DelegatingSessionFactory</code>, which allows the selection of the actual session factory at runtime.
Prior to invoking the FTP endpoint, call <code>setThreadKey()</code> on the factory to associate a key with the current thread.
That key is then used to lookup the actual session factory to be used.
You can clear the key by calling <code>clearThreadKey()</code> after use.</p>
</div>
<div class="paragraph">
<p>We added convenience methods so that you can easily do use a delegating session factory from a message flow.</p>
</div>
<div class="paragraph">
<p>The following example shows how to declare a delegating session factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="dsf" class="org.springframework.integration.file.remote.session.DelegatingSessionFactory"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="o.s.i.file.remote.session.DefaultSessionFactoryLocator"&gt;
            &lt;!-- delegate factories here --&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;int:service-activator input-channel="in" output-channel="c1"
        expression="@dsf.setThreadKey(#root, headers['factoryToUse'])" /&gt;

&lt;int-ftp:outbound-gateway request-channel="c1" reply-channel="c2" ... /&gt;

&lt;int:service-activator input-channel="c2" output-channel="out"
        expression="@dsf.clearThreadKey(#root)" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you use session caching (see <a href="#ftp-session-caching">FTP Session Caching</a>), each of the delegates should be cached.
You cannot cache the <code>DelegatingSessionFactory</code> itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with <em>version 5.0.7</em>, the <code>DelegatingSessionFactory</code> can be used in conjunction with a <code>RotatingServerAdvice</code> to poll multiple servers; see <a href="#ftp-rotating-server-advice">Inbound Channel Adapters: Polling Multiple Servers and Directories</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ftp-inbound"><a class="anchor" href="#ftp-inbound"></a>18.4. FTP Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The FTP inbound channel adapter is a special listener that connects to the FTP server and listens for the remote directory events (for example, new file created) at which point it initiates a file transfer.
The following example shows how to configure an <code>inbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:inbound-channel-adapter id="ftpInbound"
    channel="ftpChannel"
    session-factory="ftpSessionFactory"
    auto-create-local-directory="true"
    delete-remote-files="true"
    filename-pattern="*.txt"
    remote-directory="some/remote/path"
    remote-file-separator="/"
    preserve-timestamp="true"
    local-filename-generator-expression="#this.toUpperCase() + '.a'"
    scanner="myDirScanner"
    local-filter="myFilter"
    temporary-file-suffix=".writing"
    max-fetch-size="-1"
    local-directory="."&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int-ftp:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding configuration shows, you can configure an FTP inbound channel adapter by using the <code>inbound-channel-adapter</code> element while also providing values for various attributes, such as <code>local-directory</code>, <code>filename-pattern</code> (which is based on simple pattern matching, not regular expressions), and the reference to a <code>session-factory</code>.</p>
</div>
<div class="paragraph">
<p>By default, the transferred file carries the same name as the original file.
If you want to override this behavior, you can set the <code>local-filename-generator-expression</code> attribute, which lets you provide a SpEL expression to generate the name of the local file.
Unlike outbound gateways and adapters, where the root object of the SpEL evaluation context is a <code>Message</code>, this inbound adapter does not yet have the message at the time of evaluation, since that&#8217;s what it ultimately generates with the transferred file as its payload.
Consequently, the root object of the SpEL evaluation context is the original name of the remote file (a <code>String</code>).</p>
</div>
<div class="paragraph">
<p>The inbound channel adapter first retrieves the <code>File</code> object for a local directory and then emits each file according to the poller configuration.
Starting with version 5.0, you can now limit the number of files fetched from the FTP server when new file retrievals are needed.
This can be beneficial when the target files are very large or when you run in a clustered system with a persistent file list filter, discussed later.
Use <code>max-fetch-size</code> for this purpose.
A negative value (the default) means no limit and all matching files are retrieved.
See <a href="#ftp-max-fetch">Inbound Channel Adapters: Controlling Remote File Fetching</a> for more information.
Since version 5.0, you can also provide a custom <code>DirectoryScanner</code> implementation to the <code>inbound-channel-adapter</code> by setting the <code>scanner</code> attribute.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, you can specify the <code>preserve-timestamp</code> attribute (its default is <code>false</code>).
When <code>true</code>, the local file&#8217;s modified timestamp is set to the value retrieved from the server.
Otherwise, it is set to the current time.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, you can specify <code>remote-directory-expression</code> instead of <code>remote-directory</code>, letting you dynamically determine the directory on each poll&#8201;&#8212;&#8201;for example, <code>remote-directory-expression="@myBean.determineRemoteDir()"</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can omit the <code>remote-directory</code> and <code>remote-directory-expression</code> attributes.
They default to <code>null</code>.
In this case, according to the FTP protocol, the client working directory is used as the default remote directory.</p>
</div>
<div class="paragraph">
<p>Sometimes, file filtering based on the simple pattern specified with the <code>filename-pattern</code> attribute might not suffice.
If this is the case, you can use the <code>filename-regex</code> attribute to specify a regular expression (such as <code>filename-regex=".*\.test$"</code>).
Also, if you need complete control, you can use the <code>filter</code> attribute and provide a reference to any custom implementation of the <code>o.s.i.file.filters.FileListFilter</code>, a strategy interface for filtering a list of files.
This filter determines which remote files are retrieved.
You can also combine a pattern-based filter with other filters (such as an <code>AcceptOnceFileListFilter</code> to avoid synchronizing files that have previously been fetched) by using a <code>CompositeFileListFilter</code>.</p>
</div>
<div class="paragraph">
<p>The <code>AcceptOnceFileListFilter</code> stores its state in memory.
If you wish the state to survive a system restart, consider using the <code>FtpPersistentAcceptOnceFileListFilter</code> instead.
This filter stores the accepted file names in an instance of the <code>MetadataStore</code> strategy (see <a href="#metadata-store">Metadata Store</a>).
This filter matches on the filename and the remote modified time.</p>
</div>
<div class="paragraph">
<p>Since version 4.0, this filter requires a <code>ConcurrentMetadataStore</code>.
When used with a shared data store (such as <code>Redis</code> with the <code>RedisMetadataStore</code>), it lets filter keys be shared across multiple application or server instances.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>FtpPersistentAcceptOnceFileListFilter</code> with in-memory <code>SimpleMetadataStore</code> is applied by default for the <code>FtpInboundFileSynchronizer</code>.
This filter is also applied with the <code>regex</code> or <code>pattern</code> option in the XML configuration as well as with <code>FtpInboundChannelAdapterSpec</code> in the Java DSL.
Any other use cases can be managed with <code>CompositeFileListFilter</code> (or <code>ChainFileListFilter</code>).</p>
</div>
<div class="paragraph">
<p>The preceding discussion refers to filtering the files before retrieving them.
Once the files have been retrieved, an additional filter is applied to the files on the file system.
By default, this is an <code>AcceptOnceFileListFilter</code> which, as discussed earlier, retains state in memory and does not consider the file&#8217;s modified time.
Unless your application removes files after processing, the adapter will re-process the files on disk by default after an application restart.</p>
</div>
<div class="paragraph">
<p>Also, if you configure the <code>filter</code> to use a <code>FtpPersistentAcceptOnceFileListFilter</code> and the remote file timestamp changes (causing it to be re-fetched), the default local filter does not let this new file be processed.</p>
</div>
<div class="paragraph">
<p>You can use the <code>local-filter</code> attribute to configure the behavior of the local file system filter.
Starting with version 4.3.8, a <code>FileSystemPersistentAcceptOnceFileListFilter</code> is configured by default.
This filter stores the accepted file names and modified timestamp in an instance of the <code>MetadataStore</code> strategy (see <a href="#metadata-store">Metadata Store</a>) and detects changes to the local file modified time.
The default <code>MetadataStore</code> is a <code>SimpleMetadataStore</code>, which stores state in memory.</p>
</div>
<div class="paragraph">
<p>Since version 4.1.5, these filters have a new property (<code>flushOnUpdate</code>) that causes them to flush the
metadata store on every update (if the store implements <code>Flushable</code>).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Further, if you use a distributed <code>MetadataStore</code> (such as <a href="#redis-metadata-store">Redis</a> or <a href="#gemfire-metadata-store">GemFire</a>), you can have multiple instances of the same adapter or application and be sure that each file is processed only once.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The actual local filter is a <code>CompositeFileListFilter</code> that contains the supplied filter and a pattern filter that prevents processing files that are in the process of being downloaded (based on the <code>temporary-file-suffix</code>).
Files are downloaded with this suffix (the default is <code>.writing</code>), and the file is renamed to its final name when the transfer is complete, making it 'visible' to the filter.</p>
</div>
<div class="paragraph">
<p>The <code>remote-file-separator</code> attribute lets you configure a file separator character to use if the default '/' is not applicable for your particular environment.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema</a> for more details on these attributes.</p>
</div>
<div class="paragraph">
<p>You should also understand that the FTP inbound channel adapter is a polling consumer.
Therefore, you must configure a poller (by using either a global default or a local sub-element).
Once a file has been transferred, a message with a <code>java.io.File</code> as its payload is generated and sent to the channel identified by the <code>channel</code> attribute.</p>
</div>
<div class="sect3">
<h4 id="more-on-file-filtering-and-incomplete-files"><a class="anchor" href="#more-on-file-filtering-and-incomplete-files"></a>18.4.1. More on File Filtering and Incomplete Files</h4>
<div class="paragraph">
<p>Sometimes the file that just appeared in the monitored (remote) directory is not complete.
Typically, such a file is written with a temporary extension (such as <code>somefile.txt.writing</code>) and is then renamed once the writing process finishes.
In most cases, you are only interested in files that are complete and would like to filter for only files that are complete.
To handle these scenarios, you can use the filtering support provided by the <code>filename-pattern</code>, <code>filename-regex</code>, and <code>filter</code> attributes.
The following example uses a custom filter implementation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:inbound-channel-adapter
    channel="ftpChannel"
    session-factory="ftpSessionFactory"
    filter="customFilter"
    local-directory="file:/my_transfers"&gt;
    remote-directory="some/remote/path"
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int-ftp:inbound-channel-adapter&gt;

&lt;bean id="customFilter" class="org.example.CustomFilter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="poller-configuration-notes-for-the-inbound-ftp-adapter"><a class="anchor" href="#poller-configuration-notes-for-the-inbound-ftp-adapter"></a>18.4.2. Poller Configuration Notes for the Inbound FTP Adapter</h4>
<div class="paragraph">
<p>The job of the inbound FTP adapter consists of two tasks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Communicate with a remote server in order to transfer files from a remote directory to a local directory.</p>
</li>
<li>
<p>For each transferred file, generate a message with that file as a payload and send it to the channel identified by the 'channel' attribute.
That is why they are called "'channel adapters'" rather than just "'adapters'".
The main job of such an adapter is to generate a message to send to a message channel.
Essentially, the second task takes precedence in such a way that, if your local directory already has one or more files, it first generates messages from those.
Only when all local files have been processed does it initiate the remote communication to retrieve more files.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Also, when configuring a trigger on the poller, you should pay close attention to the <code>max-messages-per-poll</code> attribute.
Its default value is <code>1</code> for all <code>SourcePollingChannelAdapter</code> instances (including FTP).
This means that, as soon as one file is processed, it waits for the next execution time as determined by your trigger configuration.
If you happened to have one or more files sitting in the <code>local-directory</code>, it would process those files before it would initiate communication with the remote FTP server.
Also, if the <code>max-messages-per-poll</code> is set to <code>1</code> (the default), it processes only one file at a time with intervals as defined by your trigger, essentially working as &#8220;one-poll === one-file&#8221;.</p>
</div>
<div class="paragraph">
<p>For typical file-transfer use cases, you most likely want the opposite behavior: to process all the files you can for each poll and only then wait for the next poll.
If that is the case, set <code>max-messages-per-poll</code> to -1.
Then, on each poll, the adapter tries to generate as many messages as it possibly can.
In other words, it processes everything in the local directory, and then it connects to the remote directory to transfer everything that is available there to be processed locally.
Only then is the poll operation considered complete, and the poller waits for the next execution time.</p>
</div>
<div class="paragraph">
<p>You can alternatively set the 'max-messages-per-poll' value to a positive value that indicates the upward limit of messages to be created from files with each poll.
For example, a value of <code>10</code> means that, on each poll, it tries to process no more than ten files.</p>
</div>
</div>
<div class="sect3">
<h4 id="recovering-from-failures"><a class="anchor" href="#recovering-from-failures"></a>18.4.3. Recovering from Failures</h4>
<div class="paragraph">
<p>It is important to understand the architecture of the adapter.
There is a file synchronizer that fetches the files and a <code>FileReadingMessageSource</code> that emits a message for each
synchronized file.
As discussed earlier, two filters are involved.
The <code>filter</code> attribute (and patterns) refers to the remote (FTP) file list, to avoid fetching files that have already
been fetched.
The <code>local-filter</code> is used by the <code>FileReadingMessageSource</code> to determine which files are to be sent as messages.</p>
</div>
<div class="paragraph">
<p>The synchronizer lists the remote files and consults its filter.
The files are then transferred.
If an IO error occurs during file transfer, any files that have already been added to the filter are removed so that they
are eligible to be re-fetched on the next poll.
This only applies if the filter implements <code>ReversibleFileListFilter</code> (such as the <code>AcceptOnceFileListFilter</code>).</p>
</div>
<div class="paragraph">
<p>If, after synchronizing the files, an error occurs on the downstream flow processing a file, no automatic rollback of the filter occurs, so the failed file is not reprocessed by default.</p>
</div>
<div class="paragraph">
<p>If you wish to reprocess such files after a failure, you can use configuration similar to the following to facilitate
the removal of the failed file from the filter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:inbound-channel-adapter id="ftpAdapter"
        session-factory="ftpSessionFactory"
        channel="requestChannel"
        remote-directory-expression="'/sftpSource'"
        local-directory="file:myLocalDir"
        auto-create-local-directory="true"
        filename-pattern="*.txt"&gt;
    &lt;int:poller fixed-rate="1000"&gt;
        &lt;int:transactional synchronization-factory="syncFactory" /&gt;
    &lt;/int:poller&gt;
&lt;/int-ftp:inbound-channel-adapter&gt;

&lt;bean id="acceptOnceFilter"
    class="org.springframework.integration.file.filters.AcceptOnceFileListFilter" /&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-rollback expression="payload.delete()" /&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;bean id="transactionManager"
    class="org.springframework.integration.transaction.PseudoTransactionManager" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration works for any <code>ResettableFileListFilter</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the inbound channel adapter can build sub-directories locally that correspond to the generated local file name.
That can be a remote sub-path as well.
To be able to read a local directory recursively for modification according to the hierarchy support, you can now supply an internal <code>FileReadingMessageSource</code> with a new <code>RecursiveDirectoryScanner</code> based on the <code>Files.walk()</code> algorithm.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/synchronizer/AbstractInboundFileSynchronizingMessageSource.html#setScanner"><code>AbstractInboundFileSynchronizingMessageSource.setScanner()</code></a> for more information.
Also, you can now switch the <code>AbstractInboundFileSynchronizingMessageSource</code> to the <code>WatchService</code>-based <code>DirectoryScanner</code> by using <code>setUseWatchService()</code> option.
It is also configured for all the <code>WatchEventType</code> instances to react to any modifications in local directory.
The reprocessing sample shown earlier is based on the built-in functionality of the <code>FileReadingMessageSource.WatchServiceDirectoryScanner</code> to perform <code>ResettableFileListFilter.remove()</code> when the file is deleted (<code>StandardWatchEventKinds.ENTRY_DELETE</code>) from the local directory.
See <a href="#watch-service-directory-scanner"><code>WatchServiceDirectoryScanner</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-10"><a class="anchor" href="#configuring-with-java-configuration-10"></a>18.4.4. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application show an example of how to configure the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FtpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FtpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        sf.setTestSession(true);
        return new CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    @Bean
    public FtpInboundFileSynchronizer ftpInboundFileSynchronizer() {
        FtpInboundFileSynchronizer fileSynchronizer = new FtpInboundFileSynchronizer(ftpSessionFactory());
        fileSynchronizer.setDeleteRemoteFiles(false);
        fileSynchronizer.setRemoteDirectory("foo");
        fileSynchronizer.setFilter(new FtpSimplePatternFileListFilter("*.xml"));
        return fileSynchronizer;
    }

    @Bean
    @InboundChannelAdapter(channel = "ftpChannel", poller = @Poller(fixedDelay = "5000"))
    public MessageSource&lt;File&gt; ftpMessageSource() {
        FtpInboundFileSynchronizingMessageSource source =
                new FtpInboundFileSynchronizingMessageSource(ftpInboundFileSynchronizer());
        source.setLocalDirectory(new File("ftp-inbound"));
        source.setAutoCreateLocalDirectory(true);
        source.setLocalFilter(new AcceptOnceFileListFilter&lt;File&gt;());
        source.setMaxFetchSize(1);
        return source;
    }

    @Bean
    @ServiceActivator(inputChannel = "ftpChannel")
    public MessageHandler handler() {
        return new MessageHandler() {

            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-11"><a class="anchor" href="#configuring-with-the-java-dsl-11"></a>18.4.5. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FtpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FtpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow ftpInboundFlow() {
        return IntegrationFlows
            .from(Fpt.inboundAdapter(this.ftpSessionFactory)
                    .preserveTimestamp(true)
                    .remoteDirectory("foo")
                    .regexFilter(".*\\.txt$")
                    .localFilename(f -&gt; f.toUpperCase() + ".a")
                    .localDirectory(new File("d:\\ftp_files")),
                e -&gt; e.id("ftpInboundAdapter")
                    .autoStartup(true)
                    .poller(Pollers.fixedDelay(5000)))
            .handle(m -&gt; System.out.println(m.getPayload()))
            .get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ftp-incomplete"><a class="anchor" href="#ftp-incomplete"></a>18.4.6. Dealing With Incomplete Data</h4>
<div class="paragraph">
<p>See <a href="#file-incomplete">Dealing With Incomplete Data</a>.</p>
</div>
<div class="paragraph">
<p>The <code>FtpSystemMarkerFilePresentFileListFilter</code> is provided to filter remote files that do not have a corresponding marker file on the remote system.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/filters/FtpSystemMarkerFilePresentFileListFilter.html">Javadoc</a> (and browse to the parent classes) for configuration information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-streaming"><a class="anchor" href="#ftp-streaming"></a>18.5. FTP Streaming Inbound Channel Adapter</h3>
<div class="paragraph">
<p>Version 4.3 introduced the streaming inbound channel adapter.
This adapter produces message with payloads of type <code>InputStream</code>, letting files be fetched without writing to the
local file system.
Since the session remains open, the consuming application is responsible for closing the session when the file has been
consumed.
The session is provided in the <code>closeableResource</code> header (<code>IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code>).
Standard framework components, such as the <code>FileSplitter</code> and <code>StreamTransformer</code>, automatically close the session.
See <a href="#file-splitter">File Splitter</a> and <a href="#stream-transformer">Stream Transformer</a> for more information about these components.
The follwoing example shows how to configure an <code>inbound-streaming-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:inbound-streaming-channel-adapter id="ftpInbound"
            channel="ftpChannel"
            session-factory="sessionFactory"
            filename-pattern="*.txt"
            filename-regex=".*\.txt"
            filter="filter"
            filter-expression="@myFilterBean.check(#root)"
            remote-file-separator="/"
            comparator="comparator"
            max-fetch-size="1"
            remote-directory-expression="'foo/bar'"&gt;
        &lt;int:poller fixed-rate="1000" /&gt;
&lt;/int-ftp:inbound-streaming-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Only one of <code>filename-pattern</code>, <code>filename-regex</code>, <code>filter</code>, or <code>filter-expression</code> is allowed.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.0, by default, the <code>FtpStreamingMessageSource</code> adapter prevents duplicates for remote files with <code>FtpPersistentAcceptOnceFileListFilter</code> based on the in-memory <code>SimpleMetadataStore</code>.
By default, this filter is also applied with the filename pattern (or regex).
If you need to allow duplicates, you can use <code>AcceptAllFileListFilter</code>.
Any other use cases can be handled by <code>CompositeFileListFilter</code> (or <code>ChainFileListFilter</code>).
The Java configuration (<a href="#ftp-streaming-java">later in the document</a>) shows one technique to remove the remote file after processing to avoid duplicates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use the <code>max-fetch-size</code> attribute to limit the number of files fetched on each poll when a fetch is necessary.
Set it to <code>1</code> and use a persistent filter when running in a clustered environment.
See <a href="#ftp-max-fetch">Inbound Channel Adapters: Controlling Remote File Fetching</a> for more information.</p>
</div>
<div class="paragraph">
<p>The adapter puts the remote directory and file name in the <code>FileHeaders.REMOTE_DIRECTORY</code> and <code>FileHeaders.REMOTE_FILE</code> headers, respectively.
Starting with version 5.0, the <code>FileHeaders.REMOTE_FILE_INFO</code> header provides additional remote file information (represented in JSON by default).
If you set the <code>fileInfoJson</code> property on the <code>FtpStreamingMessageSource</code> to <code>false</code>, the header contains an <code>FtpFileInfo</code> object.
The <code>FTPFile</code> object provided by the underlying Apache Net library can be accessed by using the <code>FtpFileInfo.getFileInfo()</code> method.
The <code>fileInfoJson</code> property is not available when you use XML configuration, but you can set it by injecting the <code>FtpStreamingMessageSource</code> into one of your configuration classes.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the generic type of the <code>comparator</code> is <code>FTPFile</code>.
Previously, it was <code>AbstractFileInfo&lt;FTPFile&gt;</code>.
This is because the sort is now performed earlier in the processing, before filtering and applying <code>maxFetch</code>.</p>
</div>
<div class="sect3">
<h4 id="ftp-streaming-java"><a class="anchor" href="#ftp-streaming-java"></a>18.5.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FtpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FtpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    @InboundChannelAdapter(channel = "stream")
    public MessageSource&lt;InputStream&gt; ftpMessageSource() {
        FtpStreamingMessageSource messageSource = new FtpStreamingMessageSource(template());
        messageSource.setRemoteDirectory("ftpSource/");
        messageSource.setFilter(new AcceptAllFileListFilter&lt;&gt;());
        messageSource.setMaxFetchSize(1);
        return messageSource;
    }

    @Bean
    @Transformer(inputChannel = "stream", outputChannel = "data")
    public org.springframework.integration.transformer.Transformer transformer() {
        return new StreamTransformer("UTF-8");
    }

    @Bean
    public FtpRemoteFileTemplate template() {
        return new FtpRemoteFileTemplate(ftpSessionFactory());
    }

    @ServiceActivator(inputChannel = "data", adviceChain = "after")
    @Bean
    public MessageHandler handle() {
        return System.out::println;
    }

    @Bean
    public ExpressionEvaluatingRequestHandlerAdvice after() {
        ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();
        advice.setOnSuccessExpression(
                "@template.remove(headers['file_remoteDirectory'] + headers['file_remoteFile'])");
        advice.setPropagateEvaluationFailures(true);
        return advice;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that, in this example, the message handler downstream of the transformer has an advice that removes the remote file after processing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-rotating-server-advice"><a class="anchor" href="#ftp-rotating-server-advice"></a>18.6. Inbound Channel Adapters: Polling Multiple Servers and Directories</h3>
<div class="paragraph">
<p>Starting with <em>version 5.0.7</em>, the <code>RotatingServerAdvice</code> is available; when configured as a poller advice, the inbound adapters can poll multiple servers and directories.
Configure the advice and add it to the poller&#8217;s advice chain as normal.
A <code>DelegatingSessionFactory</code> is used to select the server see <a href="#ftp-dsf">Delegating Session Factory</a> for more information.
The advice configuration consists of a list of <code>RotatingServerAdvice.KeyDirectory</code> objects.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    List&lt;KeyDirectory&gt; keyDirectories = new ArrayList&lt;&gt;();
    keyDirectories.add(new KeyDirectory("one", "foo"));
    keyDirectories.add(new KeyDirectory("one", "bar"));
    keyDirectories.add(new KeyDirectory("two", "baz"));
    keyDirectories.add(new KeyDirectory("two", "qux"));
    keyDirectories.add(new KeyDirectory("three", "fiz"));
    keyDirectories.add(new KeyDirectory("three", "buz"));
    return new RotatingServerAdvice(delegatingSf(), keyDirectories);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advice will poll directory <code>foo</code> on server <code>one</code> until no new files exist then move to directory <code>bar</code> and then directory <code>baz</code> on server <code>two</code>, etc.</p>
</div>
<div class="paragraph">
<p>This default behavior can be modified with the <code>fair</code> constructor arg:</p>
</div>
<div class="listingblock">
<div class="title">fair</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    ...
    return new RotatingServerAdvice(delegatingSf(), keyDirectories, true);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the advice will move to the next server/directory regardless of whether the previous poll returned a file.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can provide your own <code>RotatingServerAdvice.RotationPolicy</code> to reconfigure the message source as needed:</p>
</div>
<div class="listingblock">
<div class="title">policy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface RotationPolicy {

    void beforeReceive(MessageSource&lt;?&gt; source);

    void afterReceive(boolean messageReceived, MessageSource&lt;?&gt; source);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="title">custom</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    return new RotatingServerAdvice(myRotationPolicy());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>local-filename-generator-expression</code> attribute (<code>localFilenameGeneratorExpression</code> on the synchronizer) can now contain the <code>#remoteDirectory</code> variable.
This allows files retrieved from different directories to be downloaded to similar directories locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow() {
    return IntegrationFlows.from(Ftp.inboundAdapter(sf())
                    .filter(new FtpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), "rotate"))
                    .localDirectory(new File(tmpDir))
                    .localFilenameExpression("#remoteDirectory + T(java.io.File).separator + #root")
                    .remoteDirectory("."),
                e -&gt; e.poller(Pollers.fixedDelay(1).advice(advice())))
            .channel(MessageChannels.queue("files"))
            .get();
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not configure a <code>TaskExecutor</code> on the poller when using this advice; see <a href="#conditional-pollers">Conditional Pollers for Message Sources</a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ftp-max-fetch"><a class="anchor" href="#ftp-max-fetch"></a>18.7. Inbound Channel Adapters: Controlling Remote File Fetching</h3>
<div class="paragraph">
<p>There are two properties that you should consider when you configure inbound channel adapters.
<code>max-messages-per-poll</code>, as with all pollers, can be used to limit the number of messages emitted on each poll (if more than the configured value are ready).
<code>max-fetch-size</code> (since version 5.0) can limit the number of files retrieved from the remote server at one time.</p>
</div>
<div class="paragraph">
<p>The following scenarios assume the starting state is an empty local directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=1</code>: The adapter fetches one file, emits it, fetches the next file, emits it, and then sleeps until the next poll.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=2</code>): The adapter fetches both files and then emits each one.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=4</code>: The adapter fetches up to four files (if available) and emits the first two (if there are at least two).
The next two files are emitted on the next poll.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size</code> not specified: The adapter fetches all remote files and emits the first two (if there are at least two).
The subsequent files are emitted on subsequent polls (two at a time).
When all files are consumed, the remote fetch is attempted again, to pick up any new files.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you deploy multiple instances of an application, we recommend a small <code>max-fetch-size</code>, to avoid one instance &#8220;grabbing&#8221; all the files and starving other instances.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another use for <code>max-fetch-size</code> is if you want to stop fetching remote files but continue to process files that have already been fetched.
Setting the <code>maxFetchSize</code> property on the <code>MessageSource</code> (programmatically, with JMX, or with a <a href="#control-bus">control bus</a>) effectively stops the adapter from fetching more files but lets the poller continue to emit messages for files that have previously been fetched.
If the poller is active when the property is changed, the change takes effect on the next poll.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the synchronizer can be provided with a <code>Comparator&lt;FTPFile&gt;</code>.
This is useful when restricting the number of files fetched with <code>maxFetchSize</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ftp-outbound"><a class="anchor" href="#ftp-outbound"></a>18.8. FTP Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The FTP outbound channel adapter relies on a <code>MessageHandler</code> implementation that connects to the FTP server and initiates an FTP transfer for every file it receives in the payload of incoming messages.
It also supports several representations of a file, so you are not limited only to <code>java.io.File</code>-typed payloads.
The FTP outbound channel adapter supports the following payloads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.io.File</code>: The actual file object</p>
</li>
<li>
<p><code>byte[]</code>: A byte array that represents the file contents</p>
</li>
<li>
<p><code>java.lang.String</code>: Text that represents the file contents.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to configure an <code>outbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:outbound-channel-adapter id="ftpOutbound"
    channel="ftpChannel"
    session-factory="ftpSessionFactory"
    charset="UTF-8"
    remote-file-separator="/"
    auto-create-directory="true"
    remote-directory-expression="headers['remote_dir']"
    temporary-remote-directory-expression="headers['temp_remote_dir']"
    filename-generator="fileNameGenerator"
    use-temporary-filename="true"
    mode="REPLACE"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration shows how you can configure an FTP outbound channel adapter by using the <code>outbound-channel-adapter</code> element while also providing values for various attributes, such as <code>filename-generator</code> (an implementation of the <code>o.s.i.file.FileNameGenerator</code> strategy interface), a reference to a <code>session-factory</code>, and other attributes.
You can also see some examples of <code>*expression</code> attributes that let you use SpEL to configure settings such as <code>remote-directory-expression</code>, <code>temporary-remote-directory-expression</code>, and <code>remote-filename-generator-expression</code> (a SpEL alternative to <code>filename-generator</code>, shown in the preceding example).
As with any component that allows the usage of SpEL, access to the payload and the message Headers is available through the 'payload' and 'headers' variables.
See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema</a> for more details on the available attributes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default,  if no file name generator is specified, Spring Integration uses <code>o.s.i.file.DefaultFileNameGenerator</code>.
<code>DefaultFileNameGenerator</code> determines the file name based on the value of the <code>file_name</code> header (if it exists) in the <code>MessageHeaders</code>, or, if the payload of the Message is already a <code>java.io.File</code>, it uses the original name of that file.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Defining certain values (such as <code>remote-directory</code>) might be platform- or FTP server-dependent.
For example, as was reported on <a href="https://forum.spring.io/showthread.php?p=333478&amp;posted=1#post333478" class="bare">forum.spring.io/showthread.php?p=333478&amp;posted=1#post333478</a>, on some platforms, you must add a slash to the end of the directory definition (for example, <code>remote-directory="/thing1/thing2/"</code> instead of <code>remote-directory="/thing1/thing2"</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.1, you can specify the <code>mode</code> when transferring the file.
By default, an existing file is overwritten.
The modes are defined by the <code>FileExistsMode</code> enumeration, which includes the following values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REPLACE</code> (default)
*<code>APPEND</code></p>
</li>
<li>
<p><code>IGNORE</code></p>
</li>
<li>
<p><code>FAIL</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IGNORE</code> and <code>FAIL</code> do not transfer the file.
<code>FAIL</code> causes an exception to be thrown, while <code>IGNORE</code> silently ignores the transfer (although a <code>DEBUG</code> log entry is produced).</p>
</div>
<div class="sect3">
<h4 id="avoiding-partially-written-files"><a class="anchor" href="#avoiding-partially-written-files"></a>18.8.1. Avoiding Partially Written Files</h4>
<div class="paragraph">
<p>One of the common problems that arises when dealing with file transfers is the possibility of processing a partial file.
That is, a file might appear in the file system before its transfer is actually complete.</p>
</div>
<div class="paragraph">
<p>To deal with this issue, Spring Integration FTP adapters use a common algorithm: Files are transferred under a temporary name and then renamed once they are fully transferred.</p>
</div>
<div class="paragraph">
<p>By default, every file that is in the process of being transferred appears in the file system with an additional suffix, which, by default, is <code>.writing</code>.
You can change this suffix by setting the <code>temporary-file-suffix</code> attribute.</p>
</div>
<div class="paragraph">
<p>However, there may be situations where you do not want to use this technique (for example, if the server does not permit renaming files).
For situations like this, you can disable this feature by setting <code>use-temporary-file-name</code> to <code>false</code> (the default is <code>true</code>).
When this attribute is <code>false</code>, the file is written with its final name and the consuming application needs some other mechanism to detect that the file is completely uploaded before accessing it.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-11"><a class="anchor" href="#configuring-with-java-configuration-11"></a>18.8.2. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class FtpJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
                    new SpringApplicationBuilder(FtpJavaApplication.class)
                        .web(false)
                        .run(args);
        MyGateway gateway = context.getBean(MyGateway.class);
        gateway.sendToFtp(new File("/foo/bar.txt"));
    }

    @Bean
    public SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        sf.setTestSession(true);
        return new CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    @Bean
    @ServiceActivator(inputChannel = "ftpChannel")
    public MessageHandler handler() {
        FtpMessageHandler handler = new FtpMessageHandler(ftpSessionFactory());
        handler.setRemoteDirectoryExpressionString("headers['remote-target-dir']");
        handler.setFileNameGenerator(new FileNameGenerator() {

            @Override
            public String generateFileName(Message&lt;?&gt; message) {
                 return "handlerContent.test";
            }

        });
        return handler;
    }

    @MessagingGateway
    public interface MyGateway {

         @Gateway(requestChannel = "toFtpChannel")
         void sendToFtp(File file);

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-12"><a class="anchor" href="#configuring-with-the-java-dsl-12"></a>18.8.3. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter using the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class FtpJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
            new SpringApplicationBuilder(FtpJavaApplication.class)
                .web(false)
                .run(args);
        MyGateway gateway = context.getBean(MyGateway.class);
        gateway.sendToFtp(new File("/foo/bar.txt"));
    }

    @Bean
    public SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        sf.setTestSession(true);
        return new CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    @Bean
    public IntegrationFlow ftpOutboundFlow() {
        return IntegrationFlows.from("toFtpChannel")
                .handle(Ftp.outboundAdapter(ftpSessionFactory(), FileExistsMode.FAIL)
                        .useTemporaryFileName(false)
                        .fileNameExpression("headers['" + FileHeaders.FILENAME + "']")
                        .remoteDirectory(this.ftpServer.getTargetFtpDirectory().getName())
                ).get();
    }

    @MessagingGateway
    public interface MyGateway {

         @Gateway(requestChannel = "toFtpChannel")
         void sendToFtp(File file);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-outbound-gateway"><a class="anchor" href="#ftp-outbound-gateway"></a>18.9. FTP Outbound Gateway</h3>
<div class="paragraph">
<p>The FTP outbound gateway provides a limited set of commands to interact with a remote FTP or FTPS server.
The supported commands are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ls</code> (list files)</p>
</li>
<li>
<p><code>nlst</code> (list file names)</p>
</li>
<li>
<p><code>get</code> (retrieve file)</p>
</li>
<li>
<p><code>mget</code> (retrieve file(s))</p>
</li>
<li>
<p><code>rm</code> (remove file(s))</p>
</li>
<li>
<p><code>mv</code> (move/rename file)</p>
</li>
<li>
<p><code>put</code> (send file)</p>
</li>
<li>
<p><code>mput</code> (send multiple files)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="ftp-using-ls"><a class="anchor" href="#ftp-using-ls"></a>18.9.1. Using the <code>ls</code> Command</h4>
<div class="paragraph">
<p><code>ls</code> lists remote files and supports the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-1</code>: Retrieve a list of file names.
The default is to retrieve a list of <code>FileInfo</code> objects.</p>
</li>
<li>
<p><code>-a</code>: Include all files (including those starting with '.')</p>
</li>
<li>
<p><code>-f</code>: Do not sort the list</p>
</li>
<li>
<p><code>-dirs</code>: Include directories (they are excluded by default)</p>
</li>
<li>
<p><code>-links</code>: Include symbolic links (they are excluded by default)</p>
</li>
<li>
<p><code>-R</code>: List the remote directory recursively</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, filename filtering is provided, in the same manner as the <code>inbound-channel-adapter</code>.
See <a href="#ftp-inbound">FTP Inbound Channel Adapter</a>.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>ls</code> operation is a list of file names or a list of <code>FileInfo</code> objects.
These objects provide information such as modified time, permissions, and other details.</p>
</div>
<div class="paragraph">
<p>The remote directory that the <code>ls</code> command acted on is provided in the <code>file_remoteDirectory</code> header.</p>
</div>
<div class="paragraph">
<p>When using the recursive option (<code>-R</code>), the <code>fileName</code> includes any subdirectory elements, representing a relative path to the file (relative to the remote directory).
If the <code>-dirs</code> option is included, each recursive directory is also returned as an element in the list.
In this case, it is recommended that you not use the <code>-1</code> option, because you would not be able to distinguish files from directories, which you can do with the <code>FileInfo</code> objects.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, the <code>FtpSession</code> supports <code>null</code> for the <code>list()</code> and <code>listNames()</code> methods.
Therefore, you can omit the <code>expression</code> attribute.
For convenience, Java configuration has two constructors that do not have an <code>expression</code> argument.
or <code>LS</code>, <code>NLST</code>, <code>PUT</code> and <code>MPUT</code> commands, <code>null</code> is treated as the client working directory, according to the FTP protocol.
All other commands must be supplied with the <code>expression</code> to evaluate the remote path against the request message.
You can set the working directory with the <code>FTPClient.changeWorkingDirectory()</code> function when you extend the <code>DefaultFtpSessionFactory</code> and implement the <code>postProcessClientAfterConnect()</code> callback.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-nlst-command"><a class="anchor" href="#using-the-nlst-command"></a>18.9.2. Using the <code>nlst</code> Command</h4>
<div class="paragraph">
<p>Version 5 introduced support for the <code>nlst</code> command.</p>
</div>
<div class="paragraph">
<p><code>nlst</code> lists remote file names and supports only one option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-f</code>: Do not sort the list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>nlst</code> operation is a list of file names.</p>
</div>
<div class="paragraph">
<p>The remote directory that the <code>nlst</code> command acted on is provided in the <code>file_remoteDirectory</code> header.</p>
</div>
<div class="paragraph">
<p>Unlike the <code>-1</code> option for the <a href="#ftp-using-ls"><code>ls</code> command</a>, which uses the <code>LIST</code> command, the <code>nlst</code> command sends an <code>NLST</code> command to the target FTP server.
This command is useful when the server does not support <code>LIST</code> (due to security restrictions, for example).
The result of the <code>nlst</code> operation is the names without other detail.
Therefore, the framework cannot determine if an entity is a directory, to perform filtering or recursive listing, for example.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-get-command"><a class="anchor" href="#using-the-get-command"></a>18.9.3. Using the <code>get</code> Command</h4>
<div class="paragraph">
<p><code>get</code> retrieves a remote file.
It supports the following option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-P</code>: Preserve the timestamp of the remote file.</p>
</li>
<li>
<p><code>-stream</code>: Retrieve the remote file as a stream.</p>
</li>
<li>
<p><code>-D</code>: Delete the remote file after successful transfer.
The remote file is not deleted if the transfer is ignored, because the <code>FileExistsMode</code> is <code>IGNORE</code> and the local file already exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>file_remoteDirectory</code> header provides the remote directory name, and the <code>file_remoteFile</code> header provides the file name.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from a <code>get</code> operation is a <code>File</code> object that represents the retrieved file or an <code>InputStream</code> when you use the <code>-stream</code> option.
The <code>-stream</code> option allows retrieving the file as a stream.
For text files, a common use case is to combine this operation with a <a href="#file-splitter">file splitter</a> or a <a href="#stream-transformer">stream transformer</a>.
When consuming remote files as streams, you are responsible for closing the <code>Session</code> after the stream is consumed.
For convenience, the <code>Session</code> is provided in the <code>closeableResource</code> header, which you can access with a convenience method on <code>IntegrationMessageHeaderAccessor</code>
The following example shows how to do use the covenience method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Closeable closeable = new IntegrationMessageHeaderAccessor(message).getCloseableResource();
if (closeable != null) {
    closeable.close();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Framework components such as the <a href="#file-splitter">file splitter</a> and the <a href="#stream-transformer">stream transformer</a> automatically close the session after the data is transferred.</p>
</div>
<div class="paragraph">
<p>The following example shows how to consume a file as a stream:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:outbound-gateway session-factory="ftpSessionFactory"
                            request-channel="inboundGetStream"
                            command="get"
                            command-options="-stream"
                            expression="payload"
                            remote-directory="ftpTarget"
                            reply-channel="stream" /&gt;

&lt;int-file:splitter input-channel="stream" output-channel="lines" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you consume the input stream in a custom component, you must close the <code>Session</code>.
You can do so either in your custom code or by routing a copy of the message to a <code>service-activator</code> and using SpEL, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="closeSession"
    expression="headers['closeableResource'].close()" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mget-command"><a class="anchor" href="#using-the-mget-command"></a>18.9.4. Using the <code>mget</code> Command</h4>
<div class="paragraph">
<p><code>mget</code> retrieves multiple remote files based on a pattern and supports the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-P</code>: Preserve the timestamps of the remote files.</p>
</li>
<li>
<p><code>-R</code>: Retrieve the entire directory tree recursively.</p>
</li>
<li>
<p><code>-x</code>: Throw an exception if no files match the pattern (otherwise an empty list is returned).</p>
</li>
<li>
<p><code>-D</code>: Delete each remote file after successful transfer.
The remote file is not deleted if the transfer is ignored, because the <code>FileExistsMode</code> is <code>IGNORE</code> and the local file already exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>mget</code> operation is a <code>List&lt;File&gt;</code> object (that is, a <code>List</code> of <code>File</code> objects, each representing a retrieved file).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.0, if the <code>FileExistsMode</code> is <code>IGNORE</code>, the payload of the output message no longer contains files that were not fetched due to the file already existing.
Previously, the list contained all files, including those that already existed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The expression used to determine the remote path should produce a result that ends with <code><strong></code> - e.g. <code>somedir/</strong></code> will fetch the complete tree under <code>somedir</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, a recursive <code>mget</code>, combined with the new <code>FileExistsMode.REPLACE_IF_MODIFIED</code> mode, can be used to periodically synchronize an entire remote directory tree locally.
This mode replaces the local file&#8217;s last modified timestamp with the remote timestamp, regardless of the <code>-P</code> (preserve timestamp) option.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Using recursion (<code>-R</code>)</div>
<div class="paragraph">
<p>The pattern is ignored, and <code>*</code> is assumed.
By default, the entire remote tree is retrieved.
However, files in the tree can be filtered, by providing a <code>FileListFilter</code>.
Directories in the tree can also be filtered this way.
A <code>FileListFilter</code> can be provided by reference, by <code>filename-pattern</code>, or by <code>filename-regex</code> attributes.
For example, <code>filename-regex="(subDir|.*1.txt)"</code> retrieves all files ending with <code>1.txt</code> in the remote directory and the <code>subDir</code> child directory.
However, the next example shows an alternative, which version 5.0 made available.</p>
</div>
<div class="paragraph">
<p>If a subdirectory is filtered, no additional traversal of that subdirectory is performed.</p>
</div>
<div class="paragraph">
<p>The <code>-dirs</code> option is not allowed (the recursive <code>mget</code> uses the recursive <code>ls</code> to obtain the directory tree, so the directories themselves cannot be included in the list).</p>
</div>
<div class="paragraph">
<p>Typically, you would use the <code>#remoteDirectory</code> variable in the <code>local-directory-expression</code> so that the remote directory structure is retained locally.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>FtpSimplePatternFileListFilter</code> and <code>FtpRegexPatternFileListFilter</code> can be configured to always pass directories by setting the <code>alwaysAcceptDirectories</code> property to <code>true</code>.
Doing so allows recursion for a simple pattern, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="starDotTxtFilter"
        class="org.springframework.integration.ftp.filters.FtpSimplePatternFileListFilter"&gt;
    &lt;constructor-arg value="*.txt" /&gt;
    &lt;property name="alwaysAcceptDirectories" value="true" /&gt;
&lt;/bean&gt;

&lt;bean id="dotStarDotTxtFilter"
            class="org.springframework.integration.ftp.filters.FtpRegexPatternFileListFilter"&gt;
    &lt;constructor-arg value="^.*\.txt$" /&gt;
    &lt;property name="alwaysAcceptDirectories" value="true" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once you have defined filters such as those in the preceding example, you can use one by setting the <code>filter</code> property on the gateway.</p>
</div>
<div class="paragraph">
<p>See also <a href="#ftp-partial">Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="ftp-put-command"><a class="anchor" href="#ftp-put-command"></a>18.9.5. Using the <code>put</code> Command</h4>
<div class="paragraph">
<p>The <code>put</code> commad sends a file to the remote server.
The payload of the message can be a <code>java.io.File</code>, a <code>byte[]</code>, or a <code>String</code>.
A <code>remote-filename-generator</code> (or expression) is used to name the remote file.
Other available attributes include <code>remote-directory</code>, <code>temporary-remote-directory</code>, and their <code>*-expression</code> equivalents: <code>use-temporary-file-name</code> and <code>auto-create-directory</code>.
See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema</a> documentation for more information.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from a <code>put</code> operation is a <code>String</code> that represents the full path of the file on the server after transfer.</p>
</div>
<div class="paragraph">
<p>Using the <code>mput</code> Command</p>
</div>
<div class="paragraph">
<p>The <code>mput</code> sends multiple files to the server and supports only one option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-R</code>: Recursive.
Send all files (possibly filtered) in the directory and its subdirectories.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload must be a <code>java.io.File</code> (or <code>String</code>) that represents a local directory.
Since version 5.1, a collection of <code>File</code> or <code>String</code> is also supported.</p>
</div>
<div class="paragraph">
<p>This command supports the same attributes as the <a href="#ftp-put-command"><code>put</code> command</a>.
In addition, files in the local directory can be filtered with one of <code>mput-pattern</code>, <code>mput-regex</code>, <code>mput-filter</code>, or <code>mput-filter-expression</code>.
The filter works with recursion, as long as the subdirectories themselves pass the filter.
Subdirectories that do not pass the filter are not recursed.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>mget</code> operation is a <code>List&lt;String&gt;</code> object (that is, a <code>List</code> of remote file paths that result from the transfer).</p>
</div>
<div class="paragraph">
<p>See also <a href="#ftp-partial">Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-rm-command"><a class="anchor" href="#using-the-rm-command"></a>18.9.6. Using the <code>rm</code> Command</h4>
<div class="paragraph">
<p>The <code>rm</code> command removes files.</p>
</div>
<div class="paragraph">
<p>The <code>rm</code> command has no options.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>rm</code> operation is <code>Boolean.TRUE</code> if the remove was successful or <code>Boolean.FALSE</code> otherwise.
The <code>file_remoteDirectory</code> header provides the remote directory, and the <code>file_remoteFile</code> header provides the file name.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mv-command"><a class="anchor" href="#using-the-mv-command"></a>18.9.7. Using the <code>mv</code> Command</h4>
<div class="paragraph">
<p>The <code>mv</code> command moves files</p>
</div>
<div class="paragraph">
<p>The <code>mv</code> command has no options.</p>
</div>
<div class="paragraph">
<p>The <code>expression</code> attribute defines the &#8220;from&#8221; path and the <code>rename-expression</code> attribute defines the &#8220;to&#8221; path.
By default, the <code>rename-expression</code> is <code>headers['file_renameTo']</code>.
This expression must not evaluate to null or an empty <code>String</code>.
If necessary, any necessary remote directories are created.
The payload of the result message is <code>Boolean.TRUE</code>.
The <code>file_remoteDirectory</code> header provides the original remote directory, and <code>file_remoteFile</code> header provides the file name.
The new path is in the <code>file_renameTo</code> header.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-information-about-ftp-outbound-gateway-commands"><a class="anchor" href="#additional-information-about-ftp-outbound-gateway-commands"></a>18.9.8. Additional Information about FTP Outbound Gateway Commands</h4>
<div class="paragraph">
<p>The <code>get</code> and <code>mget</code> commands support the <code>local-filename-generator-expression</code> attribute.
It defines a SpEL expression to generate the name of local files during the transfer.
The root object of the evaluation context is the request message.
 The <code>remoteFileName</code> variable, which is particularly useful for <code>mget</code>, is also available&#8201;&#8212;&#8201;for example, <code>local-filename-generator-expression="#remoteFileName.toUpperCase() + headers.something"</code>.</p>
</div>
<div class="paragraph">
<p>The <code>get</code> and <code>mget</code> commands support the <code>local-directory-expression</code> attribute.
It defines a SpEL expression to generate the name of local directories during the transfer.
The root object of the evaluation context is the request message but.
The <code>remoteDirectory</code> variable, which is particularly useful for <code>mget</code>, is also available&#8201;&#8212;&#8201;for example: <code>local-directory-expression="'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.something"</code>.
This attribute is mutually exclusive with the <code>local-directory</code> attribute.</p>
</div>
<div class="paragraph">
<p>For all commands, the 'expression' property of the gateway provides the path on which the command acts.
For the <code>mget</code> command, the expression might evaluate to '<strong>', meaning to retrieve all files, or 'somedirectory/</strong>', and so on.</p>
</div>
<div class="paragraph">
<p>The following example shows a gateway configured for an <code>ls</code> command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:outbound-gateway id="gateway1"
    session-factory="ftpSessionFactory"
    request-channel="inbound1"
    command="ls"
    command-options="-1"
    expression="payload"
    reply-channel="toSplitter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The payload of the message sent to the <code>toSplitter</code> channel is a list of <code>String</code> objects that each contain the name of a file.
If the <code>command-options</code> attribute was omitted, it holds <code>FileInfo</code> objects.
It uses space-delimited options&#8201;&#8212;&#8201;for example, <code>command-options="-1 -dirs -links"</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>GET</code>, <code>MGET</code>, <code>PUT</code> and <code>MPUT</code> commands support a <code>FileExistsMode</code> property (<code>mode</code> when using the namespace support).
This affects the behavior when the local file exists (<code>GET</code> and <code>MGET</code>) or the remote file exists (<code>PUT</code> and <code>MPUT</code>).
Supported modes are <code>REPLACE</code>, <code>APPEND</code>, <code>FAIL</code>, and <code>IGNORE</code>.
For backwards compatibility, the default mode for <code>PUT</code> and <code>MPUT</code> operations is <code>REPLACE</code>.
For <code>GET</code> and <code>MGET</code> operations, the default is <code>FAIL</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>setWorkingDirExpression()</code> (<code>working-dir-expression</code> in XML) option is provided on the <code>FtpOutboundGateway</code> (<code>&lt;int-ftp:outbound-gateway&gt;</code> in XML).
It lets you change the client working directory at runtime.
The expression is evaluated against the request message.
The previous working directory is restored after each gateway operation.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-12"><a class="anchor" href="#configuring-with-java-configuration-12"></a>18.9.9. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FtpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FtpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        sf.setTestSession(true);
        return new CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    @Bean
    @ServiceActivator(inputChannel = "ftpChannel")
    public MessageHandler handler() {
        FtpOutboundGateway ftpOutboundGateway =
                          new FtpOutboundGateway(ftpSessionFactory(), "ls", "'my_remote_dir/'");
        ftpOutboundGateway.setOutputChannelName("lsReplyChannel");
        return ftpOutboundGateway;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-13"><a class="anchor" href="#configuring-with-the-java-dsl-13"></a>18.9.10. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FtpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(FtpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public SessionFactory&lt;FTPFile&gt; ftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        sf.setTestSession(true);
        return new CachingSessionFactory&lt;FTPFile&gt;(sf);
    }

    @Bean
    public FtpOutboundGatewaySpec ftpOutboundGateway() {
        return Ftp.outboundGateway(ftpSessionFactory(),
            AbstractRemoteFileOutboundGateway.Command.MGET, "payload")
            .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)
            .regexFileNameFilter("(subFtpSource|.*1.txt)")
            .localDirectoryExpression("'localDirectory/' + #remoteDirectory")
            .localFilenameExpression("#remoteFileName.replaceFirst('ftpSource', 'localTarget')");
    }

    @Bean
    public IntegrationFlow ftpMGetFlow(AbstractRemoteFileOutboundGateway&lt;FTPFile&gt; ftpOutboundGateway) {
        return f -&gt; f
            .handle(ftpOutboundGateway)
            .channel(c -&gt; c.queue("remoteFileOutputChannel"));
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ftp-partial"><a class="anchor" href="#ftp-partial"></a>18.9.11. Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</h4>
<div class="paragraph">
<p>When you perform operations on multiple files (by using <code>mget</code> and <code>mput</code>), an exception can occur some time after one or more files have been transferred.
In this case (starting with version 4.2), a <code>PartialSuccessException</code> is thrown.
As well as the usual <code>MessagingException</code> properties (<code>failedMessage</code> and <code>cause</code>), this exception has two additional
properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>partialResults</code>: The successful transfer results.</p>
</li>
<li>
<p><code>derivedInput</code>: The list of files generated from the request message (for example, local files to transfer for an <code>mput</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These attributes let you determine which files were successfully transferred and which were not.</p>
</div>
<div class="paragraph">
<p>In the case of a recursive <code>mput</code>, the <code>PartialSuccessException</code> may have nested <code>PartialSuccessException</code> occurrences.</p>
</div>
<div class="paragraph">
<p>Consider the following directory structure:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>root/
|- file1.txt
|- subdir/
   | - file2.txt
   | - file3.txt
|- zoo.txt</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the exception occurs on <code>file3.txt</code>, the <code>PartialSuccessException</code> thrown by the gateway has <code>derivedInput</code>
of <code>file1.txt</code>, <code>subdir</code>, and <code>zoo.txt</code> and <code>partialResults</code> of <code>file1.txt</code>.
Its <code>cause</code> is another <code>PartialSuccessException</code> with <code>derivedInput</code> of <code>file2.txt</code> and <code>file3.txt</code> and
<code>partialResults</code> of <code>file2.txt</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ftp-session-caching"><a class="anchor" href="#ftp-session-caching"></a>18.10. FTP Session Caching</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with Spring Integration 3.0, sessions are no longer cached by default.
The <code>cache-sessions</code> attribute is no longer supported on endpoints.
You must use a <code>CachingSessionFactory</code> (shown in the next example) if you wish to cache sessions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In versions prior to 3.0, the sessions were automatically cached by default.
A <code>cache-sessions</code> attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session caching attributes.
For example, you could not limit the number of sessions created.
To support that requirement and other configuration options, a <code>CachingSessionFactory</code> was added.
It provides <code>sessionCacheSize</code> and <code>sessionWaitTimeout</code> properties.
The <code>sessionCacheSize</code> property controls how many active sessions the factory maintains in its cache (the default is unbounded).
If the <code>sessionCacheSize</code> threshold has been reached, any attempt to acquire another session blocks until either one of the cached sessions becomes available or until the wait time for a session expires (the default wait time is <code>Integer.MAX_VALUE</code>).
The <code>sessionWaitTimeout</code> property configures that value.</p>
</div>
<div class="paragraph">
<p>If you want your sessions to be cached, configure your default session factory as described earlier and then wrap it in an instance of <code>CachingSessionFactory</code>, where you can provide those additional properties.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="ftpSessionFactory" class="o.s.i.ftp.session.DefaultFtpSessionFactory"&gt;
    &lt;property name="host" value="localhost"/&gt;
&lt;/bean&gt;

&lt;bean id="cachingSessionFactory" class="o.s.i.file.remote.session.CachingSessionFactory"&gt;
    &lt;constructor-arg ref="ftpSessionFactory"/&gt;
    &lt;constructor-arg value="10"/&gt;
    &lt;property name="sessionWaitTimeout" value="1000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows a <code>CachingSessionFactory</code> created with the <code>sessionCacheSize</code> set to <code>10</code> and the
<code>sessionWaitTimeout</code> set to one second (its value is in milliseconds).</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, the <code>CachingConnectionFactory</code> provides a <code>resetCache()</code> method.
When invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.
New requests for sessions establish new sessions as necessary.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>CachingSessionFactory</code> has a new property <code>testSession</code>.
When true, the session will be tested by sending a NOOP command to ensure it is still active; if not, it will be removed from the cache; a new session is created if no active sessions are in the cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="ftp-rft"><a class="anchor" href="#ftp-rft"></a>18.11. Using <code>RemoteFileTemplate</code></h3>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, a new abstraction is provided over the <code>FtpSession</code> object.
The template provides methods to send, retrieve (as an <code>InputStream</code>), remove, and rename files.
In addition an <code>execute</code> method is provided allowing the caller to execute multiple operations on the session.
In all cases, the template takes care of reliably closing the session.
For more information, see the
<a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html">Javadoc for <code>RemoteFileTemplate</code></a>.
There is a subclass for FTP: <code>FtpRemoteFileTemplate</code>.</p>
</div>
<div class="paragraph">
<p>Version 4.1 added added additional methods, including <code>getClientInstance()</code>, which provides access to the underlying <code>FTPClient</code> and thus gives you access to low-level APIs.</p>
</div>
<div class="paragraph">
<p>Not all FTP servers properly implement the <code>STAT &lt;path&gt;</code> command.
Some return a positive result for a non-existent path.
The <code>NLST</code> command reliably returns the name when the path is a file and it exists.
However, this does not support checking that an empty directory exists since <code>NLST</code> always returns an empty list when the path is a directory.
Since the template does not know whether the path represents a directory, it has to perform additional checks when the path does not appear to exist (when using <code>NLST</code>).
This adds overhead, requiring several requests to the server.
Starting with version 4.1.9, the <code>FtpRemoteFileTemplate</code> provides the <code>FtpRemoteFileTemplate.ExistsMode</code> property, which has the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>STAT</code>: Perform the <code>STAT</code> FTP command (<code>FTPClient.getStatus(path)</code>) to check the path existence.
This is the default and requires that your FTP server properly support the <code>STAT</code> command (with a path).</p>
</li>
<li>
<p><code>NLST</code>: Perform the <code>NLST</code> FTP command&#8201;&#8212;&#8201;<code>FTPClient.listName(path)</code>.
Use this if you are testing for a path that is a full path to a file.
It does not work for empty directories.</p>
</li>
<li>
<p><code>NLST_AND_DIRS</code>:  Perform the <code>NLST</code> command first and, if it returns no files, fall back to a technique that temporarily switches the working directory by using <code>FTPClient.changeWorkingDirectory(path)</code>.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/session/FtpSession.html#exists"><code>FtpSession.exists()</code></a> for more information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since we know that the <code>FileExistsMode.FAIL</code> case is always only looking for a file (and not a directory), we safely use <code>NLST</code> mode for the <code>FtpMessageHandler</code> and <code>FtpOutboundGateway</code> components.</p>
</div>
<div class="paragraph">
<p>For any other cases, the <code>FtpRemoteFileTemplate</code> can be extended to implement custom logic in the overridden <code>exist()</code> method.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the new <code>RemoteFileOperations.invoke(OperationsCallback&lt;F, T&gt; action)</code> method is available.
This method lets several <code>RemoteFileOperations</code> calls be called in the scope of the same, thread-bounded, <code>Session</code>.
This is useful when you need to perform several high-level operations of the <code>RemoteFileTemplate</code> as one unit of work.
For example, <code>AbstractRemoteFileOutboundGateway</code> uses it with the <code>mput</code> command implementation, where we perform a <code>put</code> operation for each file in the provided directory and recursively for its sub-directories.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileOperations.html#invoke">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="ftp-session-callback"><a class="anchor" href="#ftp-session-callback"></a>18.12. Using <code>MessageSessionCallback</code></h3>
<div class="paragraph">
<p>Starting with Spring Integration 4.2, you can use a <code>MessageSessionCallback&lt;F, T&gt;</code> implementation with the
<code>&lt;int-ftp:outbound-gateway/&gt;</code> (<code>FtpOutboundGateway</code> in Java) to perform any operations on the <code>Session&lt;FTPFile&gt;</code> with
the <code>requestMessage</code> context.
It can be used for any non-standard or low-level FTP operations and allows access from an integration flow definition and functional interface (Lambda) implementation injection, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "ftpChannel")
public MessageHandler ftpOutboundGateway(SessionFactory&lt;FTPFile&gt; sessionFactory) {
    return new FtpOutboundGateway(sessionFactory,
         (session, requestMessage) -&gt; session.list(requestMessage.getPayload()));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another example might be to pre- or post-process the file data being sent or retrieved.</p>
</div>
<div class="paragraph">
<p>When using XML configuration, the <code>&lt;int-ftp:outbound-gateway/&gt;</code> provides a <code>session-callback</code> attribute to let you specify the <code>MessageSessionCallback</code> bean name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>session-callback</code> is mutually exclusive with the <code>command</code> and <code>expression</code> attributes.
When configuring with Java, different constructors are available in the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/gateway/FtpOutboundGateway.html"><code>FtpOutboundGateway</code></a> class.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="gemfire"><a class="anchor" href="#gemfire"></a>19. Pivotal GemFire and Apache Geode Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides support for Pivotal GemFire and Apache Geode.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-gemfire&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-gemfire:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>GemFire is a distributed data management platform that provides a key-value data grid along with advanced distributed system features, such as event processing, continuous querying, and remote function execution.
This guide assumes some familiarity with the commercial <a href="https://pivotal.io/pivotal-gemfire">Pivotal GemFire</a> or Open Source <a href="https://geode.apache.org">Apache Geode</a>.</p>
</div>
<div class="paragraph">
<p>Spring integration provides support for GemFire by implementing inbound adapters for entry and continuous query events, an outbound adapter to write entries to the cache, and message and metadata stores and <code>GemfireLockRegistry</code> implementations.
Spring integration leverages the <a href="https://projects.spring.io/spring-data-gemfire">Spring Data for Pivotal GemFire</a> project, providing a thin wrapper over its components.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the Spring Integration GemFire module uses the <a href="https://github.com/spring-projects/spring-data-geode">Spring Data for Apache Geode</a> transitive dependency by default.
To switch to the commercial Pivotal GemFire-based Spring Data for Pivotal GemFire, exclude <code>spring-data-geode</code> from dependencies and add <code>spring-data-gemfire</code>, as the following Maven snippet shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-gemfire&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-geode&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-gemfire&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To configure the 'int-gfe' namespace, include the following elements within the headers of your XML configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">xmlns:int-gfe="http://www.springframework.org/schema/integration/gemfire"
xsi:schemaLocation="http://www.springframework.org/schema/integration/gemfire
	https://www.springframework.org/schema/integration/gemfire/spring-integration-gemfire.xsd"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-inbound"><a class="anchor" href="#gemfire-inbound"></a>19.1. Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The inbound channel adapter produces messages on a channel when triggered by a GemFire <code>EntryEvent</code>.
GemFire generates events whenever an entry is <code>CREATED</code>, <code>UPDATED</code>, <code>DESTROYED</code>, or <code>INVALIDATED</code> in the associated region.
The inbound channel adapter lets you filter on a subset of these events.
For example, you may want to produce messages only in response to an entry being created.
In addition, the inbound channel adapter can evaluate a SpEL expression if, for example, you want your message payload to contain an event property such as the new entry value.
The following example shows how to configure an inbound channel adapter with a SpEL language (in the <code>expression</code> attribute):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;gfe:cache/&gt;
&lt;gfe:replicated-region id="region"/&gt;
&lt;int-gfe:inbound-channel-adapter id="inputChannel" region="region"
    cache-events="CREATED" expression="newValue"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration creates a GemFire <code>Cache</code> and <code>Region</code> by using Spring GemFire&#8217;s 'gfe' namespace.
The <code>inbound-channel-adapter</code> element requires a reference to the GemFire region on which the adapter listens for events.
Optional attributes include <code>cache-events</code>, which can contain a comma-separated list of event types for which a message is produced on the input channel.
By default, <code>CREATED</code> and <code>UPDATED</code> are enabled.
If no <code>channel</code> attribute is provided, the channel is created from the <code>id</code> attribute.
This adapter also supports an <code>error-channel</code>.
The GemFire <a href="https://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/EntryEvent.html"><code>EntryEvent</code></a> is the <code>#root</code> object of the <code>expression</code> evaluation.
The following example shows an expression that replaces a value for a key:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>expression="new something.MyEvent(key, oldValue, newValue)"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the <code>expression</code> attribute is not provided, the message payload is the GemFire <code>EntryEvent</code> itself.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This adapter conforms to Spring Integration conventions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-cq"><a class="anchor" href="#gemfire-cq"></a>19.2. Continuous Query Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The continuous query inbound channel adapter produces messages on a channel when triggered by a GemFire continuous query or <code>CqEvent</code> event.
In release <code>1.1</code>, Spring Data introduced continuous query support, including <code>ContinuousQueryListenerContainer</code>, which provides a nice abstraction over the GemFire native API.
This adapter requires a reference to a <code>ContinuousQueryListenerContainer</code> instance, creates a listener for a given <code>query</code>, and executes the query.
The continuous query acts as an event source that fires whenever its result set changes state.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
GemFire queries are written in OQL and are scoped to the entire cache (not just one region).
Additionally, continuous queries require a remote (that is, running in a separate process or remote host) cache server.
See the <a href="https://gemfire82.docs.pivotal.io/docs-gemfire/gemfire_nativeclient/continuous-querying/continuous-querying.html">GemFire documentation</a> for more information on implementing continuous queries.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following configuration creates a GemFire client cache (recall that a remote cache server is required for this implementation and its address is configured as a child element of the pool), a client region, and a <code>ContinuousQueryListenerContainer</code> that uses Spring Data:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;gfe:client-cache id="client-cache" pool-name="client-pool"/&gt;

&lt;gfe:pool id="client-pool" subscription-enabled="true" &gt;
    &lt;!--configure server or locator here required to address the cache server --&gt;
&lt;/gfe:pool&gt;

&lt;gfe:client-region id="test" cache-ref="client-cache" pool-name="client-pool"/&gt;

&lt;gfe:cq-listener-container id="queryListenerContainer" cache="client-cache"
    pool-name="client-pool"/&gt;

&lt;int-gfe:cq-inbound-channel-adapter id="inputChannel"
    cq-listener-container="queryListenerContainer"
    query="select * from /test"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The continuous query inbound channel adapter requires a <code>cq-listener-container</code> attribute, which must contain a reference to the <code>ContinuousQueryListenerContainer</code>.
Optionally, it accepts an <code>expression</code> attribute that uses SpEL to transform the <code>CqEvent</code> or extract an individual property as needed.
The <code>cq-inbound-channel-adapter</code> provides a <code>query-events</code> attribute that contains a comma-separated list of event types for which a message is produced on the input channel.
The available event types are <code>CREATED</code>, <code>UPDATED</code>, <code>DESTROYED</code>, <code>REGION_DESTROYED</code>, and <code>REGION_INVALIDATED</code>.
By default, <code>CREATED</code> and <code>UPDATED</code> are enabled.
Additional optional attributes include <code>query-name</code> (which provides an optional query name), <code>expression</code> (which works as described in the preceding section), and <code>durable</code> (a boolean value indicating if the query is durable&#8201;&#8212;&#8201;it is false by default).
If you do not provide a <code>channel</code>, the channel is created from the <code>id</code> attribute.
This adapter also supports an <code>error-channel</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This adapter conforms to Spring Integration conventions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-outbound"><a class="anchor" href="#gemfire-outbound"></a>19.3. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The outbound channel adapter writes cache entries that are mapped from the message payload.
In its simplest form, it expects a payload of type <code>java.util.Map</code> and puts the map entries into its configured region.
The following example shows how to configure an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-gfe:outbound-channel-adapter id="cacheChannel" region="region"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding configuration, an exception is thrown if the payload is not a <code>Map</code>.
Additionally, you can configure the outbound channel adapter to create a map of cache entries by using SpEL.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-gfe:outbound-channel-adapter id="cacheChannel" region="region"&gt;
    &lt;int-gfe:cache-entries&gt;
        &lt;entry key="payload.toUpperCase()" value="payload.toLowerCase()"/&gt;
        &lt;entry key="'thing1'" value="'thing2'"/&gt;
    &lt;/int-gfe:cache-entries&gt;
&lt;/int-gfe:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, the inner element (<code>cache-entries</code>) is semantically equivalent to a Spring 'map' element.
The adapter interprets the <code>key</code> and <code>value</code> attributes as SpEL expressions with the message as the evaluation context.
Note that this can contain arbitrary cache entries (not only those derived from the message) and that literal values must be enclosed in single quotes.
In the preceding example, if the message sent to <code>cacheChannel</code> has a <code>String</code> payload with a value <code>Hello</code>, two entries (<code>[HELLO:hello, thing1:thing2]</code>) are written (either created or updated) in the cache region.
This adapter also supports the <code>order</code> attribute, which may be useful if it is bound to a <code>PublishSubscribeChannel</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-message-store"><a class="anchor" href="#gemfire-message-store"></a>19.4. Gemfire Message Store</h3>
<div class="paragraph">
<p>As described in EIP, a <a href="https://www.enterpriseintegrationpatterns.com/MessageStore.html">message store</a> lets you persist messages.
This can be useful when dealing with components that have a capability to buffer messages (<code>QueueChannel</code>, <code>Aggregator</code>, <code>Resequencer</code>, and others) if reliability is a concern.
In Spring Integration, the <code>MessageStore</code> strategy interface also provides the foundation for the <a href="https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">claim check</a> pattern, which is described in EIP as well.</p>
</div>
<div class="paragraph">
<p>Spring Integration&#8217;s Gemfire module provides <code>GemfireMessageStore</code>, which is an implementation of both the the <code>MessageStore</code> strategy (mainly used by the <code>QueueChannel</code> and <code>ClaimCheck</code> patterns) and the <code>MessageGroupStore</code> strategy (mainly used by the <code>Aggregator</code> and <code>Resequencer</code> patterns).</p>
</div>
<div class="paragraph">
<p>The following example configures the cache and region by using the <code>spring-gemfire</code> namespace (not to be confused with the <code>spring-integration-gemfire</code> namespace):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="gemfireMessageStore" class="o.s.i.gemfire.store.GemfireMessageStore"&gt;
    &lt;constructor-arg ref="myRegion"/&gt;
&lt;/bean&gt;

&lt;gfe:cache/&gt;

&lt;gfe:replicated-region id="myRegion"/&gt;


&lt;int:channel id="somePersistentQueueChannel"&gt;
    &lt;int:queue message-store="gemfireMessageStore"/&gt;
&lt;int:channel&gt;

&lt;int:aggregator input-channel="inputChannel" output-channel="outputChannel"
    message-store="gemfireMessageStore"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Often, it is desirable for the message store to be maintained in one or more remote cache servers in a client-server configuration.
In this case, you should configure a client cache, a client region, and a client pool and inject the region into the <code>MessageStore</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="gemfireMessageStore"
    class="org.springframework.integration.gemfire.store.GemfireMessageStore"&gt;
    &lt;constructor-arg ref="myRegion"/&gt;
&lt;/bean&gt;

&lt;gfe:client-cache/&gt;

&lt;gfe:client-region id="myRegion" shortcut="PROXY" pool-name="messageStorePool"/&gt;

&lt;gfe:pool id="messageStorePool"&gt;
    &lt;gfe:server host="localhost" port="40404" /&gt;
&lt;/gfe:pool&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>pool</code> element is configured with the address of a cache server (you can substitute a locator here).
The region is configured as a 'PROXY' so that no data is stored locally.
The region&#8217;s <code>id</code> corresponds to a region with the same name in the cache server.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.12, the <code>GemfireMessageStore</code> supports the key <code>prefix</code> option to allow distinguishing between instances of the store on the same GemFire region.</p>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-lock-registry"><a class="anchor" href="#gemfire-lock-registry"></a>19.5. Gemfire Lock Registry</h3>
<div class="paragraph">
<p>Starting with version 4.0, the <code>GemfireLockRegistry</code> is available.
Certain components (for example, the aggregator and the resequencer) use a lock obtained from a <code>LockRegistry</code> instance to ensure that only one thread is manipulating a group at any given time.
The <code>DefaultLockRegistry</code> performs this function within a single component.
You can now configure an external lock registry on these components.
When you use a shared <code>MessageGroupStore</code> with the <code>GemfireLockRegistry</code>, it can provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One of the <code>GemfireLockRegistry</code> constructors requires a <code>Region</code> as an argument.
It is used to obtain a <code>Lock</code> from the <code>getDistributedLock()</code> method.
This operation requires <code>GLOBAL</code> scope for the <code>Region</code>.
Another constructor requires a <code>Cache</code>, and the <code>Region</code> is created with <code>GLOBAL</code> scope and with the name, <code>LockRegistry</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="gemfire-metadata-store"><a class="anchor" href="#gemfire-metadata-store"></a>19.6. Gemfire Metadata Store</h3>
<div class="paragraph">
<p>Version 4.0 introduced a new Gemfire-based <code>MetadataStore</code> (<a href="#metadata-store">Metadata Store</a>) implementation.
You can use the <code>GemfireMetadataStore</code> to maintain metadata state across application restarts.
This new <code>MetadataStore</code> implementation can be used with adapters such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#feed-inbound-channel-adapter">Feed Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#file-reading">Reading Files</a></p>
</li>
<li>
<p><a href="#ftp-inbound">FTP Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#sftp-inbound">SFTP Inbound Channel Adapter</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get these adapters to use the new <code>GemfireMetadataStore</code>, declare a Spring bean with a bean name of <code>metadataStore</code>.
The feed inbound channel adapter automatically picks up and use the declared <code>GemfireMetadataStore</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>GemfireMetadataStore</code> also implements <code>ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances, where only one instance can store or modify a key&#8217;s value.
These methods give various levels of concurrency guarantees based on the scope and data policy of the region.
They are implemented in the peer cache and client-server cache but are disallowed in peer regions that have <code>NORMAL</code> or <code>EMPTY</code> data policies.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since version 5.0, the <code>GemfireMetadataStore</code> also implements <code>ListenableMetadataStore</code>, which lets you listen to cache events by providing <code>MetadataStoreListener</code> instances to the store, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GemfireMetadataStore metadataStore = new GemfireMetadataStore(cache);
metadataStore.addListener(new MetadataStoreListenerAdapter() {

    @Override
    public void onAdd(String key, String value) {
         ...
    }

});</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="http"><a class="anchor" href="#http"></a>20. HTTP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration&#8217;s HTTP support allows for the running of HTTP requests and the processing of inbound HTTP requests.
The HTTP support consists of the following gateway implementations: <code>HttpInboundEndpoint</code> and <code>HttpRequestExecutingMessageHandler</code>.
See also <a href="#webflux">WebFlux Support</a>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-http&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-http:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>javax.servlet:javax.servlet-api</code> dependency must be provided on the target Servlet container.</p>
</div>
<div class="sect2">
<h3 id="http-inbound"><a class="anchor" href="#http-inbound"></a>20.1. Http Inbound Components</h3>
<div class="paragraph">
<p>To receive messages over HTTP, you need to use an HTTP inbound channel adapter or an HTTP inbound gateway.
To support the HTTP inbound adapters, they need to be deployed within a servlet container such as <a href="https://tomcat.apache.org/">Apache Tomcat</a> or <a href="https://www.eclipse.org/jetty/">Jetty</a>.
The easiest way to do this is to use Spring&#8217;s
<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/support/HttpRequestHandlerServlet.html"><code>HttpRequestHandlerServlet</code></a>, by providing the following servlet definition in the <code>web.xml</code> file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;inboundGateway&lt;/servlet-name&gt;
    &lt;servlet-class&gt;o.s.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that the servlet name matches the bean name.
For more information on using the <code>HttpRequestHandlerServlet</code>, see
<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/remoting.html">Remoting and web services using Spring</a>,
which is part of the Spring Framework Reference documentation.</p>
</div>
<div class="paragraph">
<p>If you are running within a Spring MVC application, then the aforementioned explicit servlet definition is not necessary.
In that case, the bean name for your gateway can be matched against the URL path as you would for a Spring MVC Controller bean.
For more information, see
<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html">Web MVC framework</a>, which is part of the Spring Framework Reference documentation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For a sample application and the corresponding configuration, see the <a href="https://github.com/spring-projects/spring-integration-samples">Spring Integration Samples</a> repository.
It contains the <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/basic/http">HTTP sample</a> application, which demonstrates Spring Integration&#8217;s HTTP support.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example bean defines an HTTP inbound endpoint:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="httpInbound"
  class="org.springframework.integration.http.inbound.HttpRequestHandlingMessagingGateway"&gt;
  &lt;property name="requestChannel" ref="httpRequestChannel" /&gt;
  &lt;property name="replyChannel" ref="httpReplyChannel" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>HttpRequestHandlingMessagingGateway</code> accepts a list of <code>HttpMessageConverter</code> instances or else relies on a default list.
The converters allow customization of the mapping from <code>HttpServletRequest</code> to <code>Message</code>.
The default converters encapsulate simple strategies, which (for example) create a <code>String</code> message for a <code>POST</code> request where the content type starts with <code>text</code>.
See the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> for full details.
An additional flag (<code>mergeWithDefaultConverters</code>) can be set along with the list of custom <code>HttpMessageConverter</code> to add the default converters after the custom converters.
By default, this flag is set to <code>false</code>, meaning that the custom converters replace the default list.</p>
</div>
<div class="paragraph">
<p>The message conversion process uses the (optional) <code>requestPayloadType</code> property and the incoming <code>Content-Type</code> header.
Starting with version 4.3, if a request has no content type header, <code>application/octet-stream</code> is assumed, as
recommended by <code>RFC 2616</code>.
Previously, the body of such messages was ignored.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.0 implemented multipart file support.
If the request has been wrapped as a <code>MultipartHttpServletRequest</code>, when you use the default converters, that request is converted to a <code>Message</code> payload that is a <code>MultiValueMap</code> containing values that may be byte arrays, strings, or instances of Spring&#8217;s <code>MultipartFile</code>, depending on the content type of the individual parts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The HTTP inbound endpoint locates a <code>MultipartResolver</code> in the context if one has a bean name of <code>multipartResolver</code> (the same name expected by Spring&#8217;s <code>DispatcherServlet</code>).
If it does locate that bean, the support for multipart files is enabled on the inbound request mapper.
Otherwise, it fails when it tries to map a multipart file request to a Spring Integration <code>Message</code>.
For more on Spring&#8217;s support for <code>MultipartResolver</code>, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-multipart">Spring Reference Manual</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you wish to proxy a <code>multipart/form-data</code> to another server, it may be better to keep it in raw form.
To handle this situation, do not add the <code>multipartResolver</code> bean to the context.
Configure the endpoint to expect a <code>byte[]</code> request, customize the message converters to include a <code>ByteArrayHttpMessageConverter</code>, and disable the default multipart converter.
You may need some other converters for the replies.
The following example shows such an arrangement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-gateway
                  channel="receiveChannel"
                  path="/inboundAdapter.htm"
                  request-payload-type="byte[]"
                  message-converters="converters"
                  merge-with-default-converters="false"
                  supported-methods="POST" /&gt;

&lt;util:list id="converters"&gt;
    &lt;beans:bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter" /&gt;
    &lt;beans:bean class="org.springframework.http.converter.StringHttpMessageConverter" /&gt;
    &lt;beans:bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter" /&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you send a response to the client, you have a number of ways to customize the behavior of the gateway.
By default, the gateway acknowledges that the request was received by sending a <code>200</code> status code back.
It is possible to customize this response by providing a 'viewName' to be resolved by the Spring MVC <code>ViewResolver</code>.
If the gateway should expect a reply to the <code>Message</code>, you can set the <code>expectReply</code> flag (constructor argument) to cause the gateway to wait for a reply <code>Message</code> before creating an HTTP response.
The following example configures a gateway to serve as a Spring MVC Controller with a view name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="httpInbound"
  class="org.springframework.integration.http.inbound.HttpRequestHandlingController"&gt;
  &lt;constructor-arg value="true" /&gt; &lt;!-- indicates that a reply is expected --&gt;
  &lt;property name="requestChannel" ref="httpRequestChannel" /&gt;
  &lt;property name="replyChannel" ref="httpReplyChannel" /&gt;
  &lt;property name="viewName" value="jsonView" /&gt;
  &lt;property name="supportedMethodNames" &gt;
    &lt;list&gt;
      &lt;value&gt;GET&lt;/value&gt;
      &lt;value&gt;DELETE&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because of the <code>constructor-arg</code> value of <code>true</code>, it waits for a reply.
The preceding example also shows how to customize the HTTP methods accepted by the gateway, which are <code>POST</code> and <code>GET</code> by default.</p>
</div>
<div class="paragraph">
<p>The reply message is available in the model map.
By default, the key for that map entry is 'reply', but you can override this default by setting the 'replyKey' property on the endpoint&#8217;s configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="http-outbound"><a class="anchor" href="#http-outbound"></a>20.2. HTTP Outbound Components</h3>
<div class="paragraph">
<p>This section describes Spring Integration&#8217;s HTTP outbound components</p>
</div>
<div class="sect3">
<h4 id="using-httprequestexecutingmessagehandler"><a class="anchor" href="#using-httprequestexecutingmessagehandler"></a>20.2.1. Using <code>HttpRequestExecutingMessageHandler</code></h4>
<div class="paragraph">
<p>To configure the <code>HttpRequestExecutingMessageHandler</code>, write a bean definition similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="httpOutbound"
  class="org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler"&gt;
  &lt;constructor-arg value="http://localhost:8080/example" /&gt;
  &lt;property name="outputChannel" ref="responseChannel" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This bean definition runs HTTP requests by delegating to a <code>RestTemplate</code>.
That template, in turn, delegates to a list of <code>HttpMessageConverter</code> instances to generate the HTTP request body from the <code>Message</code> payload.
You can configure those converters as well as the <code>ClientHttpRequestFactory</code> instance to use, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="httpOutbound"
  class="org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler"&gt;
  &lt;constructor-arg value="http://localhost:8080/example" /&gt;
  &lt;property name="outputChannel" ref="responseChannel" /&gt;
  &lt;property name="messageConverters" ref="messageConverterList" /&gt;
  &lt;property name="requestFactory" ref="customRequestFactory" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the HTTP request is generated by using an instance of <code>SimpleClientHttpRequestFactory</code>, which uses the JDK <code>HttpURLConnection</code>.
Use of the Apache Commons HTTP Client is also supported through <code>CommonsClientHttpRequestFactory</code>, which you can inject (as shown earlier).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the outbound gateway, the reply message produced by the gateway contains all the message headers that are present in the request message.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-cookies"><a class="anchor" href="#using-cookies"></a>20.2.2. Using Cookies</h4>
<div class="paragraph">
<p>Basic cookie support is provided by the <code>transfer-cookies</code> attribute on the outbound gateway.
When set to <code>true</code> (the default is <code>false</code>), a <code>Set-Cookie</code> header received from the server in a response is converted to <code>Cookie</code> in the reply message.
This header is then used on subsequent sends.
This enables simple stateful interactions, such as the following:</p>
</div>
<div class="paragraph">
<p><code>&#8230;&#8203;&#8594;logonGateway&#8594;&#8230;&#8203;&#8594;doWorkGateway&#8594;&#8230;&#8203;&#8594;logoffGateway&#8594;&#8230;&#8203;</code></p>
</div>
<div class="paragraph">
<p>If <code>transfer-cookies</code> is <code>false</code>, any <code>Set-Cookie</code> header received remains as <code>Set-Cookie</code> in the reply message and is dropped on subsequent sends.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Empty Response Bodies</div>
<div class="paragraph">
<p>HTTP is a request-response protocol.
However, the response may not have a body, only headers.
In this case, the <code>HttpRequestExecutingMessageHandler</code> produces a reply <code>Message</code> with the payload being an <code>org.springframework.http.ResponseEntity</code>, regardless of any provided <code>expected-response-type</code>.
According to the <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP RFC Status Code Definitions</a>, there are many statuses that mandate that a response must not contain a message-body (for example,
<code>204 No Content</code>).
There are also cases where calls to the same URL might or might not return a response body.
For example, the first request to an HTTP resource returns content, but the second does not (returning a <code>304 Not Modified</code>).
In all cases, however, the <code>http_statusCode</code> message header is populated.
This can be used in some routing logic after the HTTP outbound gateway.
You could also use a`&lt;payload-type-router/&gt;` to route messages with a <code>ResponseEntity</code> to a different flow than that used for responses with a body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">expected-response-type</div>
<div class="paragraph">
<p>Further to the preceding note about empty response bodies, if a response does contain a body, you must provide an appropriate <code>expected-response-type</code> attribute or, again, you receive a <code>ResponseEntity</code> with no body.
The <code>expected-response-type</code> must be compatible with the (configured or default) <code>HttpMessageConverter</code> instances and the <code>Content-Type</code> header in the response.
This can be an abstract class or even an interface (such as <code>java.io.Serializable</code> when you use Java serialization and <code>Content-Type: application/x-java-serialized-object</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-namespace"><a class="anchor" href="#http-namespace"></a>20.3. HTTP Namespace Support</h3>
<div class="paragraph">
<p>Spring Integration provides an <code>http</code> namespace and the corresponding schema definition.
To include it in your configuration, provide the following namespace declaration in your application context configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-http="http://www.springframework.org/schema/integration/http"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/http
    https://www.springframework.org/schema/integration/http/spring-integration-http.xsd"&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inbound-2"><a class="anchor" href="#inbound-2"></a>20.3.1. Inbound</h4>
<div class="paragraph">
<p>The XML namespace provides two components for handling HTTP inbound requests: <code>inbound-channel-adapter</code> and <code>inbound-gateway</code>.
In order to process requests without returning a dedicated response, use the <code>inbound-channel-adapter</code>.
The following example shows how to configure one:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-channel-adapter id="httpChannelAdapter" channel="requests"
    supported-methods="PUT, DELETE"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To process requests that do expect a response, use an <code>inbound-gateway</code>.
The following example shows how to configure one:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-gateway id="inboundGateway"
    request-channel="requests"
    reply-channel="responses"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http-request-mapping"><a class="anchor" href="#http-request-mapping"></a>20.3.2. Request Mapping Support</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Integration 3.0 improved the REST support by introducing the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/IntegrationRequestMappingHandlerMapping.html"><code>IntegrationRequestMappingHandlerMapping</code></a>.
The implementation relies on the enhanced REST support provided by Spring Framework 3.1 or higher.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parsing of the HTTP inbound gateway or the HTTP inbound channel adapter registers an <code>integrationRequestMappingHandlerMapping</code> bean of type <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/IntegrationRequestMappingHandlerMapping.html"><code>IntegrationRequestMappingHandlerMapping</code></a>, in case one is not yet registered.
This particular implementation of the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerMapping.html"><code>HandlerMapping</code></a> delegates its logic to <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.html"><code>RequestMappingInfoHandlerMapping</code></a>.
The implementation provides functionality similar to the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html"><code>org.springframework.web.bind.annotation.RequestMapping</code></a> annotation in Spring MVC.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more information, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping">Mapping Requests With <code>@RequestMapping</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this purpose, Spring Integration 3.0 introduces the <code>&lt;request-mapping&gt;</code> element.
You can add this optional element to <code>&lt;http:inbound-channel-adapter&gt;</code> and <code>&lt;http:inbound-gateway&gt;</code>.
It works in conjunction with the <code>path</code> and <code>supported-methods</code> attributes.
The following example shows how to configure it on an inbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;inbound-gateway id="inboundController"
    request-channel="requests"
    reply-channel="responses"
    path="/foo/{fooId}"
    supported-methods="GET"
    view-name="foo"
    error-code="oops"&gt;
   &lt;request-mapping headers="User-Agent"
     params="myParam=myValue"
     consumes="application/json"
     produces="!text/plain"/&gt;
&lt;/inbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Based on the preceding configuration, the namespace parser creates an instance of the <code>IntegrationRequestMappingHandlerMapping</code> (if none exists) and an <code>HttpRequestHandlingController</code> bean and associates with it an instance of <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/RequestMapping.html"><code>RequestMapping</code></a>.
This <code>RequestMapping</code> instance is, in turn, converted to the Spring MVC <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/RequestMappingInfo.html"><code>RequestMappingInfo</code></a>.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;request-mapping&gt;</code> element provides the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>headers</code></p>
</li>
<li>
<p><code>params</code></p>
</li>
<li>
<p><code>consumes</code></p>
</li>
<li>
<p><code>produces</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the <code>path</code> and <code>supported-methods</code> attributes of the <code>&lt;http:inbound-channel-adapter&gt;</code> or the <code>&lt;http:inbound-gateway&gt;</code>, <code>&lt;request-mapping&gt;</code> attributes translate directly into the respective options provided by the <code>org.springframework.web.bind.annotation.RequestMapping</code> annotation in Spring MVC.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;request-mapping&gt;</code> element lets you configure several Spring Integration HTTP inbound endpoints to the same <code>path</code> (or even the same <code>supported-methods</code>) and lets you provide different downstream message flows based on incoming HTTP requests.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can also declare only one HTTP inbound endpoint and apply routing and filtering logic within the Spring Integration flow to achieve the same result.
This lets you get the <code>Message</code> into the flow as early as possibly.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-gateway request-channel="httpMethodRouter"
    supported-methods="GET,DELETE"
    path="/process/{entId}"
    payload-expression="#pathVariables.entId"/&gt;

&lt;int:router input-channel="httpMethodRouter" expression="headers.http_requestMethod"&gt;
    &lt;int:mapping value="GET" channel="in1"/&gt;
    &lt;int:mapping value="DELETE" channel="in2"/&gt;
&lt;/int:router&gt;

&lt;int:service-activator input-channel="in1" ref="service" method="getEntity"/&gt;

&lt;int:service-activator input-channel="in2" ref="service" method="delete"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information regarding handler mappings, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">the Spring Framework Web Servlet documentation</a> or <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">the Spring Framework Web Reactive documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="http-cors"><a class="anchor" href="#http-cors"></a>20.3.3. Cross-origin Resource Sharing (CORS) Support</h4>
<div class="paragraph">
<p>Starting with version 4.2, you can configure the <code>&lt;http:inbound-channel-adapter&gt;</code> and <code>&lt;http:inbound-gateway&gt;</code> with
a <code>&lt;cross-origin&gt;</code> element.
It represents the same options as Spring MVC&#8217;s <code>@CrossOrigin</code> for <code>@Controller</code> annotations and allows the configuration of cross-origin resource sharing (CORS) for Spring Integration HTTP endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>origin</code>: List of allowed origins.
<code><strong></code> means that all origins are allowed.
These values are placed in the <code>Access-Control-Allow-Origin</code> header of both the pre-flight and actual responses.
The default value is <code></strong></code>.</p>
</li>
<li>
<p><code>allowed-headers</code>: Indicates which request headers can be used during the actual request.
<code><strong></code> means that all headers requested by the client are allowed.
This property controls the value of the pre-flight response&#8217;s <code>Access-Control-Allow-Headers</code> header.
The default value is <code></strong></code>.</p>
</li>
<li>
<p><code>exposed-headers</code>: List of response headers that the user-agent lets the client access.
This property controls the value of the actual response&#8217;s <code>Access-Control-Expose-Headers</code> header.</p>
</li>
<li>
<p><code>method</code>: The HTTP request methods to allow: <code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>TRACE</code>.
Methods specified here overrides those in <code>supported-methods</code>.</p>
</li>
<li>
<p><code>allow-credentials</code>: Set to <code>true</code> if the the browser should include any cookies associated to the domain of the request or <code>false</code> if it should not.
An empty string ('""') means undefined.
If <code>true</code>, the pre-flight response includes the <code>Access-Control-Allow-Credentials=true</code> header.
The default value is <code>true</code>.</p>
</li>
<li>
<p><code>max-age</code>: Controls the cache duration for pre-flight responses.
Setting this to a reasonable value can reduce the number of pre-flight request-response interactions required by the browser.
This property controls the value of the <code>Access-Control-Max-Age</code> header in the pre-flight response.
A value of <code>-1</code> means undefined.
The default value is 1800 seconds (30 minutes).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The CORS Java Configuration is represented by the <code>org.springframework.integration.http.inbound.CrossOrigin</code> class,
instances of which can be injected into the <code>HttpRequestHandlingEndpointSupport</code> beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="http-response-statuscode"><a class="anchor" href="#http-response-statuscode"></a>20.3.4. Response Status Code</h4>
<div class="paragraph">
<p>Starting with version 4.1, you can configure the <code>&lt;http:inbound-channel-adapter&gt;</code> with a <code>status-code-expression</code> to override the default <code>200 OK</code> status.
The expression must return an object that can be converted to an <code>org.springframework.http.HttpStatus</code> enum value.
The <code>evaluationContext</code> has a <code>BeanResolver</code> and, starting with version 5.1, is supplied with the <code>RequestEntity&lt;?&gt;</code> as root object.
An example might be to resolve, at runtime, some scoped bean that returns a status code value.
However, most likely, it is set to a fixed value such as <code>status-code=expression="204"</code> (No Content), or <code>status-code-expression="T(org.springframework.http.HttpStatus).NO_CONTENT"</code>.
By default, <code>status-code-expression</code> is null, meaning that the normal '200 OK' response status is returned.
Using the <code>RequestEntity&lt;?&gt;</code> as root object, the status code can be conditional e.g. on the request method, some header, URI content or even request body.
The following example shows how to set the status code to <code>ACCEPTED</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http:inbound-channel-adapter id="inboundController"
       channel="requests" view-name="foo" error-code="oops"
       status-code-expression="T(org.springframework.http.HttpStatus).ACCEPTED"&gt;
   &lt;request-mapping headers="BAR"/&gt;
&lt;/http:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;http:inbound-gateway&gt;</code> resolves the 'status code' from the <code>http_statusCode</code> header of the reply <code>Message</code>.
Starting with version 4.2, the default response status code when no reply is received within the <code>reply-timeout</code>
is <code>500 Internal Server Error</code>.
There are two ways to modify this behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add a <code>reply-timeout-status-code-expression</code>.
This has the same semantics as the <code>status-code-expression</code> on the inbound adapter.</p>
</li>
<li>
<p>Add an <code>error-channel</code> and return an appropriate message with an HTTP status code header, as the following example shows:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:chain input-channel="errors"&gt;
    &lt;int:header-enricher&gt;
        &lt;int:header name="http_statusCode" value="504" /&gt;
    &lt;/int:header-enricher&gt;
    &lt;int:transformer expression="payload.failedMessage" /&gt;
&lt;/int:chain&gt;</code></pre>
</div>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The payload of the <code>ErrorMessage</code> is a <code>MessageTimeoutException</code>.
It must be transformed to something that can be converted by the gateway, such as a <code>String</code>.
A good candidate is the exception&#8217;s message property, which is the value used when you use the <code>expression</code> technique.</p>
</div>
<div class="paragraph">
<p>If the error flow times out after a main flow timeout, <code>500 Internal Server Error</code> is returned, or, if the
<code>reply-timeout-status-code-expression</code> is present, it is evaluated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Previously, the default status code for a timeout was <code>200 OK</code>.
To restore that behavior, set <code>reply-timeout-status-code-expression="200"</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="uri-template-variables-and-expressions"><a class="anchor" href="#uri-template-variables-and-expressions"></a>20.3.5. URI Template Variables and Expressions</h4>
<div class="paragraph">
<p>By using the <code>path</code> attribute in conjunction with the <code>payload-expression</code> attribute and the <code>header</code> element, you have a high degree of flexibility for mapping inbound request data.</p>
</div>
<div class="paragraph">
<p>In the following example configuration, an inbound channel adapter is configured to accept requests using the following URI:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>/first-name/{firstName}/last-name/{lastName}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you use the <code>payload-expression</code> attribute, the <code>Mark</code> URI template variable maps to be the <code>Message</code> payload, while the <code>Fisher</code> URI template variable maps to the <code>lname</code> message header, as defined in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-channel-adapter id="inboundAdapterWithExpressions"
    path="/first-name/{firstName}/last-name/{lastName}"
    channel="requests"
    payload-expression="#pathVariables.firstName"&gt;
    &lt;int-http:header name="lname" expression="#pathVariables.lastName"/&gt;
&lt;/int-http:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information about URI template variables, see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping-uri-templates">uri template patterns</a> in the Spring Reference Manual.</p>
</div>
<div class="paragraph">
<p>Since Spring Integration 3.0, in addition to the existing <code>#pathVariables</code> and <code>#requestParams</code> variables being available in payload and header expressions, we added other useful expression variables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>#requestParams</code>: The <code>MultiValueMap</code> from the <code>ServletRequest</code> <code>parameterMap</code>.</p>
</li>
<li>
<p><code>#pathVariables</code>: The <code>Map</code> from URI Template placeholders and their values.</p>
</li>
<li>
<p><code>#matrixVariables</code>: The <code>Map</code> of <code>MultiValueMap</code> according to the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-matrix-variables">Spring MVC Specification</a>.
Note that <code>#matrixVariables</code> requires Spring MVC 3.2 or higher.</p>
</li>
<li>
<p><code>#requestAttributes</code>: The <code>org.springframework.web.context.request.RequestAttributes</code> associated with the current request.</p>
</li>
<li>
<p><code>#requestHeaders</code>: The <code>org.springframework.http.HttpHeaders</code> object from the current request.</p>
</li>
<li>
<p><code>#cookies</code>: The <code>Map&lt;String, Cookie&gt;</code> of <code>javax.servlet.http.Cookie</code> instances from the current request.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that all these values (and others) can be accessed within expressions in the downstream message flow through the <code>ThreadLocal</code> <code>org.springframework.web.context.request.RequestAttributes</code> variable, if that message flow is single-threaded and lives within the request thread.
The following example configures a transformer that uses an <code>expression</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-:transformer
    expression="T(org.springframework.web.context.request.RequestContextHolder).
                  requestAttributes.request.queryString"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="outbound-2"><a class="anchor" href="#outbound-2"></a>20.3.6. Outbound</h4>
<div class="paragraph">
<p>To configure the outbound gateway, you can use the namespace support.
The following code snippet shows the available configuration options for an outbound HTTP gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="example"
    request-channel="requests"
    url="http://localhost/test"
    http-method="POST"
    extract-request-payload="false"
    expected-response-type="java.lang.String"
    charset="UTF-8"
    request-factory="requestFactory"
    reply-timeout="1234"
    reply-channel="replies"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Most importantly, notice that the 'http-method' and 'expected-response-type' attributes are provided.
Those are two of the most commonly configured values.
The default <code>http-method</code> is <code>POST</code>, and the default response type is null.
With a null response type, the payload of the reply <code>Message</code> contains the <code>ResponseEntity</code>, as long as its HTTP status is a success (non-successful status codes throw exceptions).
If you expect a different type, such as a <code>String</code>, provide that as a fully-qualified class name (<code>java.lang.String</code> in the preceding example).
See also the note about empty response bodies in <a href="#http-outbound">HTTP Outbound Components</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Beginning with Spring Integration 2.1, the <code>request-timeout</code> attribute of the HTTP outbound gateway was renamed to <code>reply-timeout</code> to better reflect its intent.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Spring Integration 2.2, Java serialization over HTTP is no longer enabled by default.
Previously, when setting the <code>expected-response-type</code> attribute to a <code>Serializable</code> object, the <code>Accept</code> header was not properly set up.
Since Spring Integration 2.2, the <code>SerializingHttpMessageConverter</code> has now been updated to set the <code>Accept</code> header to <code>application/x-java-serialized-object</code>.</p>
</div>
<div class="paragraph">
<p>However, because this could cause incompatibility with existing applications, it was decided to no longer automatically add this converter to the HTTP endpoints.
If you wish to use Java serialization, you can add the <code>SerializingHttpMessageConverter</code> to the appropriate endpoints, by using the <code>message-converters</code> attribute (when you use XML configuration) or by using the <code>setMessageConverters()</code> method (in Java configuration).
Alternatively, you may wish to consider using JSON instead, which is enabled by having <a href="https://github.com/FasterXML/jackson">the Jackson library</a> on the classpath.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Beginning with Spring Integration 2.2, you can also determine the HTTP method dynamically by using SpEL and the <code>http-method-expression</code> attribute.
Note that this attribute is mutually exclusive with <code>http-method</code>.
You can also use the <code>expected-response-type-expression</code> attribute instead of <code>expected-response-type</code> and provide any valid SpEL expression that determines the type of the response.
The following configuration example uses <code>expected-response-type-expression</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="example"
    request-channel="requests"
    url="http://localhost/test"
    http-method-expression="headers.httpMethod"
    extract-request-payload="false"
    expected-response-type-expression="payload"
    charset="UTF-8"
    request-factory="requestFactory"
    reply-timeout="1234"
    reply-channel="replies"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If your outbound adapter is to be used in a unidirectional way, you can use an <code>outbound-channel-adapter</code> instead.
This means that a successful response executes without sending any messages to a reply channel.
In the case of any non-successful response status code, it throws an exception.
The configuration looks very similar to the gateway, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-channel-adapter id="example"
    url="http://localhost/example"
    http-method="GET"
    channel="requests"
    charset="UTF-8"
    extract-payload="false"
    expected-response-type="java.lang.String"
    request-factory="someRequestFactory"
    order="3"
    auto-startup="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To specify the URL, you can use either the 'url' attribute or the 'url-expression' attribute.
The 'url' attribute takes a simple string (with placeholders for URI variables, as described below).
The 'url-expression' is a SpEL expression, with the <code>Message</code> as the root object, which enables dynamic urls.
The URL that results from the expression evaluation can still have placeholders for URI variables.</p>
</div>
<div class="paragraph">
<p>In previous releases, some users used the place holders to replace the entire URL with a URI variable.
Changes in Spring 3.1 can cause some issues with escaped characters, such as '?'.
For this reason, we recommend that, if you wish to generate the URL entirely at runtime, you use the 'url-expression' attribute.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mapping-uri-variables"><a class="anchor" href="#mapping-uri-variables"></a>20.3.7. Mapping URI Variables</h4>
<div class="paragraph">
<p>If your URL contains URI variables, you can map them by using the <code>uri-variable</code> element.
This element is available for the HTTP outbound gateway and the HTTP outbound channel adapter.
The following example maps the <code>zipCode</code> URI variable to an expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="trafficGateway"
    url="https://local.yahooapis.com/trafficData?appid=YdnDemo&amp;amp;zip={zipCode}"
    request-channel="trafficChannel"
    http-method="GET"
    expected-response-type="java.lang.String"&gt;
    &lt;int-http:uri-variable name="zipCode" expression="payload.getZip()"/&gt;
&lt;/int-http:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>uri-variable</code> element defines two attributes: <code>name</code> and <code>expression</code>.
The <code>name</code> attribute identifies the name of the URI variable, while the <code>expression</code> attribute is used to set the actual value.
By using the <code>expression</code> attribute, you can leverage the full power of the Spring Expression Language (SpEL), which gives you full dynamic access to the message payload and the message headers.
For example, in the preceding configuration, the <code>getZip()</code> method is invoked on the payload object of the <code>Message</code> and the result of that method is used as the value of the URI variable named 'zipCode'.</p>
</div>
<div class="paragraph">
<p>Since Spring Integration 3.0, HTTP outbound endpoints support the <code>uri-variables-expression</code> attribute to specify an <code>expression</code> that should be evaluated, resulting in a <code>Map</code> of all URI variable placeholders within the URL template.
It provides a mechanism whereby you can use different variable expressions, based on the outbound message.
This attribute is mutually exclusive with the <code>&lt;uri-variable/&gt;</code> element.
The following example shows how to use the <code>uri-variables-expression</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway
     url="https://foo.host/{foo}/bars/{bar}"
     request-channel="trafficChannel"
     http-method="GET"
     uri-variables-expression="@uriVariablesBean.populate(payload)"
     expected-response-type="java.lang.String"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>uriVariablesBean</code> might be defined as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UriVariablesBean {
    private static final ExpressionParser EXPRESSION_PARSER = new SpelExpressionParser();

    public Map&lt;String, ?&gt; populate(Object payload) {
        Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
        if (payload instanceOf String.class)) {
            variables.put("foo", "foo"));
        }
        else {
            variables.put("foo", EXPRESSION_PARSER.parseExpression("headers.bar"));
        }
        return variables;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>uri-variables-expression</code> must evaluate to a <code>Map</code>.
The values of the <code>Map</code> must be instances of <code>String</code> or <code>Expression</code>.
This <code>Map</code> is provided to an <code>ExpressionEvalMap</code> for further resolution of URI variable placeholders by using those expressions in the context of the outbound <code>Message</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>IMPORTANT</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The <code>uriVariablesExpression</code> property provides a very powerful mechanism for evaluating URI variables.
We anticipate that people mostly use simple expressions, such as the preceding example.
However, you can also configure something such as <code>"@uriVariablesBean.populate(#root)"</code> with an expression in the returned map being <code>variables.put("thing1", EXPRESSION_PARSER.parseExpression(message.getHeaders().get("thing2", String.class)));</code>, where the expression is dynamically provided in the message header named <code>thing2</code>.
Since the header may come from an untrusted source, the HTTP outbound endpoints use <code>SimpleEvaluationContext</code> when evaluating these expressions.
<code>SimpleEvaluationContext</code> uses only a subset of SpEL features.
If you trust your message sources and wish to use the restricted SpEL constructs, set the <code>trustedSpel</code> property of the outbound endpoint to <code>true</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You can achieve scenarios that need to supply a dynamic set of URI variables on a per-message basis by using a custom <code>url-expression</code> and some utilities for building and encoding URL parameters.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">url-expression="T(org.springframework.web.util.UriComponentsBuilder)
                           .fromHttpUrl('http://HOST:PORT/PATH')
                           .queryParams(payload)
                           .build()
                           .toUri()"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>queryParams()</code> method expects a <code>MultiValueMap&lt;String, String&gt;</code> as an argument, so you can build a real set of URL query parameters in advance, before performing the request.</p>
</div>
<div class="paragraph">
<p>The whole <code>queryString</code> can also be presented as a <code>uri-variable</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="proxyGateway" request-channel="testChannel"
              url="http://testServer/test?{queryString}"&gt;
    &lt;int-http:uri-variable name="queryString" expression="'a=A&amp;amp;b=B'"/&gt;
&lt;/int-http:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this case, you must manually provide the URL encoding.
For example, you can use the <code>org.apache.http.client.utils.URLEncodedUtils#format()</code> for this purpose.
As mentioned earlier, a manually built <code>MultiValueMap&lt;String, String&gt;</code> can be converted to the the <code>List&lt;NameValuePair&gt;</code> <code>format()</code> method argument by using the following Java Streams snippet:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;NameValuePair&gt; nameValuePairs =
    params.entrySet()
            .stream()
            .flatMap(e -&gt; e
                    .getValue()
                    .stream()
                    .map(v -&gt; new BasicNameValuePair(e.getKey(), v)))
            .collect(Collectors.toList());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="controlling-uri-encoding"><a class="anchor" href="#controlling-uri-encoding"></a>20.3.8. Controlling URI Encoding</h4>
<div class="paragraph">
<p>By default, the URL string is encoded (see <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html"><code>UriComponentsBuilder</code></a>) to the URI object before sending the request.
In some scenarios with a non-standard URI (such as the RabbitMQ REST API), it is undesirable to perform the encoding.
The <code>&lt;http:outbound-gateway/&gt;</code> and <code>&lt;http:outbound-channel-adapter/&gt;</code> provide an <code>encode-uri</code> attribute.
To disable encoding the URL, set this attribute to <code>false</code> (by default, it is <code>true</code>).
If you wish to partially encode some of the URL, use an <code>expression</code> within a <code>&lt;uri-variable/&gt;</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http:outbound-gateway url="http://somehost/%2f/fooApps?bar={param}" encode-uri="false"&gt;
          &lt;http:uri-variable name="param"
            expression="T(org.apache.commons.httpclient.util.URIUtil)
                                             .encodeWithinQuery('Hello World!')"/&gt;
&lt;/http:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-java-config"><a class="anchor" href="#http-java-config"></a>20.4. Configuring HTTP Endpoints with Java</h3>
<div class="paragraph">
<p>The following example shows how to configure an inbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Inbound Gateway Using Java Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public HttpRequestHandlingMessagingGateway inbound() {
    HttpRequestHandlingMessagingGateway gateway =
        new HttpRequestHandlingMessagingGateway(true);
    gateway.setRequestMapping(mapping());
    gateway.setRequestPayloadType(String.class);
    gateway.setRequestChannelName("httpRequest");
    return gateway;
}

@Bean
public RequestMapping mapping() {
    RequestMapping requestMapping = new RequestMapping();
    requestMapping.setPathPatterns("/foo");
    requestMapping.setMethods(HttpMethod.POST);
    return requestMapping;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure an inbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Inbound Gateway Using the Java DSL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow inbound() {
    return IntegrationFlows.from(Http.inboundGateway("/foo")
            .requestMapping(m -&gt; m.methods(HttpMethod.POST))
            .requestPayloadType(String.class))
        .channel("httpRequest")
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure an outbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Outbound Gateway Using Java Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "httpOutRequest")
@Bean
public HttpRequestExecutingMessageHandler outbound() {
    HttpRequestExecutingMessageHandler handler =
        new HttpRequestExecutingMessageHandler("http://localhost:8080/foo");
    handler.setHttpMethod(HttpMethod.POST);
    handler.setExpectedResponseType(String.class);
    return handler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure an outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Outbound Gateway Using the Java DSL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow outbound() {
    return IntegrationFlows.from("httpOutRequest")
        .handle(Http.outboundGateway("http://localhost:8080/foo")
            .httpMethod(HttpMethod.POST)
            .expectedResponseType(String.class))
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-timeout"><a class="anchor" href="#http-timeout"></a>20.5. Timeout Handling</h3>
<div class="paragraph">
<p>In the context of HTTP components, there are two timing areas that have to be considered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Timeouts when interacting with Spring Integration Channels</p>
</li>
<li>
<p>Timeouts when interacting with a remote HTTP server</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The components interact with message channels, for which timeouts can be specified.
For example, an HTTP Inbound Gateway forwards messages received from connected HTTP Clients to a message channel (which uses a request timeout) and consequently the HTTP Inbound Gateway receives a reply message from the reply channel (which uses a reply timeout) that is used to generate the HTTP Response.
The following illustration offers a visual explanation:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/http-inbound-gateway.png" alt="http inbound gateway">
</div>
<div class="title">Figure 8. How timeout settings apply to an HTTP Inbound Gateway</div>
</div>
<div class="paragraph">
<p>For outbound endpoints, we need to consider how timing works while interacting with the remote server.
The following image shows this scenario:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/http-outbound-gateway.png" alt="http outbound gateway">
</div>
<div class="title">Figure 9. How timeout settings apply to an HTTP Outbound Gateway</div>
</div>
<div class="paragraph">
<p>You may want to configure the HTTP related timeout behavior, when making active HTTP requests by using the HTTP outbound gateway or the HTTP outbound channel adapter.
In those instances, these two components use Spring&#8217;s
<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html"><code>RestTemplate</code></a> support to execute HTTP requests.</p>
</div>
<div class="paragraph">
<p>To configure timeouts for the HTTP outbound gateway and the HTTP outbound channel adapter, you can either reference a <code>RestTemplate</code> bean directly (by using the <code>rest-template</code> attribute) or you can provide a reference to a <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/ClientHttpRequestFactory.html"><code>ClientHttpRequestFactory</code></a> bean (by using the <code>request-factory</code> attribute).
Spring provides the following implementations of the <code>ClientHttpRequestFactory</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html"><code>SimpleClientHttpRequestFactory</code></a>: Uses standard J2SE facilities for making HTTP Requests</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html"><code>HttpComponentsClientHttpRequestFactory</code></a>: Uses <a href="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpComponents HttpClient</a> (since Spring 3.1)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you do not explicitly configure the <code>request-factory</code> or <code>rest-template</code> attribute, a default <code>RestTemplate</code> (which uses a <code>SimpleClientHttpRequestFactory</code>) is instantiated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With some JVM implementations, the handling of timeouts by the <code>URLConnection</code> class may not be consistent.</p>
</div>
<div class="paragraph">
<p>For example, from the Java Platform, Standard Edition 6 API Specification on <code>setConnectTimeout</code>:</p>
</div>
<div class="quoteblock">
<blockquote>
Some non-standard implementation of this method may ignore the specified timeout.
To see the connect timeout set, please call getConnectTimeout().
</blockquote>
</div>
<div class="paragraph">
<p>If you have specific needs, you should test your timeouts.
Consider using the <code>HttpComponentsClientHttpRequestFactory</code>, which, in turn, uses <a href="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpComponents HttpClient</a> rather than relying on implementations provided by a JVM.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you use the Apache HttpComponents HttpClient with a pooling connection manager, you should be aware that, by default, the connection manager creates no more than two concurrent connections per given route and no more than 20 connections in total.
For many real-world applications, these limits may prove to be too constraining.
See the <a href="https://hc.apache.org/httpcomponents-client-ga/">Apache documentation</a> for information about configuring this important component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example configures an HTTP outbound gateway by using a <code>SimpleClientHttpRequestFactory</code> that is configured with connect and read timeouts of 5 seconds, respectively:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway url="https://www.google.com/ig/api?weather={city}"
                           http-method="GET"
                           expected-response-type="java.lang.String"
                           request-factory="requestFactory"
                           request-channel="requestChannel"
                           reply-channel="replyChannel"&gt;
    &lt;int-http:uri-variable name="city" expression="payload"/&gt;
&lt;/int-http:outbound-gateway&gt;

&lt;bean id="requestFactory"
      class="org.springframework.http.client.SimpleClientHttpRequestFactory"&gt;
    &lt;property name="connectTimeout" value="5000"/&gt;
    &lt;property name="readTimeout"    value="5000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><em>HTTP Outbound Gateway</em></p>
</div>
<div class="paragraph">
<p>For the <em>HTTP Outbound Gateway</em>, the XML Schema defines only the <em>reply-timeout</em>.
The <em>reply-timeout</em> maps to the <em>sendTimeout</em> property of the <em>org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler</em> class.
More precisely, the property is set on the extended <code>AbstractReplyProducingMessageHandler</code> class, which ultimately sets the property on the <code>MessagingTemplate</code>.</p>
</div>
<div class="paragraph">
<p>The value of the <em>sendTimeout</em> property defaults to "-1" and will be applied to the connected <code>MessageChannel</code>.
This means, that depending on the implementation, the Message Channel&#8217;s <em>send</em> method may block indefinitely.
Furthermore, the <em>sendTimeout</em> property is only used, when the actual MessageChannel implementation has a blocking send (such as 'full' bounded QueueChannel).</p>
</div>
<div class="sect3">
<h4 id="http-inbound-gateway"><a class="anchor" href="#http-inbound-gateway"></a>20.5.1. HTTP Inbound Gateway</h4>
<div class="paragraph">
<p>For the HTTP inbound gateway, the XML Schema defines the <code>request-timeout</code> attribute, which is used to set the <code>requestTimeout</code> property on the <code>HttpRequestHandlingMessagingGateway</code> class (on the extended <code>MessagingGatewaySupport</code> class).
You can also use the <code>reply-timeout</code> attribute to map to the <code>replyTimeout</code> property on the same class.</p>
</div>
<div class="paragraph">
<p>The default for both timeout properties is <code>1000ms</code> (one thousand milliseconds or one second).
Ultimately, the <code>request-timeout</code> property is used to set the <code>sendTimeout</code> on the <code>MessagingTemplate</code> instance.
The <code>replyTimeout</code> property, on the other hand, is used to set the <code>receiveTimeout</code> property on the <code>MessagingTemplate</code> instance.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To simulate connection timeouts, you can connect to a non-routable IP address, such as 10.255.255.10.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-proxy"><a class="anchor" href="#http-proxy"></a>20.6. HTTP Proxy configuration</h3>
<div class="paragraph">
<p>If you are behind a proxy and need to configure proxy settings for HTTP outbound adapters or gateways, you can apply one of two approaches.
In most cases, you can rely on the standard Java system properties that control the proxy settings.
Otherwise, you can explicitly configure a Spring bean for the HTTP client request factory instance.</p>
</div>
<div class="sect3">
<h4 id="standard-java-proxy-configuration"><a class="anchor" href="#standard-java-proxy-configuration"></a>20.6.1. Standard Java Proxy configuration</h4>
<div class="paragraph">
<p>You can set three system properties to configure the proxy settings that are used by the HTTP protocol handler:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>http.proxyHost</code>: The host name of the proxy server.</p>
</li>
<li>
<p><code>http.proxyPort</code>: The port number (the default is <code>80</code>).</p>
</li>
<li>
<p><code>http.nonProxyHosts</code>: A list of hosts that should be reached directly, bypassing the proxy.
This is a list of patterns separated by <code>|</code>.
The patterns may start or end with a <code>*</code> for wildcards.
Any host that matches one of these patterns is reached through a direct connection instead of through a proxy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For HTTPS, the following properties are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>https.proxyHost</code>: The host name of the proxy server.</p>
</li>
<li>
<p><code>https.proxyPort</code>: The port number, the default value being 80.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://download.oracle.com/javase/6/docs/technotes/guides/net/proxies.html" class="bare">download.oracle.com/javase/6/docs/technotes/guides/net/proxies.html</a></p>
</div>
</div>
<div class="sect3">
<h4 id="springs-simpleclienthttprequestfactory"><a class="anchor" href="#springs-simpleclienthttprequestfactory"></a>20.6.2. Spring&#8217;s <code>SimpleClientHttpRequestFactory</code></h4>
<div class="paragraph">
<p>If you need more explicit control over the proxy configuration, you can use Spring&#8217;s <code>SimpleClientHttpRequestFactory</code> and configure its 'proxy' property, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="requestFactory"
    class="org.springframework.http.client.SimpleClientHttpRequestFactory"&gt;
    &lt;property name="proxy"&gt;
        &lt;bean id="proxy" class="java.net.Proxy"&gt;
            &lt;constructor-arg&gt;
                &lt;util:constant static-field="java.net.Proxy.Type.HTTP"/&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
                &lt;bean class="java.net.InetSocketAddress"&gt;
                    &lt;constructor-arg value="123.0.0.1"/&gt;
                    &lt;constructor-arg value="8080"/&gt;
                &lt;/bean&gt;
            &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-header-mapping"><a class="anchor" href="#http-header-mapping"></a>20.7. HTTP Header Mappings</h3>
<div class="paragraph">
<p>Spring Integration provides support for HTTP header mapping for both HTTP Request and HTTP Responses.</p>
</div>
<div class="paragraph">
<p>By default, all standard <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP headers</a> are mapped from the message to HTTP request or response headers without further configuration.
However, if you do need further customization, you can provide additional configuration by taking advantage of the namespace support.
You can provide a comma-separated list of header names, and you can include simple patterns with the '*' character acting as a wildcard.
Provide such values overrides the default behavior.
Basically, it assumes you are in complete control at that point.
However, if you do want to include all of the standard HTTP headers, you can use the shortcut patterns: <code>HTTP_REQUEST_HEADERS</code> and <code>HTTP_RESPONSE_HEADERS</code>.
The following listing shows two examples (the first of which uses a wildcard):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="httpGateway"
    url="http://localhost/test2"
    mapped-request-headers="thing1, thing2"
    mapped-response-headers="X-*, HTTP_RESPONSE_HEADERS"
    channel="someChannel"/&gt;

&lt;int-http:outbound-channel-adapter id="httpAdapter"
    url="http://localhost/test2"
    mapped-request-headers="thing1, thing2, HTTP_REQUEST_HEADERS"
    channel="someChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapters and gateways use the <code>DefaultHttpHeaderMapper</code>, which now provides two static factory methods for inbound and outbound adapters so that the proper direction can be applied (mapping HTTP requests and responses either in or out, as appropriate).</p>
</div>
<div class="paragraph">
<p>If you need further customization, you can also configure a <code>DefaultHttpHeaderMapper</code> independently and inject it into the adapter through the <code>header-mapper</code> attribute.</p>
</div>
<div class="paragraph">
<p>Before version 5.0, the <code>DefaultHttpHeaderMapper</code> the default prefix for user-defined, non-standard HTTP headers was <code>X-</code>.
Version 5.0 changed the default prefix to an empty string.
According to <a href="https://tools.ietf.org/html/rfc6648">RFC-6648</a>, the use of such prefixes is now discouraged.
You can still customize this option by setting the <code>DefaultHttpHeaderMapper.setUserDefinedHeaderPrefix()</code> property.
The following example configures a header mapper for an HTTP gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:outbound-gateway id="httpGateway"
    url="http://localhost/test2"
    header-mapper="headerMapper"
    channel="someChannel"/&gt;

&lt;bean id="headerMapper" class="o.s.i.http.support.DefaultHttpHeaderMapper"&gt;
    &lt;property name="inboundHeaderNames" value="thing1*, *thing2, thing3"/&gt;
    &lt;property name="outboundHeaderNames" value="a*b, d"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you need to do something other than what the <code>DefaultHttpHeaderMapper</code> supports, you can implement the <code>HeaderMapper</code> strategy interface directly and provide a reference to your implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="int-graph-controller"><a class="anchor" href="#int-graph-controller"></a>20.8. Integration Graph Controller</h3>
<div class="paragraph">
<p>Starting with version 4.3, the HTTP module provides an <code>@EnableIntegrationGraphController</code> configuration class annotation and an <code>&lt;int-http:graph-controller/&gt;</code> XML element to expose the <code>IntegrationGraphServer</code> as a REST service.
See <a href="#integration-graph">Integration Graph</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="http-samples"><a class="anchor" href="#http-samples"></a>20.9. HTTP Samples</h3>
<div class="paragraph">
<p>This section wraps up our coverage of Spring Integration&#8217;s HTTP support with a few examples.</p>
</div>
<div class="sect3">
<h4 id="multipart-rest-inbound"><a class="anchor" href="#multipart-rest-inbound"></a>20.9.1. Multipart HTTP Request&#8201;&#8212;&#8201;RestTemplate (Client) and Http Inbound Gateway (Server)</h4>
<div class="paragraph">
<p>This example shows how simple it is to send a multipart HTTP request with Spring&#8217;s <code>RestTemplate</code> and receive it with a Spring Integration HTTP inbound adapter.
We create a <code>MultiValueMap</code> and populate it with multipart data.
The <code>RestTemplate</code> takes care of the rest (no pun intended) by converting it toa <code>MultipartHttpServletRequest</code>.
This particular client sends a multipart HTTP Request that contains the name of the company and an image file (the company logo).
The following listing shows the example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate template =newRestTemplate();
String uri ="http://localhost:8080/multipart-http/inboundAdapter.htm";
Resource s2logo =
   newClassPathResource("org/springframework/samples/multipart/spring09_logo.png");
MultiValueMap map =newLinkedMultiValueMap();
map.add("company","SpringSource");
map.add("company-logo", s2logo);
HttpHeaders headers =newHttpHeaders();
headers.setContentType(newMediaType("multipart","form-data"));
HttpEntity request =newHttpEntity(map, headers);
ResponseEntity&lt;?&gt; httpResponse = template.exchange(uri, HttpMethod.POST, request,null);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That is all we need for the client.</p>
</div>
<div class="paragraph">
<p>On the server side, we have the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-http:inbound-channel-adapter id="httpInboundAdapter"
    channel="receiveChannel"
    path="/inboundAdapter.htm"
    supported-methods="GET, POST"/&gt;

&lt;int:channel id="receiveChannel"/&gt;

&lt;int:service-activator input-channel="receiveChannel"&gt;
    &lt;bean class="org.springframework.integration.samples.multipart.MultipartReceiver"/&gt;
&lt;/int:service-activator&gt;

&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The 'httpInboundAdapter' receives the request and converts it to a <code>Message</code> with a payload that is a<code>LinkedMultiValueMap</code>.
We then parse that in the 'multipartReceiver' service-activator, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void receive(LinkedMultiValueMap&lt;String, Object&gt; multipartRequest){
    System.out.println("### Successfully received multipart request ###");
    for (String elementName : multipartRequest.keySet()) {
        if (elementName.equals("company")){
            System.out.println("\t" + elementName + " - " +
                ((String[]) multipartRequest.getFirst("company"))[0]);
        }
        else if (elementName.equals("company-logo")){
            System.out.println("\t" + elementName + " - as UploadedMultipartFile: " +
                ((UploadedMultipartFile) multipartRequest
                    .getFirst("company-logo")).getOriginalFilename());
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You should see the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">### Successfully received multipart request ###
   company - SpringSource
   company-logo - as UploadedMultipartFile: spring09_logo.png</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jdbc"><a class="anchor" href="#jdbc"></a>21. JDBC Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for receiving and sending messages by using database queries.
Through those adapters, Spring Integration supports not only plain JDBC SQL queries but also stored procedure and stored function calls.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-jdbc:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the following JDBC components are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-inbound-channel-adapter">Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#jdbc-outbound-gateway">Outbound Gateway</a></p>
</li>
<li>
<p><a href="#stored-procedure-inbound-channel-adapter">Stored Procedure Inbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#stored-procedure-outbound-channel-adapter">Stored Procedure Outbound Channel Adapter</a></p>
</li>
<li>
<p><a href="#stored-procedure-outbound-gateway">Stored Procedure Outbound Gateway</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring Integration JDBC Module also provides a <a href="#jdbc-message-store">JDBC Message Store</a>.</p>
</div>
<div class="sect2">
<h3 id="jdbc-inbound-channel-adapter"><a class="anchor" href="#jdbc-inbound-channel-adapter"></a>21.1. Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The main function of an inbound channel adapter is to execute a SQL <code>SELECT</code> query and turn the result set into a message.
The message payload is the whole result set (expressed as a <code>List</code>), and the types of the items in the list depend on the row-mapping strategy.
The default strategy is a generic mapper that returns a <code>Map</code> for each row in the query result.
Optionally, you can change this by adding a reference to a <code>RowMapper</code> instance (see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html">Spring JDBC</a> documentation for more detailed information about row mapping).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you want to convert rows in the <code>SELECT</code> query result to individual messages, you can use a downstream splitter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The inbound adapter also requires a reference to either a <code>JdbcTemplate</code> instance or a <code>DataSource</code>.</p>
</div>
<div class="paragraph">
<p>As well as the <code>SELECT</code> statement to generate the messages, the adapter also has an <code>UPDATE</code> statement that marks the records as processed so that they do not show up in the next poll.
The update can be parameterized by the list of IDs from the original select.
By default, this is done through a naming convention (a column in the input result set called <code>id</code> is translated into a list in the parameter map for the update called <code>id</code>).
The following example defines an inbound channel adapter with an update query and a <code>DataSource</code> reference.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=2"
    channel="target" data-source="dataSource"
    update="update item set status=10 where id in (:id)" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The parameters in the update query are specified with a colon (<code>:</code>) prefix to the name of a parameter (which, in the preceding example, is an expression to be applied to each of the rows in the polled result set).
This is a standard feature of the named parameter JDBC support in Spring JDBC, combined with a convention (projection onto the polled result list) adopted in Spring Integration.
The underlying Spring JDBC features limit the available expressions (for example, most special characters other than a period are disallowed), but since the target is usually a list of objects (possibly a list of one) that are addressable by bean paths this is not unduly restrictive.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To change the parameter generation strategy, you can inject a <code>SqlParameterSourceFactory</code> into the adapter to override the default behavior (the adapter has a <code>sql-parameter-source-factory</code> attribute).
Spring Integration provides <code>ExpressionEvaluatingSqlParameterSourceFactory</code>, which creates a SpEL-based parameter source, with the results of the query as the <code>#root</code> object.
(If <code>update-per-row</code> is true, the root object is the row).
If the same parameter name appears multiple times in the update query, it is evaluated only once, and its result is cached.</p>
</div>
<div class="paragraph">
<p>You can also use a parameter source for the select query.
In this case, since there is no &#8220;result&#8221; object to evaluate against, a single parameter source is used each time (rather than using a parameter source factory).
Starting with version 4.0, you can use Spring to create a SpEL based parameter source, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=:status"
	channel="target" data-source="dataSource"
	select-sql-parameter-source="parameterSource" /&gt;

&lt;bean id="parameterSource" factory-bean="parameterSourceFactory"
			factory-method="createParameterSourceNoCache"&gt;
	&lt;constructor-arg value="" /&gt;
&lt;/bean&gt;

&lt;bean id="parameterSourceFactory"
		class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
	&lt;property name="parameterExpressions"&gt;
		&lt;map&gt;
			&lt;entry key="status" value="@statusBean.which()" /&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="statusBean" class="foo.StatusDetermination" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>value</code> in each parameter expression can be any valid SpEL expression.
The <code>#root</code> object for the expression evaluation is the constructor argument defined on the <code>parameterSource</code> bean.
It is static for all evaluations (in the preceding example, an empty <code>String</code>).</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you ca supply <code>ExpressionEvaluatingSqlParameterSourceFactory</code> with <code>sqlParameterTypes</code> to specify the target SQL type for the particular parameter.</p>
</div>
<div class="paragraph">
<p>The following example provides SQL types for the parameters being used in the query:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:inbound-channel-adapter query="select * from item where status=:status"
    channel="target" data-source="dataSource"
    select-sql-parameter-source="parameterSource" /&gt;

&lt;bean id="parameterSource" factory-bean="parameterSourceFactory"
            factory-method="createParameterSourceNoCache"&gt;
    &lt;constructor-arg value="" /&gt;
&lt;/bean&gt;

&lt;bean id="parameterSourceFactory"
        class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
    &lt;property name="sqlParameterTypes"&gt;
        &lt;map&gt;
            &lt;entry key="status" value="#{ T(java.sql.Types).BINARY}" /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Use the <code>createParameterSourceNoCache</code> factory method.
Otherwise, the parameter source caches the result of the evaluation.
Also note that, because caching is disabled, if the same parameter name appears in the select query multiple times, it is re-evaluated for each occurrence.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jdbc-polling-transactions"><a class="anchor" href="#jdbc-polling-transactions"></a>21.1.1. Polling and Transactions</h4>
<div class="paragraph">
<p>The inbound adapter accepts a regular Spring Integration poller as a child element.
Consequently, the frequency of the polling can be controlled (among other uses).
An important feature of the poller for JDBC usage is the option to wrap the poll operation in a transaction, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:inbound-channel-adapter query="..."
        channel="target" data-source="dataSource" update="..."&gt;
    &lt;int:poller fixed-rate="1000"&gt;
        &lt;int:transactional/&gt;
    &lt;/int:poller&gt;
&lt;/int-jdbc:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not explicitly specify a poller, a default value is used.
As is normal with Spring Integration, it can be defined as a top-level bean).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the preceding example, the database is polled every 1000 milliseconds (or once a second), and the update and select queries are both executed in the same transaction.
The transaction manager configuration is not shown.
However, as long as it is aware of the data source,  the poll is transactional.
A common use case is for the downstream channels to be direct channels (the default), so that the endpoints are invoked in the same thread and, hence, the same transaction.
That way, if any of them fail, the transaction rolls back and the input data is reverted to its original state.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-max-rows-versus-max-messages-per-poll"><a class="anchor" href="#jdbc-max-rows-versus-max-messages-per-poll"></a>21.1.2. <code>max-rows</code> Versus <code>max-messages-per-poll</code></h4>
<div class="paragraph">
<p>The JDBC inbound channel adapter defines an attribute called <code>max-rows</code>.
When you specify the adapter&#8217;s poller, you can also define a property called <code>max-messages-per-poll</code>.
While these two attributes look similar, their meaning is quite different.</p>
</div>
<div class="paragraph">
<p><code>max-messages-per-poll</code> specifies the number of times the query is executed per polling interval, whereas <code>max-rows</code> specifies the number of rows returned for each execution.</p>
</div>
<div class="paragraph">
<p>Under normal circumstances, you would likely not want to set the poller&#8217;s <code>max-messages-per-poll</code> property when you use the JDBC inbound channel adapter.
Its default value is <code>1</code>, which means that the JDBC inbound channel adapter&#8217;s <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/jdbc/JdbcPollingChannelAdapter.html#receive()"><code>receive()</code></a> method is executed exactly once for each poll interval.</p>
</div>
<div class="paragraph">
<p>Setting the <code>max-messages-per-poll</code> attribute to a larger value means that the query is executed that many times back to back.
For more information regarding the <code>max-messages-per-poll</code> attribute, see <a href="#channel-adapter-namespace-inbound">Configuring An Inbound Channel Adapter</a>.</p>
</div>
<div class="paragraph">
<p>In contrast, the <code>max-rows</code> attribute, if greater than <code>0</code>, specifies the maximum number of rows to be used from the query result set created by the <code>receive()</code> method.
If the attribute is set to <code>0</code>, all rows are included in the resulting message.
The attribute defaults to <code>0</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is recommended to use result set limiting via vendor-specific query options, for example MySQL <code>LIMIT</code> or SQL Server <code>TOP</code> or Oracle&#8217;s <code>ROWNUM</code>.
See the particular vendor documentation for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-outbound-channel-adapter"><a class="anchor" href="#jdbc-outbound-channel-adapter"></a>21.2. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The outbound channel adapter is the inverse of the inbound: its role is to handle a message and use it to execute a SQL query.
By default, the message payload and headers are available as input parameters to the query, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:outbound-channel-adapter
    query="insert into foos (id, status, name) values (:headers[id], 0, :payload[something])"
    data-source="dataSource"
    channel="input"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, messages arriving on the channel labelled <code>input</code> have a payload of a map with a key of <code>something</code>, so the <code>[]</code> operator dereferences that value from the map.
The headers are also accessed as a map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The parameters in the preceding query are bean property expressions on the incoming message (not SpEL expressions).
This behavior is part of the <code>SqlParameterSource</code>, which is the default source created by the outbound adapter.
You can inject a different <code>SqlParameterSourceFactory</code> to get different behavior.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The outbound adapter requires a reference to either a <code>DataSource</code> or a <code>JdbcTemplate</code>.
You can also inject a <code>SqlParameterSourceFactory</code> to control the binding of each incoming message to a query.</p>
</div>
<div class="paragraph">
<p>If the input channel is a direct channel, the outbound adapter runs its query in the same thread and, therefore, the same transaction (if there is one) as the sender of the message.</p>
</div>
<div class="sect3">
<h4 id="passing-parameters-by-using-spel-expressions"><a class="anchor" href="#passing-parameters-by-using-spel-expressions"></a>21.2.1. Passing Parameters by Using SpEL Expressions</h4>
<div class="paragraph">
<p>A common requirement for most JDBC channel adapters is to pass parameters as part of SQL queries or stored procedures or functions.
As mentioned earlier, these parameters are by default bean property expressions, not SpEL expressions.
However, if you need to pass SpEL expression as parameters, you must explicitly inject a <code>SqlParameterSourceFactory</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>ExpressionEvaluatingSqlParameterSourceFactory</code> to achieve that requirement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;jdbc:outbound-channel-adapter data-source="dataSource" channel="input"
    query="insert into MESSAGES (MESSAGE_ID,PAYLOAD,CREATED_DATE)     \
    values (:id, :payload, :createdDate)"
    sql-parameter-source-factory="spelSource"/&gt;

&lt;bean id="spelSource"
      class="o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory"&gt;
    &lt;property name="parameterExpressions"&gt;
        &lt;map&gt;
            &lt;entry key="id"          value="headers['id'].toString()"/&gt;
            &lt;entry key="createdDate" value="new java.util.Date()"/&gt;
            &lt;entry key="payload"     value="payload"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For further information, see <a href="#sp-defining-parameter-sources">Defining Parameter Sources</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-preparedstatement-callback"><a class="anchor" href="#using-the-preparedstatement-callback"></a>21.2.2. Using the <code>PreparedStatement</code> Callback</h4>
<div class="paragraph">
<p>Sometimes, the flexibility and loose-coupling of <code>SqlParameterSourceFactory</code> does not do what we need for the target <code>PreparedStatement</code> or we need to do some low-level JDBC work.
The Spring JDBC module provides APIs to configure the execution environment (such as <code>ConnectionCallback</code> or <code>PreparedStatementCreator</code>) and manipulate parameter values (such as <code>SqlParameterSource</code>).
It can even access APIs for low-level operations, such as <code>StatementCallback</code>.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 4.2, <code>MessagePreparedStatementSetter</code> allows the specification of parameters on the <code>PreparedStatement</code> manually, in the <code>requestMessage</code> context.
This class plays exactly the same role as <code>PreparedStatementSetter</code> in the standard Spring JDBC API.
Actually, it is invoked directly from an inline <code>PreparedStatementSetter</code> implementation when the <code>JdbcMessageHandler</code> invokes <code>execute</code> on the <code>JdbcTemplate</code>.</p>
</div>
<div class="paragraph">
<p>This functional interface option is mutually exclusive with <code>sqlParameterSourceFactory</code> and can be used as a more powerful alternative to populate parameters of the <code>PreparedStatement</code> from the <code>requestMessage</code>.
For example, it is useful when we need to store <code>File</code> data to the DataBase <code>BLOB</code> column in a streaming manner.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "storeFileChannel")
public MessageHandler jdbcMessageHandler(DataSource dataSource) {
    JdbcMessageHandler jdbcMessageHandler = new JdbcMessageHandler(dataSource,
            "INSERT INTO imagedb (image_name, content, description) VALUES (?, ?, ?)");
    jdbcMessageHandler.setPreparedStatementSetter((ps, m) -&gt; {
        ps.setString(1, m.getHeaders().get(FileHeaders.FILENAME));
        try (FileInputStream inputStream = new FileInputStream((File) m.getPayload()); ) {
            ps.setBlob(2, inputStream);
        }
        catch (Exception e) {
            throw new MessageHandlingException(m, e);
        }
        ps.setClob(3, new StringReader(m.getHeaders().get("description", String.class)));
    });
    return jdbcMessageHandler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>From the XML configuration perspective, the <code>prepared-statement-setter</code> attribute is available on the <code>&lt;int-jdbc:outbound-channel-adapter&gt;</code> component.
It lets you specify a <code>MessagePreparedStatementSetter</code> bean reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="batch-update"><a class="anchor" href="#batch-update"></a>21.2.3. Batch Update</h4>
<div class="paragraph">
<p>Starting with version 5.1, the <code>JdbcMessageHandler</code> performs a <code>JdbcOperations.batchUpdate()</code> if the payload of the request message is an <code>Iterable</code> instance.
Each element of the <code>Iterable</code> is wrapped to a <code>Message</code> with the headers from the request message.
In the case of regular <code>SqlParameterSourceFactory</code>-based configuration these messages are used to build an <code>SqlParameterSource[]</code> for an argument used in the mentioned <code>JdbcOperations.batchUpdate()</code> function.
When a <code>MessagePreparedStatementSetter</code> configuration is applied, a <code>BatchPreparedStatementSetter</code> variant is used to iterate over those messages for each item and the provided <code>MessagePreparedStatementSetter</code> is called against them.
The batch update is not supported when <code>keysGenerated</code> mode is selected.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-outbound-gateway"><a class="anchor" href="#jdbc-outbound-gateway"></a>21.3. Outbound Gateway</h3>
<div class="paragraph">
<p>The outbound gateway is like a combination of the outbound and inbound adapters: Its role is to handle a message and use it to execute a SQL query and then respond with the result by sending it to a reply channel.
By default, the message payload and headers are available as input parameters to the query, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:outbound-gateway
    update="insert into mythings (id, status, name) values (:headers[id], 0, :payload[thing])"
    request-channel="input" reply-channel="output" data-source="dataSource" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding example is to insert a record into the <code>mythings</code> table and return a message that indicates the number of rows affected (the payload is a map: <code>{UPDATED=1}</code>) to the output channel .</p>
</div>
<div class="paragraph">
<p>If the update query is an insert with auto-generated keys, you can populate the reply message with the generated keys by adding <code>keys-generated="true"</code> to the preceding example (this is not the default because it is not supported by some database platforms).
The following example shows the changed configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:outbound-gateway
    update="insert into mythings (status, name) values (0, :payload[thing])"
    request-channel="input" reply-channel="output" data-source="dataSource"
    keys-generated="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Instead of the update count or the generated keys, you can also provide a select query to execute and generate a reply message from the result (such as the inbound adapter), as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:outbound-gateway
    update="insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])"
    query="select * from foos where id=:headers[$id]"
    request-channel="input" reply-channel="output" data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Spring Integration 2.2, the update SQL query is no longer mandatory.
You can now provide only a select query, by using either the <code>query</code> attribute or the <code>query</code> element.
This is extremely useful if you need to actively retrieve data by using, for example, a generic gateway or a payload enricher.
The reply message is then generated from the result (similar to how the inbound adapter works) and passed to the reply channel.
The following example show to use the <code>query</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:outbound-gateway
    query="select * from foos where id=:headers[id]"
    request-channel="input"
    reply-channel="output"
    data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the component for the <code>SELECT</code> query returns only one (the first) row from the cursor.
You can adjust this behavior with the <code>max-rows</code> option.
If you need to return all the rows from the SELECT, consider specifying <code>max-rows="0"</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As with the channel adapters, you can also provide <code>SqlParameterSourceFactory</code> instances for request and reply.
The default is the same as for the outbound adapter, so the request message is available as the root of an expression.
If <code>keys-generated="true"</code>, the root of the expression is the generated keys (a map if there is only one or a list of maps if multi-valued).</p>
</div>
<div class="paragraph">
<p>The outbound gateway requires a reference to either a <code>DataSource</code> or a <code>JdbcTemplate</code>.
It can also have a <code>SqlParameterSourceFactory</code> injected to control the binding of the incoming message to the query.</p>
</div>
<div class="paragraph">
<p>Starting with the version 4.2, the <code>request-prepared-statement-setter</code> attribute is available on the <code>&lt;int-jdbc:outbound-gateway&gt;</code> as an alternative to <code>request-sql-parameter-source-factory</code>.
It lets you specify a <code>MessagePreparedStatementSetter</code> bean reference, which implements more sophisticated <code>PreparedStatement</code> preparation before its execution.</p>
</div>
<div class="paragraph">
<p>See <a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a> for more information about <code>MessagePreparedStatementSetter</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-message-store"><a class="anchor" href="#jdbc-message-store"></a>21.4. JDBC Message Store</h3>
<div class="paragraph">
<p>Spring Integration provides two JDBC specific message store implementations.
The <code>JdbcMessageStore</code> is suitable for use with aggregators and the claim check pattern.
The <code>JdbcChannelMessageStore</code> implementation provides a more targeted and scalable implementation specifically for message channel.</p>
</div>
<div class="paragraph">
<p>Note that you can use a <code>JdbcMessageStore</code> to back a message channel, <code>JdbcChannelMessageStore</code> is optimized for that purpose.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with versions 5.0.11, 5.1.2, the indexes for the <code>JdbcChannelMessageStore</code> have been optimized.
If you have large message groups in such a store, you may wish to alter the indexes.
Furthermore, the index for <code>PriorityChannel</code> is commented out because it is not needed unless you are using such channels backed by JDBC.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the <code>OracleChannelMessageStoreQueryProvider</code>, the priority channel index <strong>must</strong> be added because it is included in a hint in the query.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="initializing-the-database"><a class="anchor" href="#initializing-the-database"></a>21.4.1. Initializing the Database</h4>
<div class="paragraph">
<p>Before starting to use JDBC message store components, you should provision a target database with the appropriate objects.</p>
</div>
<div class="paragraph">
<p>Spring Integration ships with some sample scripts that can be used to initialize a database.
In the <code>spring-integration-jdbc</code> JAR file, you can find scripts in the <code>org.springframework.integration.jdbc</code> package.
It provides an example create and an example drop script for a range of common database platforms.
A common way to use these scripts is to reference them in a <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-intializing-datasource">Spring JDBC data source initializer</a>.
Note that the scripts are provided as samples and as specifications of the the required table and column names.
You may find that you need to enhance them for production use (for, example, by adding index declarations).</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-message-store-generic"><a class="anchor" href="#jdbc-message-store-generic"></a>21.4.2. The Generic JDBC Message Store</h4>
<div class="paragraph">
<p>The JDBC module provides an implementation of the Spring Integration <code>MessageStore</code> (important in the claim check pattern) and <code>MessageGroupStore</code> (important in stateful patterns such as an aggregator) backed by a database.
Both interfaces are implemented by the <code>JdbcMessageStore</code>, and there is support for configuring store instances in XML, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:message-store id="messageStore" data-source="dataSource"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can specify a <code>JdbcTemplate</code> instead of a <code>DataSource</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows some other optional attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:message-store id="messageStore" data-source="dataSource"
    lob-handler="lobHandler" table-prefix="MY_INT_"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we have specified a <code>LobHandler</code> for dealing with messages as large objects (which is often necessary for Oracle) and a prefix for the table names in the queries generated by the store.
The table name prefix defaults to <code>INT_</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-message-store-channels"><a class="anchor" href="#jdbc-message-store-channels"></a>21.4.3. Backing Message Channels</h4>
<div class="paragraph">
<p>If you intend to backing message channels with JDBC, we recommend using the <code>JdbcChannelMessageStore</code> implementation.
It works only in conjunction with Message Channels.</p>
</div>
<div class="sect4">
<h5 id="supported-databases"><a class="anchor" href="#supported-databases"></a>Supported Databases</h5>
<div class="paragraph">
<p>The <code>JdbcChannelMessageStore</code> uses database-specific SQL queries to retrieve messages from the database.
Therefore, you must set the <code>ChannelMessageStoreQueryProvider</code> property on the <code>JdbcChannelMessageStore</code>.
This <code>channelMessageStoreQueryProvider</code> provides the SQL queries for the particular database you specify.
Spring Integration provides support for the following relational databases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>HSQLDB</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>Derby</p>
</li>
<li>
<p>H2</p>
</li>
<li>
<p>SqlServer</p>
</li>
<li>
<p>Sybase</p>
</li>
<li>
<p>DB2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If your database is not listed, you can extend the <code>AbstractChannelMessageStoreQueryProvider</code> class and provide your own custom queries.</p>
</div>
<div class="paragraph">
<p>Version 4.0 added the <code>MESSAGE_SEQUENCE</code> column to the table to ensure first-in-first-out (FIFO) queueing even when messages are stored in the same millisecond.</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-message-insertion"><a class="anchor" href="#custom-message-insertion"></a>Custom Message Insertion</h5>
<div class="paragraph">
<p>Since version 5.0, by overloading the <code>ChannelMessageStorePreparedStatementSetter</code> class, you can provide a custom implementation for message insertion in the <code>JdbcChannelMessageStore</code>.
You can use it to set different columns or change the table structure or serialization strategy.
For example, instead of default serialization to <code>byte[]</code>, you can store its structure as a JSON string.</p>
</div>
<div class="paragraph">
<p>The following example uses the default implementation of <code>setValues</code> to store common columns and overrides the behavior to store the message payload as a <code>varchar</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class JsonPreparedStatementSetter extends ChannelMessageStorePreparedStatementSetter {

    public JsonPreparedStatementSetter() {
        super();
    }

    @Override
    public void setValues(PreparedStatement preparedStatement, Message&lt;?&gt; requestMessage,
        Object groupId, String region, 	boolean priorityEnabled) throws SQLException {
        // Populate common columns
        super.setValues(preparedStatement, requestMessage, groupId, region, priorityEnabled);
        // Store message payload as varchar
        preparedStatement.setString(6, requestMessage.getPayload().toString());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Generally, we do not recommend using a relational database for queuing.
Instead, if possible, consider using either JMS- or AMQP-backed channels instead.
For further reference, see the following resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.engineyard.com/blog/2011/5-subtle-ways-youre-using-mysql-as-a-queue-and-why-itll-bite-you/">5 subtle ways youre using MySQL as a queue, and why itll bite you</a>.</p>
</li>
<li>
<p><a href="https://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html">The Database As Queue Anti-Pattern</a>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="concurrent-polling"><a class="anchor" href="#concurrent-polling"></a>Concurrent Polling</h5>
<div class="paragraph">
<p>When polling a message channel, you have the option to configure the associated <code>Poller</code> with a <code>TaskExecutor</code> reference.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Keep in mind, though, that if you use a JDBC backed message channel and you plan to poll the channel and consequently the message store transactionally with multiple threads, you should ensure that you use a relational database that supports <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion Concurrency Control</a> (MVCC).
Otherwise, locking may be an issue and the performance, when using multiple threads, may not materialize as expected.
For example, Apache Derby is problematic in that regard.</p>
</div>
<div class="paragraph">
<p>To achieve better JDBC queue throughput and avoid issues when different threads may poll the same <code>Message</code> from the queue, it is <strong>important</strong> to set the <code>usingIdCache</code> property of <code>JdbcChannelMessageStore</code> to <code>true</code> when using databases that do not support MVCC.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="queryProvider"
    class="o.s.i.jdbc.store.channel.PostgresChannelMessageStoreQueryProvider"/&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-commit expression="@store.removeFromIdCache(headers.id.toString())" /&gt;
    &lt;int:after-rollback expression="@store.removeFromIdCache(headers.id.toString())"/&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;task:executor id="pool" pool-size="10"
    queue-capacity="10" rejection-policy="CALLER_RUNS" /&gt;

&lt;bean id="store" class="o.s.i.jdbc.store.JdbcChannelMessageStore"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="channelMessageStoreQueryProvider" ref="queryProvider"/&gt;
    &lt;property name="region" value="TX_TIMEOUT"/&gt;
    &lt;property name="usingIdCache" value="true"/&gt;
&lt;/bean&gt;

&lt;int:channel id="inputChannel"&gt;
    &lt;int:queue message-store="store"/&gt;
&lt;/int:channel&gt;

&lt;int:bridge input-channel="inputChannel" output-channel="outputChannel"&gt;
    &lt;int:poller fixed-delay="500" receive-timeout="500"
        max-messages-per-poll="1" task-executor="pool"&gt;
        &lt;int:transactional propagation="REQUIRED" synchronization-factory="syncFactory"
        isolation="READ_COMMITTED" transaction-manager="transactionManager" /&gt;
    &lt;/int:poller&gt;
&lt;/int:bridge&gt;

&lt;int:channel id="outputChannel" /&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="priority-channel"><a class="anchor" href="#priority-channel"></a>Priority Channel</h5>
<div class="paragraph">
<p>Starting with version 4.0, <code>JdbcChannelMessageStore</code> implements <code>PriorityCapableChannelMessageStore</code> and provides the <code>priorityEnabled</code> option, letting it be used as a <code>message-store</code> reference for <code>priority-queue</code> instances.
For this purpose, the <code>INT_CHANNEL_MESSAGE</code> table has a <code>MESSAGE_PRIORITY</code> column to store the value of <code>PRIORITY</code> message headers.
In addition, a new <code>MESSAGE_SEQUENCE</code> column lets us achieve a robust first-in-first-out (FIFO) polling mechanism, even when multiple messages are stored with the same priority in the same millisecond.
Messages are polled (selected) from the database with <code>order by MESSAGE_PRIORITY DESC NULLS LAST, CREATED_DATE, MESSAGE_SEQUENCE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We do not recommend using the same <code>JdbcChannelMessageStore</code> bean for priority and non-priority queue channels, because the <code>priorityEnabled</code> option applies to the entire store and proper FIFO queue semantics are not retained for the queue channel.
However, the same <code>INT_CHANNEL_MESSAGE</code> table (and even <code>region</code>) can be used for both <code>JdbcChannelMessageStore</code> types.
To configure that scenario, you can extend one message store bean from the other, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="channelStore" class="o.s.i.jdbc.store.JdbcChannelMessageStore"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="channelMessageStoreQueryProvider" ref="queryProvider"/&gt;
&lt;/bean&gt;

&lt;int:channel id="queueChannel"&gt;
    &lt;int:queue message-store="channelStore"/&gt;
&lt;/int:channel&gt;

&lt;bean id="priorityStore" parent="channelStore"&gt;
    &lt;property name="priorityEnabled" value="true"/&gt;
&lt;/bean&gt;

&lt;int:channel id="priorityChannel"&gt;
    &lt;int:priority-queue message-store="priorityStore"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="partitioning-a-message-store"><a class="anchor" href="#partitioning-a-message-store"></a>21.4.4. Partitioning a Message Store</h4>
<div class="paragraph">
<p>It is common to use a <code>JdbcMessageStore</code> as a global store for a group of applications or nodes in the same application.
To provide some protection against name clashes and to give control over the database meta-data configuration, the message store lets the tables be partitioned in two ways.
One way is to use separate table names, by changing the prefix (as <a href="#jdbc-message-store-generic">described earlier</a>).
The other way is to specify a <code>region</code> name for partitioning data within a single table.
An important use case for the second approach is when the <code>MessageStore</code> is managing persistent queues that back a Spring Integration Message Channel.
The message data for a persistent channel is keyed in the store on the channel name.
Consequently, if the channel names are not globally unique, the channels can pick up data that is not intended for them.
To avoid this danger, you can use the message store <code>region</code> to keep data separate for different physical channels that have the same logical name.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stored-procedures"><a class="anchor" href="#stored-procedures"></a>21.5. Stored Procedures</h3>
<div class="paragraph">
<p>In certain situations, plain JDBC support is not sufficient.
Maybe you deal with legacy relational database schemas or you have complex data processing needs, but, ultimately, you have to use <a href="https://en.wikipedia.org/wiki/Stored_procedure">stored procedures</a> or stored functions.
Since Spring Integration 2.1, we provide three components to execute stored procedures or stored functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stored Procedures Inbound Channel Adapter</p>
</li>
<li>
<p>Stored Procedures Outbound Channel Adapter</p>
</li>
<li>
<p>Stored Procedures Outbound Gateway</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sp-supported-databases"><a class="anchor" href="#sp-supported-databases"></a>21.5.1. Supported Databases</h4>
<div class="paragraph">
<p>In order to enable calls to stored procedures and stored functions, the stored procedure components use the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html"><code>org.springframework.jdbc.core.simple.SimpleJdbcCall</code></a> class.
Consequently, the following databases are fully supported for executing stored procedures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Derby</p>
</li>
<li>
<p>DB2</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>Sybase</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to execute stored functions instead, the following databases are fully supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Even though your particular database may not be fully supported, chances are that you can use the stored procedure Spring Integration components quite successfully anyway, provided your RDBMS supports stored procedures or stored functions.</p>
</div>
<div class="paragraph">
<p>As a matter of fact, some of the provided integration tests use the <a href="https://www.h2database.com/">H2 database</a>.
Nevertheless, it is very important to thoroughly test those usage scenarios.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sp-configuration"><a class="anchor" href="#sp-configuration"></a>21.5.2. Configuration</h4>
<div class="paragraph">
<p>The stored procedure components provide full XML Namespace support, and configuring the components is similar as for the general purpose JDBC components discussed earlier.</p>
</div>
</div>
<div class="sect3">
<h4 id="sp-common-config-params"><a class="anchor" href="#sp-common-config-params"></a>21.5.3. Common Configuration Attributes</h4>
<div class="paragraph">
<p>All stored procedure components share certain configuration parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>auto-startup</code>: Lifecycle attribute signaling whether this component should be started during application context startup.
It defaults to <code>true</code>.
Optional.</p>
</li>
<li>
<p><code>data-source</code>: Reference to a <code>javax.sql.DataSource</code>, which is used to access the database.
Required.</p>
</li>
<li>
<p><code>id</code>:  Identifies the underlying Spring bean definition, which is an instance of either <code>EventDrivenConsumer</code> or <code>PollingConsumer</code>, depending on whether the outbound channel adapter&#8217;s <code>channel</code> attribute references a <code>SubscribableChannel</code> or a <code>PollableChannel</code>.
Optional.</p>
</li>
<li>
<p><code>ignore-column-meta-data</code>:  For fully supported databases, the underlying <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html"><code>SimpleJdbcCall</code></a> class can automatically retrieve the parameter information for the stored procedure or stored function from the JDBC metadata.</p>
<div class="paragraph">
<p>However, if the database does not support metadata lookups or if you need to provide customized parameter definitions, this flag can be set to <code>true</code>.
It defaults to <code>false</code>.
Optional.</p>
</div>
</li>
<li>
<p><code>is-function</code>:  If <code>true</code>, a SQL Function is called.
In that case, the <code>stored-procedure-name</code> or <code>stored-procedure-name-expression</code> attributes define the name of the called function.
It defaults to <code>false</code>.
Optional.</p>
</li>
<li>
<p><code>stored-procedure-name</code>: This attribute specifies the name of the stored procedure.
If the <code>is-function</code> attribute is set to <code>true</code>, this attribute specifies the function name instead.
Either this property or <code>stored-procedure-name-expression</code> must be specified.</p>
</li>
<li>
<p><code>stored-procedure-name-expression</code>: This attribute specifies the name of the stored procedure by using a SpEL expression.
By using SpEL, you have access to the full message (if available), including its headers and payload.
You can use this attribute to invoke different stored procedures at runtime.
For example, you can provide stored procedure names that you would like to execute as a message header.
The expression must resolve to a <code>String</code>.</p>
<div class="paragraph">
<p>If the <code>is-function</code> attribute is set to <code>true</code>, this attribute specifies a stored function.
Either this property or <code>stored-procedure-name</code> must be specified.</p>
</div>
</li>
<li>
<p><code>jdbc-call-operations-cache-size</code>: Defines the maximum number of cached <code>SimpleJdbcCallOperations</code> instances.
Basically, for each stored procedure name, a new <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCallOperations.html"><code>SimpleJdbcCallOperations</code></a> instance is created that, in return, is cached.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Integration 2.2 added the <code>stored-procedure-name-expression</code> attribute and the <code>jdbc-call-operations-cache-size</code> attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default cache size is <code>10</code>.
A value of <code>0</code> disables caching.
Negative values are not permitted.</p>
</div>
<div class="paragraph">
<p>If you enable JMX, statistical information about the <code>jdbc-call-operations-cache</code> is exposed as an MBean.
See <a href="#jmx-mbean-exporter">MBean Exporter</a> for more information.</p>
</div>
</li>
<li>
<p><code>sql-parameter-source-factory</code>: (Not available for the stored procedure inbound channel adapter.)
Reference to a <code>SqlParameterSourceFactory</code>.
By default, bean properties of the passed in <code>Message</code> payload are used as a source for the stored procedure&#8217;s input parameters by using a <code>BeanPropertySqlParameterSourceFactory</code>.</p>
<div class="paragraph">
<p>This may suffice for basic use cases.
For more sophisticated options, consider passing in one or more <code>ProcedureParameter</code> values.
See <a href="#sp-defining-parameter-sources">Defining Parameter Sources</a>.
Optional.</p>
</div>
</li>
<li>
<p><code>use-payload-as-parameter-source</code>: (Not available for the stored procedure inbound channel adapter.)
If set to <code>true</code>, the payload of the <code>Message</code> is used as a source for providing parameters.
If set to <code>false</code>, however, the entire <code>Message</code> is available as a source for parameters.</p>
<div class="paragraph">
<p>If no procedure parameters are passed in, this property defaults to <code>true</code>.
This means that, by using a default <code>BeanPropertySqlParameterSourceFactory</code>, the bean properties of the payload are used as a source for parameter values for the stored procedure or stored function.</p>
</div>
<div class="paragraph">
<p>However, if procedure parameters are passed in, this property (by default) evaluates to <code>false</code>.
<code>ProcedureParameter</code> lets SpEL Expressions be provided.
Therefore, it is highly beneficial to have access to the entire <code>Message</code>.
The property is set on the underlying <code>StoredProcExecutor</code>.
Optional.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sp-common-config-subelements"><a class="anchor" href="#sp-common-config-subelements"></a>21.5.4. Common Configuration Sub-Elements</h4>
<div class="paragraph">
<p>The stored procedure components share a common set of child elements that you can use to define and pass parameters to stored procedures or stored functions.
The following elements are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>parameter</code></p>
</li>
<li>
<p><code>returning-resultset</code></p>
</li>
<li>
<p><code>sql-parameter-definition</code></p>
</li>
<li>
<p><code>poller</code></p>
</li>
<li>
<p><code>parameter</code>: Provides a mechanism to provide stored procedure parameters.
Parameters can be either static or provided by using a SpEL Expressions.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:parameter name=""         <i class="conum" data-value="1"></i><b>(1)</b>
                    type=""         <i class="conum" data-value="2"></i><b>(2)</b>
                    value=""/&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

&lt;int-jdbc:parameter name=""
                    expression=""/&gt; <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>+
&lt;1&gt; The name of the parameter to be passed into the Stored Procedure or Stored Function.
Required.
&lt;2&gt; This attribute specifies the type of the value.
If nothing is provided, this attribute defaults to <code>java.lang.String</code>.
This attribute is used only when the <code>value</code> attribute is used.
Optional.
&lt;3&gt; The value of the parameter.
You must provide either this attribute or the <code>expression</code> attribute.
Optional.
&lt;4&gt; Instead of the <code>value</code> attribute, you can specify a SpEL expression for passing the value of the parameter.
If you specify the <code>expression</code>, the <code>value</code> attribute is not allowed.
Optional.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Optional.</p>
</div>
</li>
<li>
<p><code>returning-resultset</code>: Stored procedures may return multiple result sets.
By setting one or more <code>returning-resultset</code> elements, you can specify <code>RowMappers</code> to convert each returned <code>ResultSet</code> to meaningful objects.
Optional.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p><code>sql-parameter-definition</code>: If you use a database that is fully supported, you typically do not have to specify the stored procedure parameter definitions.
Instead, those parameters can be automatically derived from the JDBC metadata.
However, if you use databases that are not fully supported, you must set those parameters explicitly by using the <code>sql-parameter-definition</code> element.</p>
<div class="paragraph">
<p>You can also choose to turn off any processing of parameter metadata information obtained through JDBC by using the <code>ignore-column-meta-data</code> attribute.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:sql-parameter-definition
                                   name=""                           <i class="conum" data-value="1"></i><b>(1)</b>
                                   direction="IN"                    <i class="conum" data-value="2"></i><b>(2)</b>
                                   type="STRING"                     <i class="conum" data-value="3"></i><b>(3)</b>
                                   scale="5"                         <i class="conum" data-value="4"></i><b>(4)</b>
                                   type-name="FOO_STRUCT"            <i class="conum" data-value="5"></i><b>(5)</b>
                                   return-type="fooSqlReturnType"/&gt;  <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifies the name of the SQL parameter.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifies the direction of the SQL parameter definition.
Defaults to <code>IN</code>.
Valid values are: <code>IN</code>, <code>OUT</code>, and <code>INOUT</code>.
If your procedure is returning result sets, use the <code>returning-resultset</code> element.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The SQL type used for this SQL parameter definition.
Translates into an integer value, as defined by <code>java.sql.Types</code>.
Alternatively, you can provide the integer value as well.
If this attribute is not explicitly set, it defaults to 'VARCHAR'.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The scale of the SQL parameter.
Only used for numeric and decimal parameters.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>typeName</code> for types that are user-named, such as: <code>STRUCT</code>, <code>DISTINCT</code>, <code>JAVA_OBJECT</code>, and named array types.
This attribute is mutually exclusive with the <code>scale</code> attribute.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The reference to a custom value handler for complex types.
An implementation of <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/SqlReturnType.html"><code>SqlReturnType</code></a>.
This attribute is mutually exclusive with the <code>scale</code> attribute and is only applicable for OUT and INOUT parameters.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p><code>poller</code>: Lets you configure a message poller if this endpoint is a <code>PollingConsumer</code>.
Optional.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sp-defining-parameter-sources"><a class="anchor" href="#sp-defining-parameter-sources"></a>21.5.5. Defining Parameter Sources</h4>
<div class="paragraph">
<p>Parameter sources govern the techniques of retrieving and mapping the Spring Integration message properties to the relevant stored procedure input parameters.</p>
</div>
<div class="paragraph">
<p>The stored procedure components follow certain rules.
By default, the bean properties of the <code>Message</code> payload are used as a source for the stored procedure&#8217;s input parameters.
In that case, a <code>BeanPropertySqlParameterSourceFactory</code> is used.
This may suffice for basic use cases.
The next example illustrates that default behavior.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the &#8220;automatic&#8221; lookup of bean properties by using the <code>BeanPropertySqlParameterSourceFactory</code> to work, your bean properties must be defined in lower case.
This is due to the fact that in <code>org.springframework.jdbc.core.metadata.CallMetaDataContext</code> (the Java method is <code>matchInParameterValuesWithCallParameters()</code>), the retrieved stored procedure parameter declarations are converted to lower case.
As a result, if you have camel-case bean properties (such as <code>lastName</code>), the lookup fails.
In that case, provide an explicit <code>ProcedureParameter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose we have a payload that consists of a simple bean with the following three properties: <code>id</code>, <code>name</code>, and <code>description</code>.
Furthermore, we have a simplistic Stored Procedure called <code>INSERT_COFFEE</code> that accepts three input parameters: <code>id</code>, <code>name</code>, and <code>description</code>.
We also use a fully supported database.
In that case, the following configuration for a stored procedure outbound adapter suffices:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-outbound-channel-adapter data-source="dataSource"
    channel="insertCoffeeProcedureRequestChannel"
    stored-procedure-name="INSERT_COFFEE"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more sophisticated options, consider passing in one or more <code>ProcedureParameter</code> values.</p>
</div>
<div class="paragraph">
<p>If you do provide <code>ProcedureParameter</code> values explicitly, by default, an <code>ExpressionEvaluatingSqlParameterSourceFactory</code> is used for parameter processing, to enable the full power of SpEL expressions.</p>
</div>
<div class="paragraph">
<p>If you need even more control over how parameters are retrieved, consider passing in a custom implementation of <code>SqlParameterSourceFactory</code> by using the <code>sql-parameter-source-factory</code> attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-inbound-channel-adapter"><a class="anchor" href="#stored-procedure-inbound-channel-adapter"></a>21.5.6. Stored Procedure Inbound Channel Adapter</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-inbound-channel-adapter
                                   channel=""                                    <i class="conum" data-value="1"></i><b>(1)</b>
                                   stored-procedure-name=""
                                   data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   skip-undeclared-results=""                    <i class="conum" data-value="2"></i><b>(2)</b>
                                   return-value-required="false"                 <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;int:poller/&gt;
    &lt;int-jdbc:sql-parameter-definition name="" direction="IN"
                                               type="STRING"
                                               scale=""/&gt;
    &lt;int-jdbc:parameter name="" type="" value=""/&gt;
    &lt;int-jdbc:parameter name="" expression=""/&gt;
    &lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;
&lt;/int-jdbc:stored-proc-inbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Channel to which polled messages are sent.
If the stored procedure or function does not return any data, the payload of the <code>Message</code> is null.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If this attribute is set to <code>true</code>, all results from a stored procedure call that do not have a corresponding <code>SqlOutParameter</code> declaration are bypassed.
For example, stored procedures can return an update count value, even though your stored procedure declared only a single result parameter.
The exact behavior depends on the database implementation.
The value is set on the underlying <code>JdbcTemplate</code>.
The value defaults to <code>true</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicates whether this procedure&#8217;s return value should be included.
Since Spring Integration 3.0.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-outbound-channel-adapter"><a class="anchor" href="#stored-procedure-outbound-channel-adapter"></a>21.5.7. Stored Procedure Outbound Channel Adapter</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-outbound-channel-adapter channel=""                        <i class="conum" data-value="1"></i><b>(1)</b>
                                               stored-procedure-name=""
                                               data-source=""
                                               auto-startup="true"
                                               id=""
                                               ignore-column-meta-data="false"
                                               order=""                          <i class="conum" data-value="2"></i><b>(2)</b>
                                               sql-parameter-source-factory=""
                                               use-payload-as-parameter-source=""&gt;
    &lt;int:poller fixed-rate=""/&gt;
    &lt;int-jdbc:sql-parameter-definition name=""/&gt;
    &lt;int-jdbc:parameter name=""/&gt;

&lt;/int-jdbc:stored-proc-outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The receiving message channel of this endpoint.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a <code>failover</code> dispatching strategy.
It has no effect when this endpoint is itself a polling consumer for a channel with a queue.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stored-procedure-outbound-gateway"><a class="anchor" href="#stored-procedure-outbound-gateway"></a>21.5.8. Stored Procedure Outbound Gateway</h4>
<div class="paragraph">
<p>The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-outbound-gateway request-channel=""                        <i class="conum" data-value="1"></i><b>(1)</b>
                                       stored-procedure-name=""
                                       data-source=""
                                   auto-startup="true"
                                   id=""
                                   ignore-column-meta-data="false"
                                   is-function="false"
                                   order=""
                                   reply-channel=""                              <i class="conum" data-value="2"></i><b>(2)</b>
                                   reply-timeout=""                              <i class="conum" data-value="3"></i><b>(3)</b>
                                   return-value-required="false"                 <i class="conum" data-value="4"></i><b>(4)</b>
                                   skip-undeclared-results=""                    <i class="conum" data-value="5"></i><b>(5)</b>
                                   sql-parameter-source-factory=""
                                   use-payload-as-parameter-source=""&gt;
&lt;int-jdbc:sql-parameter-definition name="" direction="IN"
                                   type=""
                                   scale="10"/&gt;
&lt;int-jdbc:sql-parameter-definition name=""/&gt;
&lt;int-jdbc:parameter name="" type="" value=""/&gt;
&lt;int-jdbc:parameter name="" expression=""/&gt;
&lt;int-jdbc:returning-resultset name="" row-mapper="" /&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The receiving message channel of this endpoint.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Message channel to which replies should be sent after receiving the database response.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Lets you specify how long this gateway waits for the reply message to be sent successfully before throwing an exception.
Keep in mind that, when sending to a <code>DirectChannel</code>, the invocation occurs in the sender&#8217;s thread.
Consequently, the failing of the send operation may be caused by other components further downstream.
By default, the gateway waits indefinitely.
The value is specified in milliseconds.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Indicates whether this procedure&#8217;s return value should be included.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If the <code>skip-undeclared-results</code> attribute is set to <code>true</code>, all results from a stored procedure call that do not have a corresponding <code>SqlOutParameter</code> declaration are bypassed.
For example, stored procedures may return an update count value, even though your stored procedure only declared a single result parameter.
The exact behavior depends on the database.
The value is set on the underlying <code>JdbcTemplate</code>.
The value defaults to <code>true</code>.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sp-examples"><a class="anchor" href="#sp-examples"></a>21.5.9. Examples</h4>
<div class="paragraph">
<p>This section contains two examples that call <a href="https://db.apache.org/derby/">Apache Derby</a> stored procedures.
The first procedure calls a stored procedure that returns a <code>ResultSet</code>.
By using a <code>RowMapper</code>, the data is converted into a domain object, which then becomes the Spring Integration message payload.</p>
</div>
<div class="paragraph">
<p>In the second sample, we call a stored procedure that uses output parameters to return data instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Have a look at the <a href="https://github.com/spring-projects/spring-integration-samples">Spring Integration Samples project</a>.</p>
</div>
<div class="paragraph">
<p>The project contains the Apache Derby example referenced here, as well as instructions on how to run it.
The Spring Integration Samples project also provides an <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/stored-procedures-oracle">example</a> of using Oracle stored procedures.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the first example, we call a stored procedure named <code>FIND_ALL_COFFEE_BEVERAGES</code> that does not define any input parameters but that returns a <code>ResultSet</code>.</p>
</div>
<div class="paragraph">
<p>In Apache Derby, stored procedures are implemented in Java.
The following listing shows the method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void findAllCoffeeBeverages(ResultSet[] coffeeBeverages)
            throws SQLException {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the corresponding SQL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE PROCEDURE FIND_ALL_COFFEE_BEVERAGES() \
PARAMETER STYLE JAVA LANGUAGE JAVA MODIFIES SQL DATA DYNAMIC RESULT SETS 1 \
EXTERNAL NAME 'o.s.i.jdbc.storedproc.derby.DerbyStoredProcedures.findAllCoffeeBeverages';</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Spring Integration, you can now call this stored procedure by using, for example, a <code>stored-proc-outbound-gateway</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-outbound-gateway id="outbound-gateway-storedproc-find-all"
                                       data-source="dataSource"
                                       request-channel="findAllProcedureRequestChannel"
                                       expect-single-result="true"
                                       stored-procedure-name="FIND_ALL_COFFEE_BEVERAGES"&gt;
&lt;int-jdbc:returning-resultset name="coffeeBeverages"
    row-mapper="org.springframework.integration.support.CoffeBeverageMapper"/&gt;
&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the second example, we call a stored procedure named <code>FIND_COFFEE</code> that has one input parameter.
Instead of returning a <code>ResultSet</code>, it uses an output parameter.
The following example shows the method signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void findCoffee(int coffeeId, String[] coffeeDescription)
            throws SQLException {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the corresponding SQL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE PROCEDURE FIND_COFFEE(IN ID INTEGER, OUT COFFEE_DESCRIPTION VARCHAR(200)) \
PARAMETER STYLE JAVA LANGUAGE JAVA EXTERNAL NAME \
'org.springframework.integration.jdbc.storedproc.derby.DerbyStoredProcedures.findCoffee';</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Spring Integration, you can now call this Stored Procedure by using, for example, a <code>stored-proc-outbound-gateway</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jdbc:stored-proc-outbound-gateway id="outbound-gateway-storedproc-find-coffee"
                                       data-source="dataSource"
                                       request-channel="findCoffeeProcedureRequestChannel"
                                       skip-undeclared-results="true"
                                       stored-procedure-name="FIND_COFFEE"
                                       expect-single-result="true"&gt;
    &lt;int-jdbc:parameter name="ID" expression="payload" /&gt;
&lt;/int-jdbc:stored-proc-outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-lock-registry"><a class="anchor" href="#jdbc-lock-registry"></a>21.6. JDBC Lock Registry</h3>
<div class="paragraph">
<p>Version 4.3 introduced the <code>JdbcLockRegistry</code>.
Certain components (for example, aggregator and resequencer) use a lock obtained from a <code>LockRegistry</code> instance to ensure that only one thread manipulates a group at a time.
The <code>DefaultLockRegistry</code> performs this function within a single component.
You can now configure an external lock registry on these components.
When used with a shared <code>MessageGroupStore</code>, you can use the <code>JdbcLockRegistry</code> to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
</div>
<div class="paragraph">
<p>When a lock is released by a local thread, another local thread can generally acquire the lock immediately.
If a lock is released by a thread that uses a different registry instance, it can take up to 100ms to acquire the lock.</p>
</div>
<div class="paragraph">
<p>The <code>JdbcLockRegistry</code> is based on the <code>LockRepository</code> abstraction, which has a <code>DefaultLockRepository</code> implementation.
The database schema scripts are located in the <code>org.springframework.integration.jdbc</code> package, which is divided for the particular RDBMS vendors.
For example, the following listing shows the H2 DDL for the lock table:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE INT_LOCK  (
    LOCK_KEY CHAR(36),
    REGION VARCHAR(100),
    CLIENT_ID CHAR(36),
    CREATED_DATE TIMESTAMP NOT NULL,
    constraint LOCK_PK primary key (LOCK_KEY, REGION)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>INT_</code> can be changed according to the target database design requirements.
Therefore, you must use <code>prefix</code> property on the <code>DefaultLockRepository</code> bean definition.</p>
</div>
<div class="paragraph">
<p>Sometimes, one application has moved to such a state that it cannot release the distributed lock and remove the particular record in the database.
For this purpose, such dead locks can be expired by the other application on the next locking invocation.
The <code>timeToLive</code> (TTL) option on the <code>DefaultLockRepository</code> is provided for this purpose.
You may also want to specify <code>CLIENT_ID</code> for the locks stored for a given <code>DefaultLockRepository</code> instance.
If so, you can specify the <code>id</code> to be associated with the <code>DefaultLockRepository</code> as a constructor parameter.</p>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-metadata-store"><a class="anchor" href="#jdbc-metadata-store"></a>21.7. JDBC Metadata Store</h3>
<div class="paragraph">
<p>Version 5.0 introduced the JDBC <code>MetadataStore</code> (see <a href="#metadata-store">Metadata Store</a>) implementation.
You can use the <code>JdbcMetadataStore</code> to maintain the metadata state across application restarts.
This <code>MetadataStore</code> implementation can be used with adapters such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#feed-inbound-channel-adapter">Feed inbound channel adapters</a></p>
</li>
<li>
<p><a href="#file-reading">files</a></p>
</li>
<li>
<p><a href="#ftp-inbound">FTP inbound channel adapters</a></p>
</li>
<li>
<p><a href="#sftp-inbound">SFTP inbound channel adapters</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To configure these adapters to use the <code>JdbcMetadataStore</code>, declare a Spring bean by using a bean name of <code>metadataStore</code>.
The Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared <code>JdbcMetadataStore</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MetadataStore metadataStore(DataSource dataSource) {
    return new JdbcMetadataStore(dataSource);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>org.springframework.integration.jdbc</code> package has Database schema scripts for several RDMBS vendors.
For example, the following listing shows the H2 DDL for the metadata table:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE INT_METADATA_STORE  (
	METADATA_KEY VARCHAR(255) NOT NULL,
	METADATA_VALUE VARCHAR(4000),
	REGION VARCHAR(100) NOT NULL,
	constraint METADATA_STORE primary key (METADATA_KEY, REGION)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can change the <code>INT_</code> prefix to match the target database design requirements.
You can also configure <code>JdbcMetadataStore</code> to use the custom prefix.</p>
</div>
<div class="paragraph">
<p>The <code>JdbcMetadataStore</code> implements <code>ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances, where only one instance can store or modify a key&#8217;s value.
All of these operations are atomic, thanks to transaction guarantees.</p>
</div>
<div class="paragraph">
<p>Transaction management must use <code>JdbcMetadataStore</code>.
Inbound channel adapters can be supplied with a reference to the <code>TransactionManager</code> in the poller configuration.
Unlike non-transactional <code>MetadataStore</code> implementations, with <code>JdbcMetadataStore</code>, the entry appears in the target table only after the transaction commits.
When a rollback occurs, no entries are added to the <code>INT_METADATA_STORE</code> table.</p>
</div>
<div class="paragraph">
<p>Since version 5.0.7, you can configure the <code>JdbcMetadataStore</code> with the RDBMS vendor-specific <code>lockHint</code> option for lock-based queries on metadata store entries.
By default, it is <code>FOR UPDATE</code> and can be configured with an empty string if the target database does not support row locking functionality.
Consult with your vendor for particular and possible hints in the <code>SELECT</code> expression for locking rows before updates.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa"><a class="anchor" href="#jpa"></a>22. JPA Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration&#8217;s JPA (Java Persistence API) module provides components for performing various database operations using JPA.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-jpa&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-jpa:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The JPA API must be included via some vendor-specific implementation, e.g. Hibernate ORM Framework.</p>
</div>
<div class="paragraph">
<p>The following components are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jpa-inbound-channel-adapter">Inbound channel adapter</a></p>
</li>
<li>
<p><a href="#jpa-outbound-channel-adapter">Outbound channel adapter</a></p>
</li>
<li>
<p><a href="#jpa-updating-outbound-gateway">Updating outbound gateway</a></p>
</li>
<li>
<p><a href="#jpa-retrieving-outbound-gateway">Retrieving outbound gateway</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These components can be used to perform <code>select</code>, <code>create</code>, <code>update</code>, and <code>delete</code> operations on the target databases by sending and receiving messages to them.</p>
</div>
<div class="paragraph">
<p>The JPA inbound channel adapter lets you poll and retrieve (<code>select</code>) data from the database by using JPA, whereas the JPA outbound channel adapter lets you create, update, and delete entities.</p>
</div>
<div class="paragraph">
<p>You can use outbound gateways for JPA to persist entities to the database, letting you continue the flow and execute further components downstream.
Similarly, you can use an outbound gateway to retrieve entities from the database.</p>
</div>
<div class="paragraph">
<p>For example, you may use the outbound gateway, which receives a <code>Message</code> with a <code>userId</code> as payload on its request channel, to query the database, retrieve the user entity, and pass it downstream for further processing.</p>
</div>
<div class="paragraph">
<p>Recognizing these semantic differences, Spring Integration provides two separate JPA outbound gateways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Retrieving outbound gateway</p>
</li>
<li>
<p>Updating outbound gateway</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="functionality"><a class="anchor" href="#functionality"></a>22.1. Functionality</h3>
<div class="paragraph">
<p>All JPA components perform their respective JPA operations by using one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Entity classes</p>
</li>
<li>
<p>Java Persistence Query Language (JPQL) for update, select and delete (JPQL does not support inserts)</p>
</li>
<li>
<p>Native Query</p>
</li>
<li>
<p>Named Query</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections describe each of these components in more detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa-supported-persistence-providers"><a class="anchor" href="#jpa-supported-persistence-providers"></a>22.2. Supported Persistence Providers</h3>
<div class="paragraph">
<p>The Spring Integration JPA support has been tested against the following persistence providers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hibernate</p>
</li>
<li>
<p>EclipseLink</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using a persistence provider, you should ensure that the provider is compatible with JPA 2.1.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa-java-implementation"><a class="anchor" href="#jpa-java-implementation"></a>22.3. Java Implementation</h3>
<div class="paragraph">
<p>Each of the provided components uses the <code>o.s.i.jpa.core.JpaExecutor</code> class, which, in turn, uses an implementation of the <code>o.s.i.jpa.core.JpaOperations</code> interface.
<code>JpaOperations</code> operates like a typical Data Access Object (DAO) and provides methods such as find, persist, executeUpdate, and so on.
For most use cases, the default implementation (<code>o.s.i.jpa.core.DefaultJpaOperations</code>) should be sufficient.
However, you can specify your own implementation if you require custom behavior.</p>
</div>
<div class="paragraph">
<p>To initialize a <code>JpaExecutor</code>, you must use one of the constructors that accept one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EntityManagerFactory</p>
</li>
<li>
<p>EntityManager</p>
</li>
<li>
<p>JpaOperations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to initialize a <code>JpaExecutor</code> with an <code>entityManagerFactory</code> and use it in an outbound gateway:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public JpaExecutor jpaExecutor() {
    JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);
    executor.setJpaParameters(Collections.singletonList(new JpaParameter("firstName", null, "#this")));
    executor.setUsePayloadAsParameterSource(true);
    executor.setExpectSingleResult(true);
    return executor;
}

@ServiceActivator(inputChannel = "getEntityChannel")
@Bean
public MessageHandler retrievingJpaGateway() {
    JpaOutboundGateway gateway = new JpaOutboundGateway(jpaExecutor());
    gateway.setGatewayType(OutboundGatewayType.RETRIEVING);
    gateway.setOutputChannelName("resultsChannel");
    return gateway;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa-namespace-support"><a class="anchor" href="#jpa-namespace-support"></a>22.4. Namespace Support</h3>
<div class="paragraph">
<p>When using XML namespace support, the underlying parser classes instantiate the relevant Java classes for you.
Thus, you typically need not deal with the inner workings of the JPA adapter.
This section documents the XML namespace support provided by Spring Integration and shows you how to use the XML Namespace support to configure the JPA components.</p>
</div>
<div class="sect3">
<h4 id="jpa-namespace-support-common-attributes"><a class="anchor" href="#jpa-namespace-support-common-attributes"></a>22.4.1. Common XML Namespace Configuration Attributes</h4>
<div class="paragraph">
<p>Certain configuration parameters are shared by all JPA components:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>auto-startup</code></dt>
<dd>
<p>Lifecycle attribute that signals whether this component should be started during application context startup.
Defaults to <code>true</code>.
Optional.</p>
</dd>
<dt class="hdlist1"><code>id</code></dt>
<dd>
<p>Identifies the underlying Spring bean definition, which is an instance of either <code>EventDrivenConsumer</code> or <code>PollingConsumer</code>.
Optional.</p>
</dd>
<dt class="hdlist1"><code>entity-manager-factory</code></dt>
<dd>
<p>The reference to the JPA entity manager factory that the adapter uses to create the <code>EntityManager</code>.
You must provide this attribute, the <code>entity-manager</code> attribute, or the <code>jpa-operations</code> attribute.</p>
</dd>
<dt class="hdlist1"><code>entity-manager</code></dt>
<dd>
<p>The reference to the JPA Entity Manager that the component uses.
You must provide this attribute, the <code>entity-manager-factory</code> attribute, or the <code>jpa-operations</code> attribute.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Usually, your Spring application context defines only a JPA entity manager factory, and the <code>EntityManager</code> is injected by using the <code>@PersistenceContext</code> annotation.
This approach does not apply for the Spring Integration JPA components.
Usually, injecting the JPA entity manager factory is best, but, when you want to inject an <code>EntityManager</code> explicitly, you have to define a <code>SharedEntityManagerBean</code>.
For more information, see the relevant <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html">Javadoc</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to explicitly include an entity manager factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="entityManager"
      class="org.springframework.orm.jpa.support.SharedEntityManagerBean"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactoryBean" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>jpa-operations</code></dt>
<dd>
<p>A reference to a bean that implements the <code>JpaOperations</code> interface.
In rare cases, it might be advisable to provide your own implementation of the <code>JpaOperations</code> interface instead of relying on the default implementation (<code>org.springframework.integration.jpa.core.DefaultJpaOperations</code>).
If you use the <code>jpa-operations</code> attribute, you must not provide the JPA entity manager or JPA entity manager factory, because <code>JpaOperations</code> wraps the necessary datasource.</p>
</dd>
<dt class="hdlist1"><code>entity-class</code></dt>
<dd>
<p>The fully qualified name of the entity class.
The exact semantics of this attribute vary, depending on whether we are performing a persist or update operation or whether we are retrieving objects from the database.</p>
<div class="paragraph">
<p>When retrieving data, you can specify the <code>entity-class</code> attribute to indicate that you would like to retrieve objects of this type from the database.
In that case, you must not define any of the query attributes (<code>jpa-query</code>, <code>native-query</code>, or <code>named-query</code>).</p>
</div>
<div class="paragraph">
<p>When persisting data, the <code>entity-class</code> attribute indicates the type of object to persist.
If not specified (for persist operations) the entity class is automatically retrieved from the message&#8217;s payload.</p>
</div>
</dd>
<dt class="hdlist1"><code>jpa-query</code></dt>
<dd>
<p>Defines the JPA query (Java Persistence Query Language) to be used.</p>
</dd>
<dt class="hdlist1"><code>native-query</code></dt>
<dd>
<p>Defines the native SQL query to be used.</p>
</dd>
<dt class="hdlist1"><code>named-query</code></dt>
<dd>
<p>Refers to a named query.
A named query can be defined in either Native SQL or JPAQL, but the underlying JPA persistence provider handles that distinction internally.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="jpa-parameters"><a class="anchor" href="#jpa-parameters"></a>22.4.2. Providing JPA Query Parameters</h4>
<div class="paragraph">
<p>To provide parameters, you can use the <code>parameter</code> XML element.
It has a mechanism that lets you provide parameters for queries that are based on either the Java Persistence Query Language (JPQL) or native SQL queries.
You can also provide parameters for named queries.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Expression-based Parameters</dt>
<dd>
<p>The following example shows how to set an expression-based parameter:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:parameter expression="payload.name" name="firstName"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Value-based Parameters</dt>
<dd>
<p>The following example shows how to set an value-based parameter:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:parameter name="name" type="java.lang.String" value="myName"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Positional Parameters</dt>
<dd>
<p>The following example shows how to set an expression-based parameter:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:parameter expression="payload.name"/&gt;
&lt;int-jpa:parameter type="java.lang.Integer" value="21"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="jpa-transactions"><a class="anchor" href="#jpa-transactions"></a>22.4.3. Transaction Handling</h4>
<div class="paragraph">
<p>All JPA operations (such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>) require a transaction to be active whenever they are performed.
For inbound channel adapters, you need do nothing special.
It works similarly to the way we configure transaction managers with pollers that are used with other inbound channel adapters.
The following XML example configures a transaction manager that uses a poller with an inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:inbound-channel-adapter
    channel="inboundChannelAdapterOne"
    entity-manager="em"
    auto-startup="true"
    jpa-query="select s from Student s"
    expect-single-result="true"
    delete-after-poll="true"&gt;
    &lt;int:poller fixed-rate="2000" &gt;
        &lt;int:transactional propagation="REQUIRED"
            transaction-manager="transactionManager"/&gt;
    &lt;/int:poller&gt;
&lt;/int-jpa:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, you may need to specifically start a transaction when using an outbound channel adapter or gateway.
If a <code>DirectChannel</code> is an input channel for the outbound adapter or gateway and if the transaction is active in the current thread of execution, the JPA operation is performed in the same transaction context.
You can also configure this JPA operation to run as a new transaction, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-gateway
    request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em"
    gateway-type="UPDATING"&gt;
    &lt;int-jpa:parameter name="lastName" expression="payload"/&gt;
    &lt;int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/&gt;
		&lt;int-jpa:transactional propagation="REQUIRES_NEW"
        transaction-manager="transactionManager"/&gt;
&lt;/int-jpa:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the transactional element of the outbound gateway or adapter specifies the transaction attributes.
It is optional to define this child element if you have <code>DirectChannel</code> as an input channel to the adapter and you want the adapter to execute the operations in the same transaction context as the caller.
If, however, you use an <code>ExecutorChannel</code>, you must have the <code>transactional</code> element, because the invoking client&#8217;s transaction context is not propagated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike the <code>transactional</code> element of the poller, which is defined in Spring Integration&#8217;s namespace, the <code>transactional</code> element for the outbound gateway or adapter is defined in the JPA namespace.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa-inbound-channel-adapter"><a class="anchor" href="#jpa-inbound-channel-adapter"></a>22.5. Inbound Channel Adapter</h3>
<div class="paragraph">
<p>An inbound channel adapter is used to execute a select query over the database using JPA QL and return the result.
The message payload is either a single entity or a <code>List</code> of entities.
The following XML configures an <code>inbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:inbound-channel-adapter channel="inboundChannelAdapterOne"  <i class="conum" data-value="1"></i><b>(1)</b>
                    entity-manager="em"                              <i class="conum" data-value="2"></i><b>(2)</b>
                    auto-startup="true"                              <i class="conum" data-value="3"></i><b>(3)</b>
                    query="select s from Student s"                  <i class="conum" data-value="4"></i><b>(4)</b>
                    expect-single-result="true"                      <i class="conum" data-value="5"></i><b>(5)</b>
                    max-results=""                                   <i class="conum" data-value="6"></i><b>(6)</b>
                    max-results-expression=""                        <i class="conum" data-value="7"></i><b>(7)</b>
                    delete-after-poll="true"                         <i class="conum" data-value="8"></i><b>(8)</b>
                    flush-after-delete="true"&gt;                       <i class="conum" data-value="9"></i><b>(9)</b>
    &lt;int:poller fixed-rate="2000" &gt;
      &lt;int:transactional propagation="REQUIRED" transaction-manager="transactionManager"/&gt;
    &lt;/int:poller&gt;
&lt;/int-jpa:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The channel over which the <code>inbound-channel-adapter</code> puts the messages (with the payload) after executing the JPA QL in the <code>query</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>EntityManager</code> instance used to perform the required JPA operations.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Attribute signaling whether the component should automatically start when the application context starts.
The value defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The JPA QL whose result are sent out as the payload of the message</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This attribute tells whether the JPQL query gives a single entity in the result or a <code>List</code> of entities.
If the value is set to <code>true</code>, the single entity is sent as the payload of the message.
If, however, multiple results are returned after setting this to <code>true</code>, a <code>MessagingException</code> is thrown.
The value defaults to <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This non-zero, non-negative integer value tells the adapter not to select more than the given number of rows on execution of the select operation.
By default, if this attribute is not set, all possible records are selected by the query.
This attribute is mutually exclusive with <code>max-results-expression</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>An expression that is evaluated to find the maximum number of results in a result set.
Mutually exclusive with <code>max-results</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Set this value to <code>true</code> if you want to delete the rows received after execution of the query.
You must ensure that the component operates as part of a transaction.
Otherwise, you may encounter an exception such as: <code>java.lang.IllegalArgumentException: Removing a detached instance &#8230;&#8203;</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Set this value to <code>true</code> if you want to flush the persistence context immediately after deleting received entities and if you do not want to rely on the <code>flushMode</code> of the <code>EntityManager</code>.
The value defaults to <code>false</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpaInboundChannelAdapterParameters"><a class="anchor" href="#jpaInboundChannelAdapterParameters"></a>22.5.1. Configuration Parameter Reference</h4>
<div class="paragraph">
<p>The following listing shows all the values that can be set for an <code>inbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:inbound-channel-adapter
  auto-startup="true"           <i class="conum" data-value="1"></i><b>(1)</b>
  channel=""                    <i class="conum" data-value="2"></i><b>(2)</b>
  delete-after-poll="false"     <i class="conum" data-value="3"></i><b>(3)</b>
  delete-per-row="false"        <i class="conum" data-value="4"></i><b>(4)</b>
  entity-class=""               <i class="conum" data-value="5"></i><b>(5)</b>
  entity-manager=""             <i class="conum" data-value="6"></i><b>(6)</b>
  entity-manager-factory=""     <i class="conum" data-value="7"></i><b>(7)</b>
  expect-single-result="false"  <i class="conum" data-value="8"></i><b>(8)</b>
  id=""
  jpa-operations=""             <i class="conum" data-value="9"></i><b>(9)</b>
  jpa-query=""                  <i class="conum" data-value="10"></i><b>(10)</b>
  named-query=""                <i class="conum" data-value="11"></i><b>(11)</b>
  native-query=""               <i class="conum" data-value="12"></i><b>(12)</b>
  parameter-source=""           <i class="conum" data-value="13"></i><b>(13)</b>
  send-timeout=""&gt;              <i class="conum" data-value="14"></i><b>(14)</b>
  &lt;int:poller ref="myPoller"/&gt;
 &lt;/int-jpa:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This lifecycle attribute signals whether this component should automatically start when the application context starts.
This attribute defaults to <code>true</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The channel to which the adapter sends a message with the payload from performing the desired JPA operation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A boolean flag that indicates whether to delete the selected records after they have been polled by the adapter.
By default, the value is <code>false</code> (that is, the records are not deleted).
You must ensure that the component operates as part of a transaction.
Otherwise, you may encounter an exception, such as: <code>java.lang.IllegalArgumentException: Removing a detached instance &#8230;&#8203;</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A boolean flag that indicates whether the records can be deleted in bulk or must be deleted one record at a time.
By default the value is <code>false</code> (that is, the records can be bulk-deleted).
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The fully qualified name of the entity class to be queried from the database.
The adapter automatically builds a JPA Query based on the entity class name.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>An instance of <code>javax.persistence.EntityManager</code> used to perform the JPA operations.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>An instance of <code>javax.persistence.EntityManagerFactory</code> used to obtain an instance of <code>javax.persistence.EntityManager</code> that performs the JPA operations.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>A boolean flag indicating whether the select operation is expected to return a single result or a <code>List</code> of results.
If this flag is set to <code>true</code>, the single entity selected is sent as the payload of the message.
If multiple entities are returned, an exception is thrown.
If <code>false</code>, the <code>List</code> of entities is sent as the payload of the message.
The value defaults to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>An implementation of <code>org.springframework.integration.jpa.core.JpaOperations</code> used to perform the JPA operations.
We recommend not providing an implementation of your own but using the default <code>org.springframework.integration.jpa.core.DefaultJpaOperations</code> implementation.
You can use any of the <code>entity-manager</code>, <code>entity-manager-factory</code>, or <code>jpa-operations</code> attributes.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The JPA QL to be executed by this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The named query that needs to be executed by this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The native query executed by this adapter.
You can use any of the <code>jpa-query</code>, <code>named-query</code>, <code>entity-class</code>, or <code>native-query</code> attributes.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>An implementation of <code>o.s.i.jpa.support.parametersource.ParameterSource</code> used to resolve the values of the parameters in the query.
Ignored if the <code>entity-class</code> attribute has a value.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>Maximum amount of time (in milliseconds) to wait when sending a message to the channel.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-13"><a class="anchor" href="#configuring-with-java-configuration-13"></a>22.5.2. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Bean
    public JpaExecutor jpaExecutor() {
        JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);
        jpaExecutor.setJpaQuery("from Student");
        return executor;
    }

    @Bean
    @InboundChannelAdapter(channel = "jpaInputChannel",
                     poller = @Poller(fixedDelay = "${poller.interval}"))
    public MessageSource&lt;?&gt; jpaInbound() {
        return new JpaPollingChannelAdapter(jpaExecutor());
    }

    @Bean
    @ServiceActivator(inputChannel = "jpaInputChannel")
    public MessageHandler handler() {
        return message -&gt; System.out.println(message.getPayload());
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-14"><a class="anchor" href="#configuring-with-the-java-dsl-14"></a>22.5.3. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Bean
    public IntegrationFlow pollingAdapterFlow() {
        return IntegrationFlows
            .from(Jpa.inboundAdapter(this.entityManagerFactory)
                        .entityClass(StudentDomain.class)
                        .maxResults(1)
                        .expectSingleResult(true),
                e -&gt; e.poller(p -&gt; p.trigger(new OnlyOnceTrigger())))
            .channel(c -&gt; c.queue("pollingResults"))
            .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa-outbound-channel-adapter"><a class="anchor" href="#jpa-outbound-channel-adapter"></a>22.6. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The JPA outbound channel adapter lets you accept messages over a request channel.
The payload can either be used as the entity to be persisted or used with the headers in the parameter expressions for a JPQL query.
The following sections cover the possible ways of performing these operations.</p>
</div>
<div class="sect3">
<h4 id="jpa-outbound-channel-adapter-entity-class"><a class="anchor" href="#jpa-outbound-channel-adapter-entity-class"></a>22.6.1. Using an Entity Class</h4>
<div class="paragraph">
<p>The following XML configures the outbound channel adapter to persist an entity to the database:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter channel="entityTypeChannel"               <i class="conum" data-value="1"></i><b>(1)</b>
    entity-class="org.springframework.integration.jpa.test.entity.Student"  <i class="conum" data-value="2"></i><b>(2)</b>
    persist-mode="PERSIST"                                                  <i class="conum" data-value="3"></i><b>(3)</b>
    entity-manager="em"/ &gt;                                                  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The channel over which a valid JPA entity is sent to the JPA outbound channel adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The fully qualified name of the entity class accepted by the adapter to be persisted in the database.
You can actually leave off this attribute in most cases as the adapter can determine the entity class automatically from the Spring Integration message payload.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The operation to be done by the adapter.
The valid values are <code>PERSIST</code>, <code>MERGE</code>, and <code>DELETE</code>.
The default value is <code>MERGE</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The JPA entity manager to be used.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>These four attributes of the <code>outbound-channel-adapter</code> configure it to accept entities over the input channel and process them to <code>PERSIST</code>, <code>MERGE</code>, or <code>DELETE</code> the entities from the underlying data source.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring Integration 3.0, payloads to <code>PERSIST</code> or <code>MERGE</code> can also be of type <code><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html">java.lang.Iterable</a></code>.
In that case, each object returned by the <code>Iterable</code> is treated as an entity and persisted or merged using the underlying <code>EntityManager</code>.
Null values returned by the iterator are ignored.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa-using-jpaql"><a class="anchor" href="#jpa-using-jpaql"></a>22.6.2. Using JPA Query Language (JPA QL)</h4>
<div class="paragraph">
<p>The <a href="#jpa-outbound-channel-adapter-entity-class">previous section</a> showed how to perform a <code>PERSIST</code> action by using an entity.
This section shows how to use an outbound channel adapter with JPA QL.</p>
</div>
<div class="paragraph">
<p>The following XML configures the outbound channel adapter to persist an entity to the database:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter channel="jpaQlChannel"                                      <i class="conum" data-value="1"></i><b>(1)</b>
  jpa-query="update Student s set s.firstName = :firstName where s.rollNumber = :rollNumber"  <i class="conum" data-value="2"></i><b>(2)</b>
  entity-manager="em"&gt;                                                                        <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;int-jpa:parameter name="firstName"  expression="payload['firstName']"/&gt;                  <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;int-jpa:parameter name="rollNumber" expression="payload['rollNumber']"/&gt;
&lt;/int-jpa:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The input channel over which the message is sent to the outbound channel adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The JPA QL to execute.
This query may contain parameters that are evaluated by using the <code>parameter</code> element.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The entity manager used by the adapter to perform the JPA operations.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The elements (one for each parameter) used to define the value of the parameter names for the JPA QL specified in the <code>query</code> attribute.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>parameter</code> element accepts an attribute whose <code>name</code> corresponds to the named parameter specified in the provided JPA QL (point 2 in the preceding example).
The value of the parameter can either be static or be derived by using an expression.
The static value and the expression to derive the value are specified using the <code>value</code> and <code>expression</code> attributes, respectively.
These attributes are mutually exclusive.</p>
</div>
<div class="paragraph">
<p>If the <code>value</code> attribute is specified, you can provide an optional <code>type</code> attribute.
The value of this attribute is the fully qualified name of the class whose value is represented by the <code>value</code> attribute.
By default, the type is assumed to be a <code>java.lang.String</code>.
The following example shows how to define a JPA parameter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter ...
&gt;
    &lt;int-jpa:parameter name="level" value="2" type="java.lang.Integer"/&gt;
    &lt;int-jpa:parameter name="name" expression="payload['name']"/&gt;
&lt;/int-jpa:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding example shows, you can use multiple <code>parameter</code> elements within an outbound channel adapter element and define some parameters by using expressions and others with static values.
However, take care not to specify the same parameter name multiple times.
You should provide one <code>parameter</code> element for each named parameter specified in the JPA query.
For example, we specify two parameters: <code>level</code> and <code>name</code>.
The <code>level</code> attribute is a static value of type <code>java.lang.Integer</code>, while the <code>name</code> attribute is derived from the payload of the message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Though specifying <code>select</code> is valid for JPA QL, it makes no sense to do so.
Outbound channel adapters do not return any result.
If you want to select some values, consider using the outbound gateway instead.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa-using-native-queries"><a class="anchor" href="#jpa-using-native-queries"></a>22.6.3. Using Native Queries</h4>
<div class="paragraph">
<p>This section describes how to use native queries to perform operations with the JPA outbound channel adapter.
Using native queries is similar to using JPA QL, except that the queries are native database queries.
By using native queries, we lose database vendor independence, which we get using JPA QL.</p>
</div>
<div class="paragraph">
<p>One of the things we can achieve by using native queries is to perform database inserts, which is not possible with JPA QL.
(To perform inserts, we send JPA entities to the channel adapter, as <a href="#jpa-outbound-channel-adapter-entity-class">described earlier</a>).
Below is a small xml fragment that demonstrates the use of native query to insert values in a table.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Named parameters may not be supported by your JPA provider in conjunction with native SQL queries.
While they work fine with Hibernate, OpenJPA and EclipseLink do not support them.
See <a href="https://issues.apache.org/jira/browse/OPENJPA-111" class="bare">issues.apache.org/jira/browse/OPENJPA-111</a>.
Section 3.8.12 of the JPA 2.0 spec states: &#8220;Only positional parameter binding and positional access to result items may be portably used for native queries.&#8221;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example configures an outbound-channel-adapter with a native query:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter channel="nativeQlChannel"
  native-query="insert into STUDENT_TABLE(FIRST_NAME,LAST_UPDATED) values (:lastName,:lastUpdated)"  <i class="conum" data-value="1"></i><b>(1)</b>
  entity-manager="em"&gt;
    &lt;int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/&gt;
    &lt;int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/&gt;
&lt;/int-jpa:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The native query executed by this outbound channel adapter.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that the other attributes (such as <code>channel</code> and <code>entity-manager</code>) and the <code>parameter</code> element have the same semantics as they do for JPA QL.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-named-queries"><a class="anchor" href="#using-named-queries"></a>22.6.4. Using Named Queries</h4>
<div class="paragraph">
<p>Using named queries is similar to using <a href="#jpa-using-jpaql">JPA QL</a> or a <a href="#jpa-using-native-queries">native query</a>, except that we specify a named query instead of a query.
First, we cover how to define a JPA named query.
Then we cover how to declare an outbound channel adapter to work with a named query.
If we have an entity called <code>Student</code>, we can use annotations on the <code>Student</code> class to define two named queries: <code>selectStudent</code> and <code>updateStudent</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
@Table(name="Student")
@NamedQueries({
    @NamedQuery(name="selectStudent",
        query="select s from Student s where s.lastName = 'Last One'"),
    @NamedQuery(name="updateStudent",
        query="update Student s set s.lastName = :lastName,
               lastUpdated = :lastUpdated where s.id in (select max(a.id) from Student a)")
})
public class Student {

...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use orm.xml to define named queries as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;entity-mappings ...&gt;
    ...
    &lt;named-query name="selectStudent"&gt;
        &lt;query&gt;select s from Student s where s.lastName = 'Last One'&lt;/query&gt;
    &lt;/named-query&gt;
&lt;/entity-mappings&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have shown how to define named queries by using annotations or by using <code>orm.xml</code>, we now show a small XML fragment that defines an <code>outbound-channel-adapter</code> by using a named query, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter channel="namedQueryChannel"
            named-query="updateStudent"	 <i class="conum" data-value="1"></i><b>(1)</b>
            entity-manager="em"&gt;
        &lt;int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/&gt;
        &lt;int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/&gt;
&lt;/int-jpa:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The named query that we want the adapter to execute when it receives a message over the channel.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpaOutboundChannelAdapterParameters"><a class="anchor" href="#jpaOutboundChannelAdapterParameters"></a>22.6.5. Configuration Parameter Reference</h4>
<div class="paragraph">
<p>The following listing shows all the attributes that you can set on an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:outbound-channel-adapter
  auto-startup="true"  <i class="conum" data-value="1"></i><b>(1)</b>
  channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
  entity-class=""  <i class="conum" data-value="3"></i><b>(3)</b>
  entity-manager=""  <i class="conum" data-value="4"></i><b>(4)</b>
  entity-manager-factory=""  <i class="conum" data-value="5"></i><b>(5)</b>
  id=""
  jpa-operations=""  <i class="conum" data-value="6"></i><b>(6)</b>
  jpa-query=""  <i class="conum" data-value="7"></i><b>(7)</b>
  named-query=""  <i class="conum" data-value="8"></i><b>(8)</b>
  native-query=""  <i class="conum" data-value="9"></i><b>(9)</b>
  order=""  <i class="conum" data-value="10"></i><b>(10)</b>
  parameter-source-factory=""   <i class="conum" data-value="11"></i><b>(11)</b>
  persist-mode="MERGE"   <i class="conum" data-value="12"></i><b>(12)</b>
  flush="true"   <i class="conum" data-value="13"></i><b>(13)</b>
  flush-size="10"   <i class="conum" data-value="14"></i><b>(14)</b>
  clear-on-flush="true"   <i class="conum" data-value="15"></i><b>(15)</b>
  use-payload-as-parameter-source="true"   <i class="conum" data-value="16"></i><b>(16)</b>
	&lt;int:poller/&gt;
	&lt;int-jpa:transactional/&gt;    <i class="conum" data-value="17"></i><b>(17)</b>
	&lt;int-jpa:parameter/&gt;    <i class="conum" data-value="18"></i><b>(18)</b>
&lt;/int-jpa:outbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lifecycle attribute signaling whether this component should start during application context startup.
It defaults to <code>true</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The channel from which the outbound adapter receives messages for performing the desired operation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The fully qualified name of the entity class for the JPA Operation.
The <code>entity-class</code>, <code>query</code>, and <code>named-query</code> attributes are mutually exclusive.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>An instance of <code>javax.persistence.EntityManager</code> used to perform the JPA operations.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>An instance of <code>javax.persistence.EntityManagerFactory</code> used to obtain an instance of <code>javax.persistence.EntityManager</code>, which performs the JPA operations.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>An implementation of <code>org.springframework.integration.jpa.core.JpaOperations</code> used to perform the JPA operations.
We recommend not providing an implementation of your own but using the default <code>org.springframework.integration.jpa.core.DefaultJpaOperations</code> implementation.
You can use any one of the <code>entity-manager</code>, <code>entity-manager-factory</code>, or <code>jpa-operations</code> attributes.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The JPA QL to be executed by this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The named query that needs to be executed by this adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The native query to be executed by this adapter.
You can use any one of the <code>jpa-query</code>, <code>named-query</code>, or <code>native-query</code> attributes.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The order for this consumer when multiple consumers are registered, thereby managing load-balancing and failover.
It defaults to <code>Ordered.LOWEST_PRECEDENCE</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>An instance of <code>o.s.i.jpa.support.parametersource.ParameterSourceFactory</code> used to get an instance of <code>o.s.i.jpa.support.parametersource.ParameterSource</code>, which is used to resolve the values of the parameters in the query.
Ignored if you perform operations by using a JPA entity.
The <code>parameter</code> sub-elements are mutually exclusive with the <code>parameter-source-factory</code> attribute and must be configured on the provided <code>ParameterSourceFactory</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Accepts one of the following: <code>PERSIST</code>, <code>MERGE</code>, or <code>DELETE</code>.
Indicates the operation that the adapter needs to perform.
Relevant only if you use an entity for JPA operations.
Ignored if you provide JPA QL, a named query, or a native query.
It defaults to <code>MERGE</code>.
Optional.
As of Spring Integration 3.0, payloads to persist or merge can also be of type <code><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html">java.lang.Iterable</a></code>.
In that case, each object returned by the <code>Iterable</code> is treated as an entity and persisted or merged by using the underlying <code>EntityManager</code>.
Null values returned by the iterator are ignored.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Set this value to <code>true</code> if you want to flush the persistence context immediately after persist, merge, or delete operations and do not want to rely on the <code>flushMode</code> of the <code>EntityManager</code>.
It defaults to <code>false</code>.
Applies only if you did not specify the <code>flush-size</code> attribute.
If this attribute is set to <code>true</code>, <code>flush-size</code> is implicitly set to <code>1</code>, if no other value configured it.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>Set this attribute to a value greater than '0' if you want to flush the persistence context immediately after persist, merge or delete operations and do not want to rely on the the <code>flushMode</code> of the <code>EntityManager</code>.
The default value is set to <code>0</code>, which means "'no flush'".
This attribute is geared towards messages with <code>Iterable</code> payloads.
For instance, if <code>flush-size</code> is set to <code>3</code>, then <code>entityManager.flush()</code> is called after every third entity.
Furthermore, <code>entityManager.flush()</code> is called once more after the entire loop.
If the 'flush-size' attribute is specified with a value greater than '0', you need not configure the <code>flush</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>Set this value to 'true' if you want to clear the persistence context immediately after each flush operation.
The attribute&#8217;s value is applied only if the <code>flush</code> attribute is set to <code>true</code> or if the <code>flush-size</code> attribute is set to a value greater than <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>If set to <code>true</code>, the payload of the message is used as a source for parameters.
If set to <code>false</code>, however, the entire <code>Message</code> is available as a source for parameters.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>Defines the transaction management attributes and the reference to the transaction manager to be used by the JPA adapter.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>One or more <code>parameter</code> attributes&#8201;&#8212;&#8201;one for each parameter used in the query.
The value or expression is evaluated to compute the value of the parameter.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-14"><a class="anchor" href="#configuring-with-java-configuration-14"></a>22.6.6. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
@IntegrationComponentScan
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @MessagingGateway
    interface JpaGateway {

       @Gateway(requestChannel = "jpaPersistChannel")
       @Transactional
       void persistStudent(StudentDomain payload);

    }

    @Bean
    public JpaExecutor jpaExecutor() {
        JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);
        jpaExecutor.setEntityClass(StudentDomain.class);
        jpaExecutor.setPersistMode(PersistMode.PERSIST);
        return executor;
    }

    @Bean
    @ServiceActivator(channel = "jpaPersistChannel")
    public MessageHandler jpaOutbound() {
        JpaOutboundGateway adapter = new JpaOutboundGateway(jpaExecutor());
        adapter.setProducesReply(false);
        return adapter;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-15"><a class="anchor" href="#configuring-with-the-java-dsl-15"></a>22.6.7. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Bean
    public IntegrationFlow outboundAdapterFlow() {
        return f -&gt; f
                .handle(Jpa.outboundAdapter(this.entityManagerFactory)
                                .entityClass(StudentDomain.class)
                                .persistMode(PersistMode.PERSIST),
                        e -&gt; e.transactional());
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa-outbound-gateways"><a class="anchor" href="#jpa-outbound-gateways"></a>22.7. Outbound Gateways</h3>
<div class="paragraph">
<p>The JPA inbound channel adapter lets you poll a database to retrieve one or more JPA entities.
The retrieved data is consequently used to start a Spring Integration flow that uses the retrieved data as message payload.</p>
</div>
<div class="paragraph">
<p>Additionally, you can use JPA outbound channel adapters at the end of your flow in order to persist data, essentially terminating the flow at the end of the persistence operation.</p>
</div>
<div class="paragraph">
<p>However, how can you execute JPA persistence operations in the middle of a flow? For example, you may have business data that you are processing in your Spring Integration message flow and that you would like to persist, yet you still need to use other components further downstream.
Alternatively, instead of polling the database using a poller, you need to execute JPQL queries and actively retrieve data, which is then processed in subsequent components within your flow.</p>
</div>
<div class="paragraph">
<p>This is where JPA Outbound Gateways come into play.
They give you the ability to persist data as well as retrieving data.
To facilitate these uses, Spring Integration provides two types of JPA outbound gateways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Updating outbound gateway</p>
</li>
<li>
<p>Retrieving outbound gateway</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whenever the outbound gateway is used to perform an action that saves, updates, or solely deletes some records in the database, you need to use an updating outbound gateway.
If, for example, you use an <code>entity</code> to persist it, a merged and persisted entity is returned as a result.
In other cases, the number of records affected (updated or deleted) is returned instead.</p>
</div>
<div class="paragraph">
<p>When retrieving (selecting) data from the database, we use a retrieving outbound gateway.
With a retrieving outbound gateway, we can use JPQL, Named Queries (native or JPQL-based), or Native Queries (SQL) for selecting the data and retrieving the results.</p>
</div>
<div class="paragraph">
<p>An updating outbound gateway is functionally similar to an outbound channel adapter, except that an updating outbound gateway sends a result to the gateway&#8217;s reply channel after performing the JPA operation.</p>
</div>
<div class="paragraph">
<p>A retrieving outbound gateway is similar to an inbound channel adapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We recommend you first read the <a href="#jpa-outbound-channel-adapter">Outbound Channel Adapter</a> section and the <a href="#jpa-inbound-channel-adapter">Inbound Channel Adapter</a> sections earlier in this chapter, as most of the common concepts are explained there.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This similarity was the main factor to use the central <code>JpaExecutor</code> class to unify common functionality as much as possible.</p>
</div>
<div class="paragraph">
<p>Common for all JPA outbound gateways and similar to the <code>outbound-channel-adapter</code>, we can use for performing various JPA operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Entity classes</p>
</li>
<li>
<p>JPA Query Language (JPQL)</p>
</li>
<li>
<p>Native query</p>
</li>
<li>
<p>Named query</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For configuration examples see <a href="#outboundGatewaySamples">JPA Outbound Gateway Samples</a>.</p>
</div>
<div class="sect3">
<h4 id="jpa-outbound-gateway-common-parameters"><a class="anchor" href="#jpa-outbound-gateway-common-parameters"></a>22.7.1. Common Configuration Parameters</h4>
<div class="paragraph">
<p>JPA Outbound Gateways always have access to the Spring Integration <code>Message</code> as input.
Consequently, the following parameters is available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>parameter-source-factory</code></dt>
<dd>
<p>An instance of <code>o.s.i.jpa.support.parametersource.ParameterSourceFactory</code> used to get an instance of <code>o.s.i.jpa.support.parametersource.ParameterSource</code>.
The <code>ParameterSource</code> is used to resolve the values of the parameters provided in the query.
If you perform operations by using a JPA entity, the <code>parameter-source-factory</code> attribute is ignored.
The <code>parameter</code> sub-elements are mutually exclusive with the <code>parameter-source-factory</code> and they have to be configured on the provided <code>ParameterSourceFactory</code>.
Optional.</p>
</dd>
<dt class="hdlist1"><code>use-payload-as-parameter-source</code></dt>
<dd>
<p>If set to <code>true</code>, the payload of the <code>Message</code> is used as a source for parameters.
If set to <code>false</code>, the entire <code>Message</code> is available as a source for parameters.
If no JPA Parameters are passed in, this property defaults to <code>true</code>.
This means that, if you use a default <code>BeanPropertyParameterSourceFactory</code>, the bean properties of the payload are used as a source for parameter values for the JPA query.
However, if JPA Parameters are passed in, this property, by default, evaluates to <code>false</code>.
The reason is that JPA Parameters let you provide SpEL Expressions.
Therefore, it is highly beneficial to have access to the entire <code>Message</code>, including the headers.
Optional.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="jpa-updating-outbound-gateway"><a class="anchor" href="#jpa-updating-outbound-gateway"></a>22.7.2. Updating Outbound Gateway</h4>
<div class="paragraph">
<p>The following listing shows all the attributes that you can set on an updating-outbound-gateway and describes the key attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:updating-outbound-gateway request-channel=""  <i class="conum" data-value="1"></i><b>(1)</b>
    auto-startup="true"
    entity-class=""
    entity-manager=""
    entity-manager-factory=""
    id=""
    jpa-operations=""
    jpa-query=""
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    persist-mode="MERGE"
    reply-channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
    reply-timeout=""  <i class="conum" data-value="3"></i><b>(3)</b>
    use-payload-as-parameter-source="true"&gt;

    &lt;int:poller/&gt;
    &lt;int-jpa:transactional/&gt;

    &lt;int-jpa:parameter name="" type="" value=""/&gt;
    &lt;int-jpa:parameter name="" expression=""/&gt;
&lt;/int-jpa:updating-outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The channel from which the outbound gateway receives messages for performing the desired operation.
This attribute is similar to the <code>channel</code> attribute of the <code>outbound-channel-adapter</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The channel to which the gateway send the response after performing the required JPA operation.
If this attribute is not defined, the request message must have a <code>replyChannel</code> header.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specifies the time the gateway waits to send the result to the reply channel.
Only applies when the reply channel itself might block the send operation (for example, a bounded <code>QueueChannel</code> that is currently full).
By default, the gateway waits indefinitely.
The value is specified in milliseconds.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The remaining attributes are described earlier in this chapter.
See <a href="#jpaInboundChannelAdapterParameters">Configuration Parameter Reference</a> and <a href="#jpaOutboundChannelAdapterParameters">Configuration Parameter Reference</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-15"><a class="anchor" href="#configuring-with-java-configuration-15"></a>22.7.3. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how configure the outbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
@IntegrationComponentScan
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @MessagingGateway
    interface JpaGateway {

       @Gateway(requestChannel = "jpaUpdateChannel")
       @Transactional
       void updateStudent(StudentDomain payload);

    }

    @Bean
    @ServiceActivator(channel = "jpaUpdateChannel")
    public MessageHandler jpaOutbound() {
        JpaOutboundGateway adapter =
               new JpaOutboundGateway(new JpaExecutor(this.entityManagerFactory));
        adapter.setOutputChannelName("updateResults");
        return adapter;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-16"><a class="anchor" href="#configuring-with-the-java-dsl-16"></a>22.7.4. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter using the Java DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Bean
    public IntegrationFlow updatingGatewayFlow() {
        return f -&gt; f
                .handle(Jpa.updatingGateway(this.entityManagerFactory),
                        e -&gt; e.transactional(true))
                .channel(c -&gt; c.queue("updateResults"));
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa-retrieving-outbound-gateway"><a class="anchor" href="#jpa-retrieving-outbound-gateway"></a>22.7.5. Retrieving Outbound Gateway</h4>
<div class="paragraph">
<p>The following example shows all the attributes that you can set on a retrieving outbound gateway and describes the key attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:retrieving-outbound-gateway request-channel=""
    auto-startup="true"
    delete-after-poll="false"
    delete-in-batch="false"
    entity-class=""
    id-expression=""              <i class="conum" data-value="1"></i><b>(1)</b>
    entity-manager=""
    entity-manager-factory=""
    expect-single-result="false"  <i class="conum" data-value="2"></i><b>(2)</b>
    id=""
    jpa-operations=""
    jpa-query=""
    max-results=""                <i class="conum" data-value="3"></i><b>(3)</b>
    max-results-expression=""     <i class="conum" data-value="4"></i><b>(4)</b>
    first-result=""               <i class="conum" data-value="5"></i><b>(5)</b>
    first-result-expression=""    <i class="conum" data-value="6"></i><b>(6)</b>
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    reply-channel=""
    reply-timeout=""
    use-payload-as-parameter-source="true"&gt;
    &lt;int:poller&gt;&lt;/int:poller&gt;
    &lt;int-jpa:transactional/&gt;

    &lt;int-jpa:parameter name="" type="" value=""/&gt;
    &lt;int-jpa:parameter name="" expression=""/&gt;
&lt;/int-jpa:retrieving-outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(Since Spring Integration 4.0) The SpEL expression that determines the <code>primaryKey</code> value for <code>EntityManager.find(Class entityClass, Object primaryKey)</code> method against the <code>requestMessage</code> as the root object of evaluation context.
The <code>entityClass</code> argument is determined from the <code>entity-class</code> attribute, if present.
Otherwise, it is determined from the <code>payload</code> class.
All other attributes are disallowed if you use <code>id-expression</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A boolean flag indicating whether the select operation is expected to return a single result or a <code>List</code> of results.
If this flag is set to <code>true</code>, a single entity is sent as the payload of the message.
If multiple entities are returned, an exception is thrown.
If <code>false</code>, the <code>List</code> of entities is sent as the payload of the message.
It defaults to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This non-zero, non-negative integer value tells the adapter not to select more than the specified number of rows on execution of the select operation.
By default, if this attribute is not set, all the possible records are selected by given query.
This attribute is mutually exclusive with <code>max-results-expression</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>An expression that can be used to find the maximum number of results in a result set.
It is mutually exclusive with <code>max-results</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This non-zero, non-negative integer value tells the adapter the first record from which results are to be retrieved.
This attribute is mutually exclusive with <code>first-result-expression</code>.
Version 3.0 introduced this attribute.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This expression is evaluated against the message, to find the position of the first record in the result set.
This attribute is mutually exclusive to <code>first-result</code>.
Version 3.0 introduced this attribute.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The remaining attributes are described earlier in this chapter.
See <a href="#jpaInboundChannelAdapterParameters">Configuration Parameter Reference</a> and <a href="#jpaOutboundChannelAdapterParameters">Configuration Parameter Reference</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-16"><a class="anchor" href="#configuring-with-java-configuration-16"></a>22.7.6. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how configure the outbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;


    @Bean
    public JpaExecutor jpaExecutor() {
        JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);
        jpaExecutor.setJpaQuery("from Student s where s.id = :id");
        executor.setJpaParameters(Collections.singletonList(new JpaParameter("id", null, "payload")));
        jpaExecutor.setExpectSingleResult(true);
        return executor;
    }

    @Bean
    @ServiceActivator(channel = "jpaRetrievingChannel")
    public MessageHandler jpaOutbound() {
        JpaOutboundGateway adapter = new JpaOutboundGateway(jpaExecutor());
        adapter.setOutputChannelName("retrieveResults");
        adapter.setGatewayType(OutboundGatewayType.RETRIEVING);
        return adapter;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-17"><a class="anchor" href="#configuring-with-the-java-dsl-17"></a>22.7.7. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EntityScan(basePackageClasses = StudentDomain.class)
public class JpaJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(JpaJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    @Bean
    public IntegrationFlow retrievingGatewayFlow() {
        return f -&gt; f
                .handle(Jpa.retrievingGateway(this.entityManagerFactory)
                       .jpaQuery("from Student s where s.id = :id")
                       .expectSingleResult(true)
                       .parameterExpression("id", "payload"))
                .channel(c -&gt; c.queue("retrieveResults"));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you choose to delete entities upon retrieval and you have retrieved a collection of entities, by default, entities are deleted on a per-entity basis.
This may cause performance issues.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can set attribute <code>deleteInBatch</code> to <code>true</code>, which performs a batch delete.
However, the limitation of doing so is that cascading deletes are not supported.</p>
</div>
<div class="paragraph">
<p>JSR 317: Java Persistence 2.0 states in chapter 4.10, &#8220;Bulk Update and Delete Operations&#8221; that:</p>
</div>
<div class="paragraph">
<p>&#8220;A delete operation only applies to entities of the specified class and its subclasses.
It does not cascade to related entities.&#8221;</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://jcp.org/en/jsr/detail?id=317">JSR 317: Java Persistence 2.0</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="outboundGatewaySamples"><a class="anchor" href="#outboundGatewaySamples"></a>22.7.8. JPA Outbound Gateway Samples</h4>
<div class="paragraph">
<p>This section contains various examples of using the updating outbound gateway and the retrieving outbound gateway:</p>
</div>
<div class="sect4">
<h5 id="update-by-using-an-entity-class"><a class="anchor" href="#update-by-using-an-entity-class"></a>Update by Using an Entity Class</h5>
<div class="paragraph">
<p>In the following example, an updating outbound gateway is persisted by using the <code>org.springframework.integration.jpa.test.entity.Student</code> entity class as a JPA defining parameter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:updating-outbound-gateway request-channel="entityRequestChannel"  <i class="conum" data-value="1"></i><b>(1)</b>
    reply-channel="entityResponseChannel"  <i class="conum" data-value="2"></i><b>(2)</b>
    entity-class="org.springframework.integration.jpa.test.entity.Student"
    entity-manager="em"/&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the request channel for the outbound gateway.
It is similar to the <code>channel</code> attribute of the <code>outbound-channel-adapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is where a gateway differs from an outbound adapter.
This is the channel over which the reply from the JPA operation is received.
If, however, you are not interested in the reply received and want only to perform the operation, using a JPA <code>outbound-channel-adapter</code> is the appropriate choice.
In this example, where we use an entity class, the reply is the entity object that was created or merged as a result of the JPA operation.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="update-using-jpql"><a class="anchor" href="#update-using-jpql"></a>Update using JPQL</h5>
<div class="paragraph">
<p>The following example updates an entity by using the Java Persistence Query Language (JPQL),
which mandates using an updating outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:updating-outbound-gateway request-channel="jpaqlRequestChannel"
  reply-channel="jpaqlResponseChannel"
  jpa-query="update Student s set s.lastName = :lastName where s.rollNumber = :rollNumber"  <i class="conum" data-value="1"></i><b>(1)</b>
  entity-manager="em"&gt;
    &lt;int-jpa:parameter name="lastName" expression="payload"/&gt;
    &lt;int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/&gt;
&lt;/int-jpa:updating-outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The JPQL query that the gateway executes.
Since we used updating outbound gateway, only <code>update</code> and <code>delete</code> JPQL queries would be sensible choices.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>When you send a message with a <code>String</code> payload that also contains a header called <code>rollNumber</code> with a <code>long</code> value, the last name of the student with the specified roll number is updated to the value in the message payload.
When using an updating gateway, the return value is always an integer value, which denotes the number of records affected by execution of the JPA QL.</p>
</div>
</div>
<div class="sect4">
<h5 id="retrieving-an-entity-using-jpql"><a class="anchor" href="#retrieving-an-entity-using-jpql"></a>Retrieving an Entity using JPQL</h5>
<div class="paragraph">
<p>The following example uses a retrieving outbound gateway and JPQL to retrieve (select) one or more entities from the database:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:retrieving-outbound-gateway request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    jpa-query="select s from Student s where s.firstName = :firstName and s.lastName = :lastName"
    entity-manager="em"&gt;
    &lt;int-jpa:parameter name="firstName" expression="payload"/&gt;
    &lt;int-jpa:parameter name="lastName" expression="headers['lastName']"/&gt;
&lt;/int-jpa:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="retrieving-an-entity-by-using-id-expression"><a class="anchor" href="#retrieving-an-entity-by-using-id-expression"></a>Retrieving an Entity by Using <code>id-expression</code></h5>
<div class="paragraph">
<p>The following example uses a retrieving outbound gateway with <code>id-expression</code> to retrieve (find) one and only one entity from the database:
The <code>primaryKey</code> is the result of <code>id-expression</code> evaluation.
The <code>entityClass</code> is a class of Message <code>payload</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:retrieving-outbound-gateway
	request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    id-expression="payload.id"
    entity-manager="em"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="update-using-a-named-query"><a class="anchor" href="#update-using-a-named-query"></a>Update using a Named Query</h5>
<div class="paragraph">
<p>Using a named query is basically the same as using a JPQL query directly.
The difference is that the <code>named-query</code> attribute is used instead, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jpa:updating-outbound-gateway request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em"&gt;
    &lt;int-jpa:parameter name="lastName" expression="payload"/&gt;
    &lt;int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/&gt;
&lt;/int-jpa:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can find a complete sample application that uses Spring Integration&#8217;s JPA adapter <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/basic/jpa">here</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jms"><a class="anchor" href="#jms"></a>23. JMS Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for receiving and sending JMS messages.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-jms&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-jms:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>javax.jms:javax.jms-api</code> must be added explicitly via some JMS vendor-specific implementation, e.g. Apache ActiveMQ.</p>
</div>
<div class="paragraph">
<p>There are actually two JMS-based inbound Channel Adapters.
The first uses Spring&#8217;s <code>JmsTemplate</code> to receive based on a polling period.
The second is &#8220;message-driven&#8221; and relies on a Spring <code>MessageListener</code> container.
The outbound channel adapter uses the <code>JmsTemplate</code> to convert and send a JMS message on demand.</p>
</div>
<div class="paragraph">
<p>By using <code>JmsTemplate</code> and the <code>MessageListener</code> container, Spring Integration relies on Spring&#8217;s JMS support.
This is important to understand, since most of the attributes exposed on these adapters configure the underlying <code>JmsTemplate</code> and <code>MessageListener</code> container.
For more details about <code>JmsTemplate</code> and the <code>MessageListener</code> container, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jms.html">Spring JMS documentation</a>.</p>
</div>
<div class="paragraph">
<p>Whereas the JMS channel adapters are intended for unidirectional messaging (send-only or receive-only), Spring Integration also provides inbound and outbound JMS Gateways for request and reply operations.
The inbound gateway relies on one of Spring&#8217;s <code>MessageListener</code> container implementations for message-driven reception.
It is also capable of sending a return value to the <code>reply-to</code> destination, as provided by the received message.
The outbound gateway sends a JMS message to a <code>request-destination</code> (or <code>request-destination-name</code> or <code>request-destination-expression</code>) and then receives a reply message.
You can explicitly configure the <code>reply-destination</code> reference (or <code>reply-destination-name</code> or <code>reply-destination-expression</code>).
Otherwise, the outbound gateway uses a JMS <a href="https://docs.oracle.com/javaee/6/api/javax/jms/TemporaryQueue.html">TemporaryQueue</a>.</p>
</div>
<div class="paragraph">
<p>Prior to Spring Integration 2.2, if necessary, a <code>TemporaryQueue</code> was created (and removed) for each request or reply.
Beginning with Spring Integration 2.2, you can configure the outbound gateway to use a <code>MessageListener</code> container to receive replies instead of directly using a new (or cached) <code>Consumer</code> to receive the reply for each request.
When so configured, and no explicit reply destination is provided, a single <code>TemporaryQueue</code> is used for each gateway instead of one for each request.</p>
</div>
<div class="sect2">
<h3 id="jms-inbound-channel-adapter"><a class="anchor" href="#jms-inbound-channel-adapter"></a>23.1. Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The inbound channel adapter requires a reference to either a single <code>JmsTemplate</code> instance or both a <code>ConnectionFactory</code> and a <code>Destination</code> (you can provide a 'destinationName' in place of the 'destination' reference).
The following example defines an inbound channel adapter with a <code>Destination</code> reference:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:inbound-channel-adapter id="jmsIn" destination="inQueue" channel="exampleChannel"&gt;
    &lt;int:poller fixed-rate="30000"/&gt;
&lt;/int-jms:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Notice from the preceding configuration that the <code>inbound-channel-adapter</code> is a polling consumer.
That means that it invokes <code>receive()</code> when triggered.
You should use this should only in situations where polling is done relatively infrequently and timeliness is not important.
For all other situations (a vast majority of JMS-based use-cases), the <code>message-driven-channel-adapter</code> (<a href="#jms-message-driven-channel-adapter">described later</a>) is a better option.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, all of the JMS adapters that require a reference to the <code>ConnectionFactory</code> automatically look for a bean named <code>jmsConnectionFactory</code>.
That is why you do not see a <code>connection-factory</code> attribute in many of the examples.
However, if your JMS <code>ConnectionFactory</code> has a different bean name, you need to provide that attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>extract-payload</code> is set to <code>true</code> (the default), the received JMS Message is passed through the <code>MessageConverter</code>.
When relying on the default <code>SimpleMessageConverter</code>, this means that the resulting Spring Integration Message has the JMS message&#8217;s body as its payload.
A JMS <code>TextMessage</code> produces a string-based payload, a JMS <code>BytesMessage</code> produces a byte array payload, and the serializable instance of a JMS <code>ObjectMessage</code> becomes the Spring Integration message&#8217;s payload.
If you prefer to have the raw JMS message as the Spring Integration message&#8217;s payload, set <code>extract-payload</code> to <code>false</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:inbound-channel-adapter id="jmsIn"
    destination="inQueue"
    channel="exampleChannel"
    extract-payload="false"/&gt;
    &lt;int:poller fixed-rate="30000"/&gt;
&lt;/int-jms:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0.8, a default value of the <code>receive-timeout</code> is <code>-1</code> (no wait) for the <code>org.springframework.jms.connection.CachingConnectionFactory</code> and <code>cacheConsumers</code>, otherwise it is 1 second.</p>
</div>
<div class="sect3">
<h4 id="jms-ib-transactions"><a class="anchor" href="#jms-ib-transactions"></a>23.1.1. Transactions</h4>
<div class="paragraph">
<p>Starting with version 4.0, the inbound channel adapter supports the <code>session-transacted</code> attribute.
In earlier versions, you had to inject a <code>JmsTemplate</code> with <code>sessionTransacted</code> set to <code>true</code>.
(The adapter did let you set the <code>acknowledge</code> attribute to <code>transacted</code>, but this was incorrect and did not work).</p>
</div>
<div class="paragraph">
<p>Note, however, that setting <code>session-transacted</code> to <code>true</code> has little value, because the transaction is committed
immediately after the <code>receive()</code> operation and before the message is sent to the <code>channel</code>.</p>
</div>
<div class="paragraph">
<p>If you want the entire flow to be transactional (for example, if there is a downstream outbound channel adapter), you must use a <code>transactional</code> poller with a <code>JmsTransactionManager</code>.
Alternatively, consider using a <code>jms-message-driven-channel-adapter</code> with <code>acknowledge</code> set to <code>transacted</code> (the default).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-message-driven-channel-adapter"><a class="anchor" href="#jms-message-driven-channel-adapter"></a>23.2. Message-driven Channel Adapter</h3>
<div class="paragraph">
<p>The <code>message-driven-channel-adapter</code> requires a reference to either an instance of a Spring <code>MessageListener</code> container (any subclass of <code>AbstractMessageListenerContainer</code>) or both <code>ConnectionFactory</code> and <code>Destination</code> (a 'destinationName' can be provided in place of the 'destination' reference).
The following example defines a message-driven channel adapter with a <code>Destination</code> reference:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:message-driven-channel-adapter id="jmsIn" destination="inQueue" channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The message-driven adapter also accepts several properties that pertain to the <code>MessageListener</code> container.
These values are considered only if you do not provide a <code>container</code> reference.
In that case, an instance of <code>DefaultMessageListenerContainer</code> is created and configured based on these properties.
For example, you can specify the <code>transaction-manager</code> reference, the <code>concurrent-consumers</code> value, and several other property references and values.
See the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> and Spring Integration&#8217;s JMS schema (<code>spring-integration-jms.xsd</code>) for more details.</p>
</div>
<div class="paragraph">
<p>If you have a custom listener container implementation (usually a subclass of <code>DefaultMessageListenerContainer</code>), you can either provide a reference to an instance of it by using the <code>container</code> attribute or provide its fully qualified class name by using the <code>container-class</code> attribute.
In that case, the attributes on the adapter are transferred to an instance of your custom container.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can&#8217;t use the Spring JMS namespace element <code>&lt;jms:listener-container/&gt;</code> to configure a container reference for the <code>&lt;int-jms:message-driven-channel-adapter&gt;</code> since that element doesn&#8217;t actually reference a container.
Each <code>&lt;jms:listener/&gt;</code> sub-element gets its own <code>DefaultMessageListenerContainer</code> (with shared attributes defined on the parent <code>&lt;jms:listener-container/&gt;</code> element).
You can give each listener sub-element an <code>id</code>, and use that to inject into the channel adapter, however, the <code>&lt;jms:/&gt;</code> namespace requires a real listener.
Since, for Spring Integration, the adapter itself needs to configure the listener, the configured listener will be overwritten.
If you go this route, you will see a warning for each adapter.</p>
</div>
<div class="paragraph">
<p>It is recommended to configure a regular <code>&lt;bean&gt;</code> for the <code>DefaultMessageListenerContainer</code> and use it as a reference in the channel adapter.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 4.2, the default <code>acknowledge</code> mode is <code>transacted</code>, unless you provide an external
container.
In that case, you should configure the container as needed.
We recommend using <code>transacted</code> with the <code>DefaultMessageListenerContainer</code> to avoid message loss.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The 'extract-payload' property has the same effect, and its default value is 'true'.
The <code>poller</code> element is not applicable for a message-driven channel adapter, as it is actively invoked.
For most scenarios, the message-driven approach is better, since the messages are passed along to the <code>MessageChannel</code> as soon as they are received from the underlying JMS consumer.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>&lt;message-driven-channel-adapter&gt;</code> element also accepts the 'error-channel' attribute.
This provides the same basic functionality, as described in <a href="#gateway-proxy">Enter the <code>GatewayProxyFactoryBean</code></a>.
The following example shows how to set an error channel on a message-driven channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:message-driven-channel-adapter id="jmsIn" destination="inQueue"
    channel="exampleChannel"
    error-channel="exampleErrorChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When comparing the preceding example to the generic gateway configuration or the JMS 'inbound-gateway' that we discuss later, the key difference is that we are in a one-way flow, since this is a 'channel-adapter', not a gateway.
Therefore, the flow downstream from the 'error-channel' should also be one-way.
For example, it could send to a logging handler or it could connect to a different JMS <code>&lt;outbound-channel-adapter&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>When consuming from topics, set the <code>pub-sub-domain</code> attribute to true.
Set <code>subscription-durable</code> to <code>true</code> for a durable subscription or <code>subscription-shared</code> for a shared subscription (which requires a JMS 2.0 broker and has been available since version 4.2).
Use <code>subscription-name</code> to name the subscription.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, when the endpoint is stopped while the application remains running, the underlying listener container is shut down, closing its shared connection and consumers.
Previously, the connection and consumers remained open.
To revert to the previous behavior, set the <code>shutdownContainerOnStop</code> on the <code>JmsMessageDrivenEndpoint</code> to <code>false</code>.</p>
</div>
<div class="sect3">
<h4 id="jms-md-conversion-errors"><a class="anchor" href="#jms-md-conversion-errors"></a>23.2.1. Inbound Conversion Errors</h4>
<div class="paragraph">
<p>Starting with version 4.2, the 'error-channel' is used for the conversion errors, too.
Previously, if a JMS <code>&lt;message-driven-channel-adapter/&gt;</code> or <code>&lt;inbound-gateway/&gt;</code> could not deliver a message due to a conversion error, an exception would be thrown back to the container.
If the container is configured to use transactions, the message is rolled back and redelivered repeatedly.
The conversion process occurs before and during message construction so that such errors are not sent to the 'error-channel'.
Now such conversion exceptions result in an <code>ErrorMessage</code> being sent to the 'error-channel', with the exception as the <code>payload</code>.
If you wish the transaction to roll back and you have an 'error-channel' defined, the integration flow on the 'error-channel' must re-throw the exception (or another exception).
If the error flow does not throw an exception, the transaction is committed and the message is removed.
If no 'error-channel' is defined, the exception is thrown back to the container, as before.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-outbound-channel-adapter"><a class="anchor" href="#jms-outbound-channel-adapter"></a>23.3. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The <code>JmsSendingMessageHandler</code> implements the <code>MessageHandler</code> interface and is capable of converting Spring Integration <code>Messages</code> to JMS messages and then sending to a JMS destination.
It requires either a <code>jmsTemplate</code> reference or both <code>jmsConnectionFactory</code> and <code>destination</code> references (<code>destinationName</code> may be provided in place of <code>destination</code>).
As with the inbound channel adapter, the easiest way to configure this adapter is with the namespace support.
The following configuration produces an adapter that receives Spring Integration messages from the <code>exampleChannel</code>, converts those into JMS messages, and sends them to the JMS destination reference whose bean name is <code>outQueue</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:outbound-channel-adapter id="jmsOut" destination="outQueue" channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As with the inbound channel adapters, there is an 'extract-payload' property.
However, the meaning is reversed for the outbound adapter.
Rather than applying to the JMS message, the boolean property applies to the Spring Integration message payload.
In other words, the decision is whether to pass the Spring Integration message itself as the JMS message body or to pass the Spring Integration message payload as the JMS message body.
The default value is 'true'.
Therefore, if you pass a Spring Integration message whose payload is a <code>String</code>, a JMS <code>TextMessage</code> is created.
If, on the other hand, you want to send the actual Spring Integration message to another system over JMS, set it to 'false'.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Regardless of the boolean value for payload extraction, the Spring Integration <code>MessageHeaders</code> map to JMS properties, as long as you rely on the default converter or provide a reference to another instance of <code>HeaderMappingMessageConverter</code>.
(The same holds true for 'inbound' adapters, except that, in those cases, the JMS properties map to Spring Integration <code>MessageHeaders</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>&lt;int-jms:outbound-channel-adapter&gt;</code> (<code>JmsSendingMessageHandler</code>) can be configured with the <code>deliveryModeExpression</code> and <code>timeToLiveExpression</code> properties to evaluate an appropriate QoS values for JMS message to send at runtime against request Spring <code>Message</code>.
The new <code>setMapInboundDeliveryMode(true)</code> and <code>setMapInboundExpiration(true)</code> options of the <code>DefaultJmsHeaderMapper</code> may facilitate as a source of the information for the dynamic <code>deliveryMode</code> and <code>timeToLive</code> from message headers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:outbound-channel-adapter delivery-mode-expression="headers.jms_deliveryMode"
                        time-to-live-expression="headers.jms_expiration - T(System).currentTimeMillis()"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-ob-transactions"><a class="anchor" href="#jms-ob-transactions"></a>23.3.1. Transactions</h4>
<div class="paragraph">
<p>Starting with version 4.0, the outbound channel adapter supports the <code>session-transacted</code> attribute.
In earlier versions, you had to inject a <code>JmsTemplate</code> with <code>sessionTransacted</code> set to <code>true</code>.
The attribute now sets the property on the built-in default <code>JmsTemplate</code>.
If a transaction exists (perhaps from an upstream <code>message-driven-channel-adapter</code>), the send operation is performed within the same transaction.
Otherwise, a new transaction is started.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-inbound-gateway"><a class="anchor" href="#jms-inbound-gateway"></a>23.4. Inbound Gateway</h3>
<div class="paragraph">
<p>Spring Integration&#8217;s message-driven JMS inbound-gateway delegates to a <code>MessageListener</code> container, supports dynamically adjusting concurrent consumers, and can also handle replies.
The inbound gateway requires references to a <code>ConnectionFactory</code> and a request <code>Destination</code> (or 'requestDestinationName').
The following example defines a JMS <code>inbound-gateway</code> that receives from the JMS queue referenced by the bean id, <code>inQueue</code>, and sends to the Spring Integration channel named <code>exampleChannel</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:inbound-gateway id="jmsInGateway"
    request-destination="inQueue"
    request-channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Since the gateways provide request-reply behavior instead of unidirectional send or receive behavior, they also have two distinct properties for &#8220;payload extraction&#8221; (as <a href="#jms-inbound-channel-adapter">discussed earlier</a> for the channel adapters' 'extract-payload' setting).
For an inbound gateway, the 'extract-request-payload' property determines whether the received JMS Message body is extracted.
If 'false', the JMS message itself becomes the Spring Integration message payload.
The default is 'true'.</p>
</div>
<div class="paragraph">
<p>Similarly, for an inbound-gateway, the 'extract-reply-payload' property applies to the Spring Integration message that is to be converted into a reply JMS Message.
If you want to pass the whole Spring Integration message (as the body of a JMS ObjectMessage), set value this to 'false'.
By default, it is also 'true' that the Spring Integration message payload is converted into a JMS Message (for example, a
<code>String</code> payload becomes a JMS TextMessage).</p>
</div>
<div class="paragraph">
<p>As with anything else, gateway invocation might result in error.
By default, a producer is not notified of the errors that might have occurred on the consumer side and times out waiting for the reply.
However, there might be times when you want to communicate an error condition back to the consumer (in other words, you might want to treat the exception as a valid reply by mapping it to a message).
To accomplish this, JMS inbound gateway provides support for a message channel to which errors can be sent for processing, potentially resulting in a reply message payload that conforms to some contract that defines what a caller may expect as an &#8220;error&#8221; reply.
You can use the error-channel attribute to configure such a channel, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:inbound-gateway request-destination="requestQueue"
          request-channel="jmsInputChannel"
          error-channel="errorTransformationChannel"/&gt;

&lt;int:transformer input-channel="exceptionTransformationChannel"
        ref="exceptionTransformer" method="createErrorResponse"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You might notice that this example looks very similar to that included within <a href="#gateway-proxy">Enter the <code>GatewayProxyFactoryBean</code></a>.
The same idea applies here: The <code>exceptionTransformer</code> could be a POJO that creates error-response objects, you could reference the <code>nullChannel</code> to suppress the errors, or you could leave 'error-channel' out to let the exception propagate.</p>
</div>
<div class="paragraph">
<p>See <a href="#jms-md-conversion-errors">Inbound Conversion Errors</a>.</p>
</div>
<div class="paragraph">
<p>When consuming from topics, set the <code>pub-sub-domain</code> attribute to true.
Set <code>subscription-durable</code> to <code>true</code> for a durable subscription or <code>subscription-shared</code> for a shared subscription (requires a JMS 2.0 broker and has been available since version 4.2).
Use <code>subscription-name</code> to name the subscription.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 4.2, the default <code>acknowledge</code> mode is <code>transacted</code>, unless an external container is provided.
In that case, you should configure the container as needed.
We recommend that you use <code>transacted</code> with the <code>DefaultMessageListenerContainer</code> to avoid message loss.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1, when the endpoint is stopped while the application remains running, the underlying listener container is shut down, closing its shared connection and consumers.
Previously, the connection and consumers remained open.
To revert to the previous behavior, set the <code>shutdownContainerOnStop</code> on the <code>JmsInboundGateway</code> to <code>false</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jms-outbound-gateway"><a class="anchor" href="#jms-outbound-gateway"></a>23.5. Outbound Gateway</h3>
<div class="paragraph">
<p>The outbound gateway creates JMS messages from Spring Integration messages and sends them to a 'request-destination'.
It thens handle the JMS reply message either by using a selector to receive from the 'reply-destination' that you configure or, if no 'reply-destination' is provided, by creating JMS <code>TemporaryQueue</code> instances.</p>
</div>
<div id="jms-outbound-gateway-memory-caution" class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using a <code>reply-destination</code> (or <code>reply-destination-name</code>) together with a <code>CachingConnectionFactory</code> that has cacheConsumers set to <code>true</code> can cause out-of-memory conditions.
This is because each request gets a new consumer with a new selector (selecting on the <code>correlation-key</code> value or, when there is no <code>correlation-key</code>, on the sent JMSMessageID).
Given that these selectors are unique, they remain in the cache (unused) after the current request completes.</p>
</div>
<div class="paragraph">
<p>If you specify a reply destination, you are advised to not use cached consumers.
Alternatively, consider using a <code>&lt;reply-listener/&gt;</code> as <a href="#jms-outbound-gateway-reply-listener">described below</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to configure an outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:outbound-gateway id="jmsOutGateway"
    request-destination="outQueue"
    request-channel="outboundJmsRequests"
    reply-channel="jmsReplies"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The 'outbound-gateway' payload extraction properties are inversely related to those of the 'inbound-gateway' (see the <a href="#jms-message-driven-channel-adapter">earlier discussion</a>).
That means that the 'extract-request-payload' property value applies to the Spring Integration message being converted into a JMS message to be sent as a request.
The 'extract-reply-payload' property value applies to the JMS message received as a reply and is then converted into a Spring Integration message to be subsequently sent to the 'reply-channel', as shown in the preceding configuration example.</p>
</div>
<div class="sect3">
<h4 id="jms-outbound-gateway-reply-listener"><a class="anchor" href="#jms-outbound-gateway-reply-listener"></a>23.5.1. Using a <code>&lt;reply-listener/&gt;</code></h4>
<div class="paragraph">
<p>Spring Integration 2.2 introduced an alternative technique for handling replies.
If you add a <code>&lt;reply-listener/&gt;</code> child element to the gateway instead of creating a consumer for each reply, a <code>MessageListener</code> container is used to receive the replies and hand them over to the requesting thread.
This provides a number of performance benefits as well as alleviating the cached consumer memory utilization problem described in the <a href="#jms-outbound-gateway-memory-caution">earlier caution</a>.</p>
</div>
<div class="paragraph">
<p>When using a <code>&lt;reply-listener/&gt;</code> with an outbound gateway that has no <code>reply-destination</code>, instead of creating a <code>TemporaryQueue</code> for each request, a single <code>TemporaryQueue</code> is used.
(The gateway creates an additional <code>TemporaryQueue</code>, as necessary, if the connection to the broker is lost and recovered).</p>
</div>
<div class="paragraph">
<p>When using a <code>correlation-key</code>, multiple gateways can share the same reply destination, because the listener container uses a selector that is unique to each gateway.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you specify a reply listener and specify a reply destination (or reply destination name) but provide no correlation key, the gateway logs a warning and falls back to pre-version 2.2 behavior.
This is because there is no way to configure a selector in this case.
Thus, there is no way to avoid a reply going to a different gateway that might be configured with the same reply destination.</p>
</div>
<div class="paragraph">
<p>Note that, in this situation, a new consumer is used for each request, and consumers can build up in memory as described in the caution above; therefore cached consumers should not be used in this case.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a reply listener with default attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:outbound-gateway id="jmsOutGateway"
        request-destination="outQueue"
        request-channel="outboundJmsRequests"
        reply-channel="jmsReplies"&gt;
    &lt;int-jms:reply-listener /&gt;
&lt;/int-jms-outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The listener is very lightweight, and we anticipate that, in most cases, you need only a single consumer.
However, you can add attributes such as <code>concurrent-consumers</code>, <code>max-concurrent-consumers</code>, and others.
See the schema for a complete list of supported attributes, together with the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jms.html">Spring JMS documentation</a> for their meanings.</p>
</div>
</div>
<div class="sect3">
<h4 id="idle-reply-listeners"><a class="anchor" href="#idle-reply-listeners"></a>23.5.2. Idle Reply Listeners</h4>
<div class="paragraph">
<p>Starting with version 4.2, you can start the reply listener as needed (and stop it after an idle time) instead
of running for the duration of the gateway&#8217;s lifecycle.
This can be useful if you have many gateways in the application context where they are mostly idle.
One such situation is a context with many (inactive) partitioned <a href="https://projects.spring.io/spring-batch/">Spring Batch</a>
jobs using Spring Integration and JMS for partition distribution.
If all the reply listeners are active, the JMS broker has an active consumer for each gateway.
By enabling the idle timeout, each consumer exists only while the corresponding batch job is running (and
for a short time after it finishes).</p>
</div>
<div class="paragraph">
<p>See <code>idle-reply-listener-timeout</code> in <a href="#jms-og-attributes">Attribute Reference</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-reply-correlation"><a class="anchor" href="#gateway-reply-correlation"></a>23.5.3. Gateway Reply Correlation</h4>
<div class="paragraph">
<p>This section describes the mechanisms used for reply correlation (ensuring the originating gateway receives replies
to only its requests), depending on how the gateway is configured.
See <a href="#jms-og-attributes">Attribute Reference</a> for complete description of the attributes discussed here.</p>
</div>
<div class="paragraph">
<p>The following list describes the various scenarios (the numbers are for identification&#8201;&#8212;&#8201;order does not matter):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>No <code>reply-destination*</code> properties and no <code>&lt;reply-listener&gt;</code></p>
<div class="paragraph">
<p>A <code>TemporaryQueue</code> is created for each request and deleted when the request is complete (successfully or otherwise).
<code>correlation-key</code> is irrelevant.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided and neither a <code>&lt;reply-listener/&gt;</code> nor a <code>correlation-key</code> is provided</p>
<div class="paragraph">
<p>The <code>JMSCorrelationID</code> equal to the outgoing message IS is used as a message selector for the consumer:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "JMSCorrelationID = '" + messageId + "'"</code></p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>JMSMessageID</code> in the reply <code>JMSCorrelationID</code>.
This is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring&#8217;s <code>MessageListenerAdapter</code> for message-driven POJOs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use this configuration, you should not use a topic for replies.
The reply may be lost.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, no <code>&lt;reply-listener/&gt;</code> is provided, and <code>correlation-key="JMSCorrelationID"</code></p>
<div class="paragraph">
<p>The gateway generates a unique correlation IS and inserts it in the <code>JMSCorrelationID</code> header.
The message selector is:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "JMSCorrelationID = '" + uniqueId + "'"</code></p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>JMSCorrelationID</code> in the reply <code>JMSCorrelationID</code>.
This is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring&#8217;s <code>MessageListenerAdapter</code> for message-driven POJOs.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, no <code>&lt;reply-listener/&gt;</code> is provided, and <code>correlation-key="myCorrelationHeader"</code></p>
<div class="paragraph">
<p>The gateway generates a unique correlation ID and inserts it in the <code>myCorrelationHeader</code> message property.
The <code>correlation-key</code> can be any user-defined value.
The message selector is:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "myCorrelationHeader = '" + uniqueId + "'"</code></p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>myCorrelationHeader</code> in the reply <code>myCorrelationHeader</code>.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, no <code>&lt;reply-listener/&gt;</code> is provided, and <code>correlation-key="JMSCorrelationID*"</code>::
(Note the <code>*</code> in the correlation key.)</p>
<div class="paragraph">
<p>The gateway uses the value in the <code>jms_correlationId</code> header (if present) from the request message and inserts it in
the <code>JMSCorrelationID</code> header.
The message selector is:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "JMSCorrelationID = '" + headers['jms_correlationId'] + "'"</code></p>
</div>
<div class="paragraph">
<p>The user must ensure this value is unique.</p>
</div>
<div class="paragraph">
<p>If the header does not exist, the gateway behaves as in <code>3</code>.</p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>JMSCorrelationID</code> in the reply <code>JMSCorrelationID</code>.
This is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring&#8217;s <code>MessageListenerAdapter</code> for message-driven POJOs.</p>
</div>
</li>
<li>
<p>No <code>reply-destination*</code> properties is provided, and a <code>&lt;reply-listener&gt;</code> is provided</p>
<div class="paragraph">
<p>A temporary queue is created and used for all replies from this gateway instance.
No correlation data is needed in the message, but the outgoing <code>JMSMessageID</code> is used internally in the gateway to direct the reply to the correct requesting thread.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, a <code>&lt;reply-listener&gt;</code> is provided, and no <code>correlation-key</code> is provided</p>
<div class="paragraph">
<p>Not allowed.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;reply-listener/&gt;</code> configuration is ignored, and the gateway behaves as in <code>2</code>.
A warning log message is written to indicate this situation.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, a <code>&lt;reply-listener&gt;</code> is provided, and <code>correlation-key="JMSCorrelationID"</code></p>
<div class="paragraph">
<p>The gateway has a unique correlation ID and inserts it, together with an incrementing value in the <code>JMSCorrelationID</code> header (<code>gatewayId + "_" + ++seq</code>).
The message selector is:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "JMSCorrelationID LIKE '" + gatewayId%'"</code></p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>JMSCorrelationID</code> in the reply <code>JMSCorrelationID</code>.
This is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring&#8217;s <code>MessageListenerAdapter</code> for message-driven POJOs.
Since each gateway has a unique ID, each instance gets only its own replies.
The complete correlation data is used to route the reply to the correct requesting thread.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided a <code>&lt;reply-listener/&gt;</code> is provided, and <code>correlation-key="myCorrelationHeader"</code></p>
<div class="paragraph">
<p>The gateway has a unique correlation ID and inserts it, together with an incrementing value in the <code>myCorrelationHeader</code>
property (<code>gatewayId + "_" + ++seq</code>).
The <code>correlation-key</code> can be any user-defined value.
The message selector is:</p>
</div>
<div class="paragraph">
<p><code>messageSelector = "myCorrelationHeader LIKE '" + gatewayId%'"</code></p>
</div>
<div class="paragraph">
<p>The responding system is expected to return the inbound <code>myCorrelationHeader</code> in the reply <code>myCorrelationHeader</code>.
Since each gateway has a unique ID, each instance only gets its own replies.
The complete correlation data is used to route the reply to the correct requesting thread.</p>
</div>
</li>
<li>
<p>A <code>reply-destination*</code> property is provided, a <code>&lt;reply-listener/&gt;</code> is provided, and <code>correlation-key="JMSCorrelationID*"</code>*</p>
<div class="paragraph">
<p>(Note the <code>*</code> in the correlation key)</p>
</div>
<div class="paragraph">
<p>Not allowed.</p>
</div>
<div class="paragraph">
<p>User-supplied correlation IDs are not permitted with a reply listener.
The gateway does not initialize with this configuration.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="jms-async-gateway"><a class="anchor" href="#jms-async-gateway"></a>23.5.4. Async Gateway</h4>
<div class="paragraph">
<p>Starting with version 4.3, you can now specify <code>async="true"</code> (or <code>setAsync(true)</code> in Java) when configuring the outbound
gateway.</p>
</div>
<div class="paragraph">
<p>By default, when a request is sent to the gateway, the requesting thread is suspended until the reply is received.
The flow then continues on that thread.
If <code>async</code> is <code>true</code>, the requesting thread is released immediately after the send completes, and the reply is returned
(and the flow continues) on the listener container thread.
This can be useful when the gateway is invoked on a poller thread.
The thread is released and is available for other tasks within the framework.</p>
</div>
<div class="paragraph">
<p><code>async</code> requires a <code>&lt;reply-listener/&gt;</code> (or <code>setUseReplyContainer(true)</code> when using Java configuration).
It also requires a <code>correlationKey</code> (usually <code>JMSCorrelationID</code>) to be specified.
If either of these conditions are not met, <code>async</code> is ignored.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-og-attributes"><a class="anchor" href="#jms-og-attributes"></a>23.5.5. Attribute Reference</h4>
<div class="paragraph">
<p>The following listing shows all the available attributes for an <code>outbound-gateway</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:outbound-gateway
    connection-factory="connectionFactory" <i class="conum" data-value="1"></i><b>(1)</b>
    correlation-key="" <i class="conum" data-value="2"></i><b>(2)</b>
    delivery-persistent="" <i class="conum" data-value="3"></i><b>(3)</b>
    destination-resolver="" <i class="conum" data-value="4"></i><b>(4)</b>
    explicit-qos-enabled="" <i class="conum" data-value="5"></i><b>(5)</b>
    extract-reply-payload="true" <i class="conum" data-value="6"></i><b>(6)</b>
    extract-request-payload="true" <i class="conum" data-value="7"></i><b>(7)</b>
    header-mapper="" <i class="conum" data-value="8"></i><b>(8)</b>
    message-converter="" <i class="conum" data-value="9"></i><b>(9)</b>
    priority="" <i class="conum" data-value="10"></i><b>(10)</b>
    receive-timeout="" <i class="conum" data-value="11"></i><b>(11)</b>
    reply-channel="" <i class="conum" data-value="12"></i><b>(12)</b>
    reply-destination="" <i class="conum" data-value="13"></i><b>(13)</b>
    reply-destination-expression="" <i class="conum" data-value="14"></i><b>(14)</b>
    reply-destination-name="" <i class="conum" data-value="15"></i><b>(15)</b>
    reply-pub-sub-domain="" <i class="conum" data-value="16"></i><b>(16)</b>
    reply-timeout="" <i class="conum" data-value="17"></i><b>(17)</b>
    request-channel="" <i class="conum" data-value="18"></i><b>(18)</b>
    request-destination="" <i class="conum" data-value="19"></i><b>(19)</b>
    request-destination-expression="" <i class="conum" data-value="20"></i><b>(20)</b>
    request-destination-name="" <i class="conum" data-value="21"></i><b>(21)</b>
    request-pub-sub-domain="" <i class="conum" data-value="22"></i><b>(22)</b>
    time-to-live="" <i class="conum" data-value="23"></i><b>(23)</b>
    requires-reply="" <i class="conum" data-value="24"></i><b>(24)</b>
    idle-reply-listener-timeout="" <i class="conum" data-value="25"></i><b>(25)</b>
    async=""&gt; <i class="conum" data-value="26"></i><b>(26)</b>
  &lt;int-jms:reply-listener /&gt; <i class="conum" data-value="27"></i><b>(27)</b>
&lt;/int-jms:outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Reference to a <code>javax.jms.ConnectionFactory</code>.
The default <code>jmsConnectionFactory</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The name of a property that contains correlation data to correlate responses with replies.
If omitted, the gateway expects the responding system to return the value of the outbound <code>JMSMessageID</code> header in the <code>JMSCorrelationID</code> header.
If specified, the gateway generates a correlation ID and populates the specified property with it.
The responding system must echo back that value in the same property.
It can be set to <code>JMSCorrelationID</code>, in which case the standard header is used instead of a <code>String</code> property to hold the correlation data.
When you use a <code>&lt;reply-container/&gt;</code>, you must specify the <code>correlation-key</code> if you provide an explicit <code>reply-destination</code>.
Starting with version 4.0.1, this attribute also supports the value <code>JMSCorrelationID*</code>, which means that if the outbound message already has a <code>JMSCorrelationID</code> (mapped from the <code>jms_correlationId</code>) header, it is used instead of generating a new one.
Note, the <code>JMSCorrelationID*</code> key is not allowed when you use a <code>&lt;reply-container/&gt;</code>, because the container needs to set up a message selector during initialization.
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You should understand that the gateway has no way to ensure uniqueness, and unexpected side effects can occur if the provided correlation ID is not unique.
</td>
</tr>
</table>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A boolean value indicating whether the delivery mode should be <code>DeliveryMode.PERSISTENT</code> (<code>true</code>) or <code>DeliveryMode.NON_PERSISTENT</code> (<code>false</code>).
This setting takes effect only if <code>explicit-qos-enabled</code> is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A <code>DestinationResolver</code>.
The default is a <code>DynamicDestinationResolver</code>, which maps the destination name to a queue or topic of that name.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When set to <code>true</code>, it enables the use of quality of service attributes: <code>priority</code>, <code>delivery-mode</code>, and <code>time-to-live</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>When set to <code>true</code> (the default), the payload of the Spring Integration reply message is created from the JMS Reply message&#8217;s body (by using the <code>MessageConverter</code>).
When set to <code>false</code>, the entire JMS message becomes the payload of the Spring Integration message.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>When set to <code>true</code> (the default), the payload of the Spring Integration message is converted to a <code>JMSMessage</code> (by using the <code>MessageConverter</code>).
When set to <code>false</code>, the entire Spring Integration Message is converted to the <code>JMSMessage</code>.
In both cases, the Spring Integration message headers are mapped to JMS headers and properties by using the <code>HeaderMapper</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>A <code>HeaderMapper</code> used to map Spring Integration message headers to and from JMS message headers and properties.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>A reference to a <code>MessageConverter</code> for converting between JMS messages and the Spring Integration message payloads (or messages if <code>extract-request-payload</code> is <code>false</code>).
The default is a <code>SimpleMessageConverter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The default priority of request messages.
Overridden by the message priority header, if present.
Its range is <code>0</code> to <code>9</code>.
This setting takes effect only if <code>explicit-qos-enabled</code> is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The time (in milliseconds) to wait for a reply.
The default is <code>5000</code> (five seconds).</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The channel to which the reply message is sent.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>A reference to a <code>Destination</code>, which is set as the <code>JMSReplyTo</code> header.
At most, only one of <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is allowed.
If none is provided, a <code>TemporaryQueue</code> is used for replies to this gateway.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>A SpEL expression evaluating to a <code>Destination</code>, which will be set as the <code>JMSReplyTo</code> header.
The expression can result in a <code>Destination</code> object or a <code>String</code>.
It is used by the <code>DestinationResolver</code> to resolve the actual <code>Destination</code>.
At most, only one of <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is allowed.
If none is provided, a <code>TemporaryQueue</code> is used for replies to this gateway.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>The name of the destination that is set as the JMSReplyTo header.
It is used by the <code>DestinationResolver</code> to resolve the actual <code>Destination</code>.
At most, only one of <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is allowed.
If none is provided, a <code>TemporaryQueue</code> is used for replies to this gateway.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>When set to <code>true</code>, it indicates that any reply <code>Destination</code> resolved by the <code>DestinationResolver</code> should be a <code>Topic</code> rather then a <code>Queue</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>The time the gateway waits when sending the reply message to the <code>reply-channel</code>.
This only has an effect if the <code>reply-channel</code> can block&#8201;&#8212;&#8201;such as a <code>QueueChannel</code> with a capacity limit that is currently full.
The default is infinity.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>The channel on which this gateway receives request messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="19"></i><b>19</b></td>
<td>A reference to a <code>Destination</code> to which request messages are sent.
One of <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is required.
You can use only one of those three attributes.</td>
</tr>
<tr>
<td><i class="conum" data-value="20"></i><b>20</b></td>
<td>A SpEL expression evaluating to a <code>Destination</code> to which request messages are sent.
The expression can result in a <code>Destination</code> object or a <code>String</code>.
It is used by the <code>DestinationResolver</code> to resolve the actual <code>Destination</code>.
Oneof <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is required.
You can use only one of those three attributes.</td>
</tr>
<tr>
<td><i class="conum" data-value="21"></i><b>21</b></td>
<td>The name of the destination to which request messages are sent.
It is used by the <code>DestinationResolver</code> to resolve the actual <code>Destination</code>.
One of <code>reply-destination</code>, <code>reply-destination-expression</code>, or <code>reply-destination-name</code> is required.
You can use only one of those three attributes.</td>
</tr>
<tr>
<td><i class="conum" data-value="22"></i><b>22</b></td>
<td>When set to <code>true</code>, it indicates that any request <code>Destination</code> resolved by the <code>DestinationResolver</code> should be a <code>Topic</code> rather then a <code>Queue</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="23"></i><b>23</b></td>
<td>Specifies the message time to live.
This setting takes effect only if <code>explicit-qos-enabled</code> is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="24"></i><b>24</b></td>
<td>Specifies whether this outbound gateway must return a non-null value.
By default, this value is <code>true</code>, and a <code>MessageTimeoutException</code> is thrown when the underlying service does not return a value after the <code>receive-timeout</code>.
Note that, if the service is never expected to return a reply, it would be better to use a <code>&lt;int-jms:outbound-channel-adapter/&gt;</code> instead of a <code>&lt;int-jms:outbound-gateway/&gt;</code> with <code>requires-reply="false"</code>.
With the latter, the sending thread is blocked, waiting for a reply for the <code>receive-timeout</code> period.</td>
</tr>
<tr>
<td><i class="conum" data-value="25"></i><b>25</b></td>
<td>When you use a <code>&lt;reply-listener /&gt;</code>, its lifecycle (start and stop) matches that of the gateway by default.
When this value is greater than <code>0</code>, the container is started on demand (when a request is sent).
The container continues to run until at least this time elapses with no requests being received (and until no replies are outstanding).
The container is started again on the next request.
The stop time is a minimum and may actually be up to 1.5x this value.</td>
</tr>
<tr>
<td><i class="conum" data-value="26"></i><b>26</b></td>
<td>See <a href="#jms-async-gateway">Async Gateway</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="27"></i><b>27</b></td>
<td>When this element is included, replies are received by an asynchronous <code>MessageListenerContainer</code> rather than creating a consumer for each reply.
This can be more efficient in many cases.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-header-mapping"><a class="anchor" href="#jms-header-mapping"></a>23.6. Mapping Message Headers to and from JMS Message</h3>
<div class="paragraph">
<p>JMS messages can contain meta-information such as JMS API headers and simple properties.
You can map those to and from Spring Integration message headers by using <code>JmsHeaderMapper</code>.
The JMS API headers are passed to the appropriate setter methods (such as <code>setJMSReplyTo</code>), whereas other headers are copied to the general properties of the JMS Message.
JMS outbound gateway is bootstrapped with the default implementation of <code>JmsHeaderMapper</code>, which will map standard JMS API Headers as well as primitive or <code>String</code> message headers.
You could also provide a custom header mapper by using the <code>header-mapper</code> attribute of inbound and outbound gateways.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Since version 4.0, the <code>JMSPriority</code> header is mapped to the standard <code>priority</code> header for inbound messages.
(previously, the <code>priority</code> header was only used for outbound messages).
To revert to the previous behavior (that is, to not map the inbound priority), set the <code>mapInboundPriority</code> property of <code>DefaultJmsHeaderMapper</code> to <code>false</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Since version 4.3, the <code>DefaultJmsHeaderMapper</code> maps the standard <code>correlationId</code> header as a message
property by invoking its <code>toString()</code> method (<code>correlationId</code> is often a <code>UUID</code>, which is not supported by JMS).
On the inbound side, it is mapped as a <code>String</code>.
This is independent of the <code>jms_correlationId</code> header, which is mapped to and from the <code>JMSCorrelationID</code> header.
The <code>JMSCorrelationID</code> is generally used to correlate requests and replies, whereas the <code>correlationId</code> is often used to combine related messages into a group (such as with an aggregator or a resequencer).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>DefaultJmsHeaderMapper</code> can be configured for mapping inbound <code>JMSDeliveryMode</code> and <code>JMSExpiration</code> properties:
 ====
 [source,java]
 ----
 @Bean
 public DefaultJmsHeaderMapper jmsHeaderMapper() {
     DefaultJmsHeaderMapper mapper = new DefaultJmsHeaderMapper();
     mapper.setMapInboundDeliveryMode(true)
     mapper.setMapInboundExpiration(true)
     return mapper;
 }
 ----
 ====</p>
</div>
<div class="paragraph">
<p>These JMS properties are mapped to the <code>JmsHeaders.DELIVERY_MODE</code> and <code>JmsHeaders.EXPIRATION</code> Spring Message headers respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="jms-conversion-and-marshalling"><a class="anchor" href="#jms-conversion-and-marshalling"></a>23.7. Message Conversion, Marshalling, and Unmarshalling</h3>
<div class="paragraph">
<p>If you need to convert the message, all JMS adapters and gateways let you provide a <code>MessageConverter</code> by setting the <code>message-converter</code> attribute.
To do so, provide the bean name of an instance of <code>MessageConverter</code> that is available within the same ApplicationContext.
Also, to provide some consistency with marshaller and unmarshaller interfaces, Spring provides <code>MarshallingMessageConverter</code>, which you can configure with your own custom marshallers and unmarshallers.
The following example shows how to do so</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:inbound-gateway request-destination="requestQueue"
    request-channel="inbound-gateway-channel"
    message-converter="marshallingMessageConverter"/&gt;

&lt;bean id="marshallingMessageConverter"
    class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.bar.SampleMarshaller"/&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.bar.SampleUnmarshaller"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you provide your own <code>MessageConverter</code> instance, it is still wrapped within the <code>HeaderMappingMessageConverter</code>.
This means that the 'extract-request-payload' and 'extract-reply-payload' properties can affect the actual objects passed to your converter.
The <code>HeaderMappingMessageConverter</code> itself delegates to a target <code>MessageConverter</code> while also mapping the Spring Integration <code>MessageHeaders</code> to JMS message properties and back again.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jms-channel"><a class="anchor" href="#jms-channel"></a>23.8. JMS-backed Message Channels</h3>
<div class="paragraph">
<p>The channel adapters and gateways featured earlier are all intended for applications that integrate with other external systems.
The inbound options assume that some other system is sending JMS messages to the JMS destination, and the outbound options assume that some other system is receiving from the destination.
The other system may or may not be a Spring Integration application.
Of course, when sending a Spring Integration message instance as the body of the JMS message itself (with 'extract-payload' value set to <code>false</code>), it is assumed that the other system is based on Spring Integration.
However, that is by no means a requirement.
That flexibility is one of the benefits of using a message-based integration option with the abstraction of &#8220;channels&#8221;( or destinations in the case of JMS).</p>
</div>
<div class="paragraph">
<p>Sometimes, both the producer and consumer for a given JMS Destination are intended to be part of the same application, running within the same process.
You can accomplish this by using a pair of inbound and outbound channel adapters.
The problem with that approach is that you need two adapters, even though, conceptually, the goal is to have a single message channel.
A better option is supported as of Spring Integration version 2.0.
Now it is possible to define a single &#8220;channel&#8221; when using the JMS namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:channel id="jmsChannel" queue="exampleQueue"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The channel in the preceding example behaves much like a normal <code>&lt;channel/&gt;</code> element from the main Spring Integration namespace.
It can be referenced by both the <code>input-channel</code> and <code>output-channel</code> attributes of any endpoint.
The difference is that this channel is backed by a JMS Queue instance named <code>exampleQueue</code>.
This means that asynchronous messaging is possible between the producing and consuming endpoints.
However, unlike the simpler asynchronous message channels created by adding a <code>&lt;queue/&gt;</code> element within a non-JMS <code>&lt;channel/&gt;</code> element, the messages are not stored in an in-memory queue.
Instead, those messages are passed within a JMS message body, and the full power of the underlying JMS provider is then available for that channel.
Probably the most common rationale for using this alternative is to take advantage of the persistence made available by the store-and-forward approach of JMS messaging.</p>
</div>
<div class="paragraph">
<p>If configured properly, the JMS-backed message channel also supports transactions.
In other words, a producer would not actually write to a transactional JMS-backed channel if its send operation is part of a transaction that rolls back.
Likewise, a consumer would not physically remove a JMS message from the channel if the reception of that message is part of a transaction that rolls back.
Note that the producer and consumer transactions are separate in such a scenario.
This is significantly different than the propagation of a transactional context across a simple, synchronous <code>&lt;channel/&gt;</code> element that has no <code>&lt;queue/&gt;</code> child element.</p>
</div>
<div class="paragraph">
<p>Since the preceding example above references a JMS Queue instance, it acts as a point-to-point channel.
If, on the other hand, you need publish-subscribe behavior, you can use a separate element and reference a JMS Topic instead.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:publish-subscribe-channel id="jmsChannel" topic="exampleTopic"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For either type of JMS-backed channel, the name of the destination may be provided instead of a reference, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:channel id="jmsQueueChannel" queue-name="exampleQueueName"/&gt;

&lt;jms:publish-subscribe-channel id="jmsTopicChannel" topic-name="exampleTopicName"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding examples, the destination names are resolved by Spring&#8217;s default <code>DynamicDestinationResolver</code> implementation, but you could provide any implementation of the <code>DestinationResolver</code> interface.
Also, the JMS <code>ConnectionFactory</code> is a required property of the channel, but, by default, the expected bean name would be <code>jmsConnectionFactory</code>.
The following example provides both a custom instance for resolution of the JMS destination names and a different name for the <code>ConnectionFactory</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-jms:channel id="jmsChannel" queue-name="exampleQueueName"
    destination-resolver="customDestinationResolver"
    connection-factory="customConnectionFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For the <code>&lt;publish-subscribe-channel /&gt;</code>, set the <code>durable</code> attribute to <code>true</code> for a durable subscription or <code>subscription-shared</code> for a shared subscription (requires a JMS 2.0 broker and has been available since version 4.2).
Use <code>subscription</code> to name the subscription.</p>
</div>
</div>
<div class="sect2">
<h3 id="jms-selectors"><a class="anchor" href="#jms-selectors"></a>23.9. Using JMS Message Selectors</h3>
<div class="paragraph">
<p>With JMS message selectors, you can filter <a href="https://docs.oracle.com/javaee/6/api/javax/jms/Message.html">JMS Messages</a> based on JMS headers as well as JMS properties.
For example, if you want to listen to messages whose custom JMS header property, <code>myHeaderProperty</code>, equals <code>something</code>, you can specify the following expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">myHeaderProperty = 'something'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Message selector expressions are a subset of the <a href="https://en.wikipedia.org/wiki/SQL-92">SQL-92</a> conditional expression syntax and are defined as part of the <a href="https://download.oracle.com/otn-pub/jcp/7195-jms-1.1-fr-spec-oth-JSpec/jms-1_1-fr-spec.pdf">Java Message Service</a> specification (Version 1.1, April 12, 2002).
Specifically, see chapter "3.8, Message Selection".
It contains a detailed explanation of the expressions syntax.</p>
</div>
<div class="paragraph">
<p>You can specify the JMS message <code>selector</code> attribute by using XML namespace configuration for the following Spring Integration JMS components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JMS Channel</p>
</li>
<li>
<p>JMS Publish Subscribe Channel</p>
</li>
<li>
<p>JMS Inbound Channel Adapter</p>
</li>
<li>
<p>JMS Inbound Gateway</p>
</li>
<li>
<p>JMS Message-driven Channel Adapter</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You cannot reference message body values by using JMS Message selectors.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jms-samples"><a class="anchor" href="#jms-samples"></a>23.10. JMS Samples</h3>
<div class="paragraph">
<p>To experiment with these JMS adapters, check out the JMS samples available in the Spring Integration Samples Git repository at <a href="https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jms">https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jms</a>.</p>
</div>
<div class="paragraph">
<p>That repository includes two samples.
One provides inbound and outbound channel adapters, and the other provides inbound and outbound gateways.
They are configured to run with an embedded <a href="https://activemq.apache.org/">ActiveMQ</a> process, but you can modify the <a href="https://github.com/SpringSource/spring-integration-samples/blob/master/basic/jms/src/main/resources/META-INF/spring/integration/common.xml">common.xml</a> Spring application context file of each sample to support either a different JMS provider or a standalone ActiveMQ process.</p>
</div>
<div class="paragraph">
<p>In other words, you can split the configuration so that the inbound and outbound adapters run in separate JVMs.
If you have ActiveMQ installed,  modify the <code>brokerURL</code> property within the common.xml file to use <code>tcp://localhost:61616</code> (instead of <code>vm://localhost</code>).
Both of the samples accept input from stdin and echo back to stdout.
Look at the configuration to see how these messages are routed over JMS.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mail"><a class="anchor" href="#mail"></a>24. Mail Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how to work with mail messages in Spring Integration.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-mail&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-mail:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>javax.mail:javax.mail-api</code> must be included via vendor-specific implementation.</p>
</div>
<div class="sect2">
<h3 id="mail-outbound"><a class="anchor" href="#mail-outbound"></a>24.1. Mail-sending Channel Adapter</h3>
<div class="paragraph">
<p>Spring Integration provides support for outbound email with the <code>MailSendingMessageHandler</code>.
It delegates to a configured instance of Spring&#8217;s <code>JavaMailSender</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> JavaMailSender mailSender = context.getBean("mailSender", JavaMailSender.class);

 MailSendingMessageHandler mailSendingHandler = new MailSendingMessageHandler(mailSender);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>MailSendingMessageHandler</code> has various mapping strategies that use Spring&#8217;s <code>MailMessage</code> abstraction.
If the received message&#8217;s payload is already a <code>MailMessage</code> instance, it is sent directly.
Therefore, we generally recommend that you precede this consumer with a transformer for non-trivial <code>MailMessage</code> construction requirements.
However, Spring Integration supports a few simple message mapping strategies.
For example, if the message payload is a byte array, that is mapped to an attachment.
For simple text-based emails, you can provide a string-based message payload.
In that case, a <code>MailMessage</code> is created with that <code>String</code> as the text content.
If you work with a message payload type whose <code>toString()</code> method returns appropriate mail text content, consider adding Spring Integration&#8217;s <code>ObjectToStringTransformer</code> prior to the outbound mail adapter (see the example in <a href="#transformer-namespace">Configuring a Transformer with XML</a> for more detail).</p>
</div>
<div class="paragraph">
<p>You can also configure the outbound <code>MailMessage</code> with certain values from <code>MessageHeaders</code>.
If available, values are mapped to the outbound mail&#8217;s properties, such as the recipients (To, Cc, and BCc), the from, the reply-to, and the subject.
The header names are defined by the following constants:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> MailHeaders.SUBJECT
 MailHeaders.TO
 MailHeaders.CC
 MailHeaders.BCC
 MailHeaders.FROM
 MailHeaders.REPLY_TO</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MailHeaders</code> also lets you override corresponding <code>MailMessage</code> values.
For example, if <code>MailMessage.to</code> is set to '<a href="mailto:thing1@things.com">thing1@things.com</a>' and the <code>MailHeaders.TO</code> message header is provided, it takes precedence and overrides the corresponding value in <code>MailMessage</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mail-inbound"><a class="anchor" href="#mail-inbound"></a>24.2. Mail-receiving Channel Adapter</h3>
<div class="paragraph">
<p>Spring Integration also provides support for inbound email with the <code>MailReceivingMessageSource</code>.
It delegates to a configured instance of Spring Integration&#8217;s own <code>MailReceiver</code> interface.
There are two implementations: <code>Pop3MailReceiver</code> and <code>ImapMailReceiver</code>.
The easiest way to instantiate either of these is by passing the 'uri' for a mail store to the receiver&#8217;s constructor, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MailReceiver receiver = new Pop3MailReceiver("pop3://usr:pwd@localhost/INBOX");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another option for receiving mail is the IMAP <code>idle</code> command (if supported by your mail server).
Spring Integration provides the <code>ImapIdleChannelAdapter</code>, which is itself a message-producing endpoint.
It delegates to an instance of the <code>ImapMailReceiver</code> but enables asynchronous reception of mail messages.
The next section has examples of configuring both types of inbound channel adapter with Spring Integration&#8217;s namespace support in the 'mail' schema.</p>
</div>
<div id="imap-format-important" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Normally, when the <code>IMAPMessage.getContent()</code> method is called, certain headers as well as the body are rendered (for a simple text email), as the following example shows:</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>To: thing1@things.com
From: thing2@morethings.com
Subject: Test Email

something</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With a simple <code>MimeMessage</code>, <code>getContent()</code> returns the mail body (<code>something</code> in the preceding example).</p>
</div>
<div class="paragraph">
<p>Starting with version 2.2, the framework eagerly fetches IMAP messages and exposes them as an internal subclass of <code>MimeMessage</code>.
This had the undesired side effect of changing the <code>getContent()</code> behavior.
This inconsistency was further exacerbated by the <a href="#mail-mapping">Mail Mapping</a> enhancement introduced in version 4.3, because, when a header mapper was provided, the payload was rendered by the <code>IMAPMessage.getContent()</code> method.
This meant that the IMAP content differed, depending on whether or not a header mapper was provided.
Starting with version 5.0, messages originating from an IMAP source render the content in accordance with <code>IMAPMessage.getContent()</code> behavior, regardless of whether a header mapper is provided.
If you do not use a header mapper and you wish to revert to the previous behavior of rendering only the body, set the <code>simpleContent</code> boolean property on the mail receiver to <code>true</code>.
This property now controls the rendering regardless of whether a header mapper is used.
It now allows body-only rendering when a header mapper is provided.</p>
</div>
</div>
<div class="sect2">
<h3 id="mail-mapping"><a class="anchor" href="#mail-mapping"></a>24.3. Inbound Mail Message Mapping</h3>
<div class="paragraph">
<p>By default, the payload of messages produced by the inbound adapters is the raw <code>MimeMessage</code>.
You can use that object to interrogate the headers and content.
Starting with version 4.3, you can provide a <code>HeaderMapper&lt;MimeMessage&gt;</code> to map the headers to <code>MessageHeaders</code>.
For convenience, Spring Integration provides a <code>DefaultMailHeaderMapper</code> for this purpose.
It maps the following headers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mail_from</code>: A <code>String</code> representation of the <code>from</code> address.</p>
</li>
<li>
<p><code>mail_bcc</code>: A <code>String</code> array containing the <code>bcc</code> addresses.</p>
</li>
<li>
<p><code>mail_cc</code>: A <code>String</code> array containing the <code>cc</code> addresses.</p>
</li>
<li>
<p><code>mail_to</code>: A <code>String</code> array containing the <code>to</code> addresses.</p>
</li>
<li>
<p><code>mail_replyTo</code>: A <code>String</code> representation of the <code>replyTo</code> address.</p>
</li>
<li>
<p><code>mail_subject</code>: The mail subject.</p>
</li>
<li>
<p><code>mail_lineCount</code>: A line count (if available).</p>
</li>
<li>
<p><code>mail_receivedDate</code>: The received date (if available).</p>
</li>
<li>
<p><code>mail_size</code>: The mail size (if available).</p>
</li>
<li>
<p><code>mail_expunged</code>: A boolean indicating if the message is expunged.</p>
</li>
<li>
<p><code>mail_raw</code>: A <code>MultiValueMap</code> containing all the mail headers and their values.</p>
</li>
<li>
<p><code>mail_contentType</code>: The content type of the original mail message.</p>
</li>
<li>
<p><code>contentType</code>: The payload content type (see below).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When message mapping is enabled, the payload depends on the mail message and its implementation.
Email contents are usually rendered by a <code>DataHandler</code> within the <code>MimeMessage</code>.</p>
</div>
<div class="paragraph">
<p>For a <code>text/*</code> email, the payload is a <code>String</code> and the <code>contentType</code> header is the same as <code>mail_contentType</code>.</p>
</div>
<div class="paragraph">
<p>For a messages with embedded <code>javax.mail.Part</code> instances, the <code>DataHandler</code> usually renders a <code>Part</code> object.
These objects are not <code>Serializable</code> and are not suitable for serialization with alternative technologies such as <code>Kryo</code>.
For this reason, by default, when mapping is enabled, such payloads are rendered as a raw <code>byte[]</code> containing the <code>Part</code> data.
Examples of <code>Part</code> are <code>Message</code> and <code>Multipart</code>.
The <code>contentType</code> header is <code>application/octet-stream</code> in this case.
To change this behavior and receive a <code>Multipart</code> object payload, set <code>embeddedPartsAsBytes</code> to <code>false</code> on <code>MailReceiver</code>.
For content types that are unknown to the <code>DataHandler</code>, the contents are rendered as a <code>byte[]</code> with a <code>contentType</code> header of <code>application/octet-stream</code>.</p>
</div>
<div class="paragraph">
<p>When you do not provide a header mapper, the message payload is the <code>MimeMessage</code> presented by <code>javax.mail</code>.
The framework provides a <code>MailToStringTransformer</code> that you can use to convert the message by using a strategy to convert the mail contents to a <code>String</code>.
This is also available by using the XML namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:mail-to-string-transformer ... &gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example does the same thing with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Transformer(inputChannel="...", outputChannel="...")
public Transformer transformer() {
    return new MailToStringTransformer();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example does the same thing with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">   ...
   .transform(Mail.toStringTransformer())
   ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.3, the transformer handles embedded <code>Part</code> instances (as well as <code>Multipart</code> instances, which were handled previously).
The transformer is a subclass of <code>AbstractMailTransformer</code> that maps the address and subject headers from the preceding list.
If you wish to perform some other transformation on the message, consider subclassing <code>AbstractMailTransformer</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mail-namespace"><a class="anchor" href="#mail-namespace"></a>24.4. Mail Namespace Support</h3>
<div class="paragraph">
<p>Spring Integration provides a namespace for mail-related configuration.
To use it, configure the following schema locations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int-mail="http://www.springframework.org/schema/integration/mail"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration/mail
    https://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To configure an outbound channel adapter, provide the channel from which to receive and the MailSender, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:outbound-channel-adapter channel="outboundMail"
    mail-sender="mailSender"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can provide the host, username, and password, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:outbound-channel-adapter channel="outboundMail"
    host="somehost" username="someuser" password="somepassword"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.1.3, the <code>host</code>, <code>username</code> ane <code>mail-sender</code> can be omitted, if <code>java-mail-properties</code> is provided.
However the <code>host</code> and <code>username</code> has to be configured with appropriate Java mail properties, e.g. for SMTP:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>mail.user=someuser@gmail.com
mail.smtp.host=smtp.gmail.com
mail.smtp.port=587</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with any outbound Channel Adapter, if the referenced channel is a <code>PollableChannel</code>, you should provide a <code>&lt;poller&gt;</code> element (see <a href="#endpoint-namespace">Endpoint Namespace Support</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you use the namespace support, you can also use a <code>header-enricher</code> message transformer.
Doing so simplifies the application of the headers mentioned earlier to any message prior to sending to the mail outbound channel adapter.</p>
</div>
<div class="paragraph">
<p>The following example assumes the payload is a Java bean with appropriate getters for the specified properties, but you can use any SpEL expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:header-enricher input-channel="expressionsInput" default-overwrite="false"&gt;
	&lt;int-mail:to expression="payload.to"/&gt;
	&lt;int-mail:cc expression="payload.cc"/&gt;
	&lt;int-mail:bcc expression="payload.bcc"/&gt;
	&lt;int-mail:from expression="payload.from"/&gt;
	&lt;int-mail:reply-to expression="payload.replyTo"/&gt;
	&lt;int-mail:subject expression="payload.subject" overwrite="true"/&gt;
&lt;/int-mail:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use the <code>value</code> attribute to specify a literal.
You also can specify <code>default-overwrite</code> and individual <code>overwrite</code> attributes to control the behavior with existing headers.</p>
</div>
<div class="paragraph">
<p>To configure an inbound channel adapter, you have the choice between polling or event-driven (assuming your mail server supports IMAP <code>idle</code>&#8201;&#8212;&#8201;if not, then polling is the only option).
A polling channel adapter requires the store URI and the channel to which to send inbound messages.
The URI may begin with <code>pop3</code> or <code>imap</code>.
The following example uses an <code>imap</code> URI:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:inbound-channel-adapter id="imapAdapter"
      store-uri="imaps://[username]:[password]@imap.gmail.com/INBOX"
      java-mail-properties="javaMailProperties"
      channel="receiveChannel"
      should-delete-messages="true"
      should-mark-messages-as-read="true"
      auto-startup="true"&gt;
      &lt;int:poller max-messages-per-poll="1" fixed-rate="5000"/&gt;
&lt;/int-mail:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do have IMAP <code>idle</code> support, you may want to configure the <code>imap-idle-channel-adapter</code> element instead.
Since the <code>idle</code> command enables event-driven notifications, no poller is necessary for this adapter.
It sends a message to the specified channel as soon as it receives the notification that new mail is available.
The following example configures an IMAP <code>idle</code> mail channel:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:imap-idle-channel-adapter id="customAdapter"
      store-uri="imaps://[username]:[password]@imap.gmail.com/INBOX"
      channel="receiveChannel"
      auto-startup="true"
      should-delete-messages="false"
      should-mark-messages-as-read="true"
      java-mail-properties="javaMailProperties"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can provide <code>javaMailProperties</code> by creating and populating a regular <code>java.utils.Properties</code> object&#8201;&#8212;&#8201;for example, by using the <code>util</code> namespace provided by Spring.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If your username contains the '@' character, use '%40' instead of '@' to avoid parsing errors from the underlying JavaMail API.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>java.util.Properties</code> object:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:properties id="javaMailProperties"&gt;
  &lt;prop key="mail.imap.socketFactory.class"&gt;javax.net.ssl.SSLSocketFactory&lt;/prop&gt;
  &lt;prop key="mail.imap.socketFactory.fallback"&gt;false&lt;/prop&gt;
  &lt;prop key="mail.store.protocol"&gt;imaps&lt;/prop&gt;
  &lt;prop key="mail.debug"&gt;false&lt;/prop&gt;
&lt;/util:properties&gt;</code></pre>
</div>
</div>
</div>
</div>
<div id="search-term" class="paragraph">
<p>By default, the <code>ImapMailReceiver</code> searches for messages based on the default <code>SearchTerm</code>, which is all mail messages that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are RECENT (if supported)</p>
</li>
<li>
<p>Are NOT ANSWERED</p>
</li>
<li>
<p>Are NOT DELETED</p>
</li>
<li>
<p>Are NOT SEEN</p>
</li>
<li>
<p>hHave not been processed by this mail receiver (enabled by the use of the custom USER flag or simply NOT FLAGGED if not supported)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The custom user flag is <code>spring-integration-mail-adapter</code>, but you can configure it.
Since version 2.2, the <code>SearchTerm</code> used by the <code>ImapMailReceiver</code> is fully configurable with <code>SearchTermStrategy</code>, which you can inject by using the <code>search-term-strategy</code> attribute.
<code>SearchTermStrategy</code> is a strategy interface with a single method that lets you create an instance of the <code>SearchTerm</code> used by the <code>ImapMailReceiver</code>.
The following listing shows the <code>SearchTermStrategy</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SearchTermStrategy {

    SearchTerm generateSearchTerm(Flags supportedFlags, Folder folder);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example relies <code>TestSearchTermStrategy</code> rather than the default <code>SearchTermStrategy</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;mail:imap-idle-channel-adapter id="customAdapter"
			store-uri="imap:something"
			
			search-term-strategy="searchTermStrategy"/&gt;

&lt;bean id="searchTermStrategy"
  class="o.s.i.mail.config.ImapIdleChannelAdapterParserTests.TestSearchTermStrategy"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#imap-seen">Marking IMAP Messages When <code>\Recent</code> Is Not Supported</a> for information about message flagging.</p>
</div>
<div id="imap-peek" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Important: IMAP PEEK</div>
<div class="paragraph">
<p>Starting with version 4.1.1, the IMAP mail receiver uses the <code>mail.imap.peek</code> or <code>mail.imaps.peek</code> JavaMail property, if specified.
Previously, the receiver ignored the property and always set the <code>PEEK</code> flag.
Now, if you explicitly set this property to <code>false</code>, the message ise marked as <code>\Seen</code> regardless of the setting of <code>shouldMarkMessagesRead</code>.
If not specified, the previous behavior is retained (peek is <code>true</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="imap-idle-and-lost-connections"><a class="anchor" href="#imap-idle-and-lost-connections"></a>24.4.1. IMAP <code>idle</code> and Lost Connections</h4>
<div class="paragraph">
<p>When using an IMAP <code>idle</code> channel adapter, connections to the server may be lost (for example, through network failure) and, since the JavaMail documentation explicitly states that the actual IMAP API is experimental, it is important to understand the differences in the API and how to deal with them when configuring IMAP <code>idle</code> adapters.
Currently, Spring Integration mail adapters were tested with JavaMail 1.4.1 and JavaMail 1.4.3.
Depending on which one is used, you must pay special attention to some of the JavaMail properties that need to be set with regard to auto-reconnect.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following behavior was observed with Gmail but should provide you with some tips on how to solve re-connect issue with other providers.
However feedback is always welcome.
Again, the following notes are based on Gmail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With JavaMail 1.4.1, if you set the <code>mail.imaps.timeout</code> property to a relatively short period of time (approximately 5 min in our testing), <code>IMAPFolder.idle()</code> throws <code>FolderClosedException</code> after this timeout.
However, if this property is not set (it should be indefinite) the  <code>IMAPFolder.idle()</code> method never returns and never throws an exception.
It does, however, reconnect automatically if the connection was lost for a short period of time (under 10 min in our testing).
However, if the connection was lost for a long period of time (over 10 min), <code>IMAPFolder.idle()</code>, does not throw <code>FolderClosedException</code> and does not re-establish the connection, and remains in the blocked state indefinitely, thus leaving you no possibility to reconnect without restarting the adapter.
Consequently, the only way to make re-connecting work with JavaMail 1.4.1 is to set the <code>mail.imaps.timeout</code> property explicitly to some value, but it also means that such value should be relatively short (under 10 min) and the connection should be re-established relatively quickly.
Again, it may be different with providers other than Gmail.
With JavaMail 1.4.3 introduced significant improvements to the API, ensuring that there is always a condition that forces the <code>IMAPFolder.idle()</code> method to return  <code>StoreClosedException</code> or <code>FolderClosedException</code> or to simply return, thus letting you proceed with auto-reconnecting.
Currently auto-reconnecting runs infinitely making attempts to reconnect every ten seconds.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In both configurations, <code>channel</code> and <code>should-delete-messages</code> are required attributes.
You should understand why <code>should-delete-messages</code> is required.
The issue is with the POP3 protocol, which does not have any knowledge of messages that were read.
It can only know what has been read within a single session.
This means that, when your POP3 mail adapter runs, emails are successfully consumed as as they become available during each poll
and no single email message is delivered more then once.
However, as soon as you restart your adapter and begin a new session, all the email messages that might have been retrieved in the previous session are retrieved again.
That is the nature of POP3.
Some might argue that <code>should-delete-messages</code> should be <code>true</code> by default.
In other words, there are two valid and mutually exclusive use that make it very hard to pick a single best default.
You may want to configure your adapter as the only email receiver, in which case you want to be able to restart your adapter without fear that previously delivered messages are not delivered again.
In this case, setting <code>should-delete-messages</code> to <code>true</code> would make the most sense.
However, you may have another use case where you may want to have multiple adapters monitor email servers and their content.
In other words, you want to 'peek but not touch'.
Then setting <code>should-delete-messages</code> to <code>false</code> is much more appropriate.
So since it is hard to choose what should be the right default value for the <code>should-delete-messages</code> attribute, we made it a required attribute to be set by you.
Leaving it up to you also means that you are less likely to end up with unintended behavior.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When configuring a polling email adapter&#8217;s <code>should-mark-messages-as-read</code> attribute, you should be aware of the protocol you are configuring to retrieve messages.
For example, POP3 does not support this flag, which means setting it to either value has no effect, as messages are not marked as read.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You should understand that that these actions (marking messages read and deleting messages) are performed after the messages are received but before they are processed.
This can cause messages to be lost.</p>
</div>
<div class="paragraph">
<p>You may wish to consider using transaction synchronization instead.
See <a href="#mail-tx-sync">Transaction Synchronization</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>&lt;imap-idle-channel-adapter/&gt;</code> also accepts the 'error-channel' attribute.
If a downstream exception is thrown and an 'error-channel' is specified, a <code>MessagingException</code> message containing the failed message and the original exception is sent to this channel.
Otherwise, if the downstream channels are synchronous, any such exception is logged as a warning by the channel adapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Beginning with the 3.0 release, the IMAP <code>idle</code> adapter emits application events (specifically <code>ImapIdleExceptionEvent</code> instances) when exceptions occur.
This allows applications to detect and act on those exceptions.
You can obtain the events by using an <code>&lt;int-event:inbound-channel-adapter&gt;</code> or any <code>ApplicationListener</code> configured to receive an <code>ImapIdleExceptionEvent</code> or one of its super classes.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="imap-seen"><a class="anchor" href="#imap-seen"></a>24.5. Marking IMAP Messages When <code>\Recent</code> Is Not Supported</h3>
<div class="paragraph">
<p>If <code>shouldMarkMessagesAsRead</code> is true, the IMAP adapters set the <code>\Seen</code> flag.</p>
</div>
<div class="paragraph">
<p>In addition, when an email server does not support the <code>\Recent</code> flag, the IMAP adapters mark messages with a user flag (by default, <code>spring-integration-mail-adapter</code>), as long as the server supports user flags.
If not, <code>Flag.FLAGGED</code> is set to <code>true</code>.
These flags are applied regardless of the <code>shouldMarkMessagesRead</code> setting.</p>
</div>
<div class="paragraph">
<p>As discussed in <a href="#search-term">[search-term]</a>, the default <code>SearchTermStrategy</code> ignore messages that are so flagged.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2.2, you can set the name of the user flag by using <code>setUserFlag</code> on the <code>MailReceiver</code>.
Doing so lets multiple receivers use a different flag (as long as the mail server supports user flags).
The <code>user-flag</code> attribute is available when configuring the adapter with the namespace.</p>
</div>
</div>
<div class="sect2">
<h3 id="mail-filtering"><a class="anchor" href="#mail-filtering"></a>24.6. Email Message Filtering</h3>
<div class="paragraph">
<p>Very often, you may encounter a requirement to filter incoming messages (for example, you want to read only emails that have 'Spring Integration' in the <code>Subject</code> line).
You can accomplish this by connecting an inbound mail adapter with an expression-based <code>Filter</code>.
Although it would work, there is a downside to this approach.
Since messages would be filtered after going through the inbound mail adapter, all such messages would be marked as read (<code>SEEN</code>) or unread (depending on the value of <code>should-mark-messages-as-read</code> attribute).
However, in reality, it be more useful to mark messages as <code>SEEN</code> only if they pass the filtering criteria.
This is similar to looking at your email client while scrolling through all the messages in the preview pane, but only flagging messages that were actually opened and read as <code>SEEN</code>.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.0.4 introduced the <code>mail-filter-expression</code> attribute on <code>inbound-channel-adapter</code> and <code>imap-idle-channel-adapter</code>.
This attribute lets you provide an expression that is a combination of SpEL and a regular expression.
For example if you would like to read only emails that contain 'Spring Integration' in the subject line, you would configure the <code>mail-filter-expression</code> attribute like as follows: <code>mail-filter-expression="subject matches '(?i).<strong>Spring Integration.</strong>"</code>.</p>
</div>
<div class="paragraph">
<p>Since <code>javax.mail.internet.MimeMessage</code> is the root context of the SpEL evaluation context, you can filter on any value available through <code>MimeMessage</code>, including the actual body of the message.
This one is particularly important, since reading the body of the message typically results in such messages being marked as <code>SEEN</code> by default.
However, since we now set the <code>PEEK</code> flag of every incoming message to 'true', only messages that were explicitly marked as <code>SEEN</code> are marked as read.</p>
</div>
<div class="paragraph">
<p>So, in the following example, only messages that match the filter expression are output by this adapter and only those messages are marked as read:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:imap-idle-channel-adapter id="customAdapter"
	store-uri="imaps://some_google_address:${password}@imap.gmail.com/INBOX"
	channel="receiveChannel"
	should-mark-messages-as-read="true"
	java-mail-properties="javaMailProperties"
	mail-filter-expression="subject matches '(?i).*Spring Integration.*'"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, thanks to the <code>mail-filter-expression</code> attribute, only messages that contain 'Spring Integration' in the subject line are produced by this adapter.</p>
</div>
<div class="paragraph">
<p>Another reasonable question is what happens on the next poll or idle event or what happens when such an adapter is restarted.
Can there be duplication of massages to be filtered? In other words, if, on the last retrieval where you had five new messages and only one passed the filter, what would happen with the other four?
Would they go through the filtering logic again on the next poll or idle? After all, they were not marked as <code>SEEN</code>.
The answer is no.
They would not be subject to duplicate processing due to another flag (<code>RECENT</code>) that is set by the email server and is used by the Spring Integration mail search filter.
Folder implementations set this flag to indicate that this message is new to this folder.
That is, it has arrived since the last time this folder was opened.
In other words, while our adapter may peek at the email, it also lets the email server know that such email was touched and should therefore be marked as <code>RECENT</code> by the email server.</p>
</div>
</div>
<div class="sect2">
<h3 id="mail-tx-sync"><a class="anchor" href="#mail-tx-sync"></a>24.7. Transaction Synchronization</h3>
<div class="paragraph">
<p>Transaction synchronization for inbound adapters lets you take different actions after a transaction commits or rolls back.
You can enable transaction synchronization by adding a <code>&lt;transactional/&gt;</code> element to the poller for the polled <code>&lt;inbound-adapter/&gt;</code> or to the <code>&lt;imap-idle-inbound-adapter/&gt;</code>.
Even if there is no 'real' transaction involved, you can still enable this feature by using a <code>PseudoTransactionManager</code> with the <code>&lt;transactional/&gt;</code> element.
For more information, see <a href="#transaction-synchronization">Transaction Synchronization</a>.</p>
</div>
<div class="paragraph">
<p>Because of the many different mail servers and specifically the limitations that some have, at this time we provide only a strategy for these transaction synchronizations.
You can send the messages to some other Spring Integration components or invoke a custom bean to perform some action.
For example, to move an IMAP message to a different folder after the transaction commits, you might use something similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mail:imap-idle-channel-adapter id="customAdapter"
    store-uri="imaps://something.com:password@imap.something.com/INBOX"
    channel="receiveChannel"
    auto-startup="true"
    should-delete-messages="false"
    java-mail-properties="javaMailProperties"&gt;
    &lt;int:transactional synchronization-factory="syncFactory"/&gt;
&lt;/int-mail:imap-idle-channel-adapter&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-commit expression="@syncProcessor.process(payload)"/&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;bean id="syncProcessor" class="thing1.thing2.Mover"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows what the <code>Mover</code> class might look like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Mover {

    public void process(MimeMessage message) throws Exception{
        Folder folder = message.getFolder();
        folder.open(Folder.READ_WRITE);
        String messageId = message.getMessageID();
        Message[] messages = folder.getMessages();
        FetchProfile contentsProfile = new FetchProfile();
        contentsProfile.add(FetchProfile.Item.ENVELOPE);
        contentsProfile.add(FetchProfile.Item.CONTENT_INFO);
        contentsProfile.add(FetchProfile.Item.FLAGS);
        folder.fetch(messages, contentsProfile);
        // find this message and mark for deletion
        for (int i = 0; i &lt; messages.length; i++) {
            if (((MimeMessage) messages[i]).getMessageID().equals(messageId)) {
                messages[i].setFlag(Flags.Flag.DELETED, true);
                break;
            }
        }

        Folder somethingFolder = store.getFolder("SOMETHING"));
        somethingFolder.appendMessages(new MimeMessage[]{message});
        folder.expunge();
        folder.close(true);
        somethingFolder.close(false);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the message to be still available for manipulation after the transaction, <em>should-delete-messages</em> must be set to 'false'.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="java-dsl-configuration"><a class="anchor" href="#java-dsl-configuration"></a>24.8. Configuring channel adapters with the Java DSL</h3>
<div class="paragraph">
<p>To configure mail mail component in Java DSL, the framework provides a <code>o.s.i.mail.dsl.Mail</code> factory, which can be used like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MailApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MailApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow imapMailFlow() {
        return IntegrationFlows
                .from(Mail.imapInboundAdapter("imap://user:pw@host:port/INBOX")
                            .searchTermStrategy(this::fromAndNotSeenTerm)
                            .userFlag("testSIUserFlag")
                            .simpleContent(true)
                            .javaMailProperties(p -&gt; p.put("mail.debug", "false")),
                    e -&gt; e.autoStartup(true)
                            .poller(p -&gt; p.fixedDelay(1000)))
                .channel(MessageChannels.queue("imapChannel"))
                .get();
    }

    @Bean
    public IntegrationFlow sendMailFlow() {
        return IntegrationFlows.from("sendMailChannel")
                .enrichHeaders(Mail.headers()
                        .subjectFunction(m -&gt; "foo")
                        .from("foo@bar")
                        .toFunction(m -&gt; new String[] { "bar@baz" }))
                .handle(Mail.outboundAdapter("gmail")
                            .port(smtpServer.getPort())
                            .credentials("user", "pw")
                            .protocol("smtp")),
                    e -&gt; e.id("sendMailEndpoint"))
                .get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mongodb"><a class="anchor" href="#mongodb"></a>25. MongoDb Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Version 2.1 introduced support for <a href="https://www.mongodb.org/">MongoDB</a>: a &#8220;high-performance, open source, document-oriented database&#8221;.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-mongodb&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-mongodb:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To download, install, and run MongoDB, see the <a href="https://www.mongodb.org/downloads">MongoDB documentation</a>.</p>
</div>
<div class="sect2">
<h3 id="mongodb-connection"><a class="anchor" href="#mongodb-connection"></a>25.1. Connecting to MongoDb</h3>
<div class="paragraph">
<p>To begin interacting with MongoDB, you first need to connect to it.
Spring Integration builds on the support provided by another Spring project, <a href="https://projects.spring.io/spring-data-mongodb/">Spring Data MongoDB</a>.
It provides a factory class called <code>MongoDbFactory</code>, which simplifies integration with the MongoDB Client API.</p>
</div>
<div class="sect3">
<h4 id="using-mongodbfactory"><a class="anchor" href="#using-mongodbfactory"></a>25.1.1. Using <code>MongoDbFactory</code></h4>
<div class="paragraph">
<p>To connect to MongoDB you can use an implementation of the <code>MongoDbFactory</code> interface.
The following listing shows the <code>MongoDbFactory</code> interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface MongoDbFactory {

    /**
     * Creates a default {@link DB} instance.
     *
     * @return the DB instance
     * @throws DataAccessException
     */
    DB getDb() throws DataAccessException;

    /**
     * Creates a {@link DB} instance to access the database with the given name.
     *
     * @param dbName must not be {@literal null} or empty.
     *
     * @return the DB instance
     * @throws DataAccessException
     */
    DB getDb(String dbName) throws DataAccessException;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>SimpleMongoDbFactory</code>, the out-of-the-box implementation, in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MongoDbFactory mongoDbFactory = new SimpleMongoDbFactory(new Mongo(), "test");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>SimpleMongoDbFactory</code> in XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="mongoDbFactory" class="o.s.data.mongodb.core.SimpleMongoDbFactory"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="com.mongodb.Mongo"/&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg value="test"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>SimpleMongoDbFactory</code> takes two arguments: a <code>Mongo</code> instance and a <code>String</code> that specifies the name of the database.
If you need to configure properties such as <code>host</code>, <code>port</code>, and others, you can pass those by using one of the constructors provided by the underlying <code>Mongo</code> class.
For more information on how to configure MongoDB, see the <a href="https://docs.spring.io/spring-data/data-mongo/docs/current/reference/html/">Spring-Data-MongoDB</a> reference.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-message-store"><a class="anchor" href="#mongodb-message-store"></a>25.2. MongoDB Message Store</h3>
<div class="paragraph">
<p>As described in the <em>Enterprise Integration Patterns</em> (EIP) book, a <a href="https://www.enterpriseintegrationpatterns.com/MessageStore.html">Message Store</a> lets you persist messages.
Doing so can be useful when dealing with components that have the ability to buffer messages (<code>QueueChannel</code>, <code>aggregator</code>, <code>resequencer</code>, and others.) if reliability is a concern.
In Spring Integration, the <code>MessageStore</code> strategy also provides the foundation for the <a href="https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">claim check</a> pattern, which is described in EIP as well.</p>
</div>
<div class="paragraph">
<p>Spring Integration&#8217;s MongoDB module provides the <code>MongoDbMessageStore</code>, which is an implementation of both the <code>MessageStore</code> strategy (mainly used by the claim check pattern) and the <code>MessageGroupStore</code> strategy (mainly used by the aggregator and resequencer patterns).</p>
</div>
<div class="paragraph">
<p>The following example configures a <code>MongoDbMessageStore</code> to use a <code>QueueChannel</code> and an <code>aggregator</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="mongoDbMessageStore" class="o.s.i.mongodb.store.MongoDbMessageStore"&gt;
    &lt;constructor-arg ref="mongoDbFactory"/&gt;
&lt;/bean&gt;

&lt;int:channel id="somePersistentQueueChannel"&gt;
    &lt;int:queue message-store="mongoDbMessageStore"/&gt;
&lt;int:channel&gt;

&lt;int:aggregator input-channel="inputChannel" output-channel="outputChannel"
         message-store="mongoDbMessageStore"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example is a simple bean configuration, and it expects a <code>MongoDbFactory</code> as a constructor argument.</p>
</div>
<div class="paragraph">
<p>The <code>MongoDbMessageStore</code> expands the <code>Message</code> as a Mongo document with all nested properties by using the Spring Data Mongo mapping mechanism.
It is useful when you need to have access to the <code>payload</code> or <code>headers</code> for auditing or analytics&#8201;&#8212;&#8201;for example, against stored messages.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>MongoDbMessageStore</code> uses a custom <code>MappingMongoConverter</code> implementation to store <code>Message</code> instances as MongoDB documents, and there are some limitations for the properties (<code>payload</code> and <code>header</code> values) of the <code>Message</code>.
For example, there is no ability to configure custom converters for complex domain <code>payload</code> instances or <code>header</code> values.
There is also no way to provide a custom <code>MongoTemplate</code> (or <code>MappingMongoConverter</code>).
To achieve these capabilities, an alternative MongoDB <code>MessageStore</code> implementation has been introduced (we describe it next).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Integration 3.0 introduced the <code>ConfigurableMongoDbMessageStore</code>.
It implements both the <code>MessageStore</code> and <code>MessageGroupStore</code> interfaces.
This class can receive, as a constructor argument, a <code>MongoTemplate</code>, with which you can, for example, configure a custom <code>WriteConcern</code>.
Another constructor requires a <code>MappingMongoConverter</code> and a <code>MongoDbFactory</code>, which lets you provide some custom conversions for <code>Message</code> instances and their properties.
Note that, by default, the <code>ConfigurableMongoDbMessageStore</code> uses standard Java serialization to write and read <code>Message</code> instances to and from MongoDB (see <code>MongoDbMessageBytesConverter</code>) and relies on default values for other properties from <code>MongoTemplate</code>.
It builds a <code>MongoTemplate</code> from the provided <code>MongoDbFactory</code> and <code>MappingMongoConverter</code>.
The default name for the collection stored by the <code>ConfigurableMongoDbMessageStore</code> is <code>configurableStoreMessages</code>.
We recommend using this implementation to create robust and flexible solutions when messages contain complex data types.</p>
</div>
<div class="sect3">
<h4 id="mongodb-priority-channel-message-store"><a class="anchor" href="#mongodb-priority-channel-message-store"></a>25.2.1. MongoDB Channel Message Store</h4>
<div class="paragraph">
<p>Version 4.0 introduced the new <code>MongoDbChannelMessageStore</code>.
It is an optimized <code>MessageGroupStore</code> for use in <code>QueueChannel</code> instances.
With <code>priorityEnabled = true</code>, you can use it in <code>&lt;int:priority-queue&gt;</code> instances to achieve priority-order polling for persisted messages.
The priority MongoDB document field is populated from the <code>IntegrationMessageHeaderAccessor.PRIORITY</code> (<code>priority</code>) message header.</p>
</div>
<div class="paragraph">
<p>In addition, all MongoDB <code>MessageStore</code> instances now have a <code>sequence</code> field for <code>MessageGroup</code> documents.
The <code>sequence</code> value is the result of an <code>$inc</code> operation for a simple <code>sequence</code> document from the same collection, which is created on demand.
The <code>sequence</code> field is used in <code>poll</code> operations to provide first-in-first-out (FIFO) message order (within priority, if configured) when messages are stored within the same millisecond.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We do not recommend using the same <code>MongoDbChannelMessageStore</code> bean for priority and non-priority, because the <code>priorityEnabled</code> option applies to the entire store.
However, the same <code>collection</code> can be used for both <code>MongoDbChannelMessageStore</code> types, because message polling from the store is sorted and uses indexes.
To configure that scenario, you can extend one message store bean from the other, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="channelStore" class="o.s.i.mongodb.store.MongoDbChannelMessageStore"&gt;
    &lt;constructor-arg name="mongoDbFactory" ref="mongoDbFactory"/&gt;
&lt;/bean&gt;

&lt;int:channel id="queueChannel"&gt;
    &lt;int:queue message-store="store"/&gt;
&lt;/int:channel&gt;

&lt;bean id="priorityStore" parent="channelStore"&gt;
    &lt;property name="priorityEnabled" value="true"/&gt;
&lt;/bean&gt;

&lt;int:channel id="priorityChannel"&gt;
    &lt;int:priority-queue message-store="priorityStore"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mongodb-metadata-store"><a class="anchor" href="#mongodb-metadata-store"></a>25.2.2. MongoDB Metadata Store</h4>
<div class="paragraph">
<p>Spring Integration 4.2 introduced a new MongoDB-based <code>MetadataStore</code> (see <a href="#metadata-store">Metadata Store</a>) implementation.
You can use the <code>MongoDbMetadataStore</code> to maintain metadata state across application restarts.
You can use this new <code>MetadataStore</code> implementation with adapters such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#feed-inbound-channel-adapter">Feed</a></p>
</li>
<li>
<p><a href="#file-reading">File</a></p>
</li>
<li>
<p><a href="#ftp-inbound">FTP</a></p>
</li>
<li>
<p><a href="#sftp-inbound">SFTP</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To instruct these adapters to use the new <code>MongoDbMetadataStore</code>, declare a Spring bean with a bean name of <code>metadataStore</code>.
The feed inbound channel adapter automatically picks up and use the declared <code>MongoDbMetadataStore</code>.
The following example shows how to declare a bean with a name of <code>metadataStore</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MetadataStore metadataStore(MongoDbFactory factory) {
    return new MongoDbMetadataStore(factory, "integrationMetadataStore");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>MongoDbMetadataStore</code> also implements <code>ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances, where only one instance is allowed to store or modify a key&#8217;s value.
All these operations are atomic, thanks to MongoDB guarantees.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-inbound-channel-adapter"><a class="anchor" href="#mongodb-inbound-channel-adapter"></a>25.3. MongoDB Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The MongoDB inbound channel adapter is a polling consumer that reads data from MongoDB and sends it as a <code>Message</code> payload.
The following example shows how to configure a MongoDB inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mongodb:inbound-channel-adapter id="mongoInboundAdapter"
       channel="replyChannel"
       query="{'name' : 'Bob'}"
       entity-class="java.lang.Object"
       auto-startup="false"&gt;
		&lt;int:poller fixed-rate="100"/&gt;
&lt;/int-mongodb:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding configuration shows, you configure a MongoDb inbound channel adapter by using the <code>inbound-channel-adapter</code> element and providing values for various attributes, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>query</code>: A JSON query (see <a href="https://www.mongodb.org/display/DOCS/Querying">MongoDB Querying</a>)</p>
</li>
<li>
<p><code>query-expression</code>: A SpEL expression that is evaluated to a JSON query string (as the <code>query</code> attribute above) or to an instance of <code>o.s.data.mongodb.core.query.Query</code>.
Mutually exclusive with the <code>query</code> attribute.</p>
</li>
<li>
<p><code>entity-class</code>: The type of the payload object.
If not supplied, a <code>com.mongodb.DBObject</code> is returned.</p>
</li>
<li>
<p><code>collection-name</code> or <code>collection-name-expression</code>: Identifies the name of the MongoDB collection to use.</p>
</li>
<li>
<p><code>mongodb-factory</code>: Reference to an instance of <code>o.s.data.mongodb.MongoDbFactory</code></p>
</li>
<li>
<p><code>mongo-template</code>: Reference to an instance of <code>o.s.data.mongodb.core.MongoTemplate</code></p>
</li>
<li>
<p>Other attributes that are common across all other inbound adapters (such as 'channel').</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot set both <code>mongo-template</code> and <code>mongodb-factory</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding example is relatively simple and static, since it has a literal value for the <code>query</code> and uses the default name for a <code>collection</code>.
Sometimes, you may need to change those values at runtime, based on some condition.
To do so, use their <code>-expression</code> equivalents (<code>query-expression</code> and <code>collection-name-expression</code>), where the provided expression can be any valid SpEL expression.</p>
</div>
<div class="paragraph">
<p>Also, you may wish to do some post-processing to the successfully processed data that was read from the MongoDB.
For example; you may want to move or remove a document after it has been processed.
You can do so by using that transaction synchronization feature Spring Integration 2.2 added, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mongodb:inbound-channel-adapter id="mongoInboundAdapter"
    channel="replyChannel"
    query-expression="new BasicQuery('{''name'' : ''Bob''}').limit(100)"
    entity-class="java.lang.Object"
    auto-startup="false"&gt;
        &lt;int:poller fixed-rate="200" max-messages-per-poll="1"&gt;
            &lt;int:transactional synchronization-factory="syncFactory"/&gt;
        &lt;/int:poller&gt;
&lt;/int-mongodb:inbound-channel-adapter&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-commit
        expression="@documentCleaner.remove(#mongoTemplate, payload, headers.mongo_collectionName)"
        channe="someChannel"/&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;bean id="documentCleaner" class="thing1.thing2.DocumentCleaner"/&gt;

&lt;bean id="transactionManager" class="o.s.i.transaction.PseudoTransactionManager"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the <code>DocumentCleaner</code> referenced in the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DocumentCleaner {
    public void remove(MongoOperations mongoOperations, Object target, String collectionName) {
        if (target instanceof List&lt;?&gt;){
            List&lt;?&gt; documents = (List&lt;?&gt;) target;
            for (Object document : documents) {
                mongoOperations.remove(new BasicQuery(JSON.serialize(document)), collectionName);
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can declare your poller to be transactional by using the <code>transactional</code> element.
This element can reference a real transaction manager (for example, if some other part of your flow invokes JDBC).
If you do not have a &#8220;real&#8221; transaction, you can use an instance of <code>o.s.i.transaction.PseudoTransactionManager</code>, which is an implementation of Spring&#8217;s <code>PlatformTransactionManager</code> and enables the use of the transaction synchronization features of the Mongo adapter when there is no actual transaction.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Doing so does not make MongoDB itself transactional.
It lets the synchronization of actions be taken before or after success (commit) or after failure (rollback).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once your poller is transactional, you can set an instance of the <code>o.s.i.transaction.TransactionSynchronizationFactory</code> on the <code>transactional</code> element.
A <code>TransactionSynchronizationFactory</code> creates an instance of the <code>TransactionSynchronization</code>.
For your convenience, we have exposed a default SpEL-based <code>TransactionSynchronizationFactory</code> that lets you configure SpEL expressions, with their execution being coordinated (synchronized) with a transaction.
Expressions for before-commit, after-commit, and after-rollback events are supported, together with a channel for each event where the evaluation result (if any) is sent.
For each child element, you can specify <code>expression</code> and <code>channel</code> attributes.
If only the <code>channel</code> attribute is present, the received message is sent there as part of the particular synchronization scenario.
If only the <code>expression</code> attribute is present and the result of an expression is a non-null value, a message with the result as the payload is generated and sent to a default channel (<code>NullChannel</code>) and appears in the logs (on the <code>DEBUG</code> level).
If you want the evaluation result to go to a specific channel, add a <code>channel</code> attribute.
If the result of an expression is null or void, no message is generated.</p>
</div>
<div class="paragraph">
<p>For more information about transaction synchronization, see <a href="#transaction-synchronization">Transaction Synchronization</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-outbound-channel-adapter"><a class="anchor" href="#mongodb-outbound-channel-adapter"></a>25.4. MongoDB Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The MongoDB outbound channel adapter lets you write the message payload to a MongoDB document store, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mongodb:outbound-channel-adapter id="fullConfigWithCollectionExpression"
	collection-name="myCollection"
	mongo-converter="mongoConverter"
	mongodb-factory="mongoDbFactory" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding configuration shows, you can configure a MongoDB outbound channel adapter by using the <code>outbound-channel-adapter</code> element, providing values for various attributes, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>collection-name</code> or <code>collection-name-expression</code>: Identifies the name of the MongoDb collection to use.</p>
</li>
<li>
<p><code>mongo-converter</code>: Reference to an instance of <code>o.s.data.mongodb.core.convert.MongoConverter</code> that assists with converting a raw Java object to a JSON document representation.</p>
</li>
<li>
<p><code>mongodb-factory</code>: Reference to an instance of <code>o.s.data.mongodb.MongoDbFactory</code>.</p>
</li>
<li>
<p><code>mongo-template</code>: Reference to an instance of <code>o.s.data.mongodb.core.MongoTemplate</code>.
NOTE: you can not have both mongo-template and mongodb-factory set.</p>
</li>
<li>
<p>Other attributes that are common across all other inbound adapters (such as 'channel').</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The preceding example is relatively simple and static, since it has a literal value for the <code>collection-name</code>.
Sometimes, you may need to change this value at runtime, based on some condition.
To do that,  use <code>collection-name-expression</code>, where the provided expression is any valid SpEL expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="mongodb-outbound-gateway"><a class="anchor" href="#mongodb-outbound-gateway"></a>25.5. MongoDB Outbound Gateway</h3>
<div class="paragraph">
<p>Version 5.0 introduced the MongoDB outbound gateway.
It allows you query a database by sending a message to its request channel.
The gateway then send the response to the reply channel.
You can use the message payload and headers to specify the query and the collection name, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mongodb:outbound-gateway id="gatewayQuery"
    mongodb-factory="mongoDbFactory"
    mongo-converter="mongoConverter"
    query="{firstName: 'Bob'}"
    collection-name="myCollection"
    request-channel="in"
    reply-channel="out"
    entity-class="org.springframework.integration.mongodb.test.entity$Person"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the following attributes with a MongoDB outbound Gateway:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>collection-name</code> or <code>collection-name-expression</code>: Identifies the name of the MongoDB collection to use.</p>
</li>
<li>
<p><code>mongo-converter</code>: Reference to an instance of <code>o.s.data.mongodb.core.convert.MongoConverter</code> that assists with converting a raw Java object to a JSON document representation.</p>
</li>
<li>
<p><code>mongodb-factory</code>: Reference to an instance of <code>o.s.data.mongodb.MongoDbFactory</code>.</p>
</li>
<li>
<p><code>mongo-template</code>: Reference to an instance of <code>o.s.data.mongodb.core.MongoTemplate</code>.
NOTE: you can not set both <code>mongo-template</code> and <code>mongodb-factory</code>.</p>
</li>
<li>
<p><code>entity-class</code>: The fully qualified name of the entity class to be passed to the <code>find(..)</code> and <code>findOne(..)</code> methods in MongoTemplate.
If this attribute is not provided, the default value is <code>org.bson.Document</code>.</p>
</li>
<li>
<p><code>query</code> or <code>query-expression</code>: Specifies the MongoDB query.
See the <a href="https://www.mongodb.org/display/DOCS/Querying">MongoDB documentation</a> for more query samples.</p>
</li>
<li>
<p><code>collection-callback</code>: Reference to an instance of <code>org.springframework.data.mongodb.core.CollectionCallback</code>.
Preferable an instance of <code>o.s.i.mongodb.outbound.MessageCollectionCallback</code> since 5.0.11 with the request message context.
See its Javadocs for more information.
NOTE: You can not have both <code>collection-callback</code> and any of the query attributes.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-17"><a class="anchor" href="#configuring-with-java-configuration-17"></a>25.5.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MongoDbJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MongoDbJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private MongoDbFactory mongoDbFactory;

    @Bean
    @ServiceActivator(inputChannel = "requestChannel")
    public MessageHandler mongoDbOutboundGateway() {
        MongoDbOutboundGateway gateway = new MongoDbOutboundGateway(this.mongoDbFactory);
        gateway.setCollectionNameExpressionString("'myCollection'");
        gateway.setQueryExpressionString("'{''name'' : ''Bob''}'");
        gateway.setExpectSingleResult(true);
        gateway.setEntityClass(Person.class);
        gateway.setOutputChannelName("replyChannel");
        return gateway;
    }

    @Bean
    @ServiceActivator(inputChannel = "replyChannel")
    public MessageHandler handler() {
        return message -&gt; System.out.println(message.getPayload());
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-18"><a class="anchor" href="#configuring-with-the-java-dsl-18"></a>25.5.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application show an example of how to configure the outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MongoDbJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MongoDbJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Autowired
    private MongoDbFactory;

    @Autowired
    private MongoConverter;


    @Bean
    public IntegrationFlow gatewaySingleQueryFlow() {
        return f -&gt; f
                .handle(queryOutboundGateway())
                .channel(c -&gt; c.queue("retrieveResults"));
    }

    private MongoDbOutboundGatewaySpec queryOutboundGateway() {
        return MongoDb.outboundGateway(this.mongoDbFactory, this.mongoConverter)
                .query("{name : 'Bob'}")
                .collectionNameFunction(m -&gt; m.getHeaders().get("collection"))
                .expectSingleResult(true)
                .entityClass(Person.class);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an alternate to the <code>query</code> and <code>query-expression</code> properties, you can specify other database operations by using the <code>collectionCallback</code> property as a reference to the <code>MessageCollectionCallback</code> functional interface implementation.
The following example specifies a count operation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private MongoDbOutboundGatewaySpec collectionCallbackOutboundGateway() {
    return MongoDb.outboundGateway(this.mongoDbFactory, this.mongoConverter)
            .collectionCallback((collection, requestMessage) -&gt; collection.count())
            .collectionName("myCollection");
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mqtt"><a class="anchor" href="#mqtt"></a>26. MQTT Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides inbound and outbound channel adapters to support the Message Queueing Telemetry Transport (MQTT) protocol.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-mqtt&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-mqtt:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The current implementation uses the <a href="https://www.eclipse.org/paho/">Eclipse Paho MQTT Client</a> library.</p>
</div>
<div class="paragraph">
<p>Configuration of both adapters is achieved using the <code>DefaultMqttPahoClientFactory</code>.
Refer to the Paho documentation for more information about configuration options.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We recommend configuring an <code>MqttConnectOptions</code> object and injecting it into the factory, instead of setting the (deprecated) options on the factory itself.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="mqtt-inbound"><a class="anchor" href="#mqtt-inbound"></a>26.1. Inbound (Message-driven) Channel Adapter</h3>
<div class="paragraph">
<p>The inbound channel adapter is implemented by the <code>MqttPahoMessageDrivenChannelAdapter</code>.
For convenience, you can configure it by using the namespace.
A minimal configuration might be as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="clientFactory"
        class="org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory"&gt;
    &lt;property name="connectionOptions"&gt;
        &lt;bean class="org.eclipse.paho.client.mqttv3.MqttConnectOptions"&gt;
            &lt;property name="userName" value="${mqtt.username}"/&gt;
            &lt;property name="password" value="${mqtt.password}"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;int-mqtt:message-driven-channel-adapter id="mqttInbound"
    client-id="${mqtt.default.client.id}.src"
    url="${mqtt.url}"
    topics="sometopic"
    client-factory="clientFactory"
    channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the available attributes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mqtt:message-driven-channel-adapter id="oneTopicAdapter"
    client-id="foo"  <i class="conum" data-value="1"></i><b>(1)</b>
    url="tcp://localhost:1883"  <i class="conum" data-value="2"></i><b>(2)</b>
    topics="bar,baz"  <i class="conum" data-value="3"></i><b>(3)</b>
    qos="1,2"  <i class="conum" data-value="4"></i><b>(4)</b>
    converter="myConverter"  <i class="conum" data-value="5"></i><b>(5)</b>
    client-factory="clientFactory"  <i class="conum" data-value="6"></i><b>(6)</b>
    send-timeout="123"  <i class="conum" data-value="7"></i><b>(7)</b>
    error-channel="errors"  <i class="conum" data-value="8"></i><b>(8)</b>
    recovery-interval="10000"  <i class="conum" data-value="9"></i><b>(9)</b>
    channel="out" /&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The client ID.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The broker URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A comma-separated list of topics from which this adapter receives messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A comma-separated list of QoS values.
It can be a single value that is applied to all topics or a value for each topic (in which case, the lists must be the same length).</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>An <code>MqttMessageConverter</code> (optional).
By default, the default <code>DefaultPahoMessageConverter</code> produces a message with a <code>String</code> payload with the following headers:
<div class="ulist">
<ul>
<li>
<p><code>mqtt_topic</code>: The topic from which the message was received</p>
</li>
<li>
<p><code>mqtt_duplicate</code>: <code>true</code> if the message is a duplicate</p>
</li>
<li>
<p><code>mqtt_qos</code>: The quality of service
You can configure the <code>DefaultPahoMessageConverter</code> to return the raw <code>byte[]</code> in the payload by declaring it as a <code>&lt;bean/&gt;</code> and setting the <code>payloadAsBytes</code> property to <code>true</code>.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The client factory.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The send timeout.
It applies only if the channel might block (such as a bounded <code>QueueChannel</code> that is currently full).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The error channel.
Downstream exceptions are sent to this channel, if supplied, in an <code>ErrorMessage</code>.
The payload is a <code>MessagingException</code> that contains the failed message and cause.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The recovery interval.
It controls the interval at which the adapter attempts to reconnect after a failure.
It defaults to <code>10000ms</code> (ten seconds).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 4.1, you can omit the URL.
Instead, you can provide the server URIs in the <code>serverURIs</code> property of the <code>DefaultMqttPahoClientFactory</code>.
Doing so enables, for example, connection to a highly available (HA) cluster.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.2.2, an <code>MqttSubscribedEvent</code> is published when the adapter successfully subscribes to the topics.
<code>MqttConnectionFailedEvent</code> events are published when the connection or subscription fails.
These events can be received by a bean that implements <code>ApplicationListener</code>.</p>
</div>
<div class="paragraph">
<p>Also, a new property called <code>recoveryInterval</code> controls the interval at which the adapter attempts to reconnect after a failure.
It defaults to <code>10000ms</code> (ten seconds).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Prior to version 4.2.3, the client always unsubscribed when the adapter was stopped.
This was incorrect because, if the client QOS is greater than 0, we need to keep the subscription active so that messages arriving
while the adapter is stopped are delivered on the next start.
This also requires setting the <code>cleanSession</code> property on the client factory to <code>false</code>.
It defaults to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2.3, the adapter does not unsubscribe (by default) if the <code>cleanSession</code> property is <code>false</code>.</p>
</div>
<div class="paragraph">
<p>This behavior can be overridden by setting the <code>consumerCloseAction</code> property on the factory.
It can have values: <code>UNSUBSCRIBE_ALWAYS</code>, <code>UNSUBSCRIBE_NEVER</code>, and <code>UNSUBSCRIBE_CLEAN</code>.
The latter (the default) unsubscribes only if the <code>cleanSession</code> property is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>To revert to the pre-4.2.3 behavior, use <code>UNSUBSCRIBE_ALWAYS</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with version 5.0, the <code>topic</code>, <code>qos</code>, and <code>retained</code> properties are mapped to <code>.RECEIVED_&#8230;&#8203;</code> headers (<code>MqttHeaders.RECEIVED_TOPIC</code>, <code>MqttHeaders.RECEIVED_QOS</code>, and <code>MqttHeaders.RECEIVED_RETAINED</code>), to avoid inadvertent propagation to an outbound message that (by default) uses the <code>MqttHeaders.TOPIC</code>, <code>MqttHeaders.QOS</code>, and <code>MqttHeaders.RETAINED</code> headers.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="adding-and-removing-topics-at-runtime"><a class="anchor" href="#adding-and-removing-topics-at-runtime"></a>26.1.1. Adding and Removing Topics at Runtime</h4>
<div class="paragraph">
<p>Starting with version 4.1, you can programmatically change the topics to which the adapter is subscribed.
Spring Integration provides the  <code>addTopic()</code> and <code>removeTopic()</code> methods.
When adding topics, you can optionally specify the <code>QoS</code> (default: 1).
You can also modify the topics by sending an appropriate message to a <code>&lt;control-bus/&gt;</code> with an appropriate payload&#8201;&#8212;&#8201;for example: <code>"myMqttAdapter.addTopic('foo', 1)"</code>.</p>
</div>
<div class="paragraph">
<p>Stopping and starting the adapter has no effect on the topic list (it does not revert to the original settings in the configuration).
The changes are not retained beyond the life cycle of the application context.
A new application context reverts to the configured settings.</p>
</div>
<div class="paragraph">
<p>Changing the topics while the adapter is stopped (or disconnected from the broker) takes effect the next time a connection is established.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-18"><a class="anchor" href="#configuring-with-java-configuration-18"></a>26.1.2. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MqttJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MqttJavaApplication.class)
                .web(false)
                .run(args);
    }

    @Bean
    public MessageChannel mqttInputChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageProducer inbound() {
        MqttPahoMessageDrivenChannelAdapter adapter =
                new MqttPahoMessageDrivenChannelAdapter("tcp://localhost:1883", "testClient",
                                                 "topic1", "topic2");
        adapter.setCompletionTimeout(5000);
        adapter.setConverter(new DefaultPahoMessageConverter());
        adapter.setQos(1);
        adapter.setOutputChannel(mqttInputChannel());
        return adapter;
    }

    @Bean
    @ServiceActivator(inputChannel = "mqttInputChannel")
    public MessageHandler handler() {
        return new MessageHandler() {

            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-19"><a class="anchor" href="#configuring-with-the-java-dsl-19"></a>26.1.3. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application provides an example of configuring the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MqttJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MqttJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow mqttInbound() {
        return IntegrationFlows.from(
                         new MqttPahoMessageDrivenChannelAdapter("tcp://localhost:1883",
                                        "testClient", "topic1", "topic2");)
                .handle(m -&gt; System.out.println(m.getPayload()))
                .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mqtt-outbound"><a class="anchor" href="#mqtt-outbound"></a>26.2. Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The outbound channel adapter is implemented by the <code>MqttPahoMessageHandler</code>, which is wrapped in a <code>ConsumerEndpoint</code>.
For convenience, you can configure it by using the namespace.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.1, the adapter supports asynchronous send operations, avoiding blocking until the delivery is confirmed.
You can emit application events to enable applications to confirm delivery if desired.</p>
</div>
<div class="paragraph">
<p>The following listing shows the attributes available for an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-mqtt:outbound-channel-adapter id="withConverter"
    client-id="foo"  <i class="conum" data-value="1"></i><b>(1)</b>
    url="tcp://localhost:1883"  <i class="conum" data-value="2"></i><b>(2)</b>
    converter="myConverter"  <i class="conum" data-value="3"></i><b>(3)</b>
    client-factory="clientFactory"  <i class="conum" data-value="4"></i><b>(4)</b>
    default-qos="1"  <i class="conum" data-value="5"></i><b>(5)</b>
    qos-expression="" <i class="conum" data-value="6"></i><b>(6)</b>
    default-retained="true"  <i class="conum" data-value="7"></i><b>(7)</b>
    retained-expression="" <i class="conum" data-value="8"></i><b>(8)</b>
    default-topic="bar"  <i class="conum" data-value="9"></i><b>(9)</b>
    topic-expression="" <i class="conum" data-value="10"></i><b>(10)</b>
    async="false"  <i class="conum" data-value="11"></i><b>(11)</b>
    async-events="false"  <i class="conum" data-value="12"></i><b>(12)</b>
    channel="target" /&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The client ID.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The broker URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An <code>MqttMessageConverter</code> (optional).
The default <code>DefaultPahoMessageConverter</code> recognizes the following headers:
<div class="ulist">
<ul>
<li>
<p><code>mqtt_topic</code>: The topic to which the message will be sent</p>
</li>
<li>
<p><code>mqtt_retained</code>: <code>true</code> if the message is to be retained</p>
</li>
<li>
<p><code>mqtt_qos</code>: The quality of service</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The client factory.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The default quality of service.
It is used if no <code>mqtt_qos</code> header is found or the <code>qos-expression</code> returns <code>null</code>.
It is not used if you supply a custom <code>converter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>An expression to evaluate to determine the qos.
The default is <code>headers[mqtt_qos]</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The default value of the retained flag.
It is used if no <code>mqtt_retained</code> header is found.
It is not used if a custom <code>converter</code> is supplied.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>An expression to evaluate to determine the retained boolean.
The default is <code>headers[mqtt_retained]</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The default topic to which the message is sent (used if no <code>mqtt_topic</code> header is found).</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>An expression to evaluate to determine the destination topic.
The default is <code>headers['topic']</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>When <code>true</code>, the caller does not block.
Rather, it waits for delivery confirmation when a message is sent.
The default is <code>false</code> (the send blocks until delivery is confirmed).</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>When <code>async</code> and <code>async-events</code> are both <code>true</code>, an <code>MqttMessageSentEvent</code> is emitted.
It contains the message, the topic, the <code>messageId</code> generated by the client library, the <code>clientId</code>, and the <code>clientInstance</code> (incremented each time the client is connected).
When the delivery is confirmed by the client library, an <code>MqttMessageDeliveredEvent</code> is emitted.
It contains the the <code>messageId</code>, the <code>clientId</code>, and the <code>clientInstance</code>, enabling delivery to be correlated with the send.
Any <code>ApplicationListener</code> or an event inbound channel adapter can received these events.
Note that it is possible for the <code>MqttMessageDeliveredEvent</code> to be received before the <code>MqttMessageSentEvent</code>.
The default is <code>false</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 4.1, the URL can be omitted.
Instead, the server URIs can be provided in the <code>serverURIs</code> property of the <code>DefaultMqttPahoClientFactory</code>.
This enables, for example, connection to a highly available (HA) cluster.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-19"><a class="anchor" href="#configuring-with-java-configuration-19"></a>26.2.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application show an example of how to configure the outbound adapter with Java configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class MqttJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
                new SpringApplicationBuilder(MqttJavaApplication.class)
                        .web(false)
                        .run(args);
        MyGateway gateway = context.getBean(MyGateway.class);
        gateway.sendToMqtt("foo");
    }

    @Bean
    public MqttPahoClientFactory mqttClientFactory() {
        DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
        MqttConnectOptions options = new MqttConnectOptions();
        options.setServerURIs(new String[] { "tcp://host1:1883", "tcp://host2:1883" });
        options.setUserName("username");
        options.setPassword("password".toCharArray());
        factory.setConnectionOptions(options);
        return factory;
    }

    @Bean
    @ServiceActivator(inputChannel = "mqttOutboundChannel")
    public MessageHandler mqttOutbound() {
        MqttPahoMessageHandler messageHandler =
                       new MqttPahoMessageHandler("testClient", mqttClientFactory());
        messageHandler.setAsync(true);
        messageHandler.setDefaultTopic("testTopic");
        return messageHandler;
    }

    @Bean
    public MessageChannel mqttOutboundChannel() {
        return new DirectChannel();
    }

    @MessagingGateway(defaultRequestChannel = "mqttOutboundChannel")
    public interface MyGateway {

        void sendToMqtt(String data);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-20"><a class="anchor" href="#configuring-with-the-java-dsl-20"></a>26.2.2. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application provides an example of configuring the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class MqttJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(MqttJavaApplication.class)
            .web(false)
            .run(args);
    }

   	@Bean
   	public IntegrationFlow mqttOutboundFlow() {
   	    return f -&gt; f.handle(new MqttPahoMessageHandler("tcp://host1:1883", "someMqttClient"));
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis"><a class="anchor" href="#redis"></a>27. Redis Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration 2.1 introduced support for <a href="https://redis.io/">Redis</a>: &#8220;an open source advanced key-value store&#8221;.
This support comes in the form of a Redis-based <code>MessageStore</code> as well as publish-subscribe messaging adapters that are supported by Redis through its <a href="https://redis.io/topics/pubsub"><code>PUBLISH</code>, <code>SUBSCRIBE</code>, and <code>UNSUBSCRIBE</code></a> commands.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-redis:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You also need to include Redis client dependency, e.g. Lettuce.</p>
</div>
<div class="paragraph">
<p>To download, install, and run Redis, see the <a href="https://redis.io/download">Redis documentation</a>.</p>
</div>
<div class="sect2">
<h3 id="redis-connection"><a class="anchor" href="#redis-connection"></a>27.1. Connecting to Redis</h3>
<div class="paragraph">
<p>To begin interacting with Redis, you first need to connect to it.
Spring Integration uses support provided by another Spring project, <a href="https://github.com/SpringSource/spring-data-redis">Spring Data Redis</a>, which provides typical Spring constructs: <code>ConnectionFactory</code> and <code>Template</code>.
Those abstractions simplify integration with several Redis client Java APIs.
Currently Spring Data Redis supports <a href="https://github.com/xetorthio/jedis">Jedis</a> and <a href="https://lettuce.io/">Lettuce</a>.</p>
</div>
<div class="sect3">
<h4 id="using-redisconnectionfactory"><a class="anchor" href="#using-redisconnectionfactory"></a>27.1.1. Using <code>RedisConnectionFactory</code></h4>
<div class="paragraph">
<p>To connect to Redis, you can use one of the implementations of the <code>RedisConnectionFactory</code> interface.
The following listing shows the interface definition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface RedisConnectionFactory extends PersistenceExceptionTranslator {

    /**
     * Provides a suitable connection for interacting with Redis.
     * @return connection for interacting with Redis.
     */
    RedisConnection getConnection();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to create a <code>LettuceConnectionFactory</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LettuceConnectionFactory cf = new LettuceConnectionFactory();
cf.afterPropertiesSet();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to create a <code>LettuceConnectionFactory</code> in Spring&#8217;s XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="redisConnectionFactory"
    class="o.s.data.redis.connection.lettuce.LettuceConnectionFactory"&gt;
    &lt;property name="port" value="7379" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The implementations of <code>RedisConnectionFactory</code> provide a set of properties, such as port and host, that you can set if needed.
Once you have an instance of <code>RedisConnectionFactory</code>, you can create an instance of <code>RedisTemplate</code> and inject it with the <code>RedisConnectionFactory</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-redistemplate"><a class="anchor" href="#using-redistemplate"></a>27.1.2. Using <code>RedisTemplate</code></h4>
<div class="paragraph">
<p>As with other template classes in Spring (such as <code>JdbcTemplate</code> and <code>JmsTemplate</code>) <code>RedisTemplate</code> is a helper class that simplifies Redis data access code.
For more information about <code>RedisTemplate</code> and its variations (such as <code>StringRedisTemplate</code>) see the <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/">Spring Data Redis documentation</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create an instance of <code>RedisTemplate</code> in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RedisTemplate rt = new RedisTemplate&lt;String, Object&gt;();
rt.setConnectionFactory(redisConnectionFactory);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to create an instance of <code>RedisTemplate</code> in Spring&#8217;s XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="redisTemplate"
         class="org.springframework.data.redis.core.RedisTemplate"&gt;
    &lt;property name="connectionFactory" ref="redisConnectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-messages"><a class="anchor" href="#redis-messages"></a>27.2. Messaging with Redis</h3>
<div class="paragraph">
<p>As mentioned in <a href="#redis">the introduction</a>, Redis provides support for publish-subscribe messaging through its <code>PUBLISH</code>, <code>SUBSCRIBE</code>, and <code>UNSUBSCRIBE</code> commands.
As with JMS and AMQP, Spring Integration provides message channels and adapters for sending and receiving messages through Redis.</p>
</div>
<div class="sect3">
<h4 id="redis-pub-sub-channel"><a class="anchor" href="#redis-pub-sub-channel"></a>27.2.1. Redis Publish/Subscribe channel</h4>
<div class="paragraph">
<p>Similarly to JMS, there are cases where both the producer and consumer are intended to be part of the same application, running within the same process.
You can accomplished this by using a pair of inbound and outbound channel adapters.
However, as with Spring Integration&#8217;s JMS support, there is a simpler way to address this use case.
You can create a publish-subscribe channel, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:publish-subscribe-channel id="redisChannel" topic-name="si.test.topic"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A <code>publish-subscribe-channel</code> behaves much like a normal <code>&lt;publish-subscribe-channel/&gt;</code> element from the main Spring Integration namespace.
It can be referenced by both the <code>input-channel</code> and the <code>output-channel</code> attributes of any endpoint.
The difference is that this channel is backed by a Redis topic name: a <code>String</code> value specified by the <code>topic-name</code> attribute.
However, unlike JMS, this topic does not have to be created in advance or even auto-created by Redis.
In Redis, topics are simple <code>String</code> values that play the role of an address.
The producer and consumer can communicate by using the same <code>String</code> value as their topic name.
A simple subscription to this channel means that asynchronous publish-subscribe messaging is possible between the producing and consuming endpoints.
However, unlike the asynchronous message channels created by adding a <code>&lt;queue/&gt;</code> element within a simple Spring Integration <code>&lt;channel/&gt;</code> element, the messages are not stored in an in-memory queue.
Instead, those messages are passed through Redis, which lets you rely on its support for persistence and clustering as well as its interoperability with other non-Java platforms.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-inbound-channel-adapter"><a class="anchor" href="#redis-inbound-channel-adapter"></a>27.2.2. Redis Inbound Channel Adapter</h4>
<div class="paragraph">
<p>The Redis inbound channel adapter (<code>RedisInboundChannelAdapter</code>) adapts incoming Redis messages into Spring messages in the same way as other inbound adapters.
It receives platform-specific messages (Redis in this case) and converts them to Spring messages by using a <code>MessageConverter</code> strategy.
The following example shows how to configure a Redis inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:inbound-channel-adapter id="redisAdapter"
       topics="thing1, thing2"
       channel="receiveChannel"
       error-channel="testErrorChannel"
       message-converter="testConverter" /&gt;

&lt;bean id="redisConnectionFactory"
    class="o.s.data.redis.connection.lettuce.LettuceConnectionFactory"&gt;
    &lt;property name="port" value="7379" /&gt;
&lt;/bean&gt;

&lt;bean id="testConverter" class="things.something.SampleMessageConverter" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows a simple but complete configuration of a Redis inbound channel adapter.
Note that the preceding configuration relies on the familiar Spring paradigm of auto-discovering certain beans.
In this case, the <code>redisConnectionFactory</code> is implicitly injected into the adapter.
You can specify it explicitly by using the <code>connection-factory</code> attribute instead.</p>
</div>
<div class="paragraph">
<p>Also, note that the preceding configuration injects the adapter with a custom <code>MessageConverter</code>.
The approach is similar to JMS, where <code>MessageConverter</code> instances are used to convert between Redis messages and the Spring Integration message payloads.
The default is a <code>SimpleMessageConverter</code>.</p>
</div>
<div class="paragraph">
<p>Inbound adapters can subscribe to multiple topic names, hence the comma-separated set of values in the <code>topics</code> attribute.</p>
</div>
<div class="paragraph">
<p>Since version 3.0, the inbound adapter, in addition to the existing <code>topics</code> attribute, now has the <code>topic-patterns</code> attribute.
This attribute contains a comma-separated set of Redis topic patterns.
For more information regarding Redis publish-subscribe, see <a href="https://redis.io/topics/pubsub">Redis Pub/Sub</a>.</p>
</div>
<div class="paragraph">
<p>Inbound adapters can use a <code>RedisSerializer</code> to deserialize the body of Redis messages.
The <code>serializer</code> attribute of the <code>&lt;int-redis:inbound-channel-adapter&gt;</code> can be set to an empty string, which results in a <code>null</code> value for the <code>RedisSerializer</code> property.
In this case, the raw <code>byte[]</code> bodies of Redis messages are provided as the message payloads.</p>
</div>
<div class="paragraph">
<p>Since version 5.0, you can provide an <code>Executor</code> instance to the inbound adapter by using the <code>task-executor</code> attribute of the <code>&lt;int-redis:inbound-channel-adapter&gt;</code>.
Also, the received Spring Integration messages now have the <code>RedisHeaders.MESSAGE_SOURCE</code> header to indicate the source of the published message: topic or pattern.
You can use this downstream for routing logic.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-outbound-channel-adapter"><a class="anchor" href="#redis-outbound-channel-adapter"></a>27.2.3. Redis Outbound Channel Adapter</h4>
<div class="paragraph">
<p>The Redis outbound channel adapter adapts outgoing Spring Integration messages into Redis messages in the same way as other outbound adapters.
It receives Spring Integration messages and converts them to platform-specific messages (Redis in this case) by using a <code>MessageConverter</code> strategy.
The following example shows how to configure a Redis outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:outbound-channel-adapter id="outboundAdapter"
    channel="sendChannel"
    topic="thing1"
    message-converter="testConverter"/&gt;

&lt;bean id="redisConnectionFactory"
    class="o.s.data.redis.connection.lettuce.LettuceConnectionFactory"&gt;
    &lt;property name="port" value="7379"/&gt;
&lt;/bean&gt;

&lt;bean id="testConverter" class="things.something.SampleMessageConverter" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration parallels the Redis inbound channel adapter.
The adapter is implicitly injected with a <code>RedisConnectionFactory</code>, which is defined with <code>redisConnectionFactory</code> as its bean name.
This example also includes the optional (and custom) <code>MessageConverter</code> (the <code>testConverter</code> bean).</p>
</div>
<div class="paragraph">
<p>Since Spring Integration 3.0, the <code>&lt;int-redis:outbound-channel-adapter&gt;</code> offers an alternative to the <code>topic</code> attribute: You can use the <code>topic-expression</code> attribute to determine the Redis topic for the message at runtime.
These attributes are mutually exclusive.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-queue-inbound-channel-adapter"><a class="anchor" href="#redis-queue-inbound-channel-adapter"></a>27.2.4. Redis Queue Inbound Channel Adapter</h4>
<div class="paragraph">
<p>Spring Integration 3.0 introduced a queue inbound channel adapter to &#8220;pop&#8221; messages from a Redis list.
By default, it uses &#8220;right pop&#8221;, but you can configure it to use &#8220;left pop&#8221; instead.
The adapter is message-driven.
It uses an internal listener thread and does not use a poller.</p>
</div>
<div class="paragraph">
<p>The following listing shows all the available attributes for <code>queue-inbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:queue-inbound-channel-adapter id=""  <i class="conum" data-value="1"></i><b>(1)</b>
                    channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
                    auto-startup=""  <i class="conum" data-value="3"></i><b>(3)</b>
                    phase=""  <i class="conum" data-value="4"></i><b>(4)</b>
                    connection-factory=""  <i class="conum" data-value="5"></i><b>(5)</b>
                    queue=""  <i class="conum" data-value="6"></i><b>(6)</b>
                    error-channel=""  <i class="conum" data-value="7"></i><b>(7)</b>
                    serializer=""  <i class="conum" data-value="8"></i><b>(8)</b>
                    receive-timeout=""  <i class="conum" data-value="9"></i><b>(9)</b>
                    recovery-interval=""  <i class="conum" data-value="10"></i><b>(10)</b>
                    expect-message=""  <i class="conum" data-value="11"></i><b>(11)</b>
                    task-executor=""  <i class="conum" data-value="12"></i><b>(12)</b>
                    right-pop=""/&gt;  <i class="conum" data-value="13"></i><b>(13)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
If you do not provide the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with this <code>id</code> attribute as the bean name.
In this case, the endpoint itself is registered with the bean name <code>id</code> plus <code>.adapter</code>.
(If the bean name were <code>thing1</code>, the endpoint is registered as <code>thing1.adapter</code>.)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MessageChannel</code> to which to send <code>Message</code> instances from this Endpoint.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A <code>SmartLifecycle</code> attribute to specify whether this endpoint should start automatically after the application context start or not.
It defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A <code>SmartLifecycle</code> attribute to specify the phase in which this endpoint is started.
It defaults to <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A reference to a <code>RedisConnectionFactory</code> bean.
It defaults to <code>redisConnectionFactory</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The name of the Redis list on which the queue-based 'pop' operation is performed to get Redis messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The <code>MessageChannel</code> to which to send <code>ErrorMessage</code> instances when exceptions are received from the listening task of the endpoint.
By default, the underlying <code>MessagePublishingErrorHandler</code> uses the default <code>errorChannel</code> from the application context.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The <code>RedisSerializer</code> bean reference.
It can be an empty string, which means 'no serializer'.
In this case, the raw <code>byte[]</code> from the inbound Redis message is sent to the <code>channel</code> as the <code>Message</code> payload.
By default it is a <code>JdkSerializationRedisSerializer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The timeout in milliseconds for 'pop' operation to wait for a Redis message from the queue.
The default is 1 second.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The time in milliseconds for which the listener task should sleep after exceptions on the 'pop' operation, before restarting the listener task.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Specifies whether this endpoint expects data from the Redis queue to contain entire <code>Message</code> instances.
If this attribute is set to <code>true</code>, the <code>serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).
Its default is <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>A reference to a Spring <code>TaskExecutor</code> (or standard JDK 1.5+ <code>Executor</code>) bean.
It is used for the underlying listening task.
It defaults to a <code>SimpleAsyncTaskExecutor</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Specifies whether this endpoint should use &#8220;right pop&#8221; (when <code>true</code>) or &#8220;left pop&#8221; (when <code>false</code>) to read messages from the Redis list.
If <code>true</code>, the Redis List acts as a <code>FIFO</code> queue when used with a default Redis queue outbound channel adapter.
Set it to <code>false</code> to use with software that writes to the list with &#8220;right push&#8221; or to achieve a stack-like message order.
Its default is <code>true</code>.
Since version 4.3.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>task-executor</code> has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the <code>RedisQueueMessageDrivenEndpoint</code> tries to restart the listener task after an error.
The <code>errorChannel</code> can be used to process those errors, to avoid restarts, but it preferable to not expose your application to the possible deadlock situation.
See Spring Framework <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types">Reference Manual</a> for possible <code>TaskExecutor</code> implementations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="redis-queue-outbound-channel-adapter"><a class="anchor" href="#redis-queue-outbound-channel-adapter"></a>27.2.5. Redis Queue Outbound Channel Adapter</h4>
<div class="paragraph">
<p>Spring Integration 3.0 introduced a queue outbound channel adapter to &#8220;push&#8221; to a Redis list from Spring Integration messages.
By default, it uses &#8220;left push&#8221;, but you can configure it to use &#8220;right push&#8221; instead.
The following listing shows all the available attributes for a Redis <code>queue-outbound-channel-adapter</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:queue-outbound-channel-adapter id=""  <i class="conum" data-value="1"></i><b>(1)</b>
                    channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
                    connection-factory=""  <i class="conum" data-value="3"></i><b>(3)</b>
                    queue=""  <i class="conum" data-value="4"></i><b>(4)</b>
                    queue-expression=""  <i class="conum" data-value="5"></i><b>(5)</b>
                    serializer=""  <i class="conum" data-value="6"></i><b>(6)</b>
                    extract-payload=""  <i class="conum" data-value="7"></i><b>(7)</b>
                    left-push=""/&gt;  <i class="conum" data-value="8"></i><b>(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
If you do not provide the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with this <code>id</code> attribute as the bean name.
In this case, the endpoint is registered with a bean name of <code>id</code> plus <code>.adapter</code>.
(If the bean name were <code>thing1</code>, the endpoint is registered as <code>thing1.adapter</code>.)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MessageChannel</code> from which this endpoint receives <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A reference to a <code>RedisConnectionFactory</code> bean.
It defaults to <code>redisConnectionFactory</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The name of the Redis list on which the queue-based 'push' operation is performed to send Redis messages.
This attribute is mutually exclusive with <code>queue-expression</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A SpEL <code>Expression</code> to determine the name of the Redis list.
It uses the incoming <code>Message</code> at runtime as the <code>#root</code> variable.
This attribute is mutually exclusive with <code>queue</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A <code>RedisSerializer</code> bean reference.
It defaults to a <code>JdkSerializationRedisSerializer</code>.
However, for <code>String</code> payloads, a <code>StringRedisSerializer</code> is used, if a <code>serializer</code> reference is not provided.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Specifies whether this endpoint should send only the payload or the entire <code>Message</code> to the Redis queue.
It defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Specifies whether this endpoint should use &#8220;left push&#8221; (when <code>true</code>) or &#8220;right push&#8221; (when <code>false</code>) to write messages to the Redis list.
If <code>true</code>, the Redis list acts as a <code>FIFO</code> queue when used with a default Redis queue inbound channel adapter.
Set it to <code>false</code> to use with software that reads from the list with &#8220;left pop&#8221; or to achieve a stack-like message order.
It defaults to <code>true</code>.
Since version 4.3.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis-application-events"><a class="anchor" href="#redis-application-events"></a>27.2.6. Redis Application Events</h4>
<div class="paragraph">
<p>Since Spring Integration 3.0, the Redis module provides an implementation of <code>IntegrationEvent</code>, which, in turn, is a <code>org.springframework.context.ApplicationEvent</code>.
The <code>RedisExceptionEvent</code> encapsulates exceptions from Redis operations (with the endpoint being the &#8220;source&#8221; of the event).
For example, the <code>&lt;int-redis:queue-inbound-channel-adapter/&gt;</code> emits those events after catching exceptions from the <code>BoundListOperations.rightPop</code> operation.
The exception may be any generic <code>org.springframework.data.redis.RedisSystemException</code> or a <code>org.springframework.data.redis.RedisConnectionFailureException</code>.
Handling these events with an <code>&lt;int-event:inbound-channel-adapter/&gt;</code> can be useful to determine problems with background Redis tasks and to take administrative actions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-message-store"><a class="anchor" href="#redis-message-store"></a>27.3. Redis Message Store</h3>
<div class="paragraph">
<p>As described in the <em>Enterprise Integration Patterns</em> (EIP) book, a <a href="https://www.enterpriseintegrationpatterns.com/MessageStore.html">message store</a> lets you persist messages.
This can be useful when dealing with components that have a capability to buffer messages (aggregator, resequencer, and others) when reliability is a concern.
In Spring Integration, the <code>MessageStore</code> strategy also provides the foundation for the <a href="https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">claim check</a> pattern, which is described in EIP as well.</p>
</div>
<div class="paragraph">
<p>Spring Integration&#8217;s Redis module provides the <code>RedisMessageStore</code>.
The following example shows how to use it with a aggregator:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="redisMessageStore" class="o.s.i.redis.store.RedisMessageStore"&gt;
    &lt;constructor-arg ref="redisConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;int:aggregator input-channel="inputChannel" output-channel="outputChannel"
         message-store="redisMessageStore"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example is a bean configuration, and it expects a <code>RedisConnectionFactory</code> as a constructor argument.</p>
</div>
<div class="paragraph">
<p>By default, the <code>RedisMessageStore</code> uses Java serialization to serialize the message.
However, if you want to use a different serialization technique (such as JSON), you can provide your own serializer by setting the <code>valueSerializer</code> property of the <code>RedisMessageStore</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.10, the Framework provides Jackson serializer and deserializer implementations for <code>Message</code> instances and <code>MessageHeaders</code> instances&#8201;&#8212;&#8201;<code>MessageJacksonDeserializer</code> and <code>MessageHeadersJacksonSerializer</code>, respectively.
They have to be configured with the <code>SimpleModule</code> options for the <code>ObjectMapper</code>.
In addition, you should set <code>enableDefaultTyping</code> on the <code>ObjectMapper</code> to add type information for each serialized complex object.
That type information is then used during deserialization.
The framework provides a utility method called <code>JacksonJsonUtils.messagingAwareMapper()</code>, which is already supplied with all the previously mentioned properties and serializers.
To manage JSON serialization in the <code>RedisMessageStore</code>, you must configure it in a fashion similar to the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RedisMessageStore store = new RedisMessageStore(redisConnectionFactory);
ObjectMapper mapper = JacksonJsonUtils.messagingAwareMapper();
RedisSerializer&lt;Object&gt; serializer = new GenericJackson2JsonRedisSerializer(mapper);
store.setValueSerializer(serializer);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.3.12, <code>RedisMessageStore</code> supports the <code>prefix</code> option to allow distinguishing between instances of the store on the same Redis server.</p>
</div>
<div class="sect3">
<h4 id="redis-cms"><a class="anchor" href="#redis-cms"></a>27.3.1. Redis Channel Message Stores</h4>
<div class="paragraph">
<p>The <code>RedisMessageStore</code> <a href="#redis-message-store">shown earlier</a> maintains each group as a value under a single key (the group ID).
While you can use this to back a <code>QueueChannel</code> for persistence, a specialized <code>RedisChannelMessageStore</code> is provided for that purpose (since version 4.0).
This store uses a <code>LIST</code> for each channel, <code>LPUSH</code> when sending messages, and <code>RPOP</code> when receiving messages.
By default, this store also uses JDK serialization, but you can modify the value serializer, as <a href="#redis-message-store">described earlier</a>.</p>
</div>
<div class="paragraph">
<p>We recommend using this store backing channels, instead of using the general <code>RedisMessageStore</code>.
The following example defines a Redis message store and uses it in a channel with a queue:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="redisMessageStore" class="o.s.i.redis.store.RedisChannelMessageStore"&gt;
	&lt;constructor-arg ref="redisConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;int:channel id="somePersistentQueueChannel"&gt;
    &lt;int:queue message-store="redisMessageStore"/&gt;
&lt;int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The keys used to store the data have the form: <code>&lt;storeBeanName&gt;:&lt;channelId&gt;</code> (in the preceding example, <code>redisMessageStore:somePersistentQueueChannel</code>).</p>
</div>
<div class="paragraph">
<p>In addition, a subclass <code>RedisChannelPriorityMessageStore</code> is also provided.
When you use this with a <code>QueueChannel</code>, the messages are received in (FIFO) priority order.
It uses the standard <code>IntegrationMessageHeaderAccessor.PRIORITY</code> header and supports priority values (<code>0 - 9</code>).
Messages with other priorities (and messages with no priority) are retrieved in FIFO order after any messages with priority.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
These stores implement only <code>BasicMessageGroupStore</code> and do not implement <code>MessageGroupStore</code>.
They can be used only for situations such as backing a <code>QueueChannel</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-metadata-store"><a class="anchor" href="#redis-metadata-store"></a>27.4. Redis Metadata Store</h3>
<div class="paragraph">
<p>Spring Integration 3.0 introduced a new Redis-based <a href="https://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/metadata/MetadataStore.html"><code>MetadataStore</code></a> (see <a href="#metadata-store">Metadata Store</a>) implementation.
You can use the <code>RedisMetadataStore</code> to maintain the state of a <code>MetadataStore</code> across application restarts.
You can use this new <code>MetadataStore</code> implementation with adapters such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#feed-inbound-channel-adapter">Feed</a></p>
</li>
<li>
<p><a href="#file-reading">File</a></p>
</li>
<li>
<p><a href="#ftp-inbound">FTP</a></p>
</li>
<li>
<p><a href="#sftp-inbound">SFTP</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To instruct these adapters to use the new <code>RedisMetadataStore</code>, declare a Spring bean named <code>metadataStore</code>.
The Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared <code>RedisMetadataStore</code>.
The following example shows how to declare such a bean:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean name="metadataStore" class="o.s.i.redis.store.metadata.RedisMetadataStore"&gt;
    &lt;constructor-arg name="connectionFactory" ref="redisConnectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>RedisMetadataStore</code> is backed by <a href="https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/support/collections/RedisProperties.html"><code>RedisProperties</code></a>.
Interaction with it uses <a href="https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/core/BoundHashOperations.html"><code>BoundHashOperations</code></a>, which, in turn, requires a <code>key</code> for the entire <code>Properties</code> store.
In the case of the <code>MetadataStore</code>, this <code>key</code> plays the role of a region, which is useful in a distributed environment, when several applications use the same Redis server.
By default, this <code>key</code> has a value of <code>MetaData</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.0, this store implements <code>ConcurrentMetadataStore</code>, letting it be reliably shared across multiple application instances where only one instance is allowed to store or modify a key&#8217;s value.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You cannot use the <code>RedisMetadataStore.replace()</code> (for example, in the <code>AbstractPersistentAcceptOnceFileListFilter</code>) with a Redis cluster, since the <code>WATCH</code> command for atomicity is not currently supported.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis-store-inbound-channel-adapter"><a class="anchor" href="#redis-store-inbound-channel-adapter"></a>27.5. Redis Store Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The Redis store inbound channel adapter is a polling consumer that reads data from a Redis collection and sends it as a <code>Message</code> payload.
The following example shows how to configure a Redis store inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:store-inbound-channel-adapter id="listAdapter"
    connection-factory="redisConnectionFactory"
    key="myCollection"
    channel="redisChannel"
    collection-type="LIST" &gt;
    &lt;int:poller fixed-rate="2000" max-messages-per-poll="10"/&gt;
&lt;/int-redis:store-inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows how to configure a Redis store inbound channel adapter by using the <code>store-inbound-channel-adapter</code> element, providing values for various attributes, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key</code> or <code>key-expression</code>: The name of the key for the collection being used.</p>
</li>
<li>
<p><code>collection-type</code>: An enumeration of the collection types supported by this adapter.
The supported Collections are <code>LIST</code>, <code>SET</code>, <code>ZSET</code>, <code>PROPERTIES</code>, and <code>MAP</code>.</p>
</li>
<li>
<p><code>connection-factory</code>: Reference to an instance of <code>o.s.data.redis.connection.RedisConnectionFactory</code>.</p>
</li>
<li>
<p><code>redis-template</code>: Reference to an instance of <code>o.s.data.redis.core.RedisTemplate</code>.</p>
</li>
<li>
<p>Other attributes that are common across all other inbound adapters (such as 'channel').</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot set both <code>redis-template</code> and <code>connection-factory</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the adapter uses a <code>StringRedisTemplate</code>.
This uses <code>StringRedisSerializer</code> instances for keys, values, hash keys, and hash values.
If your Redis store contains objects that are serialized with other techniques, you must supply a <code>RedisTemplate</code> configured with appropriate serializers.
For example, if the store is written to using a Redis store outbound adapter that has its <code>extract-payload-elements</code> set to <code>false</code>, you must provide a <code>RedisTemplate</code> configured as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt;
    &lt;property name="connectionFactory" ref="redisConnectionFactory"/&gt;
    &lt;property name="keySerializer"&gt;
        &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
    &lt;/property&gt;
    &lt;property name="hashKeySerializer"&gt;
        &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Th <code>RedisTemplate</code> uses <code>String</code> serializers for keys and hash keys and the default JDK Serialization serializers for values and hash values.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because it has a literal value for the <code>key</code>, the preceding example is relatively simple and static.
Sometimes, you may need to change the value of the key at runtime based on some condition.
To do so, use <code>key-expression</code> instead, where the provided expression can be any valid SpEL expression.</p>
</div>
<div class="paragraph">
<p>Also, you may wish to perform some post-processing on the successfully processed data that was read from the Redis collection.
For example, you may want to move or remove the value after its been processed.
You can do so by using the transaction synchronization feature that was added with Spring Integration 2.2.
The following example uses <code>key-expression</code> and transaction synchronization:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:store-inbound-channel-adapter id="zsetAdapterWithSingleScoreAndSynchronization"
        connection-factory="redisConnectionFactory"
        key-expression="'presidents'"
        channel="otherRedisChannel"
        auto-startup="false"
        collection-type="ZSET"&gt;
            &lt;int:poller fixed-rate="1000" max-messages-per-poll="2"&gt;
                &lt;int:transactional synchronization-factory="syncFactory"/&gt;
            &lt;/int:poller&gt;
&lt;/int-redis:store-inbound-channel-adapter&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
	&lt;int:after-commit expression="payload.removeByScore(18, 18)"/&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;bean id="transactionManager" class="o.s.i.transaction.PseudoTransactionManager"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can declare your poller to be transactional by using a <code>transactional</code> element.
This element can reference a real transaction manager (for example, if some other part of your flow invokes JDBC).
If you do not have a &#8220;real&#8221; transaction, you can use an <code>o.s.i.transaction.PseudoTransactionManager</code>, which is an implementation of Spring&#8217;s <code>PlatformTransactionManager</code> and enables the use of the transaction synchronization features of the Redis adapter when there is no actual transaction.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This does not make the Redis activities themselves transactional.
It lets the synchronization of actions be taken before or after success (commit) or after failure (rollback).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once your poller is transactional, you can set an instance of the <code>o.s.i.transaction.TransactionSynchronizationFactory</code> on the <code>transactional</code> element.
<code>TransactionSynchronizationFactory</code> creates an instance of the <code>TransactionSynchronization</code>.
For your convenience, we have exposed a default SpEL-based <code>TransactionSynchronizationFactory</code>, which lets you configure SpEL expressions, with their execution being coordinated (synchronized) with a transaction.
Expressions for before-commit, after-commit, and after-rollback are supported, together with channels (one for each kind of event) where the evaluation result (if any) is sent.
For each child element, you can specify <code>expression</code> and <code>channel</code> attributes.
If only the <code>channel</code> attribute is present, the received message is sent there as part of the particular synchronization scenario.
If only the <code>expression</code> attribute is present and the result of an expression is a non-null value, a message with the result as the payload is generated and sent to a default channel (<code>NullChannel</code>) and appears in the logs (at the <code>DEBUG</code> level).
If you want the evaluation result to go to a specific channel, add a <code>channel</code> attribute.
If the result of an expression is null or void, no message is generated.</p>
</div>
<div class="paragraph">
<p>For more information about transaction synchronization, see <a href="#transaction-synchronization">Transaction Synchronization</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis-store-outbound-channel-adapter"><a class="anchor" href="#redis-store-outbound-channel-adapter"></a>27.6. RedisStore Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The RedisStore outbound channel adapter lets you write a message payload to a Redis collection, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:store-outbound-channel-adapter id="redisListAdapter"
          collection-type="LIST"
          channel="requestChannel"
          key="myCollection" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration a Redis store outbound channel adapter by using the <code>store-inbound-channel-adapter</code> element.
It provides values for various attributes, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key</code> or <code>key-expression</code>: The name of the key for the collection being used.</p>
</li>
<li>
<p><code>extract-payload-elements</code>: If set to <code>true</code> (the default) and the payload is an instance of a &#8220;multi-value&#8221; object (that is, a <code>Collection</code> or a <code>Map</code>), it is stored by using &#8220;addAll&#8221; and &#8220;putAll&#8221; semantics.
Otherwise, if set to <code>false</code>, the payload is stored as a single entry regardless of its type.
If the payload is not an instance of a &#8220;multi-value&#8221; object, the value of this attribute is ignored and the payload is always stored as a single entry.</p>
</li>
<li>
<p><code>collection-type</code>: An enumeration of the <code>Collection</code> types supported by this adapter.
The supported Collections are <code>LIST</code>, <code>SET</code>, <code>ZSET</code>, <code>PROPERTIES</code>, and <code>MAP</code>.</p>
</li>
<li>
<p><code>map-key-expression</code>: SpEL expression that returns the name of the key for the entry being stored.
It applies only if the <code>collection-type</code> is <code>MAP</code> or <code>PROPERTIES</code> and 'extract-payload-elements' is false.</p>
</li>
<li>
<p><code>connection-factory</code>: Reference to an instance of <code>o.s.data.redis.connection.RedisConnectionFactory</code>.</p>
</li>
<li>
<p><code>redis-template</code>: Reference to an instance of <code>o.s.data.redis.core.RedisTemplate</code>.</p>
</li>
<li>
<p>Other attributes that are common across all other inbound adapters (such as 'channel').</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot set both <code>redis-template</code> and <code>connection-factory</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, the adapter uses a <code>StringRedisTemplate</code>.
This uses <code>StringRedisSerializer</code> instances for keys, values, hash keys, and hash values.
However, if <code>extract-payload-elements</code> is set to <code>false</code>, a <code>RedisTemplate</code> that has <code>StringRedisSerializer</code> instances for keys and hash keys and <code>JdkSerializationRedisSerializer</code> instances s for values and hash values will be used.
With the JDK serializer, it is important to understand that Java serialization is used for all values, regardless of whether the value is actually a collection or not.
If you need more control over the serialization of values, consider providing your own <code>RedisTemplate</code> rather than relying upon these defaults.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because it has literal values for the <code>key</code> and other attributes, the preceding example is relatively simple and static.
Sometimes, you may need to change the values dynamically at runtime based on some condition.
To do so, use their <code>-expression</code> equivalents (<code>key-expression</code>, <code>map-key-expression</code>, and so on), where the provided expression can be any valid SpEL expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis-outbound-gateway"><a class="anchor" href="#redis-outbound-gateway"></a>27.7. Redis Outbound Command Gateway</h3>
<div class="paragraph">
<p>Spring Integration 4.0 introduced the Redis command gateway to let you perform any standard Redis command by using the generic <code>RedisConnection#execute</code> method.
The following listing shows the available attributes for the Redis outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:outbound-gateway
        request-channel=""  <i class="conum" data-value="1"></i><b>(1)</b>
        reply-channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
        requires-reply=""  <i class="conum" data-value="3"></i><b>(3)</b>
        reply-timeout=""  <i class="conum" data-value="4"></i><b>(4)</b>
        connection-factory=""  <i class="conum" data-value="5"></i><b>(5)</b>
        redis-template=""  <i class="conum" data-value="6"></i><b>(6)</b>
        arguments-serializer=""  <i class="conum" data-value="7"></i><b>(7)</b>
        command-expression=""  <i class="conum" data-value="8"></i><b>(8)</b>
        argument-expressions=""  <i class="conum" data-value="9"></i><b>(9)</b>
        use-command-variable=""  <i class="conum" data-value="10"></i><b>(10)</b>
        arguments-strategy="" /&gt; <i class="conum" data-value="11"></i><b>(11)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>MessageChannel</code> from which this endpoint receives <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MessageChannel</code> where this endpoint sends reply <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specifies whether this outbound gateway must return a non-null value.
It defaults to <code>true</code>.
A <code>ReplyRequiredException</code> is thrown when Redis returns a <code>null</code> value.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A reference to a <code>RedisConnectionFactory</code> bean.
It defaults to <code>redisConnectionFactory</code>.
It is mutually exclusive with 'redis-template' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A reference to a <code>RedisTemplate</code> bean.
It is mutually exclusive with 'connection-factory' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A reference to an instance of <code>org.springframework.data.redis.serializer.RedisSerializer</code>.
It is used to serialize each command argument to byte[], if necessary.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The SpEL expression that returns the command key.
It defaults to the <code>redis_command</code> message header.
It must not evaluate to <code>null</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Comma-separated SpEL expressions that are evaluated as command arguments.
Mutually exclusive with the <code>arguments-strategy</code> attribute.
If you provide neither attribute, the <code>payload</code> is used as the command arguments.
The argument expressions can evaluate to 'null' to support a variable number of arguments.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A <code>boolean</code> flag to specify whether the evaluated Redis command string is made available as the <code>#cmd</code> variable in the expression evaluation context in the <code>o.s.i.redis.outbound.ExpressionArgumentsStrategy</code> when <code>argument-expressions</code> is configured.
Otherwise this attribute is ignored.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Reference to an instance of <code>o.s.i.redis.outbound.ArgumentsStrategy</code>.
It is mutually exclusive with <code>argument-expressions</code> attribute.
If you provide neither attribute, the <code>payload</code> is used as the command arguments.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>&lt;int-redis:outbound-gateway&gt;</code> as a common component to perform any desired Redis operation.
For example, the following examlpe shows how to get incremented values from Redis atomic number:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:outbound-gateway request-channel="requestChannel"
    reply-channel="replyChannel"
    command-expression="'INCR'"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>Message</code> payload should have a name of <code>redisCounter</code>, which may be provided by <code>org.springframework.data.redis.support.atomic.RedisAtomicInteger</code> bean definition.</p>
</div>
<div class="paragraph">
<p>The <code>RedisConnection#execute</code> method has a generic <code>Object</code> as its return type.
Real result depends on command type.
For example, <code>MGET</code> returns a <code>List&lt;byte[]&gt;</code>.
For more information about commands, their arguments and result type, see <a href="https://redis.io/commands">Redis Specification</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis-queue-outbound-gateway"><a class="anchor" href="#redis-queue-outbound-gateway"></a>27.8. Redis Queue Outbound Gateway</h3>
<div class="paragraph">
<p>Spring Integration introduced the Redis queue outbound gateway to perform request and reply scenarios.
It pushes a conversation <code>UUID</code> to the provided <code>queue</code>, pushes the value with that <code>UUID</code> as its key to a Redis list, and waits for the reply from a Redis list with a key of <code>UUID' plus '.reply</code>.
A different UUID is used for each interaction.
The following listing shows the available attributes for a Redis outbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:queue-outbound-gateway
        request-channel=""  <i class="conum" data-value="1"></i><b>(1)</b>
        reply-channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
        requires-reply=""  <i class="conum" data-value="3"></i><b>(3)</b>
        reply-timeout=""  <i class="conum" data-value="4"></i><b>(4)</b>
        connection-factory=""  <i class="conum" data-value="5"></i><b>(5)</b>
        queue=""  <i class="conum" data-value="6"></i><b>(6)</b>
        order=""  <i class="conum" data-value="7"></i><b>(7)</b>
        serializer=""  <i class="conum" data-value="8"></i><b>(8)</b>
        extract-payload=""/&gt;  <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>MessageChannel</code> from which this endpoint receives <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MessageChannel</code> where this endpoint sends reply <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specifies whether this outbound gateway must return a non-null value.
This value is <code>false</code> by default.
Otherwise, a <code>ReplyRequiredException</code> is thrown when Redis returns a <code>null</code> value.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A reference to a <code>RedisConnectionFactory</code> bean.
It defaults to <code>redisConnectionFactory</code>.
It is mutually exclusive with the 'redis-template' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The name of the Redis list to which the outbound gateway sends a conversation <code>UUID</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The order of this outbound gateway when multiple gateways are registered.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The <code>RedisSerializer</code> bean reference.
It can be an empty string, which means &#8220;no serializer&#8221;.
In this case, the raw <code>byte[]</code> from the inbound Redis message is sent to the <code>channel</code> as the <code>Message</code> payload.
By default, it is a <code>JdkSerializationRedisSerializer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Specifies whether this endpoint expects data from the Redis queue to contain entire <code>Message</code> instances.
If this attribute is set to <code>true</code>, the <code>serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis-queue-inbound-gateway"><a class="anchor" href="#redis-queue-inbound-gateway"></a>27.9. Redis Queue Inbound Gateway</h3>
<div class="paragraph">
<p>Spring Integration 4.1 introduced the Redis queue inbound gateway to perform request and reply scenarios.
It pops a conversation <code>UUID</code> from the provided <code>queue</code>, pops the value with that <code>UUID</code> as its key from the Redis list, and pushes the reply to the Redis list with a key of <code>UUID</code> plus <code>.reply</code>.
The following listing shows the available attributes for a Redis queue inbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-redis:queue-inbound-gateway
        request-channel=""  <i class="conum" data-value="1"></i><b>(1)</b>
        reply-channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
        executor=""  <i class="conum" data-value="3"></i><b>(3)</b>
        reply-timeout=""  <i class="conum" data-value="4"></i><b>(4)</b>
        connection-factory=""  <i class="conum" data-value="5"></i><b>(5)</b>
        queue=""  <i class="conum" data-value="6"></i><b>(6)</b>
        order=""  <i class="conum" data-value="7"></i><b>(7)</b>
        serializer=""  <i class="conum" data-value="8"></i><b>(8)</b>
        receive-timeout=""  <i class="conum" data-value="9"></i><b>(9)</b>
        expect-message=""  <i class="conum" data-value="10"></i><b>(10)</b>
        recovery-interval=""/&gt;  <i class="conum" data-value="11"></i><b>(11)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>MessageChannel</code> from which this endpoint receives <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MessageChannel</code> where this endpoint sends reply <code>Message</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A reference to a Spring <code>TaskExecutor</code> (or a standard JDK 1.5+ <code>Executor</code>) bean.
It is used for the underlying listening task.
It defaults to a <code>SimpleAsyncTaskExecutor</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The timeout (in milliseconds) to wait until the reply message is sent.
It is typically applied for queue-based limited reply-channels.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A reference to a <code>RedisConnectionFactory</code> bean.
It defaults to <code>redisConnectionFactory</code>.
It is mutually exclusive with 'redis-template' attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The name of the Redis list for the conversation <code>UUID</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The order of this inbound gateway when multiple gateways are registered.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The <code>RedisSerializer</code> bean reference.
It can be an empty string, which means &#8220;no serializer&#8221;.
In this case, the raw <code>byte[]</code> from the inbound Redis message is sent to the <code>channel</code> as the <code>Message</code> payload.
It default to a <code>JdkSerializationRedisSerializer</code>.
(Note that, in releases before version 4.3, it was a <code>StringRedisSerializer</code> by default.
To restore that behavior, provide a reference to a <code>StringRedisSerializer</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The timeout (in milliseconds) to wait until the receive message is fetched.
It is typically applied for queue-based limited request-channels.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Specifies whether this endpoint expects data from the Redis queue to contain entire <code>Message</code> instances.
If this attribute is set to <code>true</code>, the <code>serializer</code> cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The time (in milliseconds) the listener task should sleep after exceptions on the &#8220;right pop&#8221; operation before restarting the listener task.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>task-executor</code> has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the <code>RedisQueueMessageDrivenEndpoint</code> tries to restart the listener task after an error.
The <code>errorChannel</code> can be used to process those errors, to avoid restarts, but it preferable to not expose your application to the possible deadlock situation.
See Spring Framework <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types">Reference Manual</a> for possible <code>TaskExecutor</code> implementations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis-lock-registry"><a class="anchor" href="#redis-lock-registry"></a>27.10. Redis Lock Registry</h3>
<div class="paragraph">
<p>Spring Integration 4.0 introduced the <code>RedisLockRegistry</code>.
Certain components (for example, aggregator and resequencer) use a lock obtained from a <code>LockRegistry</code> instance to ensure that only one thread manipulates a group at a time.
The <code>DefaultLockRegistry</code> performs this function within a single component.
You can now configure an external lock registry on these components.
When you use it with a shared <code>MessageGroupStore</code>, you can use the <code>RedisLockRegistry</code> to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.</p>
</div>
<div class="paragraph">
<p>When a lock is released by a local thread, another local thread can generally acquire the lock immediately.
If a lock is released by a thread using a different registry instance, it can take up to 100ms to acquire the lock.</p>
</div>
<div class="paragraph">
<p>To avoid &#8220;hung&#8221; locks (when a server fails), the locks in this registry are expired after a default 60 seconds, but you can configure this value on the registry.
Locks are normally held for a much smaller time.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Because the keys can expire, an attempt to unlock an expired lock results in an exception being thrown.
However, the resources protected by such a lock may have been compromised, so such exceptions should be considered to be severe.
You should set the expiry at a large enough value to prevent this condition, but set it low enough that the lock can be recovered after a server failure in a reasonable amount of time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>RedisLockRegistry</code> implements <code>ExpirableLockRegistry</code>, which removes locks last acquired more than <code>age</code> ago and that are not currently locked.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resource"><a class="anchor" href="#resource"></a>28. Resource Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The resource inbound channel adapter builds upon Spring&#8217;s <code>Resource</code> abstraction to support greater flexibility across a variety of actual types of underlying resources, such as a file, a URL, or a class path resource.
Therefore, it is similar to but more generic than the file inbound channel adapter.</p>
</div>
<div class="sect2">
<h3 id="resource-inbound-channel-adapter"><a class="anchor" href="#resource-inbound-channel-adapter"></a>28.1. Resource Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The resource inbound channel adapter is a polling adapter that creates a <code>Message</code> whose payload is a collection of <code>Resource</code> objects.</p>
</div>
<div class="paragraph">
<p><code>Resource</code> objects are resolved based on the pattern specified by the <code>pattern</code> attribute.
The collection of resolved <code>Resource</code> objects is then sent as a payload within a <code>Message</code> to the adapter&#8217;s channel.
That is one major difference between resource inbound channel adapter and file inbound channel adapter: The latter buffers <code>File</code> objects and sends a single <code>File</code> object per <code>Message</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a simple configuration that finds all files that end with the 'properties' extension in the <code>things.thing1</code> package available on the classpath and sends them as the payload of a <code>Message</code> to the channel named &#8216;resultChannel&#8217;:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:resource-inbound-channel-adapter id="resourceAdapter"
               channel="resultChannel"
               pattern="classpath:things/thing1/*.properties"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:resource-inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The resource inbound channel adapter relies on the <code>org.springframework.core.io.support.ResourcePatternResolver</code> strategy interface to resolve the provided pattern.
It defaults to an instance of the current <code>ApplicationContext</code>.
However, you can provide a reference to an instance of your own implementation of <code>ResourcePatternResolver</code> by setting the <code>pattern-resolver</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:resource-inbound-channel-adapter id="resourceAdapter"
               channel="resultChannel"
               pattern="classpath:things/thing1/*.properties"
               pattern-resolver="myPatternResolver"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:resource-inbound-channel-adapter&gt;

&lt;bean id="myPatternResolver" class="org.example.MyPatternResolver"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may have a use case where you need to further filter the collection of resources resolved by the <code>ResourcePatternResolver</code>.
For example, you may want to prevent resources that were already resolved from appearing in a collection of resolved resources ever again.
On the other hand, your resources might be updated rather often and you <em>do</em> want them to be picked up again.
In other words, both defining an additional filter and disabling filtering altogether are valid use cases.
You can provide your own implementation of the <code>org.springframework.integration.util.CollectionFilter</code> strategy interface, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CollectionFilter&lt;T&gt; {

    Collection&lt;T&gt; filter(Collection&lt;T&gt; unfilteredElements);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CollectionFilter</code> receives a collection of un-filtered elements (which are <code>Resource</code> objects in the preceding example), and it returns a collection of filtered elements of that same type.</p>
</div>
<div class="paragraph">
<p>If you define the adapter with XML but you do not specify a filter reference, the resource inbound channel adapter uses a default implementation of <code>CollectionFilter</code>.
The implementation class of that default filter is <code>org.springframework.integration.util.AcceptOnceCollectionFilter</code>.
It remembers the elements passed in the previous invocation in order to avoid returning those elements more than once.</p>
</div>
<div class="paragraph">
<p>To inject your own implementation of <code>CollectionFilter</code> instead, use the <code>filter</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:resource-inbound-channel-adapter id="resourceAdapter"
               channel="resultChannel"
               pattern="classpath:things/thing1/*.properties"
               filter="myFilter"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:resource-inbound-channel-adapter&gt;

&lt;bean id="myFilter" class="org.example.MyFilter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not need any filtering and want to disable even the default <code>CollectionFilter</code> strategy, provide an empty value for the filter attribute (for example, <code>filter=""</code>)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rmi"><a class="anchor" href="#rmi"></a>29. RMI Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter explains how to use channel adapters that are specific to RMI (Remote Method Invocation) to distribute a system over multiple JVMs.
The first section deals with sending messages over RMI.
The second section shows how to receive messages over RMI.
The last section shows how to define RMI channel adapters by using the namespace support.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-rmi&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-rmi:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rmi-outbound"><a class="anchor" href="#rmi-outbound"></a>29.1. Outbound RMI</h3>
<div class="paragraph">
<p>To send messages from a channel over RMI, you can define an <code>RmiOutboundGateway</code>.
This gateway uses Spring&#8217;s <code>RmiProxyFactoryBean</code> internally to create a proxy for a remote gateway.
Note that, to invoke a remote interface that does not use Spring Integration, you should use a service activator in combination with Spring&#8217;s RmiProxyFactoryBean.</p>
</div>
<div class="paragraph">
<p>To configure the outbound gateway, you can write a bean definition similar the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rmiOutGateway" class=org.spf.integration.rmi.RmiOutboundGateway&gt;
    &lt;constructor-arg value="rmi://host"/&gt;
    &lt;property name="replyChannel" value="replies"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rmi-inbound"><a class="anchor" href="#rmi-inbound"></a>29.2. Inbound RMI</h3>
<div class="paragraph">
<p>To receive messages over RMI, you need to use an <code>RmiInboundGateway</code>.
You can configure the gateway as shown in the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="rmiInGateway" class=org.spf.integration.rmi.RmiInboundGateway&gt;
    &lt;property name="requestChannel" value="requests"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you use an <code>errorChannel</code> on an inbound gateway, it the error flow normally returns a result or throws an exception.
This is because it is likely that there is a corresponding outbound gateway waiting for a response of some kind.
Consuming a message on the error flow and not replying results in no reply for the inbound gateway.
Exceptions (on the main flow when there is no <code>errorChannel</code> or on the error flow) propagate to the corresponding inbound gateway.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rmi-namespace"><a class="anchor" href="#rmi-namespace"></a>29.3. RMI namespace support</h3>
<div class="paragraph">
<p>To configure the inbound gateway, you can use the namespace support for it.
The following code snippet shows the different configuration options that are supported:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-rmi:inbound-gateway id="gatewayWithDefaults" request-channel="testChannel"/&gt;

&lt;int-rmi:inbound-gateway id="gatewayWithCustomProperties" request-channel="testChannel"
    expect-reply="false" request-timeout="123" reply-timeout="456"/&gt;

&lt;int-rmi:inbound-gateway id="gatewayWithHost" request-channel="testChannel"
    registry-host="localhost"/&gt;

&lt;int-rmi:inbound-gateway id="gatewayWithPort" request-channel="testChannel"
    registry-port="1234" error-channel="rmiErrorChannel"/&gt;

&lt;int-rmi:inbound-gateway id="gatewayWithExecutorRef" request-channel="testChannel"
    remote-invocation-executor="invocationExecutor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use the namespace support to configure the outbound gateway.
The following code snippet shows the different configuration for an outbound RMI gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-rmi:outbound-gateway id="gateway"
    request-channel="localChannel"
    remote-channel="testChannel"
    host="localhost"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-with-java-configuration-20"><a class="anchor" href="#configuring-with-java-configuration-20"></a>29.4. Configuring with Java Configuration</h3>
<div class="paragraph">
<p>The following example shows how to configure an inbound gateway and an outbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RmiInboundGateway inbound() {
    RmiInboundGateway gateway = new RmiInboundGateway();
    gateway.setRequestChannel(requestChannel());
    gateway.setRegistryHost("host");
    gateway.setRegistryPort(port);
    return gateway;
}

@Bean
@ServiceActivator(inputChannel="inChannel")
public RmiOutboundGateway outbound() {
    RmiOutboundGateway gateway = new RmiOutboundGateway("rmi://host:port/"
        + RmiInboundGateway.SERVICE_NAME_PREFIX + "remoteChannelName");
    return gateway;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As of version 4.3, the outbound gateway has a second constructor that takes an <code>RmiProxyFactoryBeanConfigurer</code> instance, along with the service url argument.
It allows further configuration before the proxy is created&#8201;&#8212;&#8201;for example, to inject a Spring Security <code>ContextPropagatingRemoteInvocationFactory</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel="inChannel")
public RmiOutboundGateway outbound() {
    RmiOutboundGateway gateway = new RmiOutboundGateway("rmi://host:port/"
                + RmiInboundGateway.SERVICE_NAME_PREFIX + "remoteChannelName",
        pfb -&gt; {
            pfb.setRemoteInvocationFactory(new ContextPropagatingRemoteInvocationFactory());
        });
    return gateway;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can set this with the XML namespace by using the <code>configurer</code> attribute.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sftp"><a class="anchor" href="#sftp"></a>30. SFTP Adapters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides support for file transfer operations over SFTP.</p>
</div>
<div class="paragraph">
<p>The Secure File Transfer Protocol (SFTP) is a network protocol that lets you transfer files between two computers on the Internet over any reliable stream.</p>
</div>
<div class="paragraph">
<p>The SFTP protocol requires a secure channel, such as SSH, and visibility to a client&#8217;s identity throughout the SFTP session.</p>
</div>
<div class="paragraph">
<p>Spring Integration supports sending and receiving files over SFTP by providing three client side endpoints: inbound channel adapter, outbound channel adapter, and outbound gateway.
It also provides convenient namespace configuration to define these client components.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-sftp&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-sftp:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To include the SFTP namespace in your xml configuration, include the following attributes on the root element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">xmlns:int-sftp="http://www.springframework.org/schema/integration/sftp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/sftp
    https://www.springframework.org/schema/integration/sftp/spring-integration-sftp.xsd"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-session-factory"><a class="anchor" href="#sftp-session-factory"></a>30.1. SFTP Session Factory</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As of version 3.0, sessions are no longer cached by default.
See <a href="#sftp-session-caching">SFTP Session Caching</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Before configuring SFTP adapters, you must configure an SFTP session factory.
You can configure the SFTP session factory with a regular bean definition, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans:bean id="sftpSessionFactory"
    class="org.springframework.integration.sftp.session.DefaultSftpSessionFactory"&gt;
    &lt;beans:property name="host" value="localhost"/&gt;
    &lt;beans:property name="privateKey" value="classpath:META-INF/keys/sftpTest"/&gt;
    &lt;beans:property name="privateKeyPassphrase" value="springIntegration"/&gt;
    &lt;beans:property name="port" value="22"/&gt;
    &lt;beans:property name="user" value="kermit"/&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Every time an adapter requests a session object from its <code>SessionFactory</code>, a new SFTP session is created.
Under the covers, the SFTP Session Factory relies on the <a href="http://www.jcraft.com/jsch/">JSch</a> library to provide the SFTP capabilities.</p>
</div>
<div class="paragraph">
<p>However, Spring Integration also supports the caching of SFTP sessions.
See <a href="#sftp-session-caching">SFTP Session Caching</a> for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSch supports multiple channels (operations) over a connection to the server.
By default, the Spring Integration session factory uses a separate physical connection for each channel.
Since Spring Integration 3.0, you can configure the session factory (using a boolean constructor arg - default <code>false</code>) to use a single connection to the server and create multiple <code>JSch</code> channels on that single connection.</p>
</div>
<div class="paragraph">
<p>When using this feature, you must wrap the session factory in a caching session factory, as <a href="#sftp-session-caching">described later</a>, so that the connection is not physically closed when an operation completes.</p>
</div>
<div class="paragraph">
<p>If the cache is reset, the session is disconnected only when the last channel is closed.</p>
</div>
<div class="paragraph">
<p>The connection is refreshed if it is found to be disconnected when a new operation obtains a session.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you experience connectivity problems and would like to trace session creation and see which sessions are polled, you may enable tracing by setting the logger to <code>TRACE</code> level (for example, <code>log4j.category.org.springframework.integration.sftp=TRACE</code>).
See <a href="#sftp-jsch-logging">SFTP/JSCH Logging</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now all you need to do is inject this SFTP session factory into your adapters.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A more practical way to provide values for the SFTP session factory is to use Spring&#8217;s <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-placeholderconfigurer">property placeholder support</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="sftp-session-factory-properties"><a class="anchor" href="#sftp-session-factory-properties"></a>30.1.1. Configuration Properties</h4>
<div class="paragraph">
<p>The following list describes all the properties that are exposed by the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.html"><code>DefaultSftpSessionFactory</code></a>.</p>
</div>
<div class="paragraph">
<p><code>isSharedSession</code> (constructor argument)::When <code>true</code>, a single connection is used, and <code>JSch Channels</code> are multiplexed.
It defaults to <code>false</code>.</p>
</div>
<div class="paragraph">
<p><code>clientVersion</code>::Lets you set the client version property.
It&#8217;s default depends on the underlying JSch version but it will look like:_SSH-2.0-JSCH-0.1.45_</p>
</div>
<div class="paragraph">
<p><code>enableDaemonThread</code>::If <code>true</code>, all threads are daemon threads.
If set to <code>false</code>, normal non-daemon threads are used instead.
This property is set on the underlying <a href="https://epaul.github.io/jsch-documentation/javadoc/com/jcraft/jsch/Session.html">session</a>.
There, this property defaults to <code>false</code>.</p>
</div>
<div class="paragraph">
<p><code>host</code>::The URL of the host to which you want to connect.
Required.</p>
</div>
<div class="paragraph">
<p><code>hostKeyAlias</code>::Sets the host key alias, which is used when comparing the host key to the known hosts list.</p>
</div>
<div class="paragraph">
<p><code>knownHosts</code>::Specifies the filename that used for a host key repository.
The file has the same format as OpenSSH&#8217;s <code>known_hosts</code> file and is required and must be pre-populated if <code>allowUnknownKeys</code> is false.</p>
</div>
<div class="paragraph">
<p><code>password</code>::The password to authenticate against the remote host.
If a password is not provided, then the <code>privateKey</code> property is required.
It is not allowed if you set <code>userInfo</code>.
The password is obtained from that object.</p>
</div>
<div class="paragraph">
<p><code>port</code>::The port over which the SFTP connection shall be established.
If not specified, this value defaults to <code>22</code>.
If specified, this properties must be a positive number.</p>
</div>
<div class="paragraph">
<p><code>privateKey</code>::Lets you set a <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html">resource</a> that represents the location of the private key used for authenticating against the remote host.
If the <code>privateKey</code> is not provided, then the <code>password</code> property is required.</p>
</div>
<div class="paragraph">
<p><code>privateKeyPassphrase</code>::The password for the private key.
If you set <code>userInfo</code>, <code>privateKeyPassphrase</code> is not allowed .
The passphrase is obtained from that object.
Optional.</p>
</div>
<div class="paragraph">
<p><code>proxy</code>::Allows for specifying a JSch-based <a href="https://epaul.github.com/jsch-documentation/javadoc/com/jcraft/jsch/Proxy.html">proxy</a>.
If set, the proxy object is used to create the connection to the remote host through the proxy.
See <a href="#sftp-proxy-factory-bean">Proxy Factory Bean</a> for a convenient way to configure the proxy.</p>
</div>
<div class="paragraph">
<p><code>serverAliveCountMax</code>::Specifies the number of server-alive messages, which are sent without any reply from the server before disconnecting.
If not set, this property defaults to <code>1</code>.</p>
</div>
<div class="paragraph">
<p><code>serverAliveInterval</code>::Sets the timeout interval (in milliseconds) before a server-alive message is sent, in case no message is received from the server.</p>
</div>
<div class="paragraph">
<p><code>sessionConfig</code>::By using <code>Properties</code>, you can set additional configuration setting on the underlying JSch Session.</p>
</div>
<div class="paragraph">
<p><code>socketFactory</code>::Lets you pass in a <a href="https://epaul.github.com/jsch-documentation/javadoc/com/jcraft/jsch/SocketFactory.html"><code>SocketFactory</code></a>.
The socket factory is used to create a socket to the target host.
When a proxy is used, the socket factory is passed to the proxy.
By default, plain TCP sockets are used.</p>
</div>
<div class="paragraph">
<p><code>timeout</code>::The timeout property is used as the socket timeout parameter, as well as the default connection timeout.
Defaults to <code>0</code>, which means, that no timeout will occur.</p>
</div>
<div class="paragraph">
<p><code>user</code>::The remote user to use.
Required.</p>
</div>
<div id="sftp-unk-keys" class="paragraph">
<p><code>allowUnknownKeys</code>::Set to <code>true</code> to allow connections to hosts with unknown (or changed) keys.
Its default is 'false'.
It is applied only if no <code>userInfo</code> is provided.
If <code>false</code>, a pre-populated <code>knownHosts</code> file is required.</p>
</div>
<div class="paragraph">
<p><code>userInfo</code>::Set a custom <code>UserInfo</code> to be used during authentication.
In particular, <code>promptYesNo()</code> is invoked when an unknown (or changed) host key is received.
See also <a href="#sftp-unk-keys"><code>allowUnknownKeys</code></a>.
When you provide a <code>UserInfo</code>, the <code>password</code> and private key <code>passphrase</code> are obtained from it, and you cannot set discrete
<code>password</code> and <code>privateKeyPassprase</code> properties.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-proxy-factory-bean"><a class="anchor" href="#sftp-proxy-factory-bean"></a>30.2. Proxy Factory Bean</h3>
<div class="paragraph">
<p><code>Jsch</code> provides a mechanism to connect to the server over an HTTP or SOCKS proxy.
To use this feature, configure the <code>Proxy</code> and provide a reference to the <code>DefaultSftpSessionFactory</code>, as discussed
earlier.
Three implementations are provided by <code>Jsch</code>: <code>HTTP</code>, <code>SOCKS4</code>, and <code>SOCKS5</code>.
Spring Integration 4.3 introduced a <code>FactoryBean</code>, easing configuration of these proxies by allowing property
injection, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="proxySocks5" class="org.springframework.integration.sftp.session.JschProxyFactoryBean"&gt;
    &lt;constructor-arg value="SOCKS5" /&gt;
    &lt;constructor-arg value="${sftp.proxy.address}" /&gt;
    &lt;constructor-arg value="${sftp.proxy.port}" /&gt;
    &lt;constructor-arg value="${sftp.proxy.user}" /&gt;
    &lt;constructor-arg value="${sftp.proxy.pw}" /&gt;
&lt;/bean&gt;

&lt;bean id="sessionFactory"
          class="org.springframework.integration.sftp.session.DefaultSftpSessionFactory" &gt;
    ...
    &lt;property name="proxy" ref="proxySocks5" /&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-dsf"><a class="anchor" href="#sftp-dsf"></a>30.3. Delegating Session Factory</h3>
<div class="paragraph">
<p>Version 4.2 introduced the <code>DelegatingSessionFactory</code>, which allows the selection of the actual session factory at
runtime.
Prior to invoking the FTP endpoint, you can call <code>setThreadKey()</code> on the factory to associate a key with the current thread.
That key is then used to look up the actual session factory to be used.
You can clear the key by calling <code>clearThreadKey()</code> after use.</p>
</div>
<div class="paragraph">
<p>We added convenience methods so that you can more easily do so from a message flow, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="dsf" class="org.springframework.integration.file.remote.session.DelegatingSessionFactory"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="o.s.i.file.remote.session.DefaultSessionFactoryLocator"&gt;
            &lt;!-- delegate factories here --&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;int:service-activator input-channel="in" output-channel="c1"
        expression="@dsf.setThreadKey(#root, headers['factoryToUse'])" /&gt;

&lt;int-sftp:outbound-gateway request-channel="c1" reply-channel="c2" ... /&gt;

&lt;int:service-activator input-channel="c2" output-channel="out"
        expression="@dsf.clearThreadKey(#root)" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using session caching (see <a href="#sftp-session-caching">SFTP Session Caching</a>), each of the delegates should be cached.
You cannot cache the <code>DelegatingSessionFactory</code> itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with <em>version 5.0.7</em>, the <code>DelegatingSessionFactory</code> can be used in conjunction with a <code>RotatingServerAdvice</code> to poll multiple servers; see <a href="#sftp-rotating-server-advice">Inbound Channel Adapters: Polling Multiple Servers and Directories</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sftp-session-caching"><a class="anchor" href="#sftp-session-caching"></a>30.4. SFTP Session Caching</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with Spring Integration version 3.0, sessions are no longer cached by default.
The <code>cache-sessions</code> attribute is no longer supported on endpoints.
If you wish to cache sessions, you must use a <code>CachingSessionFactory</code> (see the next example).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In versions prior to 3.0, the sessions were automatically cached by default.
A <code>cache-sessions</code> attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session-caching attributes.
For example, you could not limit on the number of sessions created.
To support that requirement and other configuration options, we added a <code>CachingSessionFactory</code>.
It provides <code>sessionCacheSize</code> and <code>sessionWaitTimeout</code> properties.
As its name suggests, the <code>sessionCacheSize</code> property controls how many active sessions the factory maintains in its cache (the default is unbounded).
If the <code>sessionCacheSize</code> threshold has been reached, any attempt to acquire another session blocks until either one of the cached sessions becomes available or until the wait time for a session expires (the default wait time is <code>Integer.MAX_VALUE</code>).
The <code>sessionWaitTimeout</code> property enables configuration of the wait time.</p>
</div>
<div class="paragraph">
<p>If you want your sessions to be cached, configure your default session factory (as <a href="#sftp-session-factory">described earlier</a>) and then wrap it in an instance of <code>CachingSessionFactory</code> where you may provide those additional properties.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="sftpSessionFactory"
    class="org.springframework.integration.sftp.session.DefaultSftpSessionFactory"&gt;
    &lt;property name="host" value="localhost"/&gt;
&lt;/bean&gt;

&lt;bean id="cachingSessionFactory"
    class="org.springframework.integration.file.remote.session.CachingSessionFactory"&gt;
    &lt;constructor-arg ref="sftpSessionFactory"/&gt;
    &lt;constructor-arg value="10"/&gt;
    &lt;property name="sessionWaitTimeout" value="1000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example creates a <code>CachingSessionFactory</code> with its <code>sessionCacheSize</code> set to <code>10</code> and its <code>sessionWaitTimeout</code> set to one second (1000 milliseconds).</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration version 3.0, the <code>CachingConnectionFactory</code> provides a <code>resetCache()</code> method.
When invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.
When using <code>isSharedSession=true</code>, the channel is closed and the shared session is closed only when the last channel is closed.
New requests for sessions establish new sessions as necessary.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the <code>CachingSessionFactory</code> has a new property <code>testSession</code>.
When true, the session will be tested by performing a <code>stat(getHome())</code> command to ensure it is still active; if not, it will be removed from the cache; a new session is created if no active sessions are in the cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="sftp-rft"><a class="anchor" href="#sftp-rft"></a>30.5. Using <code>RemoteFileTemplate</code></h3>
<div class="paragraph">
<p>Spring Integration version 3.0 provides a new abstraction over the <code>SftpSession</code> object.
The template provides methods to send, retrieve (as an <code>InputStream</code>), remove, and rename files.
In addition, we provide an <code>execute</code> method to let the caller run multiple operations on the session.
In all cases, the template takes care of reliably closing the session.
For more information, see the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html">Javadoc for <code>RemoteFileTemplate</code></a> There is a subclass for SFTP: <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.html"><code>SftpRemoteFileTemplate</code></a>.</p>
</div>
<div class="paragraph">
<p>We added additional methods in version 4.1, including <code>getClientInstance()</code>.
It provides access to the underlying <code>ChannelSftp</code>, which enables access to low-level APIs.</p>
</div>
<div class="paragraph">
<p>Version 5.0 introduced the <code>RemoteFileOperations.invoke(OperationsCallback&lt;F, T&gt; action)</code> method.
This method lets several <code>RemoteFileOperations</code> calls be called in the scope of the same thread-bounded <code>Session</code>.
This is useful when you need to perform several high-level operations of the <code>RemoteFileTemplate</code> as one unit of work.
For example, <code>AbstractRemoteFileOutboundGateway</code> uses it with the <code>mput</code> command implementation, where we perform a <code>put</code> operation for each file in the provided directory and recursively for its sub-directories.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html#invoke-org.springframework.integration.file.remote.OperationsCallback-">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="sftp-inbound"><a class="anchor" href="#sftp-inbound"></a>30.6. SFTP Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The SFTP inbound channel adapter is a special listener that connects to the server and listens for the remote directory events (such as a new file being created), at which point it initiates a file transfer.
The following example shows how to configure an SFTP inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:inbound-channel-adapter id="sftpAdapterAutoCreate"
              session-factory="sftpSessionFactory"
            channel="requestChannel"
            filename-pattern="*.txt"
            remote-directory="/foo/bar"
            preserve-timestamp="true"
            local-directory="file:target/foo"
            auto-create-local-directory="true"
            local-filename-generator-expression="#this.toUpperCase() + '.a'"
            scanner="myDirScanner"
            local-filter="myFilter"
            temporary-file-suffix=".writing"
            max-fetch-size="-1"
            delete-remote-files="false"&gt;
        &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int-sftp:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration example shows how to provide values for various attributes, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>local-directory</code>: The location to which files are going to be transferred</p>
</li>
<li>
<p><code>remote-directory</code>: The remote source directory from which files are going to be transferred</p>
</li>
<li>
<p><code>session-factory</code>: A reference to the bean we configured earlier</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the transferred file carries the same name as the original file.
If you want to override this behavior, you can set the <code>local-filename-generator-expression</code> attribute, which lets you provide a SpEL expression to generate the name of the local file.
Unlike outbound gateways and adapters, where the root object of the SpEL evaluation context is a <code>Message</code>, this inbound adapter does not yet have the message at the time of evaluation, since that is what it ultimately generates with the transferred file as its payload.
Consequently, the root object of the SpEL evaluation context is the original name of the remote file (a <code>String</code>).</p>
</div>
<div class="paragraph">
<p>The inbound channel adapter first retrieves the file to a local directory and then emits each file according to the poller configuration.
Starting with version 5.0, you can limit the number of files fetched from the FTP server when new file retrievals are needed.
This can be beneficial when the target files are large or when running in a clustered system with a persistent file list filter, discussed later in this section.
Use <code>max-fetch-size</code> for this purpose.
A negative value (the default) means no limit and all matching files are retrieved.
See <a href="#sftp-max-fetch">Inbound Channel Adapters: Controlling Remote File Fetching</a> for more information.
Since version 5.0, you can also provide a custom <code>DirectoryScanner</code> implementation to the <code>inbound-channel-adapter</code> by setting the <code>scanner</code> attribute.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, you can specify the <code>preserve-timestamp</code> attribute (the default is <code>false</code>).
When <code>true</code>, the local file&#8217;s modified timestamp is set to the value retrieved from the server.
Otherwise, it is set to the current time.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, you can specify <code>remote-directory-expression</code> instead of <code>remote-directory</code>, which lets
you dynamically determine the directory on each poll&#8201;&#8212;&#8201;for example, <code>remote-directory-expression="@myBean.determineRemoteDir()"</code>.</p>
</div>
<div class="paragraph">
<p>Sometimes, file filtering based on the simple pattern specified via <code>filename-pattern</code> attribute might not suffice.
If this is the case, you can use the <code>filename-regex</code> attribute to specify a regular expression (for example, <code>filename-regex=".*\.test$"</code>).
If you need complete control, you can use the <code>filter</code> attribute to provide a reference to a custom implementation of the <code>org.springframework.integration.file.filters.FileListFilter</code>, which is a strategy interface for filtering a list of files.
This filter determines which remote files are retrieved.
You can also combine a pattern-based filter with other filters (such as an <code>AcceptOnceFileListFilter</code>, to avoid synchronizing files that have previously been fetched) by using a <code>CompositeFileListFilter</code>.</p>
</div>
<div class="paragraph">
<p>The <code>AcceptOnceFileListFilter</code> stores its state in memory.
If you wish the state to survive a system restart, consider using the <code>SftpPersistentAcceptOnceFileListFilter</code> instead.
This filter stores the accepted file names in an instance of the <code>MetadataStore</code> strategy (see <a href="#metadata-store">Metadata Store</a>).
This filter matches on the filename and the remote modified time.</p>
</div>
<div class="paragraph">
<p>Since version 4.0, this filter requires a <code>ConcurrentMetadataStore</code>.
When used with a shared data store (such as <code>Redis</code> with the <code>RedisMetadataStore</code>), this lets filter keys be shared across multiple application or server instances.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>SftpPersistentAcceptOnceFileListFilter</code> with an in-memory <code>SimpleMetadataStore</code> is applied by default for the <code>SftpInboundFileSynchronizer</code>.
This filter is also applied, together with the <code>regex</code> or <code>pattern</code> option in the XML configuration, as well as through <code>FtpInboundChannelAdapterSpec</code> in Java DSL.
You can handle any other use-cases by using <code>CompositeFileListFilter</code> (or <code>ChainFileListFilter</code>).</p>
</div>
<div class="paragraph">
<p>The above discussion refers to filtering the files before retrieving them.
Once the files have been retrieved, an additional filter is applied to the files on the file system.
By default, this is an`AcceptOnceFileListFilter`, which, as discussed in this section, retains state in memory and does not consider the file&#8217;s modified time.
Unless your application removes files after processing, the adapter re-processes the files on disk by default after an application restart.</p>
</div>
<div class="paragraph">
<p>Also, if you configure the <code>filter</code> to use a <code>SftpPersistentAcceptOnceFileListFilter</code> and the remote file timestamp changes (causing it to be re-fetched), the default local filter does not allow this new file to be processed.</p>
</div>
<div class="paragraph">
<p>For more information about this filter, and how it is used, see <a href="#remote-persistent-flf">[remote-persistent-flf]</a>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>local-filter</code> attribute to configure the behavior of the local file system filter.
Starting with version 4.3.8, a <code>FileSystemPersistentAcceptOnceFileListFilter</code> is configured by default.
This filter stores the accepted file names and modified timestamp in an instance of the <code>MetadataStore</code> strategy (see <a href="#metadata-store">Metadata Store</a>) and detects changes to the local file modified time.
The default <code>MetadataStore</code> is a <code>SimpleMetadataStore</code> that stores state in memory.</p>
</div>
<div class="paragraph">
<p>Since version 4.1.5, these filters have a new property called <code>flushOnUpdate</code>, which causes them to flush the
metadata store on every update (if the store implements <code>Flushable</code>).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Further, if you use a distributed <code>MetadataStore</code> (such as <a href="#redis-metadata-store">Redis Metadata Store</a> or <a href="#gemfire-metadata-store">Gemfire Metadata Store</a>), you can have multiple instances of the same adapter or application and be sure that one and only one instance processes a file.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The actual local filter is a <code>CompositeFileListFilter</code> that contains the supplied filter and a pattern filter that prevents processing files that are in the process of being downloaded (based on the <code>temporary-file-suffix</code>).
Files are downloaded with this suffix (the default is <code>.writing</code>), and the files are renamed to their final names when the transfer is complete, making them 'visible' to the filter.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema</a> for more detail on these attributes.</p>
</div>
<div class="paragraph">
<p>SFTP inbound channel adapter is a polling consumer.
Therefore, you must configure a poller (either a global default or a local element).
Once the file has been transferred to a local directory, a message with <code>java.io.File</code> as its payload type is generated and sent to the channel identified by the <code>channel</code> attribute.</p>
</div>
<div class="sect3">
<h4 id="more-on-file-filtering-and-large-files"><a class="anchor" href="#more-on-file-filtering-and-large-files"></a>30.6.1. More on File Filtering and Large Files</h4>
<div class="paragraph">
<p>Sometimes, a file that just appeared in the monitored (remote) directory is not complete.
Typically such a file is written with some temporary extension (such as <code>.writing</code> on a file named <code>something.txt.writing</code>) and then renamed after the writing process completes.
In most cases, developers are interested only in files that are complete and would like to filter only those files.
To handle these scenarios, you can use the filtering support provided by the <code>filename-pattern</code>, <code>filename-regex</code>, and <code>filter</code> attributes.
If you need a custom filter implementation, you can include a reference in your adapter by setting the <code>filter</code> attribute.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:inbound-channel-adapter id="sftpInbondAdapter"
            channel="receiveChannel"
            session-factory="sftpSessionFactory"
            filter="customFilter"
            local-directory="file:/local-test-dir"
            remote-directory="/remote-test-dir"&gt;
        &lt;int:poller fixed-rate="1000" max-messages-per-poll="10" task-executor="executor"/&gt;
&lt;/int-sftp:inbound-channel-adapter&gt;

&lt;bean id="customFilter" class="org.foo.CustomFilter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="recovering-from-failures-2"><a class="anchor" href="#recovering-from-failures-2"></a>30.6.2. Recovering from Failures</h4>
<div class="paragraph">
<p>You should understand the architecture of the adapter.
A file synchronizer fetches the files, and a <code>FileReadingMessageSource</code> emits a message for each synchronized file.
As <a href="#sftp-inbound">discussed earlier</a>, two filters are involved.
The <code>filter</code> attribute (and patterns) refers to the remote (SFTP) file list, to avoid fetching files that have already
been fetched.
the <code>FileReadingMessageSource</code> uses the <code>local-filter</code> to determine which files are to be sent as messages.</p>
</div>
<div class="paragraph">
<p>The synchronizer lists the remote files and consults its filter.
The files are then transferred.
If an IO error occurs during file transfer, any files that have already been added to the filter are removed so that they
are eligible to be re-fetched on the next poll.
This applies only if the filter implements <code>ReversibleFileListFilter</code> (such as the <code>AcceptOnceFileListFilter</code>).</p>
</div>
<div class="paragraph">
<p>If, after synchronizing the files, an error occurs on the downstream flow processing a file, no automatic rollback of the filter occurs, so the failed file is not reprocessed by default.</p>
</div>
<div class="paragraph">
<p>If you wish to reprocess such files after a failure, you can use a configuration similar to the following to facilitate
the removal of the failed file from the filter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:inbound-channel-adapter id="sftpAdapter"
        session-factory="sftpSessionFactory"
        channel="requestChannel"
        remote-directory-expression="'/sftpSource'"
        local-directory="file:myLocalDir"
        auto-create-local-directory="true"
        filename-pattern="*.txt"&gt;
    &lt;int:poller fixed-rate="1000"&gt;
        &lt;int:transactional synchronization-factory="syncFactory" /&gt;
    &lt;/int:poller&gt;
&lt;/int-sftp:inbound-channel-adapter&gt;

&lt;bean id="acceptOnceFilter"
    class="org.springframework.integration.file.filters.AcceptOnceFileListFilter" /&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-rollback expression="payload.delete()" /&gt;
&lt;/int:transaction-synchronization-factory&gt;

&lt;bean id="transactionManager"
    class="org.springframework.integration.transaction.PseudoTransactionManager" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration works for any <code>ResettableFileListFilter</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the inbound channel adapter can build sub-directories locally, according to the generated local file name.
That can be a remote sub-path as well.
To be able to read a local directory recursively for modification according to the hierarchy support, you can now supply an internal <code>FileReadingMessageSource</code> with a new <code>RecursiveDirectoryScanner</code> based on the <code>Files.walk()</code> algorithm.
See <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/synchronizer/AbstractInboundFileSynchronizingMessageSource.html#setScanner-org.springframework.integration.file.DirectoryScanner"><code>AbstractInboundFileSynchronizingMessageSource.setScanner()</code></a> for more information.
Also, you can now switch the <code>AbstractInboundFileSynchronizingMessageSource</code> to the <code>WatchService</code>-based <code>DirectoryScanner</code> by using <code>setUseWatchService()</code> option.
It is also configured for all the <code>WatchEventType</code> instances to react for any modifications in local directory.
The reprocessing sample shown earlier is based on the built-in functionality of the <code>FileReadingMessageSource.WatchServiceDirectoryScanner</code>, which uses <code>ResettableFileListFilter.remove()</code> when the file is deleted (<code>StandardWatchEventKinds.ENTRY_DELETE</code>) from the local directory.
See <a href="#watch-service-directory-scanner"><code>WatchServiceDirectoryScanner</code></a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-21"><a class="anchor" href="#configuring-with-java-configuration-21"></a>30.6.3. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(true);
        factory.setHost("localhost");
        factory.setPort(port);
        factory.setUser("foo");
        factory.setPassword("foo");
        factory.setAllowUnknownKeys(true);
        factory.setTestSession(true);
        return new CachingSessionFactory&lt;LsEntry&gt;(factory);
    }

    @Bean
    public SftpInboundFileSynchronizer sftpInboundFileSynchronizer() {
        SftpInboundFileSynchronizer fileSynchronizer = new SftpInboundFileSynchronizer(sftpSessionFactory());
        fileSynchronizer.setDeleteRemoteFiles(false);
        fileSynchronizer.setRemoteDirectory("foo");
        fileSynchronizer.setFilter(new SftpSimplePatternFileListFilter("*.xml"));
        return fileSynchronizer;
    }

    @Bean
    @InboundChannelAdapter(channel = "sftpChannel", poller = @Poller(fixedDelay = "5000"))
    public MessageSource&lt;File&gt; sftpMessageSource() {
        SftpInboundFileSynchronizingMessageSource source =
                new SftpInboundFileSynchronizingMessageSource(sftpInboundFileSynchronizer());
        source.setLocalDirectory(new File("sftp-inbound"));
        source.setAutoCreateLocalDirectory(true);
        source.setLocalFilter(new AcceptOnceFileListFilter&lt;File&gt;());
        source.setMaxFetchSize(1);
        return source;
    }

    @Bean
    @ServiceActivator(inputChannel = "sftpChannel")
    public MessageHandler handler() {
        return new MessageHandler() {

            @Override
            public void handleMessage(Message&lt;?&gt; message) throws MessagingException {
                System.out.println(message.getPayload());
            }

        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-21"><a class="anchor" href="#configuring-with-the-java-dsl-21"></a>30.6.4. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow sftpInboundFlow() {
        return IntegrationFlows
            .from(Sftp.inboundAdapter(this.sftpSessionFactory)
                    .preserveTimestamp(true)
                    .remoteDirectory("foo")
                    .regexFilter(".*\\.txt$")
                    .localFilenameExpression("#this.toUpperCase() + '.a'")
                    .localDirectory(new File("sftp-inbound")),
                 e -&gt; e.id("sftpInboundAdapter")
                    .autoStartup(true)
                    .poller(Pollers.fixedDelay(5000)))
            .handle(m -&gt; System.out.println(m.getPayload()))
            .get();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sftp-incomplete"><a class="anchor" href="#sftp-incomplete"></a>30.6.5. Dealing With Incomplete Data</h4>
<div class="paragraph">
<p>See <a href="#file-incomplete">Dealing With Incomplete Data</a>.</p>
</div>
<div class="paragraph">
<p>The <code>SftpSystemMarkerFilePresentFileListFilter</code> is provided to filter remote files that don&#8217;t have the corresponding marker file on the remote system.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/filters/SftpSystemMarkerFilePresentFileListFilter.html">Javadoc</a> for configuration information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-streaming"><a class="anchor" href="#sftp-streaming"></a>30.7. SFTP Streaming Inbound Channel Adapter</h3>
<div class="paragraph">
<p>Version 4.3 introduced the streaming inbound channel adapter.
This adapter produces message with payloads of type <code>InputStream</code>, letting you fetch files without writing to the local file system.
Since the session remains open, the consuming application is responsible for closing the session when the file has been consumed.
The session is provided in the <code>closeableResource</code> header (<code>IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE</code>).
Standard framework components, such as the <code>FileSplitter</code> and <code>StreamTransformer</code>, automatically close the session.
See <a href="#file-splitter">File Splitter</a> and <a href="#stream-transformer">Stream Transformer</a> for more information about these components.
The following example shows how to configure an SFTP streaming inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:inbound-streaming-channel-adapter id="ftpInbound"
            channel="ftpChannel"
            session-factory="sessionFactory"
            filename-pattern="*.txt"
            filename-regex=".*\.txt"
            filter="filter"
            filter-expression="@myFilterBean.check(#root)"
            remote-file-separator="/"
            comparator="comparator"
            max-fetch-size="1"
            remote-directory-expression="'foo/bar'"&gt;
        &lt;int:poller fixed-rate="1000" /&gt;
&lt;/int-sftp:inbound-streaming-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use only one of <code>filename-pattern</code>, <code>filename-regex</code>, <code>filter</code>, or <code>filter-expression</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.0, by default, the <code>SftpStreamingMessageSource</code> adapter prevents duplicates for remote files by using <code>SftpPersistentAcceptOnceFileListFilter</code> based on the in-memory <code>SimpleMetadataStore</code>.
By default, this filter is also applied together with the filename pattern (or regex) as well.
If you need to allow duplicates, you can use the <code>AcceptAllFileListFilter</code>.
You can handle any other use cases by using <code>CompositeFileListFilter</code> (or <code>ChainFileListFilter</code>).
The Java configuration <a href="#sftp-streaming-java-config">shown later</a> shows one technique to remove the remote file after processing, avoiding duplicates.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information about the <code>SftpPersistentAcceptOnceFileListFilter</code>, and how it is used, see <a href="#remote-persistent-flf">[remote-persistent-flf]</a>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>max-fetch-size</code> attribute to limit the number of files fetched on each poll when a fetch is necessary.
Set it to <code>1</code> and use a persistent filter when running in a clustered environment.
See <a href="#sftp-max-fetch">Inbound Channel Adapters: Controlling Remote File Fetching</a> for more information.</p>
</div>
<div class="paragraph">
<p>The adapter puts the remote directory and the file name in headers (<code>FileHeaders.REMOTE_DIRECTORY</code> and <code>FileHeaders.REMOTE_FILE</code>, respectively).
Starting with version 5.0, the <code>FileHeaders.REMOTE_FILE_INFO</code> header provides additional remote file information (in JSON).
If you set the <code>fileInfoJson</code> property on the <code>SftpStreamingMessageSource</code> to <code>false</code>, the header contains an <code>SftpFileInfo</code> object.
You can access the <code>LsEntry</code> object provided by the underlying Jsch library by using the <code>SftpFileInfo.getFileInfo()</code> method.
The <code>fileInfoJson</code> property is not available when you use XML configuration, but you can set it by injecting the <code>SftpStreamingMessageSource</code> into one of your configuration classes.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the generic type of the <code>comparator</code> is <code>LsEntry</code>.
Previously, it was <code>AbstractFileInfo&lt;LsEntry&gt;</code>.
This is because the sort is now performed earlier in the processing, before filtering and applying <code>maxFetch</code>.</p>
</div>
<div class="sect3">
<h4 id="sftp-streaming-java-config"><a class="anchor" href="#sftp-streaming-java-config"></a>30.7.1. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the inbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    @InboundChannelAdapter(channel = "stream")
    public MessageSource&lt;InputStream&gt; ftpMessageSource() {
        SftpStreamingMessageSource messageSource = new SftpStreamingMessageSource(template());
        messageSource.setRemoteDirectory("sftpSource/");
        messageSource.setFilter(new AcceptAllFileListFilter&lt;&gt;());
        messageSource.setMaxFetchSize(1);
        return messageSource;
    }

    @Bean
    @Transformer(inputChannel = "stream", outputChannel = "data")
    public org.springframework.integration.transformer.Transformer transformer() {
        return new StreamTransformer("UTF-8");
    }

    @Bean
    public SftpRemoteFileTemplate template() {
        return new SftpRemoteFileTemplate(sftpSessionFactory());
    }

    @ServiceActivator(inputChannel = "data", adviceChain = "after")
    @Bean
    public MessageHandler handle() {
        return System.out::println;
    }

    @Bean
    public ExpressionEvaluatingRequestHandlerAdvice after() {
        ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();
        advice.setOnSuccessExpression(
                "@template.remove(headers['file_remoteDirectory'] + headers['file_remoteFile'])");
        advice.setPropagateEvaluationFailures(true);
        return advice;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that, in this example, the message handler downstream of the transformer has an advice that removes the remote file after processing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-rotating-server-advice"><a class="anchor" href="#sftp-rotating-server-advice"></a>30.8. Inbound Channel Adapters: Polling Multiple Servers and Directories</h3>
<div class="paragraph">
<p>Starting with <em>version 5.0.7</em>, the <code>RotatingServerAdvice</code> is available; when configured as a poller advice, the inbound adapters can poll multiple servers and directories.
Configure the advice and add it to the poller&#8217;s advice chain as normal.
A <code>DelegatingSessionFactory</code> is used to select the server see <a href="#ftp-dsf">Delegating Session Factory</a> for more information.
The advice configuration consists of a list of <code>RotatingServerAdvice.KeyDirectory</code> objects.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    List&lt;KeyDirectory&gt; keyDirectories = new ArrayList&lt;&gt;();
    keyDirectories.add(new KeyDirectory("one", "foo"));
    keyDirectories.add(new KeyDirectory("one", "bar"));
    keyDirectories.add(new KeyDirectory("two", "baz"));
    keyDirectories.add(new KeyDirectory("two", "qux"));
    keyDirectories.add(new KeyDirectory("three", "fiz"));
    keyDirectories.add(new KeyDirectory("three", "buz"));
    return new RotatingServerAdvice(delegatingSf(), keyDirectories);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advice will poll directory <code>foo</code> on server <code>one</code> until no new files exist then move to directory <code>bar</code> and then directory <code>baz</code> on server <code>two</code>, etc.</p>
</div>
<div class="paragraph">
<p>This default behavior can be modified with the <code>fair</code> constructor arg:</p>
</div>
<div class="listingblock">
<div class="title">fair</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    ...
    return new RotatingServerAdvice(delegatingSf(), keyDirectories, true);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the advice will move to the next server/directory regardless of whether the previous poll returned a file.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can provide your own <code>RotatingServerAdvice.RotationPolicy</code> to reconfigure the message source as needed:</p>
</div>
<div class="listingblock">
<div class="title">policy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface RotationPolicy {

    void beforeReceive(MessageSource&lt;?&gt; source);

    void afterReceive(boolean messageReceived, MessageSource&lt;?&gt; source);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="title">custom</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RotatingServerAdvice advice() {
    return new RotatingServerAdvice(myRotationPolicy());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>local-filename-generator-expression</code> attribute (<code>localFilenameGeneratorExpression</code> on the synchronizer) can now contain the <code>#remoteDirectory</code> variable.
This allows files retrieved from different directories to be downloaded to similar directories locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow flow() {
    return IntegrationFlows.from(Ftp.inboundAdapter(sf())
                    .filter(new FtpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), "rotate"))
                    .localDirectory(new File(tmpDir))
                    .localFilenameExpression("#remoteDirectory + T(java.io.File).separator + #root")
                    .remoteDirectory("."),
                e -&gt; e.poller(Pollers.fixedDelay(1).advice(advice())))
            .channel(MessageChannels.queue("files"))
            .get();
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not configure a <code>TaskExecutor</code> on the poller when using this advice; see <a href="#conditional-pollers">Conditional Pollers for Message Sources</a> for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sftp-max-fetch"><a class="anchor" href="#sftp-max-fetch"></a>30.9. Inbound Channel Adapters: Controlling Remote File Fetching</h3>
<div class="paragraph">
<p>You should consider two properties when configuring inbound channel adapters.
<code>max-messages-per-poll</code>, as with all pollers, can be used to limit the number of messages emitted on each poll (if more than the configured value are ready).
<code>max-fetch-size</code> (since version 5.0) can limit the number of files retrieved from the remote server at a time.</p>
</div>
<div class="paragraph">
<p>The following scenarios assume the starting state is an empty local directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=1</code>: The adapter fetches one file, emits it, fetches the next file, and emit it.
Then it sleeps until the next poll.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=2</code>): The adapter fetch both files and then emits each one.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size=4</code>: The adapter fetches up to 4 files (if available) and emits the first two (if there are at least two).
The next two files will be emitted on the next poll.</p>
</li>
<li>
<p><code>max-messages-per-poll=2</code> and <code>max-fetch-size</code> not specified: The adapter fetches all remote files and emits the first two (if there are at least two).
The subsequent files are emitted on subsequent polls (two at a time).
When all are consumed, the remote fetch is attempted again, to pick up any new files.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you deploy multiple instances of an application, we recommend setting a small <code>max-fetch-size</code>, to avoid one instance &#8220;grabbing&#8221; all the files and starving other instances.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another use for <code>max-fetch-size</code> is when you want to stop fetching remote files but continue to process files that have already been fetched.
Setting the <code>maxFetchSize</code> property on the <code>MessageSource</code> (programmatically, via JMX, or via a <a href="#control-bus">control bus</a>) effectively stops the adapter from fetching more files but lets the poller continue to emit messages for files that have previously been fetched.
If the poller is active when the property is changed, the change takes effect on the next poll.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, the synchronizer can be provided with a <code>Comparator&lt;LsEntry&gt;</code>.
This is useful when restricting the number of files fetched with <code>maxFetchSize</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sftp-outbound"><a class="anchor" href="#sftp-outbound"></a>30.10. SFTP Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The SFTP outbound channel adapter is a special <code>MessageHandler</code> that connects to the remote directory and initiates a file transfer for every file it receives as the payload of an incoming <code>Message</code>.
It also supports several representations of the file so that you are not limited to the <code>File</code> object.
Similar to the FTP outbound adapter, the SFTP outbound channel adapter supports the following payloads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.io.File</code>: The actual file object</p>
</li>
<li>
<p><code>byte[]</code>: A byte array that represents the file contents</p>
</li>
<li>
<p><code>java.lang.String</code>: Text that represents the file contents</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to configure an SFTP outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:outbound-channel-adapter id="sftpOutboundAdapter"
    session-factory="sftpSessionFactory"
    channel="inputChannel"
    charset="UTF-8"
    remote-file-separator="/"
    remote-directory="foo/bar"
    remote-filename-generator-expression="payload.getName() + '-mysuffix'"
    filename-generator="fileNameGenerator"
    use-temporary-filename="true"
    chmod="600"
    mode="REPLACE"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema</a> for more detail on these attributes.</p>
</div>
<div class="sect3">
<h4 id="spel-and-the-sftp-outbound-adapter"><a class="anchor" href="#spel-and-the-sftp-outbound-adapter"></a>30.10.1. SpEL and the SFTP Outbound Adapter</h4>
<div class="paragraph">
<p>As with many other components in Spring Integration, you can use the Spring Expression Language (SpEL) when you configure an SFTP outbound channel adapter by specifying two attributes: <code>remote-directory-expression</code> and <code>remote-filename-generator-expression</code> (<a href="#sftp-inbound">described earlier</a>).
The expression evaluation context has the message as its root object, which lets you use expressions that can dynamically compute the file name or the existing directory path based on the data in the message (from either the 'payload' or the 'headers').
In the preceding example, we define the <code>remote-filename-generator-expression</code> attribute with an expression value that computes the file name based on its original name while also appending a suffix: '-mysuffix'.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.1, you can specify the <code>mode</code> when you transferring the file.
By default, an existing file is overwritten.
The modes are defined by the <code>FileExistsMode</code> enumeration, which has the following values: <code>REPLACE</code> (default), <code>APPEND</code>, <code>IGNORE</code>, and <code>FAIL</code>.
With <code>IGNORE</code> and <code>FAIL</code>, the file is not transferred.
<code>FAIL</code> causes an exception to be thrown, while <code>IGNORE</code> silently ignores the transfer (although a <code>DEBUG</code> log entry is produced).</p>
</div>
</div>
<div class="sect3">
<h4 id="avoiding-partially-written-files-2"><a class="anchor" href="#avoiding-partially-written-files-2"></a>30.10.2. Avoiding Partially Written Files</h4>
<div class="paragraph">
<p>One of the common problems when dealing with file transfers is the possibility of processing a partial file.
A file might appear in the file system before its transfer is actually complete.</p>
</div>
<div class="paragraph">
<p>To deal with this issue, Spring Integration SFTP adapters use a common algorithm in which files are transferred under a temporary name and than renamed once they are fully transferred.</p>
</div>
<div class="paragraph">
<p>By default, every file that is in the process of being transferred appear in the file system with an additional suffix, which, by default, is <code>.writing</code>.
You can change by setting the <code>temporary-file-suffix</code> attribute.</p>
</div>
<div class="paragraph">
<p>However, there may be situations where you do not want to use this technique (for example, if the server does not permit renaming files).
For situations like this, you can disable this feature by setting <code>use-temporary-file-name</code> to <code>false</code> (the default is <code>true</code>).
When this attribute is <code>false</code>, the file is written with its final name, and the consuming application needs some other mechanism to detect that the file is completely uploaded before accessing it.</p>
</div>
<div class="paragraph">
<p>Version 4.3 introduced the <code>chmod</code> attribute, which you can use to change the remote file permissions after upload.
You can use the conventional Unix octal format (for example, <code>600</code> allows read-write for the file owner only).
When configuring the adapter using java, you can use <code>setChmodOctal("600")</code> or <code>setChmodDecimal(384)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-22"><a class="anchor" href="#configuring-with-java-configuration-22"></a>30.10.3. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@IntegrationComponentScan
public class SftpJavaApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context =
                    new SpringApplicationBuilder(SftpJavaApplication.class)
                        .web(false)
                        .run(args);
        MyGateway gateway = context.getBean(MyGateway.class);
        gateway.sendToSftp(new File("/foo/bar.txt"));
    }

    @Bean
    public SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(true);
        factory.setHost("localhost");
        factory.setPort(port);
        factory.setUser("foo");
        factory.setPassword("foo");
        factory.setAllowUnknownKeys(true);
        factory.setTestSession(true);
        return new CachingSessionFactory&lt;LsEntry&gt;(factory);
    }

    @Bean
    @ServiceActivator(inputChannel = "toSftpChannel")
    public MessageHandler handler() {
        SftpMessageHandler handler = new SftpMessageHandler(sftpSessionFactory());
        handler.setRemoteDirectoryExpressionString("headers['remote-target-dir']");
        handler.setFileNameGenerator(new FileNameGenerator() {

            @Override
            public String generateFileName(Message&lt;?&gt; message) {
                 return "handlerContent.test";
            }

        });
        return handler;
    }

    @MessagingGateway
    public interface MyGateway {

         @Gateway(requestChannel = "toSftpChannel")
         void sendToSftp(File file);

    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-22"><a class="anchor" href="#configuring-with-the-java-dsl-22"></a>30.10.4. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public IntegrationFlow sftpOutboundFlow() {
        return IntegrationFlows.from("toSftpChannel")
            .handle(Sftp.outboundAdapter(this.sftpSessionFactory, FileExistsMode.FAIL)
                         .useTemporaryFileName(false)
                         .remoteDirectory("/foo")
            ).get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-outbound-gateway"><a class="anchor" href="#sftp-outbound-gateway"></a>30.11. SFTP Outbound Gateway</h3>
<div class="paragraph">
<p>The SFTP outbound gateway provides a limited set of commands that let you interact with a remote SFTP server:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ls</code> (list files)</p>
</li>
<li>
<p><code>nlst</code> (list file names)</p>
</li>
<li>
<p><code>get</code> (retrieve a file)</p>
</li>
<li>
<p><code>mget</code> (retrieve multiple files)</p>
</li>
<li>
<p><code>rm</code> (remove file(s))</p>
</li>
<li>
<p><code>mv</code> (move and rename file)</p>
</li>
<li>
<p><code>put</code> (send a file)</p>
</li>
<li>
<p><code>mput</code> (send multiple files)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="using-the-ls-command"><a class="anchor" href="#using-the-ls-command"></a>30.11.1. Using the <code>ls</code> Command</h4>
<div class="paragraph">
<p><code>ls</code> lists remote files and supports the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-1</code>: Retrieve a list of filenames.
The default is to retrieve a list of <code>FileInfo</code> objects</p>
</li>
<li>
<p><code>-a</code>: Include all files (including those starting with '.')</p>
</li>
<li>
<p><code>-f</code>: Do not sort the list</p>
</li>
<li>
<p><code>-dirs</code>: Include directories (excluded by default)</p>
</li>
<li>
<p><code>-links</code>: Include symbolic links (excluded by default)</p>
</li>
<li>
<p><code>-R</code>: List the remote directory recursively</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, filename filtering is provided in the same manner as the <code>inbound-channel-adapter</code>.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>ls</code> operation is a list of file names or a list of <code>FileInfo</code> objects (depending on whether you usr the <code>-1</code> switch).
These objects provide information such as modified time, permissions, and others.</p>
</div>
<div class="paragraph">
<p>The remote directory that the <code>ls</code> command acted on is provided in the <code>file_remoteDirectory</code> header.</p>
</div>
<div class="paragraph">
<p>When using the recursive option (<code>-R</code>), the <code>fileName</code> includes any subdirectory elements and represents the relative path to the file (relative to the remote directory).
If you use the <code>-dirs</code> option, each recursive directory is also returned as an element in the list.
In this case, we recommend that you not use the <code>-1</code> option, because you would not be able to distinguish files from directories, which you can do when you use <code>FileInfo</code> objects.</p>
</div>
<div class="paragraph">
<p>Using <code>nlst</code> Command</p>
</div>
<div class="paragraph">
<p>Version 5 introduced support for the <code>nlst</code> command.</p>
</div>
<div class="paragraph">
<p><code>nlst</code> lists remote file names and supports only one option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-f</code>: Do not sort the list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>nlst</code> operation is a list of file names.</p>
</div>
<div class="paragraph">
<p>The <code>file_remoteDirectory</code> header holds the remote directory on which the <code>nlst</code> command acted.</p>
</div>
<div class="paragraph">
<p>The SFTP protocol does not provide the ability to list names.
This command is the equivalent of the <code>ls</code> command with the <code>-1</code> option and is added here for convenience.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-get-command-2"><a class="anchor" href="#using-the-get-command-2"></a>30.11.2. Using the <code>get</code> Command</h4>
<div class="paragraph">
<p><code>get</code> retrieves a remote file and supports the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-P</code>: Preserve the timestamp of the remote file.</p>
</li>
<li>
<p><code>-stream</code>: Retrieve the remote file as a stream.</p>
</li>
<li>
<p><code>-D</code>: Delete the remote file after successful transfer.
The remote file is not deleted if the transfer is ignored, because the <code>FileExistsMode</code> is <code>IGNORE</code> and the local file already exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>file_remoteDirectory</code> header holds the remote directory, and the <code>file_remoteFile</code> header holds the filename.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from a <code>get</code> operation is a <code>File</code> object representing the retrieved file.
If you use the <code>-stream</code> option, the payload is an <code>InputStream</code> rather than a <code>File</code>.
For text files, a common use case is to combine this operation with a <a href="#file-splitter">file splitter</a> or a
<a href="#stream-transformer">stream transformer</a>.
When consuming remote files as streams, you are responsible for closing the <code>Session</code> after the stream is consumed.
For convenience, the <code>Session</code> is provided in the <code>closeableResource</code> header, and <code>IntegrationMessageHeaderAccessor</code> offers convenience method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Closeable closeable = new IntegrationMessageHeaderAccessor(message).getCloseableResource();
if (closeable != null) {
    closeable.close();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Framework components, such as the <a href="#file-splitter">File Splitter</a> and <a href="#stream-transformer">Stream Transformer</a>,
automatically close the session after the data is transferred.</p>
</div>
<div class="paragraph">
<p>The following example shows how to consume a file as a stream:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-sftp:outbound-gateway session-factory="ftpSessionFactory"
                            request-channel="inboundGetStream"
                            command="get"
                            command-options="-stream"
                            expression="payload"
                            remote-directory="ftpTarget"
                            reply-channel="stream" /&gt;

&lt;int-file:splitter input-channel="stream" output-channel="lines" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you consume the input stream in a custom component, you must close the <code>Session</code>.
You can either do that in your custom code or route a copy of the message to a <code>service-activator</code> and use SpEL, as the following example shows:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="closeSession"
    expression="headers['closeableResource'].close()" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mget-command-2"><a class="anchor" href="#using-the-mget-command-2"></a>30.11.3. Using the <code>mget</code> Command</h4>
<div class="paragraph">
<p><code>mget</code> retrieves multiple remote files based on a pattern and supports the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-P</code>: Preserve the timestamps of the remote files.</p>
</li>
<li>
<p><code>-R</code>: Retrieve the entire directory tree recursively.</p>
</li>
<li>
<p><code>-x</code>: Throw an exception if no files match the pattern (otherwise, an empty list is returned).</p>
</li>
<li>
<p><code>-D</code>: Delete each remote file after successful transfer.
If the transfer is ignored, the remote file is not deleted, because the <code>FileExistsMode</code> is <code>IGNORE</code> and the local file already exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>mget</code> operation is a <code>List&lt;File&gt;</code> object (that is, a <code>List</code> of <code>File</code> objects, each representing a retrieved file).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.0, if the <code>FileExistsMode</code> is <code>IGNORE</code>, the payload of the output message no longer contain files that were not fetched due to the file already existing.
Previously, the array contained all files, including those that already existed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The expression you use determine the remote path should produce a result that ends with <code><strong></code> for example <code>myfiles/</strong></code> fetches the complete tree under <code>myfiles</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can use a recursive <code>MGET</code>, combined with the <code>FileExistsMode.REPLACE_IF_MODIFIED</code> mode, to periodically synchronize an entire remote directory tree locally.
This mode sets the local file&#8217;s last modified timestamp to the remote file&#8217;s timestamp, regardless of the <code>-P</code> (preserve timestamp) option.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Notes for when using recursion (<code>-R</code>)</div>
<div class="paragraph">
<p>The pattern is ignored and <code>*</code> is assumed.
By default, the entire remote tree is retrieved.
However, you can filter files in the tree by providing a <code>FileListFilter</code>.
You can also filter directories in the tree this way.
A <code>FileListFilter</code> can be provided by reference or by <code>filename-pattern</code> or <code>filename-regex</code> attributes.
For example, <code>filename-regex="(subDir|.*1.txt)"</code> retrieves all files ending with <code>1.txt</code> in the remote directory and the subdirectory <code>subDir</code>.
However, we describe an alternative available after this note.</p>
</div>
<div class="paragraph">
<p>If you filter a subdirectory, no additional traversal of that subdirectory is performed.</p>
</div>
<div class="paragraph">
<p>The <code>-dirs</code> option is not allowed (the recursive <code>mget</code> uses the recursive <code>ls</code> to obtain the directory tree and the directories themselves cannot be included in the list).</p>
</div>
<div class="paragraph">
<p>Typically, you would use the <code>#remoteDirectory</code> variable in the <code>local-directory-expression</code> so that the remote directory structure is retained locally.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can configure the <code>SftpSimplePatternFileListFilter</code> and <code>SftpRegexPatternFileListFilter</code> to always pass directories by setting the <code>alwaysAcceptDirectorties</code> to <code>true</code>.
Doing so allows recursion for a simple pattern, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="starDotTxtFilter"
            class="org.springframework.integration.sftp.filters.SftpSimplePatternFileListFilter"&gt;
    &lt;constructor-arg value="*.txt" /&gt;
    &lt;property name="alwaysAcceptDirectories" value="true" /&gt;
&lt;/bean&gt;

&lt;bean id="dotStarDotTxtFilter"
            class="org.springframework.integration.sftp.filters.SftpRegexPatternFileListFilter"&gt;
    &lt;constructor-arg value="^.*\.txt$" /&gt;
    &lt;property name="alwaysAcceptDirectories" value="true" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can provide one of these filters by using the <code>filter</code> property on the gateway.</p>
</div>
<div class="paragraph">
<p>See also <a href="#sftp-partial">Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="sftp-put-command"><a class="anchor" href="#sftp-put-command"></a>30.11.4. Using the <code>put</code> Command</h4>
<div class="paragraph">
<p><code>put</code> sends a file to the remote server.
The payload of the message can be a <code>java.io.File</code>, a <code>byte[]</code>, or a <code>String</code>.
A <code>remote-filename-generator</code> (or expression) is used to name the remote file.
Other available attributes include <code>remote-directory</code>, <code>temporary-remote-directory</code> and their <code>*-expression</code> equivalents: <code>use-temporary-file-name</code> and <code>auto-create-directory</code>.
See the <a href="https://github.com/spring-projects/spring-integration/tree/master/spring-integration-core/src/main/resources/org/springframework/integration/config">schema documentation</a> for more information.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from a <code>put</code> operation is a <code>String</code> that contains the full path of the file on the server after transfer.</p>
</div>
<div class="paragraph">
<p>Version 4.3 introduced the <code>chmod</code> attribute, which changes the remote file permissions after upload.
You can use the conventional Unix octal format (for example, <code>600</code> allows read-write for the file owner only).
When configuring the adapter using java, you can use <code>setChmod(0600)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mput-command"><a class="anchor" href="#using-the-mput-command"></a>30.11.5. Using the <code>mput</code> Command</h4>
<div class="paragraph">
<p><code>mput</code> sends multiple files to the server and supports the following option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-R</code>: Recursive&#8201;&#8212;&#8201;send all files (possibly filtered) in the directory and subdirectories</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The message payload must be a <code>java.io.File</code> (or <code>String</code>) that represents a local directory.
Since version 5.1, a collection of <code>File</code> or <code>String</code> is also supported.</p>
</div>
<div class="paragraph">
<p>The same attributes as the <a href="#sftp-put-command"><code>put</code> command</a> are supported.
In addition, you can filter files in the local directory with one of <code>mput-pattern</code>, <code>mput-regex</code>, <code>mput-filter</code>, or <code>mput-filter-expression</code>.
The filter works with recursion, as long as the subdirectories themselves pass the filter.
Subdirectories that do not pass the filter are not recursed.</p>
</div>
<div class="paragraph">
<p>The message payload resulting from an <code>mget</code> operation is a <code>List&lt;String&gt;</code> object (that is, a <code>List</code> of remote file paths resulting from the transfer).</p>
</div>
<div class="paragraph">
<p>See also <a href="#sftp-partial">Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</a>.</p>
</div>
<div class="paragraph">
<p>Version 4.3 introduced the <code>chmod</code> attribute, which lets you change the remote file permissions after upload.
You can use the conventional Unix octal format (for example, <code>600</code> allows read-write for the file owner only).
When configuring the adapter with Java, you can use <code>setChmodOctal("600")</code> or <code>setChmodDecimal(384)</code>.</p>
</div>
<div class="paragraph">
<p>Using the <code>rm</code> Command</p>
</div>
<div class="paragraph">
<p>The <code>rm</code> command has no options.</p>
</div>
<div class="paragraph">
<p>If the remove operation was successful, the resulting message payload is <code>Boolean.TRUE</code>.
Otherwise, the message payload is <code>Boolean.FALSE</code>.
The <code>file_remoteDirectory</code> header holds the remote directory, and the <code>file_remoteFile</code> header holds the file name.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-mv-command-2"><a class="anchor" href="#using-the-mv-command-2"></a>30.11.6. Using the <code>mv</code> Command</h4>
<div class="paragraph">
<p>The <code>mv</code> command has no options.</p>
</div>
<div class="paragraph">
<p>The <code>expression</code> attribute defines the &#8220;from&#8221; path, and the <code>rename-expression</code> attribute defines the &#8220;to&#8221; path.
By default, the <code>rename-expression</code> is <code>headers['file_renameTo']</code>.
This expression must not evaluate to null or an empty <code>String</code>.
If necessary, any remote directories needed are created.
The payload of the result message is <code>Boolean.TRUE</code>.
The the <code>file_remoteDirectory</code> header holds the original remote directory, and the <code>file_remoteFile</code> header holds the filename.
The <code>file_renameTo</code> header holds the new path.</p>
</div>
</div>
<div class="sect3">
<h4 id="additional-command-information"><a class="anchor" href="#additional-command-information"></a>30.11.7. Additional Command Information</h4>
<div class="paragraph">
<p>The <code>get</code> and <code>mget</code> commands support the <code>local-filename-generator-expression</code> attribute.
It defines a SpEL expression to generate the names of local files during the transfer.
The root object of the evaluation context is the request message.
The <code>remoteFileName</code> variable is also available.
It is particularly useful for <code>mget</code> (for example: <code>local-filename-generator-expression="#remoteFileName.toUpperCase() + headers.foo"</code>).</p>
</div>
<div class="paragraph">
<p>The <code>get</code> and <code>mget</code> commands support the <code>local-directory-expression</code> attribute.
It defines a SpEL expression to generate the names of local directories during the transfer.
The root object of the evaluation context is the request message.
The <code>remoteDirectory</code> variable is also available.
It is particularly useful for mget (for example: <code>local-directory-expression="'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.myheader"</code>).
This attribute is mutually exclusive with the <code>local-directory</code> attribute.</p>
</div>
<div class="paragraph">
<p>For all commands, the 'expression' property of the gateway holds the path on which the command acts.
For the <code>mget</code> command, the expression might evaluate to '<strong>', meaning to retrieve all files, 'somedirectory/</strong>', and other values that end with <code>*</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a gateway configured for an <code>ls</code> command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ftp:outbound-gateway id="gateway1"
        session-factory="ftpSessionFactory"
        request-channel="inbound1"
        command="ls"
        command-options="-1"
        expression="payload"
        reply-channel="toSplitter"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The payload of the message sent to the <code>toSplitter</code> channel is a list of <code>String</code> objects, each of which contains the name of a file.
If you omitted <code>command-options="-1"</code>, the payload would be a list of <code>FileInfo</code> objects.
You can provide options as a space-delimited list (for example, <code>command-options="-1 -dirs -links"</code>).</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>GET</code>, <code>MGET</code>, <code>PUT</code>, and <code>MPUT</code> commands support a <code>FileExistsMode</code> property (<code>mode</code> when using the namespace support).
This affects the behavior when the local file exists (<code>GET</code> and <code>MGET</code>) or the remote file exists (<code>PUT</code> and <code>MPUT</code>).
The supported modes are <code>REPLACE</code>, <code>APPEND</code>, <code>FAIL</code>, and <code>IGNORE</code>.
For backwards compatibility, the default mode for <code>PUT</code> and <code>MPUT</code> operations is <code>REPLACE</code>.
For <code>GET</code> and <code>MGET</code> operations, the default is <code>FAIL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-java-configuration-23"><a class="anchor" href="#configuring-with-java-configuration-23"></a>30.11.8. Configuring with Java Configuration</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    @ServiceActivator(inputChannel = "sftpChannel")
    public MessageHandler handler() {
        return new SftpOutboundGateway(ftpSessionFactory(), "ls", "'my_remote_dir/'");
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-with-the-java-dsl-23"><a class="anchor" href="#configuring-with-the-java-dsl-23"></a>30.11.9. Configuring with the Java DSL</h4>
<div class="paragraph">
<p>The following Spring Boot application shows an example of how to configure the outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class SftpJavaApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SftpJavaApplication.class)
            .web(false)
            .run(args);
    }

    @Bean
    public SessionFactory&lt;LsEntry&gt; sftpSessionFactory() {
        DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();
        sf.setHost("localhost");
        sf.setPort(port);
        sf.setUsername("foo");
        sf.setPassword("foo");
        factory.setTestSession(true);
        return new CachingSessionFactory&lt;LsEntry&gt;(sf);
    }

    @Bean
    public QueueChannelSpec remoteFileOutputChannel() {
        return MessageChannels.queue();
    }

    @Bean
    public IntegrationFlow sftpMGetFlow() {
        return IntegrationFlows.from("sftpMgetInputChannel")
            .handle(Sftp.outboundGateway(sftpSessionFactory(),
                            AbstractRemoteFileOutboundGateway.Command.MGET, "payload")
                    .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)
                    .regexFileNameFilter("(subSftpSource|.*1.txt)")
                    .localDirectoryExpression("'myDir/' + #remoteDirectory")
                    .localFilenameExpression("#remoteFileName.replaceFirst('sftpSource', 'localTarget')"))
            .channel("remoteFileOutputChannel")
            .get();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sftp-partial"><a class="anchor" href="#sftp-partial"></a>30.11.10. Outbound Gateway Partial Success (<code>mget</code> and <code>mput</code>)</h4>
<div class="paragraph">
<p>When performing operations on multiple files (by using <code>mget</code> and <code>mput</code>) an exception can occur some time after one or more files have been transferred.
In this case (starting with version 4.2), a <code>PartialSuccessException</code> is thrown.
As well as the usual <code>MessagingException</code> properties (<code>failedMessage</code> and <code>cause</code>), this exception has two additional
properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>partialResults</code>: The successful transfer results.</p>
</li>
<li>
<p><code>derivedInput</code>: The list of files generated from the request message (such as local files to transfer for an <code>mput</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These attributes let you determine which files were successfully transferred and which were not.</p>
</div>
<div class="paragraph">
<p>In the case of a recursive <code>mput</code>, the <code>PartialSuccessException</code> may have nested <code>PartialSuccessException</code> instances.</p>
</div>
<div class="paragraph">
<p>Consider the following directory structure:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>root/
|- file1.txt
|- subdir/
   | - file2.txt
   | - file3.txt
|- zoo.txt</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the exception occurs on <code>file3.txt</code>, the <code>PartialSuccessException</code> thrown by the gateway has <code>derivedInput</code> of <code>file1.txt</code>, <code>subdir</code>, and <code>zoo.txt</code> and <code>partialResults</code> of <code>file1.txt</code>.
Its <code>cause</code> is another <code>PartialSuccessException</code> with <code>derivedInput</code> of <code>file2.txt</code> and <code>file3.txt</code> and <code>partialResults</code> of <code>file2.txt</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-jsch-logging"><a class="anchor" href="#sftp-jsch-logging"></a>30.12. SFTP/JSCH Logging</h3>
<div class="paragraph">
<p>Since we use JSch libraries (<a href="http://www.jcraft.com/jsch/" class="bare">www.jcraft.com/jsch/</a>) to provide SFTP support, you may at times require more information from the JSch API itself, especially if something is not working properly (such as authentication exceptions).
Unfortunately JSch does not use <code>commons-logging</code> but instead relies on custom implementations of their <code>com.jcraft.jsch.Logger</code> interface.
As of Spring Integration 2.0.1, we have implemented this interface.
So now, to enable JSch logging, you can configure your logger the way you usually do.
For example, the following example is valid configuration of a logger that uses Log4J:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">log4j.category.com.jcraft.jsch=DEBUG</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sftp-session-callback"><a class="anchor" href="#sftp-session-callback"></a>30.13. MessageSessionCallback</h3>
<div class="paragraph">
<p>Starting with Spring Integration version 4.2, you can use a <code>MessageSessionCallback&lt;F, T&gt;</code> implementation with the <code>&lt;int-sftp:outbound-gateway/&gt;</code> (<code>SftpOutboundGateway</code>) to perform any operation on the <code>Session&lt;LsEntry&gt;</code> with the <code>requestMessage</code> context.
You can use it for any non-standard or low-level FTP operation (or several), such as allowing access from an integration flow definition, or functional interface (lambda) implementation injection.
The following example uses a lambda:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "sftpChannel")
public MessageHandler sftpOutboundGateway(SessionFactory&lt;ChannelSftp.LsEntry&gt; sessionFactory) {
    return new SftpOutboundGateway(sessionFactory,
         (session, requestMessage) -&gt; session.list(requestMessage.getPayload()));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another example might be to pre- or post-process the file data being sent or retrieved.</p>
</div>
<div class="paragraph">
<p>When using XML configuration, the <code>&lt;int-sftp:outbound-gateway/&gt;</code> provides a <code>session-callback</code> attribute that lets you specify the <code>MessageSessionCallback</code> bean name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>session-callback</code> is mutually exclusive with the <code>command</code> and <code>expression</code> attributes.
When configuring with Java, the <code>SftpOutboundGateway</code> class offers different constructors.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stomp"><a class="anchor" href="#stomp"></a>31. STOMP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration version 4.2 introduced STOMP (Simple Text Orientated Messaging Protocol) client support.
It is based on the architecture, infrastructure, and API from the Spring Framework&#8217;s messaging module, stomp package.
Spring Integration uses many of Spring STOMP components (such as <code>StompSession</code> and <code>StompClientSupport</code>).
For more information, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-client">Spring Framework STOMP Support</a> chapter in the Spring Framework reference manual.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-stomp&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-stomp:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For server side components you need to add a <code>org.springframework:spring-websocket</code> and/or <code>io.projectreactor.netty:reactor-netty</code> dependencies.</p>
</div>
<div class="sect2">
<h3 id="stomp-overview"><a class="anchor" href="#stomp-overview"></a>31.1. Overview</h3>
<div class="paragraph">
<p>To configure STOMP, you should start with the STOMP client object.
The Spring Framework provides the following implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WebSocketStompClient</code>: Built on the Spring WebSocket API with support for standard JSR-356 WebSocket, Jetty 9, and SockJS for HTTP-based WebSocket emulation with SockJS Client.</p>
</li>
<li>
<p><code>ReactorNettyTcpStompClient</code>: Built on <code>ReactorNettyTcpClient</code> from the <code>reactor-netty</code> project.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can provide any other <code>StompClientSupport</code> implementation.
See the <a href="https://docs.spring.io/spring-integration/api/">Javadoc</a> of those classes.</p>
</div>
<div class="paragraph">
<p>The <code>StompClientSupport</code> class is designed as a <em>factory</em> to produce a <code>StompSession</code> for the provided <code>StompSessionHandler</code> and all the remaining work is done through the <em>callbacks</em> to that <code>StompSessionHandler</code> and <code>StompSession</code> abstraction.
With the Spring Integration <em>adapter</em> abstraction, we need to provide some managed shared object to represent our application as a STOMP client with its unique session.
For this purpose, Spring Integration provides the <code>StompSessionManager</code> abstraction to manage the <em>single</em> <code>StompSession</code> between any provided <code>StompSessionHandler</code>.
This allows the use of <em>inbound</em> or <em>outbound</em> channel adapters (or both) for the particular STOMP Broker.
See <code>StompSessionManager</code> (and its implementations) JavaDocs for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="stomp-inbound-adapter"><a class="anchor" href="#stomp-inbound-adapter"></a>31.2. STOMP Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The <code>StompInboundChannelAdapter</code> is a one-stop <code>MessageProducer</code> component that subscribes your Spring Integration application to the provided STOMP destinations and receives messages from them (converted from the STOMP frames by using the provided <code>MessageConverter</code> on the connected <code>StompSession</code>).
You can change the destinations (and therefore STOMP subscriptions) at runtime by using appropriate <code>@ManagedOperation</code> annotations on the <code>StompInboundChannelAdapter</code>.</p>
</div>
<div class="paragraph">
<p>For more configuration options, see <a href="#stomp-namespace">STOMP Namespace Support</a> and the <code>StompInboundChannelAdapter</code> <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/stomp/inbound/StompInboundChannelAdapter.html">Javadoc</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="stomp-outbound-adapter"><a class="anchor" href="#stomp-outbound-adapter"></a>31.3. STOMP Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The <code>StompMessageHandler</code> is the <code>MessageHandler</code> for the <code>&lt;int-stomp:outbound-channel-adapter&gt;</code> and is used to send the outgoing <code>Message&lt;?&gt;</code> instances to the STOMP <code>destination</code> (pre-configured or determined at runtime with a SpEL expression) through the <code>StompSession</code> (which is provided by the shared <code>StompSessionManager</code>).</p>
</div>
<div class="paragraph">
<p>For more configuration options see <a href="#stomp-namespace">STOMP Namespace Support</a> and the <code>StompMessageHandler</code> <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/stomp/outbound/StompMessageHandler.html">Javadoc</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="stomp-headers"><a class="anchor" href="#stomp-headers"></a>31.4. STOMP Headers Mapping</h3>
<div class="paragraph">
<p>The STOMP protocol provides headers as part of its frame.
The entire structure of the STOMP frame has the following format:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>....
COMMAND
header1:value1
header2:value2

Body^@
....</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Framework provides <code>StompHeaders</code> to represent these headers.
See the <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/simp/stomp/StompHeaders.html">Javadoc</a> for more details.
STOMP frames are converted to and from <code>Message&lt;?&gt;</code> instances and these headers are mapped to and from <code>MessageHeaders</code> instances.
Spring Integration provides a default <code>HeaderMapper</code> implementation for the STOMP adapters.
The implementation is <code>StompHeaderMapper</code>.
It provides <code>fromHeaders()</code> and <code>toHeaders()</code> operations for the inbound and outbound adapters, respectively.</p>
</div>
<div class="paragraph">
<p>As with many other Spring Integration modules, the <code>IntegrationStompHeaders</code> class has been introduced to map standard STOMP headers to <code>MessageHeaders</code>, with <code>stomp_</code> as the header name prefix.
In addition, all <code>MessageHeaders</code> instances with that prefix are mapped to the <code>StompHeaders</code> when sending to a destination.</p>
</div>
<div class="paragraph">
<p>For more information, see the <a href="https://docs.spring.io/spring-integration/api/">Javadoc</a> for those classes and the <code>mapped-headers</code> attribute description in the <a href="#stomp-namespace">STOMP Namespace Support</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="stomp-events"><a class="anchor" href="#stomp-events"></a>31.5. STOMP Integration Events</h3>
<div class="paragraph">
<p>Many STOMP operations are asynchronous, including error handling.
For example, STOMP has a <code>RECEIPT</code> server frame that it returns when a client frame has requested one by adding the <code>RECEIPT</code> header.
To provide access to these asynchronous events, Spring Integration emits <code>StompIntegrationEvent</code> instances, which you can obtain by implementing an <code>ApplicationListener</code> or by using an <code>&lt;int-event:inbound-channel-adapter&gt;</code> (see <a href="#appevent-inbound">Receiving Spring Application Events</a>).</p>
</div>
<div class="paragraph">
<p>Specifically, a <code>StompExceptionEvent</code> is emitted from the <code>AbstractStompSessionManager</code> when a <code>stompSessionListenableFuture</code> receives <code>onFailure()</code> due to failure to connect to STOMP broker.
Another example is the <code>StompMessageHandler</code>.
It processes <code>ERROR</code> STOMP frames, which are server responses to improper (unaccepted) messages sent by this <code>StompMessageHandler</code>.</p>
</div>
<div class="paragraph">
<p>The <code>StompMessageHandler</code> emits <code>StompReceiptEvent</code> as a part of <code>StompSession.Receiptable</code> callbacks in the asynchronous answers for the messages sent to the <code>StompSession</code>.
The <code>StompReceiptEvent</code> can be positive or negative, depending on whether or not the <code>RECEIPT</code> frame was received from the server within the <code>receiptTimeLimit</code> period, which you can configure on the <code>StompClientSupport</code> instance.
It defaults to <code>15 * 1000</code> (in milliseconds, so 15 seconds).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>StompSession.Receiptable</code> callbacks are added only if the <code>RECEIPT</code> STOMP header of the message to send is not <code>null</code>.
You can enable automatic <code>RECEIPT</code> header generation on the <code>StompSession</code> through its <code>autoReceipt</code> option and on the <code>StompSessionManager</code> respectively.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#stomp-java-config">STOMP Adapters Java Configuration</a> for more information how to configure Spring Integration to accept those <code>ApplicationEvent</code> instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="stomp-java-config"><a class="anchor" href="#stomp-java-config"></a>31.6. STOMP Adapters Java Configuration</h3>
<div class="paragraph">
<p>The following example shows a comprehensive Java configuration for STOMP adapters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class StompConfiguration {

    @Bean
    public ReactorNettyTcpStompClient stompClient() {
        ReactorNettyTcpStompClient stompClient = new ReactorNettyTcpStompClient("127.0.0.1", 61613);
        stompClient.setMessageConverter(new PassThruMessageConverter());
        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
        taskScheduler.afterPropertiesSet();
        stompClient.setTaskScheduler(taskScheduler);
        stompClient.setReceiptTimeLimit(5000);
        return stompClient;
    }

    @Bean
    public StompSessionManager stompSessionManager() {
        ReactorNettyTcpStompSessionManager stompSessionManager = new ReactorNettyTcpStompSessionManager(stompClient());
        stompSessionManager.setAutoReceipt(true);
        return stompSessionManager;
    }

    @Bean
    public PollableChannel stompInputChannel() {
        return new QueueChannel();
    }

    @Bean
    public StompInboundChannelAdapter stompInboundChannelAdapter() {
        StompInboundChannelAdapter adapter =
        		new StompInboundChannelAdapter(stompSessionManager(), "/topic/myTopic");
        adapter.setOutputChannel(stompInputChannel());
        return adapter;
    }

    @Bean
    @ServiceActivator(inputChannel = "stompOutputChannel")
    public MessageHandler stompMessageHandler() {
        StompMessageHandler handler = new StompMessageHandler(stompSessionManager());
        handler.setDestination("/topic/myTopic");
        return handler;
    }

    @Bean
    public PollableChannel stompEvents() {
        return new QueueChannel();
    }

    @Bean
    public ApplicationListener&lt;ApplicationEvent&gt; stompEventListener() {
        ApplicationEventListeningMessageProducer producer = new ApplicationEventListeningMessageProducer();
        producer.setEventTypes(StompIntegrationEvent.class);
        producer.setOutputChannel(stompEvents());
        return producer;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stomp-namespace"><a class="anchor" href="#stomp-namespace"></a>31.7. STOMP Namespace Support</h3>
<div class="paragraph">
<p>The Spring Integration STOMP namespace implements the inbound and outbound channel adapter components.
To include it in your configuration, provide the following namespace declaration in your application context configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-stomp="http://www.springframework.org/schema/integration/stomp"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/stomp
    https://www.springframework.org/schema/integration/stomp/spring-integration-stomp.xsd"&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="stomp-outbound-channel-adapter"><a class="anchor" href="#stomp-outbound-channel-adapter"></a>31.7.1. Understanding the <code>&lt;int-stomp:outbound-channel-adapter&gt;</code> Element</h4>
<div class="paragraph">
<p>The following listing shows the available attributes for the STOMP outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-stomp:outbound-channel-adapter
                           id=""                      <i class="conum" data-value="1"></i><b>(1)</b>
                           channel=""                 <i class="conum" data-value="2"></i><b>(2)</b>
                           stomp-session-manager=""   <i class="conum" data-value="3"></i><b>(3)</b>
                           header-mapper=""           <i class="conum" data-value="4"></i><b>(4)</b>
                           mapped-headers=""          <i class="conum" data-value="5"></i><b>(5)</b>
                           destination=""             <i class="conum" data-value="6"></i><b>(6)</b>
                           destination-expression=""  <i class="conum" data-value="7"></i><b>(7)</b>
                           auto-startup=""            <i class="conum" data-value="8"></i><b>(8)</b>
                           phase=""/&gt;                 <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
The <code>MessageHandler</code> is registered with a bean alias of <code>id</code> plus <code>.handler</code>.
If you do not set the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with the value of this <code>id</code> attribute as the bean name.
In this case, the endpoint is registered with a bean name <code>id</code> plus <code>.adapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Identifies the channel attached to this adapter if <code>id</code> is present.
See <code>id</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Reference to a <code>StompSessionManager</code> bean, which encapsulates the low-level connection and <code>StompSession</code> handling operations.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Reference to a bean that implements <code>HeaderMapper&lt;StompHeaders&gt;</code>, which maps Spring Integration <code>MessageHeaders</code> to and from
STOMP frame headers.
It is mutually exclusive with <code>mapped-headers</code>.
It defaults to <code>StompHeaderMapper</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Comma-separated list of names of STOMP Headers to be mapped to the STOMP frame headers.
It can be provided only if the <code>header-mapper</code> reference is not set.
The values in this list can also be simple patterns to be matched against the header names (such as <code>myheader*</code> or <code>*myheader</code>).
A special token (<code>STOMP_OUTBOUND_HEADERS</code>) represents all the standard STOMP headers (content-length, receipt, heart-beat, and so on).
They are included by default.
If you want to add your own headers and want the standard headers to also be mapped, you must include this token or provide your own <code>HeaderMapper</code> implementation by using <code>header-mapper</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Name of the destination to which STOMP Messages are sent.
It is mutually exclusive with the <code>destination-expression</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A SpEL expression to be evaluated at runtime against each Spring Integration <code>Message</code> as the root object.
It is mutually exclusive with the <code>destination</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Boolean value indicating whether this endpoint should start automatically.
It defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The lifecycle phase within which this endpoint should start and stop.
The lower the value, the earlier this endpoint starts and the later it stops.
The default is <code>Integer.MIN_VALUE</code>.
Values can be negative.
See <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html"><code>SmartLifeCycle</code></a>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding-the-int-stompinbound-channel-adapter-element"><a class="anchor" href="#understanding-the-int-stompinbound-channel-adapter-element"></a>31.7.2. Understanding the <code>&lt;int-stomp:inbound-channel-adapter&gt;</code> Element</h4>
<div class="paragraph">
<p>The following listing shows the available attributes for the STOMP inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-stomp:inbound-channel-adapter
                           id=""                     <i class="conum" data-value="1"></i><b>(1)</b>
                           channel=""                <i class="conum" data-value="2"></i><b>(2)</b>
                           error-channel=""          <i class="conum" data-value="3"></i><b>(3)</b>
                           stomp-session-manager=""  <i class="conum" data-value="4"></i><b>(4)</b>
                           header-mapper=""          <i class="conum" data-value="5"></i><b>(5)</b>
                           mapped-headers=""         <i class="conum" data-value="6"></i><b>(6)</b>
                           destinations=""           <i class="conum" data-value="7"></i><b>(7)</b>
                           send-timeout=""           <i class="conum" data-value="8"></i><b>(8)</b>
                           payload-type=""           <i class="conum" data-value="9"></i><b>(9)</b>
                           auto-startup=""           <i class="conum" data-value="10"></i><b>(10)</b>
                           phase=""/&gt;                <i class="conum" data-value="11"></i><b>(11)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
If you do not set the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with the value of this <code>id</code> attribute as the bean name.
In this case, the endpoint is registered with the bean name <code>id</code> plus <code>.adapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Identifies the channel attached to this adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>MessageChannel</code> bean reference to which <code>ErrorMessage</code> instances should be sent.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>See the same option on the <a href="#stomp-outbound-channel-adapter"><code>&lt;int-stomp:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Comma-separated list of names of STOMP Headers to be mapped from the STOMP frame headers.
You can only provide this if the <code>header-mapper</code> reference is not set.
The values in this list can also be simple patterns to be matched against the header names (for example, <code>myheader*</code> or <code>*myheader</code>).
A special token (<code>STOMP_INBOUND_HEADERS</code>) represents all the standard STOMP headers (content-length, receipt, heart-beat, and so on).
They are included by default.
If you want to add your own headers and want the standard headers to also be mapped, you must also include this token or provide your own <code>HeaderMapper</code> implementation using <code>header-mapper</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>See the same option on the <a href="#stomp-outbound-channel-adapter"><code>&lt;int-stomp:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Comma-separated list of STOMP destination names to subscribe.
The list of destinations (and therefore subscriptions) can be modified at runtime through the <code>addDestination()</code> and <code>removeDestination()</code> <code>@ManagedOperation</code> annotations.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Maximum amount of time (in milliseconds) to wait when sending a message to the channel if the channel can block.
For example, a <code>QueueChannel</code> can block until space is available if its maximum capacity has been reached.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Fully qualified name of the Java type for the target <code>payload</code> to convert from the incoming STOMP frame.
It defaults to <code>String.class</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>See the same option on the <a href="#stomp-outbound-channel-adapter"><code>&lt;int-stomp:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>See the same option on the <a href="#stomp-outbound-channel-adapter"><code>&lt;int-stomp:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stream"><a class="anchor" href="#stream"></a>32. Stream Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In many cases, application data is obtained from a stream.
It is not recommended to send a reference to a stream as a message payload to a consumer.
Instead, messages are created from data that is read from an input stream, and message payloads are written to an output stream one by one.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-stream&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-stream:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stream-reading"><a class="anchor" href="#stream-reading"></a>32.1. Reading from Streams</h3>
<div class="paragraph">
<p>Spring Integration provides two adapters for streams.
Both <code>ByteStreamReadingMessageSource</code> and <code>CharacterStreamReadingMessageSource</code> implement <code>MessageSource</code>.
By configuring one of these within a channel-adapter element, the polling period can be configured and the message bus can automatically detect and schedule them.
The byte stream version requires an <code>InputStream</code>, and the character stream version requires a <code>Reader</code> as the single constructor argument.
The <code>ByteStreamReadingMessageSource</code> also accepts the 'bytesPerMessage' property to determine how many bytes it tries to read into each <code>Message</code>.
The default value is 1024.
The following example creates an input stream that creates messages that each contain 2048 bytes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.integration.stream.ByteStreamReadingMessageSource"&gt;
  &lt;constructor-arg ref="someInputStream"/&gt;
  &lt;property name="bytesPerMessage" value="2048"/&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.integration.stream.CharacterStreamReadingMessageSource"&gt;
  &lt;constructor-arg ref="someReader"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>CharacterStreamReadingMessageSource</code> wraps the reader in a <code>BufferedReader</code> (if it is not one already).
You can set the buffer size used by the buffered reader in the second constructor argument.
Starting with version 5.0, a third constructor argument (<code>blockToDetectEOF</code>) controls the behavior of the <code>CharacterStreamReadingMessageSource</code>.
When <code>false</code> (the default), the <code>receive()</code> method checks whether the reader is <code>ready()</code> and returns null if not.
EOF (end of file) is not detected in this case.
When <code>true</code>, the <code>receive()</code> method blocks until data is available or EOF is detected on the underlying stream.
When EOF is detected, a <code>StreamClosedEvent</code> (application event) is published.
You can consume this event with a bean that implements <code>ApplicationListener&lt;StreamClosedEvent&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To facilitate EOF detection, the poller thread blocks in the <code>receive()</code> method until either data arrives or EOF is detected.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The poller continues to publish an event on each poll once EOF has been detected.
The application listener can stop the adapter to prevent this.
The event is published on the poller thread.
Stopping the adapter causes the thread to be interrupted.
If you intend to perform some interruptible task after stopping the adapter, you must either perform the <code>stop()</code> on a different thread or use a different thread for those downstream activities.
Note that sending to a <code>QueueChannel</code> is interruptible, so, if you wish to send a message from the listener, do it before stopping the adapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This facilitates &#8220;piping&#8221; or redirecting data to <code>stdin</code>, as the following two examples shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>cat myfile.txt | java -jar my.jar</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>java -jar my.jar &lt; foo.txt</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This approach lets the application terminate when the pipe is closed.</p>
</div>
<div class="paragraph">
<p>Four convenient factory methods are available:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static final CharacterStreamReadingMessageSource stdin() { ... }

public static final CharacterStreamReadingMessageSource stdin(String charsetName) { ... }

public static final CharacterStreamReadingMessageSource stdinPipe() { ... }

public static final CharacterStreamReadingMessageSource stdinPipe(String charsetName) { ... }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stream-writing"><a class="anchor" href="#stream-writing"></a>32.2. Writing to Streams</h3>
<div class="paragraph">
<p>For target streams, you can use either of two implementations: <code>ByteStreamWritingMessageHandler</code> or <code>CharacterStreamWritingMessageHandler</code>.
Each requires a single constructor argument (<code>OutputStream</code> for byte streams or <code>Writer</code> for character streams), and each provides a second constructor that adds the optional 'bufferSize'.
Since both of these ultimately implement the <code>MessageHandler</code> interface, you can reference them from a <code>channel-adapter</code> configuration, as described in <a href="#channel-adapter">Channel Adapter</a>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.integration.stream.ByteStreamWritingMessageHandler"&gt;
  &lt;constructor-arg ref="someOutputStream"/&gt;
  &lt;constructor-arg value="1024"/&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.integration.stream.CharacterStreamWritingMessageHandler"&gt;
  &lt;constructor-arg ref="someWriter"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stream-namespace"><a class="anchor" href="#stream-namespace"></a>32.3. Stream Namespace Support</h3>
<div class="paragraph">
<p>Spring Integration defines a namespace to reduce the configuration needed for stream-related channel adapters.
The following schema locations are needed to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:beans="http://www.springframework.org/schema/beans"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      https://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/integration/stream
      https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following code snippet shows the different configuration options that are supported to configure the inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-stream:stdin-channel-adapter id="adapterWithDefaultCharset"/&gt;

&lt;int-stream:stdin-channel-adapter id="adapterWithProvidedCharset" charset="UTF-8"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can set the <code>detect-eof</code> attribute, which sets the <code>blockToDetectEOF</code> property.
See <a href="#stream-reading">Reading from Streams</a> for more information.</p>
</div>
<div class="paragraph">
<p>To configure the outbound channel adapter, you can use the namespace support as well.
The following example shows the different configuration for an outbound channel adapters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-stream:stdout-channel-adapter id="stdoutAdapterWithDefaultCharset"
    channel="testChannel"/&gt;

&lt;int-stream:stdout-channel-adapter id="stdoutAdapterWithProvidedCharset" charset="UTF-8"
    channel="testChannel"/&gt;

&lt;int-stream:stderr-channel-adapter id="stderrAdapter" channel="testChannel"/&gt;

&lt;int-stream:stdout-channel-adapter id="newlineAdapter" append-newline="true"
    channel="testChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="syslog"><a class="anchor" href="#syslog"></a>33. Syslog Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration 2.2 introduced the syslog transformer: <code>SyslogToMapTransformer</code>.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-syslog&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-syslog:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This transformer, together with a <code>UDP</code> or <code>TCP</code> inbound adapter, could be used to receive and analyze syslog records from other hosts.
The transformer creates a message payload that contains a map of the elements from the syslog message.</p>
</div>
<div class="paragraph">
<p>Spring Integration 3.0 introduced convenient namespace support for configuring a syslog inbound adapter in a single element.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.1.1, the framework now supports the extended syslog format, as specified in <a href="https://tools.ietf.org/html/rfc5424">RFC 5424&gt;</a>.
In addition, when using TCP and RFC5424, both <code>octet counting</code> and <code>non-transparent framing</code> described in <a href="https://tools.ietf.org/html/rfc6587">RFC 6587</a> are supported.</p>
</div>
<div class="sect2">
<h3 id="syslog-inbound-adapter"><a class="anchor" href="#syslog-inbound-adapter"></a>33.1. Syslog Inbound Channel Adapter</h3>
<div class="paragraph">
<p>This element encompasses a <code>UDP</code> or <code>TCP</code> inbound channel adapter and a <code>MessageConverter</code> to convert the syslog message to a Spring Integration message.
The <code>DefaultMessageConverter</code> delegates to the <code>SyslogToMapTransformer</code>, creating a message with its payload being the <code>Map</code> of syslog fields.
In addition, all fields except the message are also made available as headers in the message and are prefixed with <code>syslog_</code>.
In this mode, only <a href="https://tools.ietf.org/html/rfc3164">RFC 3164</a> (BSD) syslogs are supported.</p>
</div>
<div class="paragraph">
<p>Since version 4.1, the <code>DefaultMessageConverter</code> has a property called <code>asMap</code> (the default is <code>true</code>).
When it is <code>false</code>, the converter leaves the message payload as the original complete syslog message (in a <code>byte[]</code>) while still setting the headers.</p>
</div>
<div class="paragraph">
<p>Since version 4.1.1, RFC 5424 is also supported, by using the <code>RFC5424MessageConverter</code>.
In this case, the fields are not copied as headers, unless <code>asMap</code> is set to <code>false</code>, in which case the original message is the payload and the decoded fields are headers.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To use RFC 5424 with a TCP transport, you must provide additional configuration to enable the different framing techniques described in RFC 6587.
The adapter needs a TCP connection factory that is configured with a <code>RFC6587SyslogDeserializer</code>.
By default, this deserializer handles <code>octet counting</code> and <code>non-transparent framing</code> by using a linefeed (LF) to delimit syslog messages.
It uses a <code>ByteArrayLfSerializer</code> when <code>octet counting</code> is not detected.
To use different <code>non-transparent</code> framing, you can provide it with some other deserializer.
While the deserializer can support both <code>octet counting</code> and <code>non-transparent framing</code>, only one form of the latter is supported.
If <code>asMap</code> is <code>false</code> on the converter, you must set the <code>retainOriginal</code> constructor argument in the <code>RFC6587SyslogDeserializer</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="syslog-inbound-examplers"><a class="anchor" href="#syslog-inbound-examplers"></a>33.1.1. Example Configuration</h4>
<div class="paragraph">
<p>The following example defines a <code>UDP</code> adapter that sends messages to the <code>syslogIn</code> channel (the adapter bean name is <code>syslogIn.adapter</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="syslogIn" port="1514" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter listens on port <code>1514</code>.</p>
</div>
<div class="paragraph">
<p>The following example defines a <code>UDP</code> adapter that sends messages to the <code>fromSyslog</code> channel (the adapter bean name is <code>syslogIn</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="syslogIn"
	channel="fromSyslog" port="1514" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter listens on port <code>1514</code>.</p>
</div>
<div class="paragraph">
<p>The following example defines a <code>TCP</code> adapter that sends messages to channel <code>syslogIn</code> (the adapter bean name is <code>syslogIn.adapter</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="bar" protocol="tcp" port="1514" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter listens on port <code>1514</code>.</p>
</div>
<div class="paragraph">
<p>Note the addition of the <code>protocol</code> attribute.
This attribute can contain <code>udp</code> or <code>tcp</code>.
It defaults to <code>udp</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>UDP</code> adapter that sends messages to channel <code>fromSyslog</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="udpSyslog"
	channel="fromSyslog"
	auto-startup="false"
	phase="10000"
	converter="converter"
	send-timeout="1000"
	error-channel="errors"&gt;
		&lt;int-syslog:udp-attributes port="1514" lookup-host="false" /&gt;
&lt;/int-syslog:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example also shows two <code>SmartLifecycle</code> attributes: <code>auto-startup</code> and <code>phase</code>.
It has a reference to a custom <code>org.springframework.integration.syslog.MessageConverter</code> with an ID of <code>converter</code> and an <code>error-channel</code>.
Also notice the <code>udp-attributes</code> child element.
You can set various UDP attributes here, as defined in <a href="#ip-udp-ib-atts">UDP Inbound Channel Adapter Attributes</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use the <code>udp-attributes</code> element, you must provide the <code>port</code> attribute there rather than on the <code>inbound-channel-adapter</code> element itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a <code>TCP</code> adapter that sends messages to channel <code>fromSyslog</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="TcpSyslog"
	protocol="tcp"
	channel="fromSyslog"
	connection-factory="cf" /&gt;

&lt;int-ip:tcp-connection-factory id="cf" type="server" port="1514" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It also shows how to reference an externally defined connection factory, which can be used for advanced configuration (socket keep-alive and other uses).
For more information, see <a href="#tcp-connection-factories">TCP Connection Factories</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The externally configured <code>connection-factory</code> must be of type <code>server</code>, and the port is defined there rather than on the <code>inbound-channel-adapter</code> element itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a <code>TCP</code> adapter that sends messages to channel <code>fromSyslog</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-syslog:inbound-channel-adapter id="rfc5424Tcp"
	protocol="tcp"
	channel="fromSyslog"
	connection-factory="cf"
	converter="rfc5424" /&gt;

&lt;int-ip:tcp-connection-factory id="cf"
	using-nio="true"
	type="server"
	port="1514"
	deserializer="rfc6587" /&gt;

&lt;bean id="rfc5424" class="org.springframework.integration.syslog.RFC5424MessageConverter" /&gt;

&lt;bean id="rfc6587" class="org.springframework.integration.syslog.inbound.RFC6587SyslogDeserializer" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example is configured to use the <code>RFC 5424</code> converter and is configured with a reference to an externally defined connection factory with the <code>RFC 6587</code> deserializer (required for RFC 5424).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ip"><a class="anchor" href="#ip"></a>34. TCP and UDP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for receiving and sending messages over internet protocols.
Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.
Each adapter provides for one-way communication over the underlying protocol.
In addition, Spring Integration provides simple inbound and outbound TCP gateways.
These are used when two-way communication is needed.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-ip&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-ip:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ip-intro"><a class="anchor" href="#ip-intro"></a>34.1. Introduction</h3>
<div class="paragraph">
<p>Two flavors each of UDP inbound and outbound channel adapters are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UnicastSendingMessageHandler</code> sends a datagram packet to a single destination.</p>
</li>
<li>
<p><code>UnicastReceivingChannelAdapter</code> receives incoming datagram packets.</p>
</li>
<li>
<p><code>MulticastSendingMessageHandler</code> sends (broadcasts) datagram packets to a multicast address.</p>
</li>
<li>
<p><code>MulticastReceivingChannelAdapter</code> receives incoming datagram packets by joining to a multicast address.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TCP inbound and outbound channel adapters are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TcpSendingMessageHandler</code> sends messages over TCP.</p>
</li>
<li>
<p><code>TcpReceivingChannelAdapter</code> receives messages over TCP.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An inbound TCP gateway is provided.
It allows for simple request-response processing.
While the gateway can support any number of connections, each connection can only be processed serially.
The thread that reads from the socket waits for, and sends, the response before reading again.
If the connection factory is configured for single use connections, the connection is closed after the socket times out.</p>
</div>
<div class="paragraph">
<p>An outbound TCP gateway is provided.
It allows for simple request-response processing.
If the associated connection factory is configured for single-use connections, a new connection is immediately created for each new request.
Otherwise, if the connection is in use, the calling thread blocks on the connection until either a response is received or a timeout or I/O error occurs.</p>
</div>
<div class="paragraph">
<p>The TCP and UDP inbound channel adapters and the TCP inbound gateway support the <code>error-channel</code> attribute.
This provides the same basic functionality as described in <a href="#gateway-proxy">Enter the <code>GatewayProxyFactoryBean</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="udp-adapters"><a class="anchor" href="#udp-adapters"></a>34.2. UDP Adapters</h3>
<div class="paragraph">
<p>This section describes how to configure and use the UDP adapters.</p>
</div>
<div class="sect3">
<h4 id="outbound-udp-adapters-xml-configuration"><a class="anchor" href="#outbound-udp-adapters-xml-configuration"></a>34.2.1. Outbound UDP Adapters (XML Configuration)</h4>
<div class="paragraph">
<p>The following example configures a UDP outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-outbound-channel-adapter id="udpOut"
    host="somehost"
    port="11111"
    multicast="false"
    channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When setting <code>multicast</code> to <code>true</code>, you should also provide the multicast address in the host attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>UDP is an efficient but unreliable protocol.
Spring Integration adds two attributes to improve reliability: <code>check-length</code> and <code>acknowledge</code>.
When <code>check-length</code> is set to <code>true</code>, the adapter precedes the message data with a length field (four bytes in network byte order).
This enables the receiving side to verify the length of the packet received.
If a receiving system uses a buffer that is too short to contain the packet, the packet can be truncated.
The <code>length</code> header provides a mechanism to detect this.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can set the <code>port</code> to <code>0</code>, in which case the operating system chooses the port.
The chosen port can be discovered by invoking <code>getPort()</code> after the adapter is started and <code>isListening()</code> returns <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The preceding example shows an outbound channel adapter that adds length checking to the datagram packets:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-outbound-channel-adapter id="udpOut"
    host="somehost"
    port="11111"
    multicast="false"
    check-length="true"
    channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The recipient of the packet must also be configured to expect a length to precede the actual data.
For a Spring Integration UDP inbound channel adapter, set its <code>check-length</code> attribute.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second reliability improvement allows an application-level acknowledgment protocol to be used.
The receiver must send an acknowledgment to the sender within a specified time.</p>
</div>
<div class="paragraph">
<p>The following example shows an outbound channel adapter that adds length checking to the datagram packets and waits for an acknowledgment:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-outbound-channel-adapter id="udpOut"
    host="somehost"
    port="11111"
    multicast="false"
    check-length="true"
    acknowledge="true"
    ack-host="thishost"
    ack-port="22222"
    ack-timeout="10000"
    channel="exampleChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Setting <code>acknowledge</code> to <code>true</code> implies that the recipient of the packet can interpret the header added to the packet containing acknowledgment data (host and port).
Most likely, the recipient is a Spring Integration inbound channel adapter.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When multicast is true, an additional attribute (<code>min-acks-for-success</code>) specifies how many acknowledgments must be received within the <code>ack-timeout</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can set the <code>ackPort</code> to <code>0</code>, in which case the operating system chooses the port.</p>
</div>
</div>
<div class="sect3">
<h4 id="outbound-udp-adapters-java-configuration"><a class="anchor" href="#outbound-udp-adapters-java-configuration"></a>34.2.2. Outbound UDP Adapters (Java Configuration)</h4>
<div class="paragraph">
<p>The following example shows how to configure an outbound UDP adapter with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "udpOut")
public UnicastSendingMessageHandler handler() {
	return new UnicastSendingMessageHandler("localhost", 11111);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(or <code>MulticastSendingChannelAdapter</code> for multicast).</p>
</div>
</div>
<div class="sect3">
<h4 id="outbound-udp-adapters-java-dsl-configuration"><a class="anchor" href="#outbound-udp-adapters-java-dsl-configuration"></a>34.2.3. Outbound UDP Adapters (Java DSL Configuration)</h4>
<div class="paragraph">
<p>The following example shows how to configure an outbound UDP adapter with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow udpOutFlow() {
	return IntegrationFlows.from("udpOut")
			.handle(Udp.outboundAdapter("localhost", 1234))
			.get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inbound-udp-adapters-xml-configuration"><a class="anchor" href="#inbound-udp-adapters-xml-configuration"></a>34.2.4. Inbound UDP Adapters (XML Configuration)</h4>
<div class="paragraph">
<p>The following example shows how to configure a basic unicast inbound udp channel adapter.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-inbound-channel-adapter id="udpReceiver"
    channel="udpOutChannel"
    port="11111"
    receive-buffer-size="500"
    multicast="false"
    check-length="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a basic multicast inbound udp channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-inbound-channel-adapter id="udpReceiver"
    channel="udpOutChannel"
    port="11111"
    receive-buffer-size="500"
    multicast="true"
    multicast-address="225.6.7.8"
    check-length="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, reverse DNS lookups are done on inbound packets to convert IP addresses to hostnames for use in message headers.
In environments where DNS is not configured, this can cause delays.
You can override this default behavior by setting the <code>lookup-host</code> attribute to <code>false</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="inbound-udp-adapters-java-configuration"><a class="anchor" href="#inbound-udp-adapters-java-configuration"></a>34.2.5. Inbound UDP Adapters (Java Configuration)</h4>
<div class="paragraph">
<p>The following example shows how to configure an inbound UDP adapter with Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UnicastReceivingChannelAdapter udpIn() {
	UnicastReceivingChannelAdapter adapter = new UnicastReceivingChannelAdapter(11111);
	adapter.setOutputChannelName("udpChannel");
	return adapter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure an inbound UDP adapter with the Java DSL:</p>
</div>
</div>
<div class="sect3">
<h4 id="inbound-udp-adapters-java-dsl-configuration"><a class="anchor" href="#inbound-udp-adapters-java-dsl-configuration"></a>34.2.6. Inbound UDP Adapters (Java DSL Configuration)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow udpIn() {
	return IntegrationFlows.from(Udp.inboundAdapter(11111))
			.channel("udpChannel")
			.get();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="server-listening-events"><a class="anchor" href="#server-listening-events"></a>34.2.7. Server Listening Events</h4>
<div class="paragraph">
<p>Starting with version 5.0.2, a <code>UdpServerListeningEvent</code> is emitted when an inbound adapter is started and has begun listening.
This is useful when the adapter is configured to listen on port 0, meaning that the operating system chooses the port.
It can also be used instead of polling <code>isListening()</code>, if you need to wait before starting some other process that will
connect to the socket.</p>
</div>
</div>
<div class="sect3">
<h4 id="advanced-outbound-configuration"><a class="anchor" href="#advanced-outbound-configuration"></a>34.2.8. Advanced Outbound Configuration</h4>
<div class="paragraph">
<p>The <code>&lt;int-ip:udp-outbound-channel-adapter&gt;</code> (<code>UnicastSendingMessageHandler</code>) has <code>destination-expression</code> and <code>socket-expression</code> options.</p>
</div>
<div class="paragraph">
<p>You can use the <code>destination-expression</code> as a runtime alternative to the hardcoded <code>host</code>-<code>port</code> pair to determine the destination address for the outgoing datagram packet against a <code>requestMessage</code> (with the root object for the evaluation context).
The expression must evaluate to an <code>URI</code>, a <code>String</code> in the URI style (see <a href="https://www.ietf.org/rfc/rfc2396.txt">RFC-2396</a>), or a <code>SocketAddress</code>.
You can also use the inbound <code>IpHeaders.PACKET_ADDRESS</code> header for this expression.
In the framework, the <code>DatagramPacketMessageMapper</code> populates this header when we receive datagrams in the <code>UnicastReceivingChannelAdapter</code> and convert them to messages.
The header value is exactly the result of <code>DatagramPacket.getSocketAddress()</code> of the incoming datagram.</p>
</div>
<div class="paragraph">
<p>With the <code>socket-expression</code>, the outbound channel adapter can use (for example) an inbound channel adapter socket to send datagrams through the same port which they were received.
It is useful in a scenario where our application works as a UDP server and clients operate behind network address translation (NAT).
This expression must evaluate to a <code>DatagramSocket</code>.
The <code>requestMessage</code> is used as the root object for the evaluation context.
You cannot use the <code>socket-expression</code> parameter with the <code>multicast</code> and <code>acknowledge</code> parameters.
The following example shows how to configure a UDP inbound channel adapter with a transformer that converts to upper case and uses a socket:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:udp-inbound-channel-adapter id="inbound" port="0" channel="in" /&gt;

&lt;int:channel id="in" /&gt;

&lt;int:transformer expression="new String(payload).toUpperCase()"
                       input-channel="in" output-channel="out"/&gt;

&lt;int:channel id="out" /&gt;

&lt;int-ip:udp-outbound-channel-adapter id="outbound"
                        socket-expression="@inbound.socket"
                        destination-expression="headers['ip_packetAddress']"
                        channel="out" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent configuration with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow udpEchoUpcaseServer() {
	return IntegrationFlows.from(Udp.inboundAdapter(11111).id("udpIn"))
			.&lt;byte[], String&gt;transform(p -&gt; new String(p).toUpperCase())
			.handle(Udp.outboundAdapter("headers['ip_packetAddress']")
					.socketExpression("@udpIn.socket"))
			.get();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tcp-connection-factories"><a class="anchor" href="#tcp-connection-factories"></a>34.3. TCP Connection Factories</h3>
<div class="sect3">
<h4 id="overview-3"><a class="anchor" href="#overview-3"></a>34.3.1. Overview</h4>
<div class="paragraph">
<p>For TCP, the configuration of the underlying connection is provided by using a connection factory.
Two types of connection factory are provided: a client connection factory and a server connection factory.
Client connection factories establish outgoing connections.
Server connection factories listen for incoming connections.</p>
</div>
<div class="paragraph">
<p>An outbound channel adapter uses a client connection factory, but you can also provide a reference to a client connection factory to an inbound channel adapter.
That adapter receives any incoming messages that are received on connections created by the outbound adapter.</p>
</div>
<div class="paragraph">
<p>An inbound channel adapter or gateway uses a server connection factory.
(In fact, the connection factory cannot function without one).
You can also provide a reference to a server connection factory to an outbound adapter.
You can then use that adapter to send replies to incoming messages on the same connection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Reply messages are routed to the connection only if the reply contains the <code>ip_connectionId</code> header that was inserted into the original message by the connection factory.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This is the extent of message correlation performed when sharing connection factories between inbound and outbound adapters.
Such sharing allows for asynchronous two-way communication over TCP.
By default, only payload information is transferred using TCP.
Therefore, any message correlation must be performed by downstream components such as aggregators or other endpoints.
Support for transferring selected headers was introduced in version 3.0.
For more information, see <a href="#ip-correlation">TCP Message Correlation</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You may give  a reference to a connection factory to a maximum of one adapter of each type.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides connection factories that use <code>java.net.Socket</code> and <code>java.nio.channel.SocketChannel</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a simple server connection factory that uses <code>java.net.Socket</code> connections:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-connection-factory id="server"
    type="server"
    port="1234"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a simple server connection factory that uses <code>java.nio.channel.SocketChannel</code> connections:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-connection-factory id="server"
    type="server"
    port="1234"
    using-nio="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with Spring Integration version 4.2, if the server is configured to listen on a random port (by setting the port to <code>0</code>), you can get the actual port chosen by the OS by using <code>getPort()</code>.
Also, <code>getServerSocketAddress()</code> lets you get the complete <code>SocketAddress</code>.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ip/tcp/connection/TcpServerConnectionFactory.html">Javadoc for the <code>TcpServerConnectionFactory</code> interface</a> for more information.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-connection-factory id="client"
    type="client"
    host="localhost"
    port="1234"
    single-use="true"
    so-timeout="10000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a client connection factory that uses <code>java.net.Socket</code> connections and creates a new connection for each message:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-connection-factory id="client"
    type="client"
    host="localhost"
    port="1234"
    single-use="true"
    so-timeout="10000"
    using-nio=true/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message-demarcation-serializers-and-deserializers"><a class="anchor" href="#message-demarcation-serializers-and-deserializers"></a>34.3.2. Message Demarcation (Serializers and Deserializers)</h4>
<div class="paragraph">
<p>TCP is a streaming protocol.
This means that some structure has to be provided to data transported over TCP so that the receiver can demarcate the data into discrete messages.
Connection factories are configured to use serializers and deserializers to convert between the message payload and the bits that are sent over TCP.
This is accomplished by providing a deserializer and a serializer for inbound and outbound messages, respectively.
Spring Integration provides a number of standard serializers and deserializers.</p>
</div>
<div class="paragraph">
<p><code>ByteArrayCrlfSerializer</code><sup>*</sup> converts a byte array to a stream of bytes followed by carriage return and linefeed characters (<code>\r\n</code>).
This is the default serializer (and deserializer) and can be used (for example) with telnet as a client.</p>
</div>
<div class="paragraph">
<p>The <code>ByteArraySingleTerminatorSerializer</code><sup>*</sup> converts a byte array to a stream of bytes followed by a single termination character (the default is <code>0x00</code>).</p>
</div>
<div class="paragraph">
<p>The <code>ByteArrayLfSerializer</code><sup>*</sup> converts a byte array to a stream of bytes followed by a single linefeed character (<code>0x0a</code>).</p>
</div>
<div class="paragraph">
<p>The <code>ByteArrayStxEtxSerializer</code><sup>*</sup> converts a byte array to a stream of bytes preceded by an STX (<code>0x02</code>) and followed by an ETX (<code>0x03</code>).</p>
</div>
<div class="paragraph">
<p>The <code>ByteArrayLengthHeaderSerializer</code> converts a byte array to a stream of bytes preceded by a binary length in network byte order (big endian).
This an efficient deserializer because it does not have to parse every byte to look for a termination character sequence.
It can also be used for payloads that contain binary data.
The preceding serializers support only text in the payload.
The default size of the length header is four bytes (an Integer), allowing for messages up to (2^31 - 1) bytes.
However, the <code>length</code> header can be a single byte (unsigned) for messages up to 255 bytes, or an unsigned short (2 bytes) for messages up to (2^16 - 1) bytes.
If you need any other format for the header, you can subclass <code>ByteArrayLengthHeaderSerializer</code> and provide implementations for the <code>readHeader</code> and <code>writeHeader</code> methods.
The absolute maximum data size is (2^31 - 1) bytes.</p>
</div>
<div class="paragraph">
<p>The <code>ByteArrayRawSerializer</code><sup>*</sup>, converts a byte array to a stream of bytes and adds no additional message demarcation data.
With this serializer (and deserializer), the end of a message is indicated by the client closing the socket in an orderly fashion.
When using this serializer, message reception hangs until the client closes the socket or a timeout occurs.
A timeout does not result in a message.
When this serializer is being used and the client is a Spring Integration application, the client must use a connection factory that is configured with <code>single-use="true"</code>.
Doing so causes the adapter to close the socket after sending the message.
The serializer does not, by itself, close the connection.
You should use this serializer only with the connection factories used by channel adapters (not gateways), and the connection factories should be used by either an inbound or outbound adapter but not both.
See also <code>ByteArrayElasticRawDeserializer</code>, later in this section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before version 4.2.2, when using non-blocking I/O (NIO), this serializer treated a timeout (during read) as an end of file, and the data read so far was emitted as a message.
This is unreliable and should not be used to delimit messages.
It now treats such conditions as an exception.
In the unlikely event that you use it this way, you can restore the previous behavior by setting the <code>treatTimeoutAsEndOfMessage</code> constructor argument to <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each of these is a subclass of <code>AbstractByteArraySerializer</code>, which implements both <code>org.springframework.core.serializer.Serializer</code> and <code>org.springframework.core.serializer.Deserializer</code>.
For backwards compatibility, connections that use any subclass of <code>AbstractByteArraySerializer</code> for serialization also accept a <code>String</code> that is first converted to a byte array.
Each of these serializers and deserializers converts an input stream that contains the corresponding format to a byte array payload.</p>
</div>
<div class="paragraph">
<p>To avoid memory exhaustion due to a badly behaved client (one that does not adhere to the protocol of the configured serializer), these serializers impose a maximum message size.
If an incoming message exceeds this size, an exception is thrown.
The default maximum message size is 2048 bytes.
You can increase it by setting the <code>maxMessageSize</code> property.
If you use the default serializer or deserializer and wish to increase the maximum message size, you must declare the maximum message size as an explicit bean with the <code>maxMessageSize</code> property set and configure the connection factory to use that bean.</p>
</div>
<div class="paragraph">
<p>The classes marked with <sup>*</sup> earlier in this section use an intermediate buffer and copy the decoded data to a final buffer of the correct
size.
Starting with version 4.3, you can configure these buffers by setting a <code>poolSize</code> property to let these raw buffers be reused instead of being allocated and discarded for each message, which is the default behavior.
Setting the property to a negative value creates a pool that has no bounds.
If the pool is bounded, you can also set the <code>poolWaitTimeout</code> property (in milliseconds), after which an exception is thrown if no buffer becomes available.
It defaults to infinity.
Such an exception causes the socket to be closed.</p>
</div>
<div class="paragraph">
<p>If you wish to use the same mechanism in custom deserializers, you can extend <code>AbstractPooledBufferByteArraySerializer</code> (instead of its super class, <code>AbstractByteArraySerializer</code>) and implement <code>doDeserialize()</code> instead of <code>deserialize()</code>.
The buffer is automatically returned to the pool.
<code>AbstractPooledBufferByteArraySerializer</code> also provides a convenient utility method: <code>copyToSizedArray()</code>.</p>
</div>
<div class="paragraph">
<p>Version 5.0 added the <code>ByteArrayElasticRawDeserializer</code>.
This is similar to the deserializer side of <code>ByteArrayRawSerializer</code> above, except that it is not necessary to set a <code>maxMessageSize</code>.
Internally, it uses a <code>ByteArrayOutputStream</code> that lets the buffer grow as needed.
The client must close the socket in an orderly manner to signal end of message.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This deserializer should only be used when the peer is trusted; it is susceptible to a DoS attach due to out of memory conditions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>MapJsonSerializer</code> uses a Jackson <code>ObjectMapper</code> to convert between a <code>Map</code> and JSON.
You can use this serializer in conjunction with a <code>MessageConvertingTcpMessageMapper</code> and a <code>MapMessageConverter</code> to transfer selected headers and the payload in JSON.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Jackson <code>ObjectMapper</code> cannot demarcate messages in the stream.
Therefore, the <code>MapJsonSerializer</code> needs to delegate to another serializer or deserializer to handle message demarcation.
By default, a <code>ByteArrayLfSerializer</code> is used, resulting in messages with a format of <code>&lt;json&gt;&lt;LF&gt;</code> on the wire, but you can configure it to use others instead.
(The next example shows how to do so.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The final standard serializer is <code>org.springframework.core.serializer.DefaultSerializer</code>, which you can use to convert serializable objects with Java serialization.
<code>org.springframework.core.serializer.DefaultDeserializer</code> is provided for inbound deserialization of streams that contain serializable objects.</p>
</div>
<div class="paragraph">
<p>If you do not wish to use the default serializer and deserializer (<code>ByteArrayCrLfSerializer</code>), you must set the <code>serializer</code> and <code>deserializer</code> attributes on the connection factory.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="javaSerializer"
      class="org.springframework.core.serializer.DefaultSerializer" /&gt;
&lt;bean id="javaDeserializer"
      class="org.springframework.core.serializer.DefaultDeserializer" /&gt;

&lt;int-ip:tcp-connection-factory id="server"
    type="server"
    port="1234"
    deserializer="javaDeserializer"
    serializer="javaSerializer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A server connection factory that uses <code>java.net.Socket</code> connections and uses Java serialization on the wire.</p>
</div>
<div class="paragraph">
<p>For full details of the attributes available on connection factories, see <a href="#ip-annotation">the reference</a> at the end of this section.</p>
</div>
<div class="paragraph">
<p>By default, reverse DNS lookups are done on inbound packets to convert IP addresses to hostnames for use in message headers.
In environments where DNS is not configured, this can cause connection delays.
You can override this default behavior by setting the <code>lookup-host</code> attribute to <code>false</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also modify the attributes of sockets and socket factories.
See <a href="#ssl-tls">SSL/TLS Support</a>.
As noted there, such modifications are possible whether or not SSL is being used.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="custom-serializers-and-deserializers"><a class="anchor" href="#custom-serializers-and-deserializers"></a>34.3.3. Custom Serializers and Deserializers</h4>
<div class="paragraph">
<p>If your data is not in a format supported by one of the standard deserializers, you can implement your own; you can also implement a custom serializer.</p>
</div>
<div class="paragraph">
<p>To implement a custom serializer and deserializer pair, implement the <code>org.springframework.core.serializer.Deserializer</code> and <code>org.springframework.core.serializer.Serializer</code> interfaces.</p>
</div>
<div class="paragraph">
<p>When the deserializer detects a closed input stream between messages, it must throw a <code>SoftEndOfStreamException</code>; this is a signal to the framework to indicate that the close was "normal".
If the stream is closed while decoding a message, some other exception should be thrown instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="caching-cf"><a class="anchor" href="#caching-cf"></a>34.3.4. TCP Caching Client Connection Factory</h4>
<div class="paragraph">
<p>As <a href="#ip-intro">noted earlier</a>, TCP sockets can be 'single-use' (one request or response) or shared.
Shared sockets do not perform well with outbound gateways in high-volume environments, because the socket can only process one request or response at a time.</p>
</div>
<div class="paragraph">
<p>To improve performance, you can use collaborating channel adapters instead of gateways, but that requires application-level message correlation.
See <a href="#ip-correlation">TCP Message Correlation</a> for more information.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.2 introduced a caching client connection factory, which uses a pool of shared sockets, letting a gateway process multiple concurrent requests with a pool of shared connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="failover-cf"><a class="anchor" href="#failover-cf"></a>34.3.5. TCP Failover Client Connection Factory</h4>
<div class="paragraph">
<p>You can configure a TCP connection factory that supports failover to one or more other servers.
When sending a message, the factory iterates over all its configured factories until either the message can be sent or no connection can be found.
Initially, the first factory in the configured list is used.
If a connection subsequently fails, the next factory becomes the current factory.
The following example shows how to configure a failover client connection factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="failCF" class="o.s.i.ip.tcp.connection.FailoverClientConnectionFactory"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;ref bean="clientFactory1"/&gt;
            &lt;ref bean="clientFactory2"/&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the failover connection factory, the <code>singleUse</code> property must be consistent between the factory itself and the list of factories it is configured to use.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="tcp-affinity-cf"><a class="anchor" href="#tcp-affinity-cf"></a>34.3.6. TCP Thread Affinity Connection Factory</h4>
<div class="paragraph">
<p>Spring Integration version 5.0 introduced this connection factory.
It binds a connection to the calling thread, and the same connection is reused each time that thread sends a message.
This continues until the connection is closed (by the server or the network) or until the thread calls the <code>releaseConnection()</code> method.
The connections themselves are provided by another client factory implementation, which must be configured to provide non-shared (single-use) connections so that each thread gets a connection.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a TCP thread affinity connection factory:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public TcpNetClientConnectionFactory cf() {
    TcpNetClientConnectionFactory cf = new TcpNetClientConnectionFactory("localhost",
            Integer.parseInt(System.getProperty(PORT)));
    cf.setSingleUse(true);
    return cf;
}

@Bean
public ThreadAffinityClientConnectionFactory tacf() {
    return new ThreadAffinityClientConnectionFactory(cf());
}

@Bean
@ServiceActivator(inputChannel = "out")
public TcpOutboundGateway outGate() {
    TcpOutboundGateway outGate = new TcpOutboundGateway();
    outGate.setConnectionFactory(tacf());
    outGate.setReplyChannelName("toString");
    return outGate;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ip-interceptors"><a class="anchor" href="#ip-interceptors"></a>34.4. TCP Connection Interceptors</h3>
<div class="paragraph">
<p>You can configure connection factories with a reference to a <code>TcpConnectionInterceptorFactoryChain</code>.
You can use interceptors to add behavior to connections, such as negotiation, security, and other options.
No interceptors are currently provided by the framework, but see <a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/InterceptedSharedConnectionTests.java"><code>InterceptedSharedConnectionTests</code> in the source repository</a> for an example.</p>
</div>
<div class="paragraph">
<p>The <code>HelloWorldInterceptor</code> used in the test case works as follows:</p>
</div>
<div class="paragraph">
<p>The interceptor is first configured with a client connection factory.
When the first message is sent over an intercepted connection, the interceptor sends 'Hello' over the connection and expects to receive 'world!'.
When that occurs, the negotiation is complete and the original message is sent.
Further messages that use the same connection are sent without any additional negotiation.</p>
</div>
<div class="paragraph">
<p>When configured with a server connection factory, the interceptor requires the first message to be 'Hello' and, if it is, returns 'world!'.
Otherwise it throws an exception that causes the connection to be closed.</p>
</div>
<div class="paragraph">
<p>All <code>TcpConnection</code> methods are intercepted.
Interceptor instances are created for each connection by an interceptor factory.
If an interceptor is stateful, the factory should create a new instance for each connection.
If there is no state, the same interceptor can wrap each connection.
Interceptor factories are added to the configuration of an interceptor factory chain, which you can provide to a connection factory by setting the <code>interceptor-factory</code> attribute.
Interceptors must extend <code>TcpConnectionInterceptorSupport</code>.
Factories must implement the <code>TcpConnectionInterceptorFactory</code> interface.
<code>TcpConnectionInterceptorSupport</code> has passthrough methods.
By extending this class, you only need to implement those methods you wish to intercept.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a connection interceptor factory chain:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="helloWorldInterceptorFactory"
    class="o.s.i.ip.tcp.connection.TcpConnectionInterceptorFactoryChain"&gt;
    &lt;property name="interceptors"&gt;
        &lt;array&gt;
            &lt;bean class="o.s.i.ip.tcp.connection.HelloWorldInterceptorFactory"/&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;int-ip:tcp-connection-factory id="server"
    type="server"
    port="12345"
    using-nio="true"
    single-use="true"
    interceptor-factory-chain="helloWorldInterceptorFactory"/&gt;

&lt;int-ip:tcp-connection-factory id="client"
    type="client"
    host="localhost"
    port="12345"
    single-use="true"
    so-timeout="100000"
    using-nio="true"
    interceptor-factory-chain="helloWorldInterceptorFactory"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tcp-events"><a class="anchor" href="#tcp-events"></a>34.5. TCP Connection Events</h3>
<div class="paragraph">
<p>Beginning with version 3.0, changes to <code>TcpConnection</code> instances are reported by <code>TcpConnectionEvent</code> instances.
<code>TcpConnectionEvent</code> is a subclass of <code>ApplicationEvent</code> and can thus be received by any <code>ApplicationListener</code> defined in the <code>ApplicationContext</code>&#8201;&#8212;&#8201;for example <a href="#appevent-inbound">an event inbound channel adapter</a>.</p>
</div>
<div class="paragraph">
<p><code>TcpConnectionEvents</code> have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connectionId</code>: The connection identifier, which you can use in a message header to send data to the connection.</p>
</li>
<li>
<p><code>connectionFactoryName</code>: The bean name of the connection factory to which the connection belongs.</p>
</li>
<li>
<p><code>throwable</code>: The <code>Throwable</code> (for <code>TcpConnectionExceptionEvent</code> events only).</p>
</li>
<li>
<p><code>source</code>: The <code>TcpConnection</code>.
You can use this, for example, to determine the remote IP Address with <code>getHostAddress()</code> (cast required).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, since version 4.0, the standard deserializers discussed in <a href="#tcp-connection-factories">TCP Connection Factories</a> now emit <code>TcpDeserializationExceptionEvent</code> instances when they encounter problems while decoding the data stream.
These events contain the exception, the buffer that was in the process of being built, and an offset into the buffer (if available) at the point where the exception occurred.
Applications can use a normal <code>ApplicationListener</code> or an <code>ApplicationEventListeningMessageProducer</code> (see <a href="#appevent-inbound">Receiving Spring Application Events</a>) to capture these events, allowing analysis of the problem.</p>
</div>
<div class="paragraph">
<p>Starting with versions 4.0.7 and 4.1.3, <code>TcpConnectionServerExceptionEvent</code> instances are published whenever an unexpected exception occurs on a server socket (such as a <code>BindException</code> when the server socket is in use).
These events have a reference to the connection factory and the cause.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.2, <code>TcpConnectionFailedCorrelationEvent</code> instances are published whenever an endpoint (inbound gateway or
collaborating outbound channel adapter) receives a message that cannot be routed to a connection because the
<code>ip_connectionId</code> header is invalid.
Outbound gateways also publish this event when a late reply is received (the sender thread has timed out).
The event contains the connection ID as well as an exception in the <code>cause</code> property, which contains the failed message.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, a <code>TcpConnectionServerListeningEvent</code> is emitted when a server connection factory is started.
This is useful when the factory is configured to listen on port 0, meaning that the operating system chooses the port.
It can also be used instead of polling <code>isListening()</code>, if you need to wait before starting some other process that connects to the socket.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To avoid delaying the listening thread from accepting connections, the event is published on a separate thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3.2, a <code>TcpConnectionFailedEvent</code> is emitted whenever a client connection cannot be created.
The source of the event is the connection factory, which you can use to determine the host and port to which the connection could not be established.</p>
</div>
</div>
<div class="sect2">
<h3 id="tcp-adapters"><a class="anchor" href="#tcp-adapters"></a>34.6. TCP Adapters</h3>
<div class="paragraph">
<p>TCP inbound and outbound channel adapters that use connection factories <a href="#tcp-events">mentioned earlier</a> are provided.
These adapters have two relevant attributes: <code>connection-factory</code> and <code>channel</code>.
The <code>connection-factory</code> attribute indicates which connection factory is to be used to manage connections for the adapter.
The <code>channel</code> attribute specifies the channel on which messages arrive at an outbound adapter and on which messages are placed by an inbound adapter.
While both inbound and outbound adapters can share a connection factory, server connection factories are always &#8220;owned&#8221; by an inbound adapter.
Client connection factories are always &#8220;owned&#8221; by an outbound adapter.
Only one adapter of each type may get a reference to a connection factory.
The following example shows how to define client and server TCP connection factories:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="javaSerializer"
      class="org.springframework.core.serializer.DefaultSerializer"/&gt;
&lt;bean id="javaDeserializer"
      class="org.springframework.core.serializer.DefaultDeserializer"/&gt;

&lt;int-ip:tcp-connection-factory id="server"
    type="server"
    port="1234"
    deserializer="javaDeserializer"
    serializer="javaSerializer"
    using-nio="true"
    single-use="true"/&gt;

&lt;int-ip:tcp-connection-factory id="client"
    type="client"
    host="localhost"
    port="#{server.port}"
    single-use="true"
    so-timeout="10000"
    deserializer="javaDeserializer"
    serializer="javaSerializer"/&gt;

&lt;int:channel id="input" /&gt;

&lt;int:channel id="replies"&gt;
    &lt;int:queue/&gt;
&lt;/int:channel&gt;

&lt;int-ip:tcp-outbound-channel-adapter id="outboundClient"
    channel="input"
    connection-factory="client"/&gt;

&lt;int-ip:tcp-inbound-channel-adapter id="inboundClient"
    channel="replies"
    connection-factory="client"/&gt;

&lt;int-ip:tcp-inbound-channel-adapter id="inboundServer"
    channel="loop"
    connection-factory="server"/&gt;

&lt;int-ip:tcp-outbound-channel-adapter id="outboundServer"
    channel="loop"
    connection-factory="server"/&gt;

&lt;int:channel id="loop"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding configuration, messages arriving in the <code>input</code> channel are serialized over connections created by <code>client</code> connection factory, received at the server, and placed on the <code>loop</code> channel.
Since <code>loop</code> is the input channel for <code>outboundServer</code>, the message is looped back over the same connection, received by <code>inboundClient</code>, and deposited in the <code>replies</code> channel.
Java serialization is used on the wire.</p>
</div>
<div class="paragraph">
<p>Normally, inbound adapters use a <code>type="server"</code> connection factory, which listens for incoming connection requests.
In some cases, you may want to establish the connection in reverse, such that the inbound adapter connects to an external server and then waits for inbound messages on that connection.</p>
</div>
<div class="paragraph">
<p>This topology is supported by setting <code>client-mode="true"</code> on the inbound adapter.
In this case, the connection factory must be of type <code>client</code> and must have <code>single-use</code> set to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Two additional attributes support this mechanism.
The <code>retry-interval</code> specifies (in milliseconds) how often the framework attempts to reconnect after a connection failure.
<code>scheduler</code> supplies a <code>TaskScheduler</code> to schedule the connection attempts and to test that the connection is still active.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t provide a scheduler, the framework&#8217;s default <a href="#namespace-taskscheduler">taskScheduler</a> bean is used.</p>
</div>
<div class="paragraph">
<p>For an outbound adapter, the connection is normally established when the first message is sent.
<code>client-mode="true"</code> on an outbound adapter causes the connection to be established when the adapter is started.
By default, adapters are automatically started.
Again, the connection factory must be of type <code>client</code> and have <code>single-use="false"</code>.
<code>retry-interval</code> and <code>scheduler</code> are also supported.
If a connection fails, it is re-established either by the scheduler or when the next message is sent.</p>
</div>
<div class="paragraph">
<p>For both inbound and outbound, if the adapter is started, you can force the adapter to establish a connection by sending a <code>&lt;control-bus /&gt;</code> command: <code>@adapter_id.retryConnection()</code>.
Then you can examine the current state with <code>@adapter_id.isClientModeConnected()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="tcp-gateways"><a class="anchor" href="#tcp-gateways"></a>34.7. TCP Gateways</h3>
<div class="paragraph">
<p>The inbound TCP gateway <code>TcpInboundGateway</code> and outbound TCP gateway <code>TcpOutboundGateway</code> use a server and client connection factory, respectively.
Each connection can process a single request or response at a time.</p>
</div>
<div class="paragraph">
<p>The inbound gateway, after constructing a message with the incoming payload and sending it to the <code>requestChannel</code>, waits for a response and sends the payload from the response message by writing it to the connection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the inbound gateway, you must retain or populate, the <code>ip_connectionId</code> header, because it is used to correlate the message to a connection.
Messages that originate at the gateway automatically have the header set.
If the reply is constructed as a new message, you need to set the header.
The header value can be captured from the incoming message.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As with inbound adapters, inbound gateways normally use a <code>type="server"</code> connection factory, which listens for incoming connection requests.
In some cases, you may want to establish the connection in reverse, such that the inbound gateway connects to an external server and then waits for and replies to inbound messages on that connection.</p>
</div>
<div class="paragraph">
<p>This topology is supported by using <code>client-mode="true"</code> on the inbound gateway.
In this case, the connection factory must be of type <code>client</code> and must have <code>single-use</code> set to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Two additional attributes support this mechanism.
<code>retry-interval</code> specifies (in milliseconds) how often the framework tries to reconnect after a connection failure.
<code>scheduler</code> supplies a <code>TaskScheduler</code> to schedule the connection attempts and to test that the connection is still active.</p>
</div>
<div class="paragraph">
<p>If the gateway is started, you may force the gateway to establish a connection by sending a &lt;control-bus /&gt; command: <code>@adapter_id.retryConnection()</code> and examine the current state with <code>@adapter_id.isClientModeConnected()</code>.</p>
</div>
<div class="paragraph">
<p>The outbound gateway, after sending a message over the connection, waits for a response, constructs a response message, and puts it on the reply channel.
Communications over the connections are single-threaded.
Only one message can be handled at a time.
If another thread attempts to send a message before the current response has been received, it blocks until any previous requests are complete (or time out).
If, however, the client connection factory is configured for single-use connections, each new request gets its own connection and is processed immediately.
The following example configures an inbound TCP gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-inbound-gateway id="inGateway"
    request-channel="tcpChannel"
    reply-channel="replyChannel"
    connection-factory="cfServer"
    reply-timeout="10000"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If a connection factory configured with the default serializer or deserializer is used, messages is <code>\r\n</code> delimited data and the gateway can be used by a simple client such as telnet.</p>
</div>
<div class="paragraph">
<p>The following example shows an outbound TCP gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-outbound-gateway id="outGateway"
    request-channel="tcpChannel"
    reply-channel="replyChannel"
    connection-factory="cfClient"
    request-timeout="10000"
    remote-timeout="10000"/&gt; &lt;!-- or e.g.
remote-timeout-expression="headers['timeout']" --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>client-mode</code> is not currently available with the outbound gateway.</p>
</div>
</div>
<div class="sect2">
<h3 id="ip-correlation"><a class="anchor" href="#ip-correlation"></a>34.8. TCP Message Correlation</h3>
<div class="paragraph">
<p>One goal of the IP endpoints is to provide communication with systems other than Spring Integration applications.
For this reason, only message payloads are sent and received by default.
Since 3.0, you can transfer headers by using JSON, Java serialization, or custom serializers and deserializers.
See <a href="#ip-headers">Transferring Headers</a> for more information.
No message correlation is provided by the framework (except when using the gateways) or collaborating channel adapters on the server side.
<a href="#ip-collaborating-adapters">Later in this document</a>, we discuss the various correlation techniques available to applications.
In most cases, this requires specific application-level correlation of messages, even when message payloads contain some natural correlation data (such as an order number).</p>
</div>
<div class="sect3">
<h4 id="ip-gateways"><a class="anchor" href="#ip-gateways"></a>34.8.1. Gateways</h4>
<div class="paragraph">
<p>Gateways automatically correlate messages.
However, you should use an outbound gateway for relatively low-volume applications.
When you configure the connection factory to use a single shared connection for all message pairs ('single-use="false"'), only one message can be processed at a time.
A new message has to wait until the reply to the previous message has been received.
When a connection factory is configured for each new message to use a new connection ('single-use="true"'), this restriction does not apply.
While this setting can give higher throughput than a shared connection environment, it comes with the overhead of opening and closing a new connection for each message pair.</p>
</div>
<div class="paragraph">
<p>Therefore, for high-volume messages, consider using a collaborating pair of channel adapters.
However, to do so, you need to provide collaboration logic.</p>
</div>
<div class="paragraph">
<p>Another solution, introduced in Spring Integration 2.2, is to use a <code>CachingClientConnectionFactory</code>, which allows the use of a pool of shared connections.</p>
</div>
</div>
<div class="sect3">
<h4 id="ip-collaborating-adapters"><a class="anchor" href="#ip-collaborating-adapters"></a>34.8.2. Collaborating Outbound and Inbound Channel Adapters</h4>
<div class="paragraph">
<p>To achieve high-volume throughput (avoiding the pitfalls of using gateways, as <a href="#ip-gateways">mentioned earlier</a>) you can configure a pair of collaborating outbound and inbound channel adapters.
You can also use collaborating adapters (server-side or client-side) for totally asynchronous communication (rather than with request-reply semantics).
On the server side, message correlation is automatically handled by the adapters, because the inbound adapter adds a header that allows the outbound adapter to determine which connection to use when sending the reply message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
On the server side, you must populate the <code>ip_connectionId</code> header, because it is used to correlate the message to a connection.
Messages that originate at the inbound adapter automatically have the header set.
If you wish to construct other messages to send, you need to set the header.
You can get the header value from an incoming message.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the client side, the application must provide its own correlation logic, if needed.
You can do so in a number of ways.</p>
</div>
<div class="paragraph">
<p>If the message payload has some natural correlation data (such as a transaction ID or an order number) and you have no need to retain any information (such as a reply channel header) from the original outbound message, the correlation is simple and would be done at the application level in any case.</p>
</div>
<div class="paragraph">
<p>If the message payload has some natural correlation data (such as a transaction ID or an order number), but you need to retain some information (such as a reply channel header) from the original outbound message, you can retain a copy of the original outbound message (perhaps by using a publish-subscribe channel) and use an aggregator to recombine the necessary data.</p>
</div>
<div class="paragraph">
<p>For either of the previous two scenarios, if the payload has no natural correlation data, you can provide a transformer upstream of the outbound channel adapter to enhance the payload with such data.
Such a transformer may transform the original payload to a new object that contains both the original payload and some subset of the message headers.
Of course, live objects (such as reply channels) from the headers cannot be included in the transformed payload.</p>
</div>
<div class="paragraph">
<p>If you choose such a strategy, you need to ensure the connection factory has an appropriate serializer-deserializer pair to handle such a payload (such as <code>DefaultSerializer</code> and <code>DefaultDeserializer</code>, which use java serialization, or a custom serializer and deserializer).
The <code>ByteArray*Serializer</code> options mentioned in <a href="#tcp-connection-factories">TCP Connection Factories</a>, including the default <code>ByteArrayCrLfSerializer</code>, do not support such payloads unless the transformed payload is a <code>String</code> or <code>byte[]</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Before the 2.2 release, when collaborating channel adapters used a client connection factory, the <code>so-timeout</code> attribute defaulted to the default reply timeout (10 seconds).
This meant that, if no data were received by the inbound adapter for this period of time, the socket was closed.</p>
</div>
<div class="paragraph">
<p>This default behavior was not appropriate in a truly asynchronous environment, so it now defaults to an infinite timeout.
You can reinstate the previous default behavior by setting the <code>so-timeout</code> attribute on the client connection factory to 10000 milliseconds.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ip-headers"><a class="anchor" href="#ip-headers"></a>34.8.3. Transferring Headers</h4>
<div class="paragraph">
<p>TCP is a streaming protocol.
<code>Serializers</code> and <code>Deserializers</code> demarcate messages within the stream.
Prior to 3.0, only message payloads (<code>String</code> or <code>byte[]</code>) could be transferred over TCP.
Beginning with 3.0, you can transfer selected headers as well as the payload.
However, &#8220;live&#8221; objects, such as the <code>replyChannel</code> header, cannot be serialized.</p>
</div>
<div class="paragraph">
<p>Sending header information over TCP requires some additional configuration.</p>
</div>
<div class="paragraph">
<p>The first step is to provide the <code>ConnectionFactory</code> with a <code>MessageConvertingTcpMessageMapper</code> that uses the <code>mapper</code> attribute.
This mapper delegates to any <code>MessageConverter</code> implementation to convert the message to and from some object that can be serialized and deserialized by the configured <code>serializer</code> and <code>deserializer</code>.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides a <code>MapMessageConverter</code>, which allows the specification of a list of headers that are added to a <code>Map</code> object, along with the payload.
The generated Map has two entries: <code>payload</code> and <code>headers</code>.
The <code>headers</code> entry is itself a <code>Map</code> and contains the selected headers.</p>
</div>
<div class="paragraph">
<p>The second step is to provide a serializer and a deserializer that can convert between a <code>Map</code> and some wire format.
This can be a custom <code>Serializer</code> or <code>Deserializer</code>, which you typically need if the peer system is not a Spring Integration application.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides a <code>MapJsonSerializer</code> to convert a <code>Map</code> to and from JSON.
It uses a Spring Integration <code>JsonObjectMapper</code>.
You can provide a custom <code>JsonObjectMapper</code> if needed.
By default, the serializer inserts a linefeed (<code>0x0a</code>) character between objects.
See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ip/tcp/serializer/MapJsonSerializer.html">Javadoc</a> for more information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>JsonObjectMapper</code> uses whichever version of <code>Jackson</code> is on the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use standard Java serialization of the <code>Map</code>, by using the <code>DefaultSerializer</code> and <code>DefaultDeserializer</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows the configuration of a connection factory that transfers the <code>correlationId</code>, <code>sequenceNumber</code>, and <code>sequenceSize</code> headers by using JSON:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ip:tcp-connection-factory id="client"
    type="client"
    host="localhost"
    port="12345"
    mapper="mapper"
    serializer="jsonSerializer"
    deserializer="jsonSerializer"/&gt;

&lt;bean id="mapper"
      class="o.sf.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper"&gt;
    &lt;constructor-arg name="messageConverter"&gt;
        &lt;bean class="o.sf.integration.support.converter.MapMessageConverter"&gt;
            &lt;property name="headerNames"&gt;
                &lt;list&gt;
                    &lt;value&gt;correlationId&lt;/value&gt;
                    &lt;value&gt;sequenceNumber&lt;/value&gt;
                    &lt;value&gt;sequenceSize&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="jsonSerializer" class="o.sf.integration.ip.tcp.serializer.MapJsonSerializer" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A message sent with the preceding configuration, with a payload of 'something' would appear on the wire as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">{"headers":{"correlationId":"things","sequenceSize":5,"sequenceNumber":1},"payload":"something"}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="note_nio"><a class="anchor" href="#note_nio"></a>34.9. About Non-blocking I/O (NIO)</h3>
<div class="paragraph">
<p>Using NIO (see <code>using-nio</code> in <a href="#ip-endpoint-reference">IP Configuration Attributes</a>) avoids dedicating a thread to read from each socket.
For a small number of sockets, you are likely to find that not using NIO, together with an asynchronous handoff (such as to a <code>QueueChannel</code>), performs as well as or better than using NIO.</p>
</div>
<div class="paragraph">
<p>You should consider using NIO when handling a large number of connections.
However, the use of NIO has some other ramifications.
A pool of threads (in the task executor) is shared across all the sockets.
Each incoming message is assembled and sent to the configured channel as a separate unit of work on a thread selected from that pool.
Two sequential messages arriving on the same socket might be processed by different threads.
This means that the order in which the messages are sent to the channel is indeterminate.
Strict ordering of the messages arriving on the socket is not maintained.</p>
</div>
<div class="paragraph">
<p>For some applications, this is not an issue.
For others, it is a problem.
If you require strict ordering, consider setting <code>using-nio</code> to <code>false</code> and using an asynchronous handoff.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can insert a resequencer downstream of the inbound endpoint to return the messages to their proper sequence.
If you set <code>apply-sequence</code> to <code>true</code> on the connection factory, messages arriving on a TCP connection have <code>sequenceNumber</code> and <code>correlationId</code> headers set.
The resequencer uses these headers to return the messages to their proper sequence.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Starting with version 5.1.4, priority is given to accepting new connections over reading from existing connections.
This should, generally, have little impact unless you have a very high rate of new incoming connections.
If you wish to revert to the previous behavior of giving reads priority, set the <code>multiAccept</code> property on the <code>TcpNioServerConnectionFactory</code> to <code>false</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="pool-size"><a class="anchor" href="#pool-size"></a>34.9.1. Pool Size</h4>
<div class="paragraph">
<p>The pool size attribute is no longer used.
Previously, it specified the size of the default thread pool when a task-executor was not specified.
It was also used to set the connection backlog on server sockets.
The first function is no longer needed (see the next paragraph).
The second function is replaced by the <code>backlog</code> attribute.</p>
</div>
<div class="paragraph">
<p>Previously, when using a fixed thread pool task executor (which was the default) with NIO, it was possible to get a deadlock and processing would stop.
The problem occurred when a buffer was full, a thread reading from the socket was trying to add more data to the buffer, and no threads were available to make space in the buffer.
This only occurred with a very small pool size, but it could be possible under extreme conditions.
Since 2.2, two changes have eliminated this problem.
First, the default task executor is a cached thread pool executor.
Second, deadlock detection logic has been added such that, if thread starvation occurs, instead of deadlocking, an exception is thrown, thus releasing the deadlocked resources.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Now that the default task executor is unbounded, it is possible that an out-of-memory condition might occur with high rates of incoming messages, if message processing takes extended time.
If your application exhibits this type of behavior, you should use a pooled task executor with an appropriate pool size, but see <a href="#io-thread-pool-task-executor-caller-runs">the next section</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="io-thread-pool-task-executor-caller-runs"><a class="anchor" href="#io-thread-pool-task-executor-caller-runs"></a>34.9.2. Thread Pool Task Executor with <code>CALLER_RUNS</code> Policy</h4>
<div class="paragraph">
<p>You should keep in mind some important considerations when you use a fixed thread pool with the <code>CallerRunsPolicy</code> (<code>CALLER_RUNS</code> when using the <code>&lt;task/&gt;</code> namespace) and the queue capacity is small.</p>
</div>
<div class="paragraph">
<p>The following does not apply if you do not use a fixed thread pool.</p>
</div>
<div class="paragraph">
<p>With NIO connections, there are three distinct task types.
The I/O selector processing is performed on one dedicated thread (detecting events, accepting new connections, and dispatching the I/O read operations to other threads by using the task executor).
When an I/O reader thread (to which the read operation is dispatched) reads data, it hands off to another thread to assemble the incoming message.
Large messages can take several reads to complete.
These &#8220;assembler&#8221; threads can block while waiting for data.
When a new read event occurs, the reader determines if this socket already has an assembler and, if not, runs a new one.
When the assembly process is complete, the assembler thread is returned to the pool.</p>
</div>
<div class="paragraph">
<p>This can cause a deadlock when the pool is exhausted, the <code>CALLER_RUNS</code> rejection policy is in use, and the task queue is full.
When the pool is empty and there is no room in the queue, the IO selector thread receives an <code>OP_READ</code> event and dispatches the read by using the executor.
The queue is full, so the selector thread itself starts the read process.
Now it detects that there is no assembler for this socket and, before it does the read, fires off an assembler.
Again, the queue is full, and the selector thread becomes the assembler.
The assembler is now blocked, waiting for the data to be read, which never happens.
The connection factory is now deadlocked because the selector thread cannot handle new events.</p>
</div>
<div class="paragraph">
<p>To avoid this deadlock, we must avoid the selector (or reader) threads performing the assembly task.
We want to use separate pools for the IO and assembly operations.</p>
</div>
<div class="paragraph">
<p>The framework provides a <code>CompositeExecutor</code>, which allows the configuration of two distinct executors: one for performing IO operations and one for message assembly.
In this environment, an IO thread can never become an assembler thread, and the deadlock cannot occur.</p>
</div>
<div class="paragraph">
<p>In addition, the task executors should be configured to use an <code>AbortPolicy</code> (<code>ABORT</code> when using <code>&lt;task&gt;</code>).
When an I/O task cannot be completed, it is deferred for a short time and continually retried until it can be completed and have an assembler allocated.
By default, the delay is 100ms, but you can change it by setting the <code>readDelay</code> property on the connection factory (<code>read-delay</code> when configuring with the XML namespace).</p>
</div>
<div class="paragraph">
<p>The following three examples shows how to configure the composite executor:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
private CompositeExecutor compositeExecutor() {
    ThreadPoolTaskExecutor ioExec = new ThreadPoolTaskExecutor();
    ioExec.setCorePoolSize(4);
    ioExec.setMaxPoolSize(10);
    ioExec.setQueueCapacity(0);
    ioExec.setThreadNamePrefix("io-");
    ioExec.setRejectedExecutionHandler(new AbortPolicy());
    ioExec.initialize();
    ThreadPoolTaskExecutor assemblerExec = new ThreadPoolTaskExecutor();
    assemblerExec.setCorePoolSize(4);
    assemblerExec.setMaxPoolSize(10);
    assemblerExec.setQueueCapacity(0);
    assemblerExec.setThreadNamePrefix("assembler-");
    assemblerExec.setRejectedExecutionHandler(new AbortPolicy());
    assemblerExec.initialize();
    return new CompositeExecutor(ioExec, assemblerExec);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myTaskExecutor" class="org.springframework.integration.util.CompositeExecutor"&gt;
    &lt;constructor-arg ref="io"/&gt;
    &lt;constructor-arg ref="assembler"/&gt;
&lt;/bean&gt;

&lt;task:executor id="io" pool-size="4-10" queue-capacity="0" rejection-policy="ABORT" /&gt;
&lt;task:executor id="assembler" pool-size="4-10" queue-capacity="0" rejection-policy="ABORT" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="myTaskExecutor" class="org.springframework.integration.util.CompositeExecutor"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
            &lt;property name="threadNamePrefix" value="io-" /&gt;
            &lt;property name="corePoolSize" value="4" /&gt;
            &lt;property name="maxPoolSize" value="8" /&gt;
            &lt;property name="queueCapacity" value="0" /&gt;
            &lt;property name="rejectedExecutionHandler"&gt;
                &lt;bean class="java.util.concurrent.ThreadPoolExecutor.AbortPolicy" /&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
            &lt;property name="threadNamePrefix" value="assembler-" /&gt;
            &lt;property name="corePoolSize" value="4" /&gt;
            &lt;property name="maxPoolSize" value="10" /&gt;
            &lt;property name="queueCapacity" value="0" /&gt;
            &lt;property name="rejectedExecutionHandler"&gt;
                &lt;bean class="java.util.concurrent.ThreadPoolExecutor.AbortPolicy" /&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ssl-tls"><a class="anchor" href="#ssl-tls"></a>34.10. SSL/TLS Support</h3>
<div class="paragraph">
<p>Secure Sockets Layer/Transport Layer Security is supported.
When using NIO, the JDK 5+ <code>SSLEngine</code> feature is used to handle handshaking after the connection is established.
When not using NIO, standard <code>SSLSocketFactory</code> and <code>SSLServerSocketFactory</code> objects are used to create connections.
A number of strategy interfaces are provided to allow significant customization.
The default implementations of these interfaces provide for the simplest way to get started with secure communications.</p>
</div>
<div class="sect3">
<h4 id="ip-ssl-tls-getting-started"><a class="anchor" href="#ip-ssl-tls-getting-started"></a>34.10.1. Getting Started</h4>
<div class="paragraph">
<p>Regardless of whether you use NIO, you need to configure the <code>ssl-context-support</code> attribute on the connection factory.
This attribute references a &lt;bean/&gt; definition that describes the location and passwords for the required key stores.</p>
</div>
<div class="paragraph">
<p>SSL/TLS peers require two keystores each:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A keystore that contains private and public key pairs to identify the peer</p>
</li>
<li>
<p>A truststore that contains the public keys for peers that are trusted.
See the documentation for the <code>keytool</code> utility provided with the JDK.
The essential steps are</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new key pair and store it in a keystore.</p>
</li>
<li>
<p>Export the public key.</p>
</li>
<li>
<p>Import the public key into the peer&#8217;s truststore.</p>
</li>
<li>
<p>Repeat for the other peer.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is common in test cases to use the same key stores on both peers, but this should be avoided for production.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After establishing the key stores, the next step is to indicate their locations to the <code>TcpSSLContextSupport</code> bean and provide a reference to that bean to the connection factory.</p>
</div>
<div class="paragraph">
<p>The following example configures an SSL connection:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="sslContextSupport"
    class="o.sf.integration.ip.tcp.connection.support.DefaultTcpSSLContextSupport"&gt;
    &lt;constructor-arg value="client.ks"/&gt;
    &lt;constructor-arg value="client.truststore.ks"/&gt;
    &lt;constructor-arg value="secret"/&gt;
    &lt;constructor-arg value="secret"/&gt;
&lt;/bean&gt;

&lt;ip:tcp-connection-factory id="clientFactory"
    type="client"
    host="localhost"
    port="1234"
    ssl-context-support="sslContextSupport" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaulTcpSSLContextSupport</code> class also has an optional <code>protocol</code> property, which can be <code>SSL</code> or <code>TLS</code> (the default).</p>
</div>
<div class="paragraph">
<p>The keystore file names (the first two constructor arguments) use the Spring <code>Resource</code> abstraction.
By default, the files are located on the classpath, but you can override this by using the <code>file:</code> prefix (to find the files on the filesystem instead).</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.6, when you use NIO, you can specify an <code>ssl-handshake-timeout</code> (in seconds) on the connection factory.
This timeout (the default is 30 seconds) is used during SSL handshake when waiting for data.
If the timeout is exceeded, the process is aborted and the socket is closed.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcp-ssl-host-verification"><a class="anchor" href="#tcp-ssl-host-verification"></a>34.10.2. Host Verification</h4>
<div class="paragraph">
<p>Starting with version 5.0.8, you can configure whether or not to enable host verification.
Starting with version 5.1, it is enabled by default; the mechanism to disable it depends on whether or not you are using NIO.</p>
</div>
<div class="paragraph">
<p>Host verification is used to ensure the server you are connected to matches information in the certificate, even if the certificate is trusted.</p>
</div>
<div class="paragraph">
<p>When using NIO, configure the <code>DefaultTcpNioSSLConnectionSupport</code>, for example.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public DefaultTcpNioSSLConnectionSupport connectionSupport() {
    DefaultTcpSSLContextSupport sslContextSupport = new DefaultTcpSSLContextSupport("test.ks",
            "test.truststore.ks", "secret", "secret");
    sslContextSupport.setProtocol("SSL");
    DefaultTcpNioSSLConnectionSupport tcpNioConnectionSupport =
            new DefaultTcpNioSSLConnectionSupport(sslContextSupport, false);
    return tcpNioConnectionSupport;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second constructor argument disables host verification.
The <code>connectionSupport</code> bean is then injected into the NIO connection factory.</p>
</div>
<div class="paragraph">
<p>When not using NIO, the configuration is in the <code>TcpSocketSupport</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">connectionFactory.setTcpSocketSupport(new DefaultTcpSocketSupport(false));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Again, the constructor argument disables host verification.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tcp-advanced-techniques"><a class="anchor" href="#tcp-advanced-techniques"></a>34.11. Advanced Techniques</h3>
<div class="paragraph">
<p>This section covers advanced techniques that you may find to be helpful in certain situations.</p>
</div>
<div class="sect3">
<h4 id="strategy-interfaces"><a class="anchor" href="#strategy-interfaces"></a>34.11.1. Strategy Interfaces</h4>
<div class="paragraph">
<p>In many cases, the configuration described earlier is all that is needed to enable secure communication over TCP/IP.
However, Spring Integration provides a number of strategy interfaces to allow customization and modification of socket factories and sockets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TcpSSLContextSupport</code></p>
</li>
<li>
<p><code>TcpSocketFactorySupport</code></p>
</li>
<li>
<p><code>TcpSocketSupport</code></p>
</li>
<li>
<p><code>TcpNetConnectionSupport</code></p>
</li>
<li>
<p><code>TcpNioConnectionSupport</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="the-tcpsslcontextsupport-strategy-interface"><a class="anchor" href="#the-tcpsslcontextsupport-strategy-interface"></a>The <code>TcpSSLContextSupport</code> Strategy Interface</h5>
<div class="paragraph">
<p>The following listing shows the <code>TcpSSLContextSupport</code> strategy interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TcpSSLContextSupport {

    SSLContext getSSLContext() throws Exception;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Implementations of the <code>TcpSSLContextSupport</code> interface are responsible for creating an <code>SSLContext</code> object.
The implementation provided by the framework is the <code>DefaultTcpSSLContextSupport</code>, <a href="#ip-ssl-tls-getting-started">described earlier</a>.
If you require different behavior, implement this interface and provide the connection factory with a reference to a bean of your class' implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="the-tcpsocketfactorysupport-strategy-interface"><a class="anchor" href="#the-tcpsocketfactorysupport-strategy-interface"></a>The <code>TcpSocketFactorySupport</code> Strategy Interface</h5>
<div class="paragraph">
<p>The following listing shows the definition of the <code>TcpSocketFactorySupport</code> strategy interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TcpSocketFactorySupport {

    ServerSocketFactory getServerSocketFactory();

    SocketFactory getSocketFactory();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Implementations of this interface are responsible for obtaining references to <code>ServerSocketFactory</code> and <code>SocketFactory</code>.
Two implementations are provided.
The first is <code>DefaultTcpNetSocketFactorySupport</code> for non-SSL sockets (when no <code>ssl-context-support</code> attribute is defined).
This uses the JDK&#8217;s default factories.
The second implementation is <code>DefaultTcpNetSSLSocketFactorySupport</code>.
By default, this is used when an <code>ssl-context-support</code> attribute is defined.
It uses the <code>SSLContext</code> created by that bean to create the socket factories.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This interface applies only if <code>using-nio</code> is <code>false</code>.
NIO does not use socket factories.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="the-tcpsocketsupport-strategy-interface"><a class="anchor" href="#the-tcpsocketsupport-strategy-interface"></a>The <code>TcpSocketSupport</code> Strategy Interface</h5>
<div class="paragraph">
<p>The following listing shows the definition of the <code>TcpSocketSupport</code> strategy interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TcpSocketSupport {

    void postProcessServerSocket(ServerSocket serverSocket);

    void postProcessSocket(Socket socket);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Implementations of this interface can modify sockets after they are created and after all configured attributes have been applied but before the sockets are used.
This applies whether you use NIO or not.
For example, you could use an implementation of this interface to modify the supported cipher suites on an SSL socket, or you could add a listener that gets notified after SSL handshaking is complete.
The sole implementation provided by the framework is the <code>DefaultTcpSocketSupport</code>, which does not modify the sockets in any way.</p>
</div>
<div class="paragraph">
<p>To supply your own implementation of <code>TcpSocketFactorySupport</code> or <code>TcpSocketSupport</code>, provide the connection factory with references to beans of your custom type by setting the <code>socket-factory-support</code> and <code>socket-support</code> attributes, respectively.</p>
</div>
</div>
<div class="sect4">
<h5 id="the-tcpnetconnectionsupport-strategy-interface"><a class="anchor" href="#the-tcpnetconnectionsupport-strategy-interface"></a>The <code>TcpNetConnectionSupport</code> Strategy Interface</h5>
<div class="paragraph">
<p>The following listing shows the definition of the <code>TcpNetConnectionSupport</code> strategy interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TcpNetConnectionSupport {

	TcpNetConnection createNewConnection(Socket socket,
			boolean server, boolean lookupHost,
			ApplicationEventPublisher applicationEventPublisher,
			String connectionFactoryName) throws Exception;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This interface is invoked to create objects of type <code>TcpNetConnection</code> (or its subclasses).
The framework provides a single implementation (<code>DefatulTcpNetConnectionSupport</code>), which, by default, creates simple <code>TcpNetConnection</code> objects.
It has two properties: <code>pushbackCapable</code> and <code>pushbackBufferSize</code>.
When push back is enabled, the implementation returns a subclass that wraps the connection&#8217;s <code>InputStream</code> in a <code>PushbackInputStream</code>.
Aligned with the <code>PushbackInputStream</code> default, the buffer size defaults to 1.
This lets deserializers &#8220;unread&#8221; (push back) bytes into the stream.
The following trivial example shows how it might be used in a delegating deserializer that &#8220;peeks&#8221; at the first byte to determine which deserializer to invoke:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CompositeDeserializer implements Deserializer&lt;byte[]&gt; {

    private final ByteArrayStxEtxSerializer stxEtx = new ByteArrayStxEtxSerializer();

    private final ByteArrayCrLfSerializer crlf = new ByteArrayCrLfSerializer();

    @Override
    public byte[] deserialize(InputStream inputStream) throws IOException {
        PushbackInputStream pbis = (PushbackInputStream) inputStream;
        int first = pbis.read();
        if (first &lt; 0) {
            throw new SoftEndOfStreamException();
        }
        pbis.unread(first);
        if (first == ByteArrayStxEtxSerializer.STX) {
            this.receivedStxEtx = true;
            return this.stxEtx.deserialize(pbis);
        }
        else {
            this.receivedCrLf = true;
            return this.crlf.deserialize(pbis);
        }
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="the-tcpnioconnectionsupport-strategy-interface"><a class="anchor" href="#the-tcpnioconnectionsupport-strategy-interface"></a>The <code>TcpNioConnectionSupport</code> Strategy Interface</h5>
<div class="paragraph">
<p>The following listing shows the definition of the <code>TcpNioConnectionSupport</code> strategy interface:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TcpNioConnectionSupport {

    TcpNioConnection createNewConnection(SocketChannel socketChannel,
            boolean server, boolean lookupHost,
            ApplicationEventPublisher applicationEventPublisher,
            String connectionFactoryName) throws Exception;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This interface is invoked to create <code>TcpNioConnection</code> objects (or objects from subclasses).
Spring Integration provides two implementations: <code>DefaultTcpNioSSLConnectionSupport</code> and <code>DefaultTcpNioConnectionSupport</code>.
Which one is  used depends on whether SSL is in use.
A common use case is to subclass <code>DefaultTcpNioSSLConnectionSupport</code> and override <code>postProcessSSLEngine</code>.
See the <a href="#ssl-client-authentication-example">SSL client authentication example</a>.
As with the <code>DefaultTcpNetConnectionSupport</code>, these implementations also support push back.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ssl-client-authentication-example"><a class="anchor" href="#ssl-client-authentication-example"></a>34.11.2. Example: Enabling SSL Client Authentication</h4>
<div class="paragraph">
<p>To enable client certificate authentication when you use SSL, the technique depends on whether you use NIO.
When you do not NIO , provide a custom <code>TcpSocketSupport</code> implementation to post-process the server socket:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">serverFactory.setTcpSocketSupport(new DefaultTcpSocketSupport() {

    @Override
    public void postProcessServerSocket(ServerSocket serverSocket) {
        ((SSLServerSocket) serverSocket).setNeedClientAuth(true);
    }

});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(When you use XML configuration, provide a reference to your bean by setting the <code>socket-support</code> attribute).</p>
</div>
<div class="paragraph">
<p>When you use NIO, provide a custom <code>TcpNioSslConnectionSupport</code> implementation to post-process the <code>SSLEngine</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public DefaultTcpNioSSLConnectionSupport tcpNioConnectionSupport() {
    return new DefaultTcpNioSSLConnectionSupport(serverSslContextSupport) {

            @Override
            protected void postProcessSSLEngine(SSLEngine sslEngine) {
                sslEngine.setNeedClientAuth(true);
            }

    }
}

@Bean
public TcpNioServerConnectionFactory server() {
    ...
    serverFactory.setTcpNioConnectionSupport(tcpNioConnectionSupport());
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(When you use XML configuration, since version 4.3.7, provide a reference to your bean by setting the <code>nio-connection-support</code> attribute).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ip-endpoint-reference"><a class="anchor" href="#ip-endpoint-reference"></a>34.12. IP Configuration Attributes</h3>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure IP connections:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Connection Factory Attributes</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 44.4445%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Client?</th>
<th class="tableblock halign-center valign-top">Server?</th>
<th class="tableblock halign-left valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">client, server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines whether the connection factory is a client or a server.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>host</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The host name or IP address of the destination.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>port</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The port.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serializer</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An implementation of <code>Serializer</code> used to serialize the payload.
Defaults to <code>ByteArrayCrLfSerializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>deserializer</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An implementation of <code>Deserializer</code> used to deserialize the payload.
Defaults to <code>ByteArrayCrLfSerializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>using-nio</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not connection uses NIO.
Refer to the <code>java.nio</code> package for more information.
See <a href="#note_nio">About Non-blocking I/O (NIO)</a>.
Default: <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>using-direct-buffers</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When using NIO, whether or not the connection uses direct buffers.
Refer to the <code>java.nio.ByteBuffer</code> documentation for more information.
Must be <code>false</code> if <code>using-nio</code> is <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>apply-sequence</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When you use NIO, it may be necessary to resequence messages.
When this attribute is set to <code>true</code>, <code>correlationId</code> and <code>sequenceNumber</code> headers are added to received messages.
See <a href="#note_nio">About Non-blocking I/O (NIO)</a>.
Default: <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-timeout</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to <code>0</code> (infinity), except for server connection factories with <code>single-use="true"</code>.
In that case, it defaults to the default reply timeout (10 seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-send-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.Socket.</code>
<code>setSendBufferSize()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-receive-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.Socket.</code>
<code>setReceiveBufferSize()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-keep-alive</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.Socket.setKeepAlive()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-linger</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets <code>linger</code> to <code>true</code> with the supplied value.
See <code>java.net.Socket.setSoLinger()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-tcp-no-delay</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.Socket.setTcpNoDelay()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-traffic-class</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.Socket.</code>
<code>setTrafficClass()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local-address</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On a multi-homed system, specifies an IP address for the interface to which the socket is bound.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>task-executor</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a specific executor to be used for socket handling.
If not supplied, an internal cached thread executor is used.
Needed on some platforms that require the use of specific task executors, such as a <code>WorkManagerTaskExecutor</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>single-use</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether a connection can be used for multiple messages.
If <code>true</code>, a new connection is used for each message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pool-size</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This attribute is no longer used.
For backward compatibility, it sets the backlog, but you should use <code>backlog</code> to specify the connection backlog in server factories.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>backlog</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the connection backlog for server factories.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lookup-host</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.
If false, the IP address is used instead.
Default: <code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interceptor-factory-chain</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#ip-interceptors">TCP Connection Interceptors</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssl-context-support</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code><a href="#ssl-tls">SSL/TLS Support</a></code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socket-factory-support</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code><a href="#ssl-tls">SSL/TLS Support</a></code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socket-support</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#ssl-tls">SSL/TLS Support</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nio-connection-support</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#tcp-advanced-techniques">Advanced Techniques</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>read-delay</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long &gt; 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The delay (in milliseconds) before retrying a read after the previous attempt failed due to insufficient threads.
Default: 100.
Only applies if <code>using-nio</code> is <code>true</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure UDP inbound channel adapters:</p>
</div>
<table id="ip-udp-ib-atts" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. UDP Inbound Channel Adapter Attributes</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>port</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The port on which the adapter listens.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multicast</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not the UDP adapter uses multicast.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multicast-address</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When multicast is true, the multicast address to which the adapter joins.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pool-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies how many packets can be handled concurrently.
It only applies if task-executor is not configured.
Default: 5.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">task-executor</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a specific executor to be used for socket handling.
If not supplied, an internal pooled executor is used.
Needed on some platforms that require the use of specific task executors such as a <code>WorkManagerTaskExecutor</code>.
See pool-size for thread requirements.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>receive-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The size of the buffer used to receive <code>DatagramPackets</code>.
Usually set to the maximum transmission unit (MTU) size.
If a smaller buffer is used than the size of the sent packet, truncation can occur.
You can detect this by using the <code>check-length</code> attribute..</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>check-length</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not a UDP adapter expects a data length field in the packet received.
Used to detect packet truncation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See the <code>setSoTimeout()</code> methods in <code>java.net.DatagramSocket</code> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-send-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used for UDP acknowledgment packets.
See the setSendBufferSize() methods in <code>java.net.DatagramSocket</code> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-receive-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.DatagramSocket.setReceiveBufferSize()</code> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local-address</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On a multi-homed system, specifies an IP address for the interface to which the socket is bound.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a downstream component throws an exception, the <code>MessagingException</code> message that contains the exception and failed message is sent to this channel.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lookup-host</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.
If <code>false</code>, the IP address is used instead.
Default: <code>true</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure UDP outbound channel adapters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. UDP Outbound Channel Adapter Attributes</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>host</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The host name or ip address of the destination.
For multicast udp adapters, the multicast address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>port</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The port on the destination.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multicast</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not the udp adapter uses multicast.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledge</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not a UDP adapter requires an acknowledgment from the destination.
When enabled, it requires setting the following four attributes: <code>ack-host</code>, <code>ack-port</code>, <code>ack-timeout</code>, and <code>min-acks-for- success</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ack-host</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>acknowledge</code> is <code>true</code>, indicates the host or IP address to which the acknowledgment should be sent.
Usually the current host, but may be different&#8201;&#8212;&#8201;for example, when Network Address Translation (NAT) is being used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ack-port</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>acknowledge</code> is <code>true</code>, indicates the port to which the acknowledgment should be sent.
The adapter listens on this port for acknowledgments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ack-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>acknowledge</code> is <code>true</code>, indicates the time in milliseconds that the adapter waits for an acknowledgment.
If an acknowledgment is not received in time, the adapter throws an exception.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>min-acks-for- success</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to 1.
For multicast adapters, you can set this to a larger value, which requires acknowledgments from multiple destinations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>check-length</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not a UDP adapter includes a data length field in the packet sent to the destination.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>time-to-live</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For multicast adapters, specifies the time-to-live attribute for the <code>MulticastSocket</code>.
Controls the scope of the multicasts.
Refer to the Java API documentation for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>java.net.DatagramSocket</code> setSoTimeout() methods for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-send-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See the <code>setSendBufferSize()</code> methods in <code>java.net.DatagramSocket</code> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>so-receive-buffer-size</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used for UDP acknowledgment packets.
See the <code>setReceiveBufferSize()</code> methods in <code>java.net.DatagramSocket</code> for more information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local-address</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On a multi-homed system, for the UDP adapter, specifies an IP address for the interface to which the socket is bound for reply messages.
For a multicast adapter, it also determines which interface the multicast packets are sent over.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>task-executor</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a specific executor to be used for acknowledgment handling.
If not supplied, an internal single threaded executor is used.
Needed on some platforms that require the use of specific task executors, such as a <code>WorkManagerTaskExecutor</code>.
One thread is dedicated to handling acknowledgments (if the <code>acknowledge</code> option is true).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-expression</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">SpEL expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A SpEL expression to be evaluated to determine which <code>SocketAddress</code> to use as a destination address for the
outgoing UDP packets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socket-expression</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">SpEL expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A SpEL expression to be evaluated to determine which datagram socket use for sending outgoing UDP packets.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure TCP inbound channel adapters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. TCP Inbound Channel Adapter Attributes</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The channel to which inbound messages is sent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the connection factory has a type of <code>server</code>, the factory is &#8220;owned&#8221; by this adapter.
If it has a type of <code>client</code>, it is &#8220;owned&#8221; by an outbound channel adapter, and this adapter receives any incoming messages on the connection created by the outbound adapter.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an exception is thrown by a downstream component, the <code>MessagingException</code> message containing the exception and the failed message is sent to this channel.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-mode</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>true</code>, the inbound adapter acts as a client with respect to establishing the connection and then receiving incoming messages on that connection.
Default: <code>false</code>.
See also <code>retry-interval</code> and <code>scheduler</code>.
The connection factory must be of type <code>client</code> and have <code>single-use</code> set to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>retry-interval</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When in <code>client-mode</code>, specifies the number of milliseconds to wait between connection attempts or after a connection failure.
Default: 60000 (60 seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scheduler</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a <code>TaskScheduler</code> to use for managing the <code>client-mode</code> connection.
If not specified, it defaults to the global Spring Integration <code>taskScheduler</code> bean, which has a default pool size of 10.
See <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure TCP outbound channel adapters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. TCP Outbound Channel Adapter Attributes</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The channel on which outbound messages arrive.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the connection factory has a type of <code>client</code>, the factory is &#8220;owned&#8221; by this adapter.
If it has a type of <code>server</code>, it is &#8220;owned&#8221; by an inbound channel adapter, and this adapter tries to correlate messages to the connection on which an original inbound message was received.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-mode</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>true</code>, the outbound adapter tries to establish the connection as soon as it is started.
When <code>false</code>, the connection is established when the first message is sent.
Default: <code>false</code>.
See also <code>retry-interval</code> and <code>scheduler</code>.
The connection factory must be of type <code>client</code> and have <code>single-use</code> set to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>retry-interval</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When in <code>client-mode</code>, specifies the number of milliseconds to wait between connection attempts or after a connection failure.
Default: 60000 (60 seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scheduler</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a <code>TaskScheduler</code> to use for managing the <code>client-mode</code> connection.
If not specified, it defaults to the global Spring Integration <code>taskScheduler</code> bean, which has a default pool size of 10.
See <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure TCP inbound gateways:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. TCP Inbound Gateway Attributes</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The connection factory must be of type server.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>request-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The channel to which incoming messages are sent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reply-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The channel on which reply messages may arrive.
Usually, replies arrive on a temporary reply channel added to the inbound message header.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reply-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds for which the gateway waits for a reply.
Default: 1000 (1 second).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an exception is thrown by a downstream component, the <code>MessagingException</code> message containing the exception and the failed message is sent to this channel.
Any reply from that flow is then returned as a response by the gateway.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-mode</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When <code>true</code>, the inbound gateway acts as a client with respect to establishing the connection and then receiving (and replying to) incoming messages on that connection.
Default: false.
See also <code>retry-interval</code> and <code>scheduler</code>.
The connection factory must be of type <code>client</code> and have <code>single-use</code> set to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>retry-interval</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When in <code>client-mode</code>, specifies the number of milliseconds to wait between connection attempts or after a connection failure.
Default: 60000 (60 seconds).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scheduler</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a <code>TaskScheduler</code> to use for managing the <code>client-mode</code> connection.
If not specified, it defaults to the global Spring Integration <code>taskScheduler</code> bean, which has a default pool size of 10.
See <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table describes attributes that you can set to configure TCP outbound gateways:</p>
</div>
<table id="tcp-ob-gateway-attributes" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. TCP Outbound Gateway Attributes</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute Name</th>
<th class="tableblock halign-center valign-top">Allowed Values</th>
<th class="tableblock halign-left valign-top">Attribute Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The connection factory must be of type <code>client</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>request-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The channel on which outgoing messages arrive.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reply-channel</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional.
The channel to which reply messages are sent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>remote-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds for which the gateway waits for a reply from the remote system.
Mutually exclusive with <code>remote-timeout-expression</code>.
Default: 10000 (10 seconds).
Note: In versions prior to 4.2 this value defaulted to <code>reply-timeout</code> (if set).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>remote-timeout-expression</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A SpEL expression that is evaluated against the message to determine the time in milliseconds for which the gateway waits for a reply from the remote system.
Mutually exclusive with <code>remote-timeout</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>request-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a single-use connection factory is not being used, the time in milliseconds for which the gateway waits to get access to the shared connection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reply-timeout</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time in milliseconds for which the gateway waits when sending the reply to the reply-channel.
Only applies if the reply-channel might block (such as a bounded QueueChannel that is currently full).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="ip-msg-headers"><a class="anchor" href="#ip-msg-headers"></a>34.13. IP Message Headers</h3>
<div class="paragraph">
<div class="title">IP Message Headers</div>
<p>This module uses the following <code>MessageHeader</code> instances:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Name</th>
<th class="tableblock halign-left valign-top">IpHeaders Constant</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_hostname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HOSTNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The host name from which a TCP message or UDP packet was received.
If <code>lookupHost</code> is <code>false</code>, this contains the IP address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_address</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IP_ADDRESS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The IP address from which a TCP message or UDP packet was received.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_port</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PORT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The remote port for a UDP packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ip_localInetAddress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IP_LOCAL_ADDRESS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The local <code>InetAddress</code> to which the socket is connected (since version 4.2.5).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_ackTo</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACKADDRESS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The remote IP address to which UDP application-level acknowledgments are sent.
The framework includes acknowledgment information in the data packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_ackId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACK_ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A correlation ID for UDP application-level acknowledgments.
The framework includes acknowledgment information in the data packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_tcp_remotePort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REMOTE_PORT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The remote port for a TCP connection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_connectionId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONNECTION_ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unique identifier for a TCP connection.
Set by the framework for inbound messages.
When sending to a server-side inbound channel adapter or replying to an inbound gateway, this header is required so that the endpoint can determine the connection to which to send the message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ip_actualConnectionId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACTUAL_CONNECTION_ID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For information only.
When using a cached or failover client connection factory, it contains the actual underlying connection ID.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contentType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaders.</code>
<code>CONTENT_TYPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional content type for inbound messages
Described after this table.
Note that, unlike the other header constants, this constant is in the <code>MessageHeaders</code> class, not the <code>IpHeaders</code> class.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For inbound messages, <code>ip_hostname</code>, <code>ip_address</code>, <code>ip_tcp_remotePort</code>, and <code>ip_connectionId</code> are mapped by the default
<code>TcpHeaderMapper</code>.
If you set the mapper&#8217;s <code>addContentTypeHeader</code> property to <code>true</code>, the mapper sets the <code>contentType</code> header (<code>application/octet-stream;charset="UTF-8"</code>, by default).
You can change the default by setting the <code>contentType</code> property.
You can add additional headers by subclassing <code>TcpHeaderMapper</code> and overriding the <code>supplyCustomHeaders</code> method.
For example, when you use SSL, you can add properties of the <code>SSLSession</code> by obtaining the session object from the
<code>TcpConnection</code> object, which is provided as an argument to the <code>supplyCustomHeaders</code> method.</p>
</div>
<div class="paragraph">
<p>For outbound messages, <code>String</code> payloads are converted to <code>byte[]</code> with the default (<code>UTF-8</code>) charset.
Set the <code>charset</code> property to change the default.</p>
</div>
<div class="paragraph">
<p>When customizing the mapper properties or subclassing, declare the mapper as a bean and provide an instance to the connection factory by using the <code>mapper</code> property</p>
</div>
</div>
<div class="sect2">
<h3 id="ip-annotation"><a class="anchor" href="#ip-annotation"></a>34.14. Annotation-Based Configuration</h3>
<div class="paragraph">
<p>The following example from the samples repository shows some of the configuration options available when you use  annotations instead of XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableIntegration <i class="conum" data-value="1"></i><b>(1)</b>
@IntegrationComponentScan <i class="conum" data-value="2"></i><b>(2)</b>
@Configuration
public static class Config {

    @Value(${some.port})
    private int port;

    @MessagingGateway(defaultRequestChannel="toTcp") <i class="conum" data-value="3"></i><b>(3)</b>
    public interface Gateway {

        String viaTcp(String in);

    }

    @Bean
    @ServiceActivator(inputChannel="toTcp") <i class="conum" data-value="4"></i><b>(4)</b>
    public MessageHandler tcpOutGate(AbstractClientConnectionFactory connectionFactory) {
        TcpOutboundGateway gate = new TcpOutboundGateway();
        gate.setConnectionFactory(connectionFactory);
        gate.setOutputChannelName("resultToString");
        return gate;
    }

    @Bean <i class="conum" data-value="5"></i><b>(5)</b>
    public TcpInboundGateway tcpInGate(AbstractServerConnectionFactory connectionFactory)  {
        TcpInboundGateway inGate = new TcpInboundGateway();
        inGate.setConnectionFactory(connectionFactory);
        inGate.setRequestChannel(fromTcp());
        return inGate;
    }

    @Bean
    public MessageChannel fromTcp() {
        return new DirectChannel();
    }

    @MessageEndpoint
    public static class Echo { <i class="conum" data-value="6"></i><b>(6)</b>

        @Transformer(inputChannel="fromTcp", outputChannel="toEcho")
        public String convert(byte[] bytes) {
            return new String(bytes);
        }

        @ServiceActivator(inputChannel="toEcho")
        public String upCase(String in) {
            return in.toUpperCase();
        }

        @Transformer(inputChannel="resultToString")
        public String convertResult(byte[] bytes) {
            return new String(bytes);
        }

    }

    @Bean
    public AbstractClientConnectionFactory clientCF() { <i class="conum" data-value="7"></i><b>(7)</b>
        return new TcpNetClientConnectionFactory("localhost", this.port);
    }

    @Bean
    public AbstractServerConnectionFactory serverCF() { <i class="conum" data-value="8"></i><b>(8)</b>
        return new TcpNetServerConnectionFactory(this.port);
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Standard Spring Integration annotation enabling the infrastructure for an integration application.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Searches for <code>@MessagingGateway</code> interfaces.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The entry point to the client-side of the flow.
The calling application can use <code>@Autowired</code> for this <code>Gateway</code> bean and invoke its method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Outbound endpoints consist of a <code>MessageHandler</code> and a consumer that wraps it.
In this scenario, the <code>@ServiceActivator</code> configures the endpoint, according to the channel type.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Inbound endpoints (in the TCP/UDP module) are all message-driven and so only need to be declared as simple <code>@Bean</code> instances.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This class provides a number of POJO methods for use in this sample flow (a <code>@Transformer</code> and <code>@ServiceActivator</code> on the server side and a <code>@Transformer</code> on the client side).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The client-side connection factory.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The server-side connection factory.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a>35. WebFlux Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The WebFlux Spring Integration module (<code>spring-integration-webflux</code>) allows for the execution of HTTP requests and the processing of inbound HTTP requests in a reactive manner.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-webflux&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-webflux:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>io.projectreactor.netty:reactor-netty</code> dependency must be included in case of non-Servlet-based server configuration.</p>
</div>
<div class="paragraph">
<p>The WebFlux support consists of the following gateway implementations: <code>WebFluxInboundEndpoint</code> and <code>WebFluxRequestExecutingMessageHandler</code>.
The support is fully based on the Spring <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">WebFlux</a> and <a href="https://projectreactor.io/">Project Reactor</a> foundations.
See <a href="#http">HTTP Support</a> for more information, since many options are shared between reactive and regular HTTP components.</p>
</div>
<div class="sect2">
<h3 id="webflux-inbound"><a class="anchor" href="#webflux-inbound"></a>35.1. WebFlux Inbound Components</h3>
<div class="paragraph">
<p>Starting with version 5.0, the <code>WebFluxInboundEndpoint</code> implementation of <code>WebHandler</code> is provided.
This component is similar to the MVC-based <code>HttpRequestHandlingEndpointSupport</code>, with which it shares some common options through the newly extracted <code>BaseHttpInboundEndpoint</code>.
It is used in the Spring WebFlux reactive environment (instead of MVC).
The following example shows a simple implementation of a WebFlux endpoint:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableWebFlux
@EnableIntegration
public class ReactiveHttpConfiguration {

    @Bean
    public WebFluxInboundEndpoint simpleInboundEndpoint() {
        WebFluxInboundEndpoint endpoint = new WebFluxInboundEndpoint();
        RequestMapping requestMapping = new RequestMapping();
        requestMapping.setPathPatterns("/test");
        endpoint.setRequestMapping(requestMapping);
        endpoint.setRequestChannelName("serviceChannel");
        return endpoint;
    }

    @ServiceActivator(inputChannel = "serviceChannel")
    String service() {
        return "It works!";
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration is similar to the <code>HttpRequestHandlingEndpointSupport</code> (mentioned prior to the example), except that we use <code>@EnableWebFlux</code> to add the WebFlux infrastructure to our integration application.
Also, the <code>WebFluxInboundEndpoint</code> performs <code>sendAndReceive</code> operations to the downstream flow by using back-pressure, on-demand based capabilities, provided by the reactive HTTP server implementation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The reply part is non-blocking as well and is based on the internal <code>FutureReplyChannel</code>, which is flat-mapped to a reply <code>Mono</code> for on-demand resolution.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can configure the <code>WebFluxInboundEndpoint</code> with a custom <code>ServerCodecConfigurer</code>, a <code>RequestedContentTypeResolver</code>, and even a <code>ReactiveAdapterRegistry</code>.
The latter provides a mechanism you can use to return a reply as any reactive type: Reactor <code>Flux</code>, RxJava <code>Observable</code>, <code>Flowable</code>, and others.
This way, we can implement <a href="https://en.wikipedia.org/wiki/Server-sent_events">Server Sent Events</a> scenarios with Spring Integration components, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow sseFlow() {
    return IntegrationFlows
            .from(WebFlux.inboundGateway("/sse")
                    .requestMapping(m -&gt; m.produces(MediaType.TEXT_EVENT_STREAM_VALUE)))
            .handle((p, h) -&gt; Flux.just("foo", "bar", "baz"))
            .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#http-request-mapping">Request Mapping Support</a> and <a href="#http-cors">Cross-origin Resource Sharing (CORS) Support</a> for more possible configuration options.</p>
</div>
<div class="paragraph">
<p>When the request body is empty or <code>payloadExpression</code> returns <code>null</code>, the request params (<code>MultiValueMap&lt;String, String&gt;</code>) is used for a <code>payload</code> of the target message to process.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-outbound"><a class="anchor" href="#webflux-outbound"></a>35.2. WebFlux Outbound Components</h3>
<div class="paragraph">
<p>The <code>WebFluxRequestExecutingMessageHandler</code> (starting with version 5.0) implementation is similar to <code>HttpRequestExecutingMessageHandler</code>.
It uses a <code>WebClient</code> from the Spring Framework WebFlux module.
To configure it, define a bean similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="httpReactiveOutbound"
    class="org.springframework.integration.webflux.outbound.WebFluxRequestExecutingMessageHandler"&gt;
     &lt;constructor-arg value="http://localhost:8080/example" /&gt;
     &lt;property name="outputChannel" ref="responseChannel" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can configure a <code>WebClient</code> instance to use, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans:bean id="webClient" class="org.springframework.web.reactive.function.client.WebClient"
				factory-method="create"/&gt;

&lt;bean id="httpReactiveOutbound"
    class="org.springframework.integration.webflux.outbound.WebFluxRequestExecutingMessageHandler"&gt;
     &lt;constructor-arg value="http://localhost:8080/example" /&gt;
     &lt;constructor-arg re="webClient" /&gt;
     &lt;property name="outputChannel" ref="responseChannel" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>WebClient</code> <code>exchange()</code> operation returns a <code>Mono&lt;ClientResponse&gt;</code>, which is mapped (by using several <code>Mono.map()</code> steps) to an <code>AbstractIntegrationMessageBuilder</code> as the output from the <code>WebFluxRequestExecutingMessageHandler</code>.
Together with the <code>ReactiveChannel</code> as an <code>outputChannel</code>, the <code>Mono&lt;ClientResponse&gt;</code> evaluation is deferred until a downstream subscription is made.
Otherwise, it is treated as an <code>async</code> mode, and the <code>Mono</code> response is adapted to a <code>SettableListenableFuture</code> for an asynchronous reply from the <code>WebFluxRequestExecutingMessageHandler</code>.
The target payload of the output message depends on the <code>WebFluxRequestExecutingMessageHandler</code> configuration.
The <code>setExpectedResponseType(Class&lt;?&gt;)</code> or <code>setExpectedResponseTypeExpression(Expression)</code> identifies the target type of the response body element conversion.
If <code>replyPayloadToFlux</code> is set to <code>true</code>, the response body is converted to a <code>Flux</code> with the provided <code>expectedResponseType</code> for each element, and this <code>Flux</code> is sent as the payload downstream.
Afterwards, you can use a <a href="#splitter">splitter</a> to iterate over this <code>Flux</code> in a reactive manner.</p>
</div>
<div class="paragraph">
<p>In addition a <code>BodyExtractor&lt;?, ClientHttpResponse&gt;</code> can be injected into the <code>WebFluxRequestExecutingMessageHandler</code> instead of the <code>expectedResponseType</code> and <code>replyPayloadToFlux</code> properties.
It can be used for low-level access to the <code>ClientHttpResponse</code> and more control over body and HTTP headers conversion.
Spring Integration provides <code>ClientHttpResponseBodyExtractor</code> as a identity function to produce (downstream) the whole <code>ClientHttpResponse</code> and any other possible custom logic.</p>
</div>
<div class="paragraph">
<p>See <a href="#http-outbound">HTTP Outbound Components</a> for more possible configuration options.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-namespace"><a class="anchor" href="#webflux-namespace"></a>35.3. WebFlux Namespace Support</h3>
<div class="paragraph">
<p>Spring Integration provides a <code>webflux</code> namespace and the corresponding schema definition.
To include it in your configuration, include the following namespace declaration in your application context configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-webflux="http://www.springframework.org/schema/integration/webflux"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/webflux
    https://www.springframework.org/schema/integration/webflux/spring-integration-webflux.xsd"&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inbound-3"><a class="anchor" href="#inbound-3"></a>35.3.1. Inbound</h4>
<div class="paragraph">
<p>To configure Spring Integration WebFlux with XML, you caus use appropriate components from the <code>int-webflux</code> namespace: <code>inbound-channel-adapter</code> or <code>inbound-gateway</code>, corresponding to request and response requirements, respectively.
The following example shows how to configure both an inbound channel adapter and an inbound gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;inbound-channel-adapter id="reactiveFullConfig" channel="requests"
                         path="test1"
                         auto-startup="false"
                         phase="101"
                         request-payload-type="byte[]"
                         error-channel="errorChannel"
                         payload-expression="payload"
                         supported-methods="PUT"
                         status-code-expression="'202'"
                         header-mapper="headerMapper"
                         codec-configurer="codecConfigurer"
                         reactive-adapter-registry="reactiveAdapterRegistry"
                         requested-content-type-resolver="requestedContentTypeResolver"&gt;
    &lt;request-mapping headers="foo"/&gt;
    &lt;cross-origin origin="foo"
                  method="PUT"/&gt;
    &lt;header name="foo" expression="'foo'"/&gt;
&lt;/inbound-channel-adapter&gt;

&lt;inbound-gateway id="reactiveFullConfig" request-channel="requests"
                 path="test1"
                 auto-startup="false"
                 phase="101"
                 request-payload-type="byte[]"
                 error-channel="errorChannel"
                 payload-expression="payload"
                 supported-methods="PUT"
                 reply-timeout-status-code-expression="'504'"
                 header-mapper="headerMapper"
                 codec-configurer="codecConfigurer"
                 reactive-adapter-registry="reactiveAdapterRegistry"
                 requested-content-type-resolver="requestedContentTypeResolver"&gt;
    &lt;request-mapping headers="foo"/&gt;
    &lt;cross-origin origin="foo"
                  method="PUT"/&gt;
    &lt;header name="foo" expression="'foo'"/&gt;
&lt;/inbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="outbound-3"><a class="anchor" href="#outbound-3"></a>35.3.2. Outbound</h4>
<div class="paragraph">
<p>If you want to execute the HTTP request in a reactive, non-blocking way, you can use the <code>outbound-gateway</code> or <code>outbound-channel-adapter</code>.
The following example shows how to configure both an outbound gateway and an outbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-webflux:outbound-gateway id="reactiveExample1"
    request-channel="requests"
    url="http://localhost/test"
    http-method-expression="headers.httpMethod"
    extract-request-payload="false"
    expected-response-type-expression="payload"
    charset="UTF-8"
    reply-timeout="1234"
    reply-channel="replies"/&gt;

&lt;int-webflux:outbound-channel-adapter id="reactiveExample2"
    url="http://localhost/example"
    http-method="GET"
    channel="requests"
    charset="UTF-8"
    extract-payload="false"
    expected-response-type="java.lang.String"
    order="3"
    auto-startup="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-java-config"><a class="anchor" href="#webflux-java-config"></a>35.4. Configuring WebFlux Endpoints with Java</h3>
<div class="paragraph">
<p>The following example shows how to configure a WebFlux inbound endpoint with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebFluxInboundEndpoint jsonInboundEndpoint() {
    WebFluxInboundEndpoint endpoint = new WebFluxInboundEndpoint();
    RequestMapping requestMapping = new RequestMapping();
    requestMapping.setPathPatterns("/persons");
    endpoint.setRequestMapping(requestMapping);
    endpoint.setRequestChannel(fluxResultChannel());
    return endpoint;
}

@Bean
public MessageChannel fluxResultChannel() {
    return new FluxMessageChannel();
}

@ServiceActivator(inputChannel = "fluxResultChannel")
Flux&lt;Person&gt; getPersons() {
    return Flux.just(new Person("Jane"), new Person("Jason"), new Person("John"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a WebFlux inbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow inboundChannelAdapterFlow() {
    return IntegrationFlows
        .from(WebFlux.inboundChannelAdapter("/reactivePost")
            .requestMapping(m -&gt; m.methods(HttpMethod.POST))
            .requestPayloadType(ResolvableType.forClassWithGenerics(Flux.class, String.class))
            .statusCodeFunction(m -&gt; HttpStatus.ACCEPTED))
        .channel(c -&gt; c.queue("storeChannel"))
        .get();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a WebFlux outbound gateway with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServiceActivator(inputChannel = "reactiveHttpOutRequest")
@Bean
public WebFluxRequestExecutingMessageHandler reactiveOutbound(WebClient client) {
    WebFluxRequestExecutingMessageHandler handler =
        new WebFluxRequestExecutingMessageHandler("http://localhost:8080/foo", client);
    handler.setHttpMethod(HttpMethod.POST);
    handler.setExpectedResponseType(String.class);
    return handler;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a WebFlux outbound gateway with the Java DSL:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public IntegrationFlow outboundReactive() {
    return f -&gt; f
        .handle(WebFlux.&lt;MultiValueMap&lt;String, String&gt;&gt;outboundGateway(m -&gt;
                UriComponentsBuilder.fromUriString("http://localhost:8080/foo")
                        .queryParams(m.getPayload())
                        .build()
                        .toUri())
                .httpMethod(HttpMethod.GET)
                .expectedResponseType(String.class));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-header-mapping"><a class="anchor" href="#webflux-header-mapping"></a>35.5. WebFlux Header Mappings</h3>
<div class="paragraph">
<p>Since WebFlux components are fully based on the HTTP protocol, there is no difference in the HTTP headers mapping.
See <a href="#http-header-mapping">HTTP Header Mappings</a> for more possible options and components to use for mapping headers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="web-sockets"><a class="anchor" href="#web-sockets"></a>36. WebSockets Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Starting with version 4.1, Spring Integration has WebSocket support.
It is based on the architecture, infrastructure, and API from the Spring Framework&#8217;s <code>web-socket</code> module.
Therefore, many of Spring WebSocket&#8217;s components (such as <code>SubProtocolHandler</code> or <code>WebSocketClient</code>) and configuration options (such as  <code>@EnableWebSocketMessageBroker</code>) can be reused within Spring Integration.
For more information, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/#websocket">Spring Framework WebSocket Support</a> chapter in the Spring Framework reference manual.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-websocket&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-websocket:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For server side, the <code>org.springframework:spring-webmvc</code> dependency must be included explicitly.</p>
</div>
<div class="paragraph">
<p>The Spring Framework WebSocket infrastructure is based on the Spring messaging foundation and provides a basic messaging framework based on the same <code>MessageChannel</code> implementations and <code>MessageHandler</code> implementations that Spring Integration uses (and some POJO-method annotation mappings).
Consequently, Spring Integration can be directly involved in a WebSocket flow, even without WebSocket adapters.
For this purpose, you can configure a Spring Integration <code>@MessagingGateway</code> with appropriate annotations, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessagingGateway
@Controller
public interface WebSocketGateway {

    @MessageMapping("/greeting")
    @SendToUser("/queue/answer")
    @Gateway(requestChannel = "greetingChannel")
    String greeting(String payload);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="web-socket-overview"><a class="anchor" href="#web-socket-overview"></a>36.1. Overview</h3>
<div class="paragraph">
<p>Since the WebSocket protocol is streaming by definition and we can send and receive messages to and from a WebSocket at the same time, we can deal with an appropriate <code>WebSocketSession</code>, regardless of being on the client or server side.
To encapsulate the connection management and <code>WebSocketSession</code> registry, the <code>IntegrationWebSocketContainer</code> is provided with <code>ClientWebSocketContainer</code> and <code>ServerWebSocketContainer</code> implementations.
Thanks to the <a href="https://www.jcp.org/en/jsr/detail?id=356">WebSocket API</a> and its implementation in the Spring Framework (with many extensions), the same classes are used on the server side as well as the client side (from a Java perspective, of course).
Consequently, most connection and <code>WebSocketSession</code> registry options are the same on both sides.
That lets us reuse many configuration items and infrastructure hooks to build WebSocket applications on the server side as well as on the client side.
The following example shows how components can serve both purposes:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Client side
@Bean
public WebSocketClient webSocketClient() {
    return new SockJsClient(Collections.singletonList(new WebSocketTransport(new JettyWebSocketClient())));
}

@Bean
public IntegrationWebSocketContainer clientWebSocketContainer() {
    return new ClientWebSocketContainer(webSocketClient(), "ws://my.server.com/endpoint");
}

//Server side
@Bean
public IntegrationWebSocketContainer serverWebSocketContainer() {
    return new ServerWebSocketContainer("/endpoint").withSockJs();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>IntegrationWebSocketContainer</code> is designed to achieve bidirectional messaging and can be shared between inbound and outbound channel adapters (see below), can be referenced from only one of them when using one-way (sending or receiving) WebSocket messaging.
It can be used without any channel adapter, but, in this case, <code>IntegrationWebSocketContainer</code> only plays a role as the <code>WebSocketSession</code> registry.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ServerWebSocketContainer</code> implements <code>WebSocketConfigurer</code> to register an internal <code>IntegrationWebSocketContainer.IntegrationWebSocketHandler</code> as an <code>Endpoint</code>.
It does so under the provided <code>paths</code> and other server WebSocket options (such as <code>HandshakeHandler</code> or <code>SockJS fallback</code>) within the <code>ServletWebSocketHandlerRegistry</code> for the target vendor WebSocket Container.
This registration is achieved with an infrastructural <code>WebSocketIntegrationConfigurationInitializer</code> component, which does the same as the <code>@EnableWebSocket</code> annotation.
This means that, by using <code>@EnableIntegration</code> (or any Spring Integration namespace in the application context), you can omit the <code>@EnableWebSocket</code> declaration, because the Spring Integration infrastructure detects all WebSocket endpoints.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="web-socket-inbound-adapter"><a class="anchor" href="#web-socket-inbound-adapter"></a>36.2. WebSocket Inbound Channel Adapter</h3>
<div class="paragraph">
<p>The <code>WebSocketInboundChannelAdapter</code> implements the receiving part of <code>WebSocketSession</code> interaction.
You must supply it with a <code>IntegrationWebSocketContainer</code>, and the adapter registers itself as a <code>WebSocketListener</code> to handle incoming messages and <code>WebSocketSession</code> events.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only one <code>WebSocketListener</code> can be registered in the <code>IntegrationWebSocketContainer</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For WebSocket subprotocols, the <code>WebSocketInboundChannelAdapter</code> can be configured with <code>SubProtocolHandlerRegistry</code> as the second constructor argument.
The adapter delegates to the <code>SubProtocolHandlerRegistry</code> to determine the appropriate <code>SubProtocolHandler</code> for the accepted <code>WebSocketSession</code> and to convert a <code>WebSocketMessage</code> to a <code>Message</code> according to the sub-protocol implementation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, the <code>WebSocketInboundChannelAdapter</code> relies only on the raw <code>PassThruSubProtocolHandler</code> implementation, which converts the <code>WebSocketMessage</code> to a <code>Message</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>WebSocketInboundChannelAdapter</code> accepts and sends to the underlying integration flow only <code>Message</code> instances that have <code>SimpMessageType.MESSAGE</code> or an empty <code>simpMessageType</code> header.
All other <code>Message</code> types are handled through the <code>ApplicationEvent</code> instances emitted from a <code>SubProtocolHandler</code> implementation (such as
<code>StompSubProtocolHandler</code>).</p>
</div>
<div class="paragraph">
<p>On the server side, if the <code>@EnableWebSocketMessageBroker</code> configuration is present, you can configure <code>WebSocketInboundChannelAdapter</code> with the <code>useBroker = true</code> option.
In this case, all <code>non-MESSAGE</code> <code>Message</code> types are delegated to the provided <code>AbstractBrokerMessageHandler</code>.
In addition, if the broker relay is configured with destination prefixes, those messages that match the Broker destinations are routed to the <code>AbstractBrokerMessageHandler</code> instead of to the <code>outputChannel</code> of the <code>WebSocketInboundChannelAdapter</code>.</p>
</div>
<div class="paragraph">
<p>If <code>useBroker = false</code> and the received message is of the <code>SimpMessageType.CONNECT</code> type, the <code>WebSocketInboundChannelAdapter</code> immediately sends a <code>SimpMessageType.CONNECT_ACK</code> message to the <code>WebSocketSession</code> without sending it to the channel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring&#8217;s WebSocket Support allows the configuration of only one broker relay.
Consequently, we do not require an <code>AbstractBrokerMessageHandler</code> reference.
It is detected in the Application Context.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more configuration options, see <a href="#web-sockets-namespace">WebSockets Namespace Support</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="web-socket-outbound-adapter"><a class="anchor" href="#web-socket-outbound-adapter"></a>36.3. WebSocket Outbound Channel Adapter</h3>
<div class="paragraph">
<p>The <code>WebSocketOutboundChannelAdapter</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Accepts Spring Integration messages from its <code>MessageChannel</code></p>
</li>
<li>
<p>Determines the <code>WebSocketSession</code> <code>id</code> from the <code>MessageHeaders</code></p>
</li>
<li>
<p>Retrieves the <code>WebSocketSession</code> from the provided <code>IntegrationWebSocketContainer</code></p>
</li>
<li>
<p>Delegates the conversion and sending of <code>WebSocketMessage</code> work to the appropriate <code>SubProtocolHandler</code> from the provided <code>SubProtocolHandlerRegistry</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>On the client side, the <code>WebSocketSession</code> <code>id</code> message header is not required, because <code>ClientWebSocketContainer</code> deals only with a single connection and its <code>WebSocketSession</code> respectively.</p>
</div>
<div class="paragraph">
<p>To use the STOMP sub-protocol, you should configure this adapter with a <code>StompSubProtocolHandler</code>.
Then you can send any STOMP message type to this adapter, using <code>StompHeaderAccessor.create(StompCommand&#8230;&#8203;)</code> and a <code>MessageBuilder</code>, or just using a <code>HeaderEnricher</code> (see <a href="#header-enricher">Header Enricher</a>).</p>
</div>
<div class="paragraph">
<p>The rest of this chapter covers largely additional configuration options.</p>
</div>
</div>
<div class="sect2">
<h3 id="web-sockets-namespace"><a class="anchor" href="#web-sockets-namespace"></a>36.4. WebSockets Namespace Support</h3>
<div class="paragraph">
<p>The Spring Integration WebSocket namespace includes several components described in the remainder of this chapter.
To include it in your configuration, use the following namespace declaration in your application context configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-websocket="http://www.springframework.org/schema/integration/websocket"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/websocket
    https://www.springframework.org/schema/integration/websocket/spring-integration-websocket.xsd"&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-client-container-attributes"><a class="anchor" href="#websocket-client-container-attributes"></a>36.4.1. <code>&lt;int-websocket:client-container&gt;</code> Attributes</h4>
<div class="paragraph">
<p>The following listing shows the attributes available for the <code>&lt;int-websocket:client-container&gt;</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-websocket:client-container
                  id=""                        <i class="conum" data-value="1"></i><b>(1)</b>
                  client=""                    <i class="conum" data-value="2"></i><b>(2)</b>
                  uri=""                       <i class="conum" data-value="3"></i><b>(3)</b>
                  uri-variables=""             <i class="conum" data-value="4"></i><b>(4)</b>
                  origin=""                    <i class="conum" data-value="5"></i><b>(5)</b>
                  send-time-limit=""           <i class="conum" data-value="6"></i><b>(6)</b>
                  send-buffer-size-limit=""    <i class="conum" data-value="7"></i><b>(7)</b>
                  auto-startup=""              <i class="conum" data-value="8"></i><b>(8)</b>
                  phase=""&gt;                    <i class="conum" data-value="9"></i><b>(9)</b>
                &lt;int-websocket:http-headers&gt;
                  &lt;entry key="" value=""/&gt;
                &lt;/int-websocket:http-headers&gt;  <i class="conum" data-value="10"></i><b>(10)</b>
&lt;/int-websocket:client-container&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>WebSocketClient</code> bean reference.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>uri</code> or <code>uriTemplate</code> to the target WebSocket service.
If you use it as a <code>uriTemplate</code> with URI variable placeholders, the <code>uri-variables</code> attribute is required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Comma-separated values for the URI variable placeholders within the <code>uri</code> attribute value.
The values are replaced into the placeholders according to their order in the <code>uri</code>.
See <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponents.html#expand-java.lang.Object"><code>UriComponents.expand(Object&#8230;&#8203;uriVariableValues)</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>Origin</code> Handshake HTTP header value.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The WebSocket session 'send' timeout limit.
Defaults to <code>10000</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The WebSocket session 'send' message size limit.
Defaults to <code>524288</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Boolean value indicating whether this endpoint should start automatically.
Defaults to <code>false</code>, assuming that this container is started from the <a href="#web-socket-inbound-adapter">WebSocket inbound adapter</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The lifecycle phase within which this endpoint should start and stop.
The lower the value, the earlier this endpoint starts and the later it stops.
The default is <code>Integer.MAX_VALUE</code>.
Values can be negative.
See <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html"><code>SmartLifeCycle</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A <code>Map</code> of <code>HttpHeaders</code> to be used with the Handshake request.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="int-websocketserver-container-attributes"><a class="anchor" href="#int-websocketserver-container-attributes"></a>36.4.2. <code>&lt;int-websocket:server-container&gt;</code> Attributes</h4>
<div class="paragraph">
<p>The following listing shows the attributes available for the <code>&lt;int-websocket:server-container&gt;</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-websocket:server-container
          id=""                         <i class="conum" data-value="1"></i><b>(1)</b>
          path=""                       <i class="conum" data-value="2"></i><b>(2)</b>
          handshake-handler=""          <i class="conum" data-value="3"></i><b>(3)</b>
          handshake-interceptors=""     <i class="conum" data-value="4"></i><b>(4)</b>
          decorator-factories=""        <i class="conum" data-value="5"></i><b>(5)</b>
          send-time-limit=""            <i class="conum" data-value="6"></i><b>(6)</b>
          send-buffer-size-limit=""     <i class="conum" data-value="7"></i><b>(7)</b>
          allowed-origins=""&gt;           <i class="conum" data-value="8"></i><b>(8)</b>
          &lt;int-websocket:sockjs
            client-library-url=""       <i class="conum" data-value="9"></i><b>(9)</b>
            stream-bytes-limit=""       <i class="conum" data-value="10"></i><b>(10)</b>
            session-cookie-needed=""    <i class="conum" data-value="11"></i><b>(11)</b>
            heartbeat-time=""           <i class="conum" data-value="12"></i><b>(12)</b>
            disconnect-delay=""         <i class="conum" data-value="13"></i><b>(13)</b>
            message-cache-size=""       <i class="conum" data-value="14"></i><b>(14)</b>
            websocket-enabled=""        <i class="conum" data-value="15"></i><b>(15)</b>
            scheduler=""                <i class="conum" data-value="16"></i><b>(16)</b>
            message-codec=""            <i class="conum" data-value="17"></i><b>(17)</b>
            transport-handlers=""       <i class="conum" data-value="18"></i><b>(18)</b>
            suppress-cors="true"="" /&gt;  <i class="conum" data-value="19"></i><b>(19)</b>
&lt;/int-websocket:server-container&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A path (or comma-separated paths) that maps a particular request to a <code>WebSocketHandler</code>.
Supports exact path mapping URIs (such as <code>/myPath</code>) and ant-style path patterns (such as <code>/myPath/**</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>HandshakeHandler</code> bean reference.
Defaults to <code>DefaultHandshakeHandler</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>List of <code>HandshakeInterceptor</code> bean references.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>List of one or more factories (<code>WebSocketHandlerDecoratorFactory</code>) that decorate the handler used to process WebSocket messages.
This may be useful for some advanced use cases (for example, to allow Spring Security to forcibly close
the WebSocket session when the corresponding HTTP session expires).
See the <a href="https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket">Spring Session Project</a> for more information.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>See the same option on the <a href="#websocket-client-container-attributes"><code>&lt;int-websocket:client-container&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>See the same option on the <a href="#websocket-client-container-attributes"><code>&lt;int-websocket:client-container&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The allowed origin header values.
You can specify multiple origins as a comma-separated list.
This check is mostly designed for browser clients.
There is nothing preventing other types of client from modifying the origin header value.
When SockJS is enabled and allowed origins are restricted, transport types that do not use origin headers for cross-origin requests (<code>jsonp-polling</code>, <code>iframe-xhr-polling</code>, <code>iframe-eventsource</code>, and <code>iframe-htmlfile</code>) are disabled.
As a consequence, IE6 and IE7 are not supported, and IE8 and IE9 are supported only without cookies.
By default, all origins are allowed.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Transports with no native cross-domain communication (such as <code>eventsource</code> and <code>htmlfile</code>) must get a simple page from the &#8220;foreign&#8221; domain in an invisible iframe so that code in the iframe can run from a domain local to the SockJS server.
Since the iframe needs to load the SockJS javascript client library, this property lets you specify the location from which to load it.
By default, it points to <code><a href="https://d1fxtkz8shb9d2.cloudfront.net/sockjs-0.3.4.min.js" class="bare">d1fxtkz8shb9d2.cloudfront.net/sockjs-0.3.4.min.js</a></code>.
However, you can also set it to point to a URL served by the application.
Note that it is possible to specify a relative URL, in which case the URL must be relative to the iframe URL.
For example, assuming a SockJS endpoint mapped to <code>/sockjs</code> and the resulting iframe URL is <code>/sockjs/iframe.html</code>, the relative URL must start with "../../" to traverse up to the location above the SockJS mapping.
For prefix-based servlet mapping, you may need one more traversal.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Minimum number of bytes that can be sent over a single HTTP streaming request before it is closed.
Defaults to <code>128K</code> (that is, 128*1024 or 131072 bytes).</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The <code>cookie_needed</code> value in the response from the SockJs <code>/info</code> endpoint.
This property indicates whether a <code>JSESSIONID</code> cookie is required for the application to function correctly (for example, for load balancing or in Java Servlet containers for the use of an HTTP session).</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The amount of time (in milliseconds) when the server has not sent any messages and after which the server should
send a heartbeat frame to the client in order to keep the connection from breaking.
The default value is <code>25,000</code> (25 seconds).</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>The amount of time (in milliseconds) before a client is considered disconnected after not having a receiving connection (that is, an active connection over which the server can send data to the client).
The default value is <code>5000</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>The number of server-to-client messages that a session can cache while waiting for the next HTTP polling request from the client.
The default size is <code>100</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td>Some load balancers do not support WebSockets.
Set this option to <code>false</code> to disable the WebSocket transport on the server side.
The default value is <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td>The <code>TaskScheduler</code> bean reference.
A new <code>ThreadPoolTaskScheduler</code> instance is created if no value is provided.
This scheduler instance is used for scheduling heart-beat messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="17"></i><b>17</b></td>
<td>The <code>SockJsMessageCodec</code> bean reference to use for encoding and decoding SockJS messages.
By default, <code>Jackson2SockJsMessageCodec</code> is used, which requires the Jackson library to be present on the classpath.</td>
</tr>
<tr>
<td><i class="conum" data-value="18"></i><b>18</b></td>
<td>List of <code>TransportHandler</code> bean references.</td>
</tr>
<tr>
<td><i class="conum" data-value="19"></i><b>19</b></td>
<td>Whether to disable automatic addition of CORS headers for SockJS requests.
The default value is <code>false</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-outbound-channel-adapter-attributes"><a class="anchor" href="#websocket-outbound-channel-adapter-attributes"></a>36.4.3. <code>&lt;int-websocket:outbound-channel-adapter&gt;</code> Attributes</h4>
<div class="paragraph">
<p>The following listing shows the attributes available for the <code>&lt;int-websocket:outbound-channel-adapter&gt;</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-websocket:outbound-channel-adapter
                          id=""                             <i class="conum" data-value="1"></i><b>(1)</b>
                          channel=""                        <i class="conum" data-value="2"></i><b>(2)</b>
                          container=""                      <i class="conum" data-value="3"></i><b>(3)</b>
                          default-protocol-handler=""       <i class="conum" data-value="4"></i><b>(4)</b>
                          protocol-handlers=""              <i class="conum" data-value="5"></i><b>(5)</b>
                          message-converters=""             <i class="conum" data-value="6"></i><b>(6)</b>
                          merge-with-default-converters=""  <i class="conum" data-value="7"></i><b>(7)</b>
                          auto-startup=""                   <i class="conum" data-value="8"></i><b>(8)</b>
                          phase=""/&gt;                        <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
If you do not provide the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with this <code>id</code> attribute as the bean name.
In this case, the endpoint is registered with the bean name <code>id</code> plus <code>.adapter</code>.
And the <code>MessageHandler</code> is registered with the bean alias <code>id</code> plus <code>.handler</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Identifies the channel attached to this adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The reference to the <code>IntegrationWebSocketContainer</code> bean, which encapsulates the low-level connection and <code>WebSocketSession</code> handling operations.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Optional reference to a <code>SubProtocolHandler</code> instance.
It is used when the client did not request a sub-protocol or it is a single protocol-handler.
If this reference or a <code>protocol-handlers</code> list is not provided, the <code>PassThruSubProtocolHandler</code> is used by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>List of <code>SubProtocolHandler</code> bean references for this channel adapter.
If you provide only a single bean reference and do not provide a <code>default-protocol-handler</code>, that single <code>SubProtocolHandler</code> is used as the <code>default-protocol-handler</code>.
If you do not set this attribute or <code>default-protocol-handler</code>, the <code>PassThruSubProtocolHandler</code> is used by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>List of <code>MessageConverter</code> bean references for this channel adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Boolean value indicating whether the default converters should be registered after any custom converters.
This flag is used only if <code>message-converters</code> is provided.
Otherwise, all default converters are registered.
Defaults to <code>false</code>.
The default converters are (in order): <code>StringMessageConverter</code>, <code>ByteArrayMessageConverter</code>, and <code>MappingJackson2MessageConverter</code> (if the Jackson library is present on the classpath).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Boolean value indicating whether this endpoint should start automatically.
Defaults to <code>true</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The lifecycle phase within which this endpoint should start and stop.
The lower the value, the earlier this endpoint starts and the later it stops.
The default is <code>Integer.MIN_VALUE</code>.
Values can be negative.
See <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html"><code>SmartLifeCycle</code></a>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="int-websocketinbound-channel-adapter-attributes"><a class="anchor" href="#int-websocketinbound-channel-adapter-attributes"></a>36.4.4. <code>&lt;int-websocket:inbound-channel-adapter&gt;</code> Attributes</h4>
<div class="paragraph">
<p>The following listing shows the attributes available for the <code>&lt;int-websocket:outbound-channel-adapter&gt;</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-websocket:inbound-channel-adapter
                            id=""  <i class="conum" data-value="1"></i><b>(1)</b>
                            channel=""  <i class="conum" data-value="2"></i><b>(2)</b>
                            error-channel=""  <i class="conum" data-value="3"></i><b>(3)</b>
                            container=""  <i class="conum" data-value="4"></i><b>(4)</b>
                            default-protocol-handler=""  <i class="conum" data-value="5"></i><b>(5)</b>
                            protocol-handlers=""  <i class="conum" data-value="6"></i><b>(6)</b>
                            message-converters=""  <i class="conum" data-value="7"></i><b>(7)</b>
                            merge-with-default-converters=""  <i class="conum" data-value="8"></i><b>(8)</b>
                            send-timeout=""  <i class="conum" data-value="9"></i><b>(9)</b>
                            payload-type=""  <i class="conum" data-value="10"></i><b>(10)</b>
                            use-broker=""  <i class="conum" data-value="11"></i><b>(11)</b>
                            auto-startup=""  <i class="conum" data-value="12"></i><b>(12)</b>
                            phase=""/&gt;  <i class="conum" data-value="13"></i><b>(13)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component bean name.
If you do not set the <code>channel</code> attribute, a <code>DirectChannel</code> is created and registered in the application context with this <code>id</code> attribute as the bean name.
In this case, the endpoint is registered with the bean name <code>id</code> plus <code>.adapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Identifies the channel attached to this adapter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>MessageChannel</code> bean reference to which the <code>ErrorMessage</code> instances should be sent.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Maximum amount of time (in milliseconds) to wait when sending a message to the channel if the channel can block.
For example, a <code>QueueChannel</code> can block until space is available if its maximum capacity has been reached.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Fully qualified name of the Java type for the target <code>payload</code> to convert from the incoming <code>WebSocketMessage</code>.
Defaults to <code>java.lang.String</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Indicates whether this adapter sends <code>non-MESSAGE</code> <code>WebSocketMessage</code> instances and messages with broker destinations to the <code>AbstractBrokerMessageHandler</code> from the application context.
When this attribute is <code>true</code>, the <code>Broker Relay</code> configuration is required.
This attribute is used only on the server side.
On the client side, it is ignored.
Defaults to <code>false</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>See the same option on the <a href="#websocket-outbound-channel-adapter-attributes"><code>&lt;int-websocket:outbound-channel-adapter&gt;</code></a>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-stomp-encoder"><a class="anchor" href="#client-stomp-encoder"></a>36.5. Using <code>ClientStompEncoder</code></h3>
<div class="paragraph">
<p>Starting with version 4.3.13, Spring Integration provides <code>ClientStompEncoder</code> (as an extension of the standard <code>StompEncoder</code>) for use on the client side of WebSocket channel adapters.
For proper client side message preparation, you must inject an instance of the <code>ClientStompEncoder</code> into the <code>StompSubProtocolHandler</code>.
One problem with the default <code>StompSubProtocolHandler</code> is that it was designed for the server side, so it updates the <code>SEND</code> <code>stompCommand</code> header into <code>MESSAGE</code> (as required by the STOMP protocol for the server side).
If the client does not send its messages in the proper <code>SEND</code> web socket frame, some STOMP brokers do not accept them.
The purpose of the <code>ClientStompEncoder</code>, in this case, is to override the <code>stompCommand</code> header and set it to the <code>SEND</code> value before encoding the message to the <code>byte[]</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ws"><a class="anchor" href="#ws"></a>37. Web Services Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes Spring Integration&#8217;s support for web services, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webservices-outbound">Outbound Web Service Gateways</a></p>
</li>
<li>
<p><a href="#webservices-inbound">Inbound Web Service Gateways</a></p>
</li>
<li>
<p><a href="#webservices-namespace">Web Service Namespace Support</a></p>
</li>
<li>
<p><a href="#outbound-uri">Outbound URI Configuration</a></p>
</li>
<li>
<p><a href="#ws-message-headers">WS Message Headers</a></p>
</li>
<li>
<p><a href="#mtom-support">MTOM Support</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-ws&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-ws:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webservices-outbound"><a class="anchor" href="#webservices-outbound"></a>37.1. Outbound Web Service Gateways</h3>
<div class="paragraph">
<p>To invoke a web service when you send a message to a channel, you have two options, both of which build upon the <a href="https://projects.spring.io/spring-ws/">Spring Web Services</a> project: <code>SimpleWebServiceOutboundGateway</code> and <code>MarshallingWebServiceOutboundGateway</code>.
The former accepts either a <code>String</code> or <code>javax.xml.transform.Source</code> as the message payload.
The latter supports any implementation of the <code>Marshaller</code> and <code>Unmarshaller</code> interfaces.
Both require a Spring Web Services <code>DestinationProvider</code>, to determine the URI of the web service to be called.
The following example shows both options for invoking a web service:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> simpleGateway = new SimpleWebServiceOutboundGateway(destinationProvider);

 marshallingGateway = new MarshallingWebServiceOutboundGateway(destinationProvider, marshaller);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the namespace support (<a href="#webservices-namespace">described later</a>), you need only set a URI.
Internally, the parser configures a fixed URI <code>DestinationProvider</code> implementation.
If you need dynamic resolution of the URI at runtime, however, then the <code>DestinationProvider</code> can provide such behavior as looking up the URI from a registry.
See the Spring Web Services <a href="https://docs.spring.io/spring-ws/docs/current/api/org/springframework/ws/client/support/destination/DestinationProvider.html"><code>DestinationProvider</code></a> Javadoc for more information about this strategy.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, you can supply the <code>SimpleWebServiceOutboundGateway</code> and <code>MarshallingWebServiceOutboundGateway</code> with an external <code>WebServiceTemplate</code> instance, which you can configure for any custom properties, including <code>checkConnectionForFault</code> (which allows your application to deal with non-conforming services).</p>
</div>
<div class="paragraph">
<p>For more detail on the inner workings, see the Spring Web Services reference guide&#8217;s chapter covering <a href="https://docs.spring.io/spring-ws/docs/current/reference/html/client.html">client access</a> and the chapter covering <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html">Object/XML mapping</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="webservices-inbound"><a class="anchor" href="#webservices-inbound"></a>37.2. Inbound Web Service Gateways</h3>
<div class="paragraph">
<p>To send a message to a channel upon receiving a web service invocation, you again have two options: <code>SimpleWebServiceInboundGateway</code> and <code>MarshallingWebServiceInboundGateway</code>.
The former extracts a <code>javax.xml.transform.Source</code> from the <code>WebServiceMessage</code> and sets it as the message payload.
The latter supports implementation of the <code>Marshaller</code> and <code>Unmarshaller</code> interfaces.
If the incoming web service message is a SOAP message, the SOAP action header is added to the headers of the <code>Message</code> that is forwarded onto the request channel.
The following example shows both options:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> simpleGateway = new SimpleWebServiceInboundGateway();
 simpleGateway.setRequestChannel(forwardOntoThisChannel);
 simpleGateway.setReplyChannel(listenForResponseHere); //Optional

 marshallingGateway = new MarshallingWebServiceInboundGateway(marshaller);
 //set request and optionally reply channel</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Both gateways implement the Spring Web Services <code>MessageEndpoint</code> interface, so they can be configured with a <code>MessageDispatcherServlet</code> as per standard Spring Web Services configuration.</p>
</div>
<div class="paragraph">
<p>For more detail on how to use these components, see the Spring Web Services reference guide&#8217;s chapter covering <a href="https://docs.spring.io/spring-ws/docs/current/reference/html/server.html">creating a web service</a>.
The chapter covering <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html">Object/XML mapping</a> is also applicable again.</p>
</div>
<div class="paragraph">
<p>To add the <code>SimpleWebServiceInboundGateway</code> and <code>MarshallingWebServiceInboundGateway</code> configurations to the Spring WS infrastructure, you should add the <code>EndpointMapping</code> definition between <code>MessageDispatcherServlet</code> and the target <code>MessageEndpoint</code> implementations, as you would for a normal Spring WS application.
For this purpose (from the Spring Integration perspective), Spring WS provides the following convenient <code>EndpointMapping</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>o.s.ws.server.endpoint.mapping.UriEndpointMapping</code></p>
</li>
<li>
<p><code>o.s.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping</code></p>
</li>
<li>
<p><code>o.s.ws.soap.server.endpoint.mapping.SoapActionEndpointMapping</code></p>
</li>
<li>
<p><code>o.s.ws.server.endpoint.mapping.XPathPayloadEndpointMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You must specify the beans for these classes in the application context and reference the <code>SimpleWebServiceInboundGateway</code> and/or <code>MarshallingWebServiceInboundGateway</code> bean definitions according to the WS mapping algorithm.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-ws/docs/current/reference/html/server.html#server-endpoint-mapping">endpoint mappings</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="webservices-namespace"><a class="anchor" href="#webservices-namespace"></a>37.3. Web Service Namespace Support</h3>
<div class="paragraph">
<p>To configure an outbound web service gateway, use the <code>outbound-gateway</code> element from the <code>ws</code> namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ws:outbound-gateway id="simpleGateway"
                     request-channel="inputChannel"
                     uri="https://example.org"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This example does not provide a 'reply-channel'.
If the web service returns a non-empty response, the <code>Message</code> containing that response is sent to the reply channel defined in the request message&#8217;s <code>REPLY_CHANNEL</code> header.
If that is not available, a channel resolution exception is thrown.
If you want to send the reply to another channel instead, provide a 'reply-channel' attribute on the 'outbound-gateway' element.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
By default, when you invoke a web service that returns an empty response after using a String payload for the request <code>Message</code>, no reply <code>Message</code> is sent.
Therefore, you need not set a 'reply-channel' or have a <code>REPLY_CHANNEL</code> header in the request <code>Message</code>.
If you actually do want to receive the empty response as a <code>Message</code>, you can set the 'ignore-empty-responses' attribute to <code>false</code>.
Doing so works only for <code>String</code> objects, because using a <code>Source</code> or a <code>Document</code> object leads to a null response and consequently never generates a reply <code>Message</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To set up an inbound Web Service Gateway, use the <code>inbound-gateway</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ws:inbound-gateway id="simpleGateway"
                    request-channel="inputChannel"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To use Spring OXM marshallers or unmarshallers, you must provide bean references.
The following example shows how to provide a bean reference for an outbound marshalling gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ws:outbound-gateway id="marshallingGateway"
                     request-channel="requestChannel"
                     uri="https://example.org"
                     marshaller="someMarshaller"
                     unmarshaller="someUnmarshaller"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to provide a bean reference for an inbound marshalling gateway:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-ws:inbound-gateway id="marshallingGateway"
                    request-channel="requestChannel"
                    marshaller="someMarshaller"
                    unmarshaller="someUnmarshaller"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most <code>Marshaller</code> implementations also implement the <code>Unmarshaller</code> interface.
When using such a <code>Marshaller</code>, only the <code>marshaller</code> attribute is necessary.
Even when using a <code>Marshaller</code>, you may also provide a reference for the <code>request-callback</code> on the outbound gateways.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For either outbound gateway type, you can specify a <code>destination-provider</code> attribute instead of the <code>uri</code> (exactly one of them is required).
You can then reference any Spring Web Services <code>DestinationProvider</code> implementation (for example, to lookup the URI from a registry at runtime).</p>
</div>
<div class="paragraph">
<p>For either outbound gateway type, the <code>message-factory</code> attribute can also be configured with a reference to any Spring Web Services <code>WebServiceMessageFactory</code> implementation.</p>
</div>
<div class="paragraph">
<p>For the simple inbound gateway type, you can set the <code>extract-payload</code> attribute to <code>false</code> to forward the entire <code>WebServiceMessage</code> instead of just its payload as a <code>Message</code> to the request channel.
Doing so might be useful, for example, when a custom transformer works against the <code>WebServiceMessage</code> directly.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>web-service-template</code> reference attribute lets you inject a <code>WebServiceTemplate</code> with any possible custom properties.</p>
</div>
</div>
<div class="sect2">
<h3 id="outbound-uri"><a class="anchor" href="#outbound-uri"></a>37.4. Outbound URI Configuration</h3>
<div class="paragraph">
<p>For all URI schemes supported by Spring Web Services (see <a href="https://docs.spring.io/spring-ws/docs/current/reference/html/client.html#client-transports">URIs and Transports</a>) <code>&lt;uri-variable/&gt;</code> substitution is provided.
The following example shows how to define it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ws:outbound-gateway id="gateway" request-channel="input"
        uri="https://springsource.org/{thing1}-{thing2}"&gt;
    &lt;ws:uri-variable name="thing1" expression="payload.substring(1,7)"/&gt;
    &lt;ws:uri-variable name="thing2" expression="headers.x"/&gt;
&lt;/ws:outbound-gateway&gt;

&lt;ws:outbound-gateway request-channel="inputJms"
        uri="jms:{destination}?deliveryMode={deliveryMode}&amp;amp;priority={priority}"
        message-sender="jmsMessageSender"&gt;
    &lt;ws:uri-variable name="destination" expression="headers.jmsQueue"/&gt;
    &lt;ws:uri-variable name="deliveryMode" expression="headers.deliveryMode"/&gt;
    &lt;ws:uri-variable name="priority" expression="headers.jms_priority"/&gt;
&lt;/ws:outbound-gateway&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you supply a <code>DestinationProvider</code>, variable substitution is not supported and a configuration error occurs if you provide variables.</p>
</div>
<div class="sect3">
<h4 id="controlling-uri-encoding-2"><a class="anchor" href="#controlling-uri-encoding-2"></a>37.4.1. Controlling URI Encoding</h4>
<div class="paragraph">
<p>By default, the URL string is encoded (see <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html"><code>UriComponentsBuilder</code></a>) to the URI object before sending the request.
In some scenarios with a non-standard URI, it is undesirable to perform the encoding.
Since version 4.1, the <code>&lt;ws:outbound-gateway/&gt;</code> element provides an <code>encode-uri</code> attribute.
To disable encoding the URL, set this attribute <code>false</code> (it defaults to <code>true</code>).
If you wish to partially encode some of the URL, you can do so by using an <code>expression</code> within a <code>&lt;uri-variable/&gt;</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;ws:outbound-gateway url="http://somehost/%2f/fooApps?bar={param}" encode-uri="false"&gt;
          &lt;http:uri-variable name="param"
            expression="T(org.apache.commons.httpclient.util.URIUtil)
                                             .encodeWithinQuery('Hello World!')"/&gt;
&lt;/ws:outbound-gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you set <code>DestinationProvider</code>, <code>encode-uri</code> is ignored.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ws-message-headers"><a class="anchor" href="#ws-message-headers"></a>37.5. WS Message Headers</h3>
<div class="paragraph">
<p>The Spring Integration web service gateways automatically map the SOAP action header.
By default, it is copied to and from Spring Integration <code>MessageHeaders</code> by using the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/ws/DefaultSoapHeaderMapper.html"><code>DefaultSoapHeaderMapper</code></a>.</p>
</div>
<div class="paragraph">
<p>You can pass in your own implementation of SOAP-specific header mappers, as the gateways have properties to support doing so.</p>
</div>
<div class="paragraph">
<p>Unless explicitly specified by the <code>requestHeaderNames</code> or <code>replyHeaderNames</code> properties of the <code>DefaultSoapHeaderMapper</code>, any user-defined SOAP headers are not copied to or from a SOAP Message.</p>
</div>
<div class="paragraph">
<p>When you use the XML namespace for configuration, you can set these properties by using the <code>mapped-request-headers</code> and <code>mapped-reply-headers</code> attributes, you can provide a custom mapper by setting the <code>header-mapper</code> attribute.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When mapping user-defined headers, the values can also contain simple wildcard patterns (such <code>myheader*</code> or <code><strong>myheader</code>).
For example, if you need to copy all user-defined headers, you can use the wildcard character: <code></strong></code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.1, the <code>AbstractHeaderMapper</code> (a <code>DefaultSoapHeaderMapper</code> superclass) lets the <code>NON_STANDARD_HEADERS</code> token be configured for the <code>requestHeaderNames</code> and <code>replyHeaderNames</code> properties (in addition to existing <code>STANDARD_REQUEST_HEADERS</code> and <code>STANDARD_REPLY_HEADERS</code>) to map all user-defined headers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Rather than using the wildcard (<code>*</code>), we recommend using the following combination : <code>STANDARD_REPLY_HEADERS, NON_STANDARD_HEADERS</code>.
Doing so avoids mapping <code>request</code> headers to the reply.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can negate patterns in the header mappings by preceding the pattern with <code>!</code>.
Negated patterns get priority, so a list such as <code>STANDARD_REQUEST_HEADERS,thing1,thing*,!thing2,!thing3,qux,!thing1</code> does not map <code>thing1</code>, <code>thing2</code>, or <code>thing3</code>.
It does map the standard headers, <code>thing4</code>, and <code>qux</code>.
(Note that <code>thing1</code> is included in both non-negated and negated forms.
Because negated values take precedence, <code>thing1</code> is not mapped.)</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have a user-defined header that begins with <code>!</code> that you do wish to map, you can escape it with <code>\</code>, as follows: <code>STANDARD_REQUEST_HEADERS,\!myBangHeader</code>.
A <code>!myBangHeader</code> is then mapped.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Inbound SOAP headers (request headers for the inbound gateway and reply headers for the outbound gateway) are mapped as <code>SoapHeaderElement</code> objects.
You can explore the contents by accessing the <code>Source</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;soapenv:Header&gt;
        &lt;auth&gt;
            &lt;username&gt;user&lt;/username&gt;
            &lt;password&gt;pass&lt;/password&gt;
        &lt;/auth&gt;
        &lt;bar&gt;BAR&lt;/bar&gt;
        &lt;baz&gt;BAZ&lt;/baz&gt;
        &lt;qux&gt;qux&lt;/qux&gt;
    &lt;/soapenv:Header&gt;
    &lt;soapenv:Body&gt;
        ...
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If <code>mapped-request-headers</code> is <code>auth, ca*</code>, the <code>auth</code>, <code>cat</code>, and <code>can</code> headers are mapped, but <code>qux</code> is not mapped.</p>
</div>
<div class="paragraph">
<p>The following example shows how to get a value named <code>user</code> from a header named <code>auth</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
SoapHeaderElement header = (SoapHeaderElement) headers.get("auth");
DOMSource source = (DOMSource) header.getSource();
NodeList nodeList = source.getNode().getChildNodes();
assertEquals("username", nodeList.item(0).getNodeName());
assertEquals("user", nodeList.item(0).getFirstChild().getNodeValue());
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>DefaultSoapHeaderMapper</code> supports user-defined headers of type <code>javax.xml.transform.Source</code> and populates them as child nodes of the <code>&lt;soapenv:Header&gt;</code>.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; headers = new HashMap&lt;&gt;();

String authXml =
     "&lt;auth xmlns='http://test.auth.org'&gt;"
           + "&lt;username&gt;user&lt;/username&gt;"
           + "&lt;password&gt;pass&lt;/password&gt;"
           + "&lt;/auth&gt;";
headers.put("auth", new StringSource(authXml));
...
DefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();
mapper.setRequestHeaderNames("auth");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the preceding examples is the following SOAP envelope:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;soapenv:Header&gt;
        &lt;auth xmlns="http://test.auth.org"&gt;
            &lt;username&gt;user&lt;/username&gt;
            &lt;password&gt;pass&lt;/password&gt;
        &lt;/auth&gt;
    &lt;/soapenv:Header&gt;
    &lt;soapenv:Body&gt;
        ...
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mtom-support"><a class="anchor" href="#mtom-support"></a>37.6. MTOM Support</h3>
<div class="paragraph">
<p>The marshalling inbound and outbound web service gateways support attachments directly through built-in functionality of the marshaller (for example, <code>Jaxb2Marshaller</code> provides the <code>mtomEnabled</code> option).
Starting with version 5.0, the simple web service gateways can directly operate with inbound and outbound <code>MimeMessage</code> instances, which have an API to manipulate attachments.
When you need to send web service message with attachments (either a reply from a server or a client request) you should use the <code>WebServiceMessageFactory</code> directly and send a <code>WebServiceMessage</code> with attachments as a <code>payload</code> to the request or reply channel of the gateway.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebServiceMessageFactory messageFactory = new SaajSoapMessageFactory(MessageFactory.newInstance());
MimeMessage webServiceMessage = (MimeMessage) messageFactory.createWebServiceMessage();

String request = "&lt;test&gt;foo&lt;/test&gt;";

TransformerFactory transformerFactory = TransformerFactory.newInstance();
Transformer transformer = transformerFactory.newTransformer();
transformer.transform(new StringSource(request), webServiceMessage.getPayloadResult());

webServiceMessage.addAttachment("myAttachment", new ByteArrayResource("my_data".getBytes()), "plain/text");

this.webServiceChannel.send(new GenericMessage&lt;&gt;(webServiceMessage));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="xml"><a class="anchor" href="#xml"></a>38. XML Support - Dealing with XML Payloads</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration&#8217;s XML support extends the core of Spring Integration with the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xml-transformation">Marshalling Transformer</a></p>
</li>
<li>
<p><a href="#xml-transformation">Unmarshalling Transformer</a></p>
</li>
<li>
<p><a href="#xml-transformation">XSLT Transformer</a></p>
</li>
<li>
<p><a href="#xml-xpath-transformer">XPath Transformer</a></p>
</li>
<li>
<p><a href="#xml-xpath-splitting">XPath Splitter</a></p>
</li>
<li>
<p><a href="#xml-xpath-routing">XPath Router</a></p>
</li>
<li>
<p><a href="#xml-xpath-header-enricher">XPath Header Enricher</a></p>
</li>
<li>
<p><a href="#xml-xpath-filter">XPath Filter</a></p>
</li>
<li>
<p><a href="#xpath-spel-function">#xpath SpEL Function</a></p>
</li>
<li>
<p><a href="#xml-validating-filter">Validating Filter</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-xml&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-xml:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These components make working with XML messages in Spring Integration simpler.
The messaging components work with XML that is represented in a range of formats, including instances of <code>java.lang.String</code>, <code>org.w3c.dom.Document</code>, and <code>javax.xml.transform.Source</code>.
However, where a DOM representation is required (for example, in order to evaluate an XPath expression), the <code>String</code> payload is converted into the required type and then converted back to <code>String</code>.
Components that require an instance of <code>DocumentBuilder</code> create a namespace-aware instance if you do not provide one.
When you require greater control over document creation, you can provide an appropriately configured instance of <code>DocumentBuilder</code>.</p>
</div>
<div class="sect2">
<h3 id="xpath-namespace-support"><a class="anchor" href="#xpath-namespace-support"></a>38.1. Namespace Support</h3>
<div class="paragraph">
<p>All components within the Spring Integration XML module provide namespace support.
In order to enable namespace support, you need to import the schema for the Spring Integration XML Module.
The following example shows a typical setup:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-xml="http://www.springframework.org/schema/integration/xml"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/xml
    https://www.springframework.org/schema/integration/xml/spring-integration-xml.xsd"&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml-xpath-expressions"><a class="anchor" href="#xml-xpath-expressions"></a>38.1.1. XPath Expressions</h4>
<div class="paragraph">
<p>Many of the components within the Spring Integration XML module work with XPath Expressions.
Each of those components either references an XPath Expression that has been defined as a top-level element or uses a nested <code>&lt;xpath-expression/&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>All forms of XPath expressions result in the creation of an <code>XPathExpression</code> that uses the Spring <code>org.springframework.xml.xpath.XPathExpressionFactory</code>.
When XPath expressions are created, the best XPath implementation that is available on the classpath is used (either JAXP 1.3+ or Jaxen, with JAXP being preferred).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Internally, Spring Integration uses the XPath functionality provided by the Spring Web Services project (<a href="https://www.spring.io/spring-ws" class="bare">www.spring.io/spring-ws</a>).
Specifically, we use the Spring Web Services XML module (spring-xml-x.x.x.jar).
For a deeper understanding, see the respective documentation at <a href="https://docs.spring.io/spring-ws/docs/current/reference/#xpath" class="bare">docs.spring.io/spring-ws/docs/current/reference/#xpath</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an overview of all available configuration parameters of the <code>xpath-expression</code> element:
The following listing shows the available attributes for the <code>xpath-expression</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-expression expression="" <i class="conum" data-value="1"></i><b>(1)</b>
          id=""                         <i class="conum" data-value="2"></i><b>(2)</b>
          namespace-map=""              <i class="conum" data-value="3"></i><b>(3)</b>
          ns-prefix=""                  <i class="conum" data-value="4"></i><b>(4)</b>
          ns-uri=""&gt;                    <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;map&gt;&lt;/map&gt;                         <i class="conum" data-value="6"></i><b>(6)</b>
&lt;/int-xml:xpath-expression&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines an XPath expression.
Required.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The identifier of the underlying bean definition.
It is an instance of <code>org.springframework.xml.xpath.XPathExpression</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Reference to a map that contains namespaces.
The key of the map defines the namespace prefix, and the value of the map sets the namespace URI.
It is not valid to specify both this attribute and the <code>map</code> element or the <code>ns-prefix</code> and <code>ns-uri</code> attributes.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Lets you set the namespace prefix directly as an attribute on the XPath expression element.
If you set <code>ns-prefix</code>, you must also set the <code>ns-uri</code> attribute.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Lets you directly set the namespace URI as an attribute on the XPath expression element.
If you set <code>ns-uri</code>, you must also set the <code>ns-prefix</code> attribute.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Defines a map that contains namespaces.
Only one <code>map</code> child element is allowed.
The key of the map defines the namespace prefix, and the value of the map sets the namespace URI.
It is not valid to specify both this element and the <code>map</code> attribute or set the <code>ns-prefix</code> and <code>ns-uri</code> attributes.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="providing-namespaces-optional-to-xpath-expressions"><a class="anchor" href="#providing-namespaces-optional-to-xpath-expressions"></a>Providing Namespaces (Optional) to XPath Expressions</h5>
<div class="paragraph">
<p>For the XPath Expression Element, you can provide namespace information as configuration parameters.
You can define namespaces by using one of the following choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reference a map by using the <code>namespace-map</code> attribute</p>
</li>
<li>
<p>Provide a map of namespaces by using the <code>map</code> sub-element</p>
</li>
<li>
<p>Specify the <code>ns-prefix</code> and <code>ns-uri</code> attributes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All three options are mutually exclusive.
Only one option can be set.</p>
</div>
<div class="paragraph">
<p>The following example shows several different ways to use XPath expressions, including the options for setting the XML namespaces <a href="#xpath-namespace-support">mentioned earlier</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-filter id="filterReferencingXPathExpression"
                      xpath-expression-ref="refToXpathExpression"/&gt;

&lt;int-xml:xpath-expression id="refToXpathExpression" expression="/name"/&gt;

&lt;int-xml:xpath-filter id="filterWithoutNamespace"&gt;
    &lt;int-xml:xpath-expression expression="/name"/&gt;
&lt;/int-xml:xpath-filter&gt;

&lt;int-xml:xpath-filter id="filterWithOneNamespace"&gt;
    &lt;int-xml:xpath-expression expression="/ns1:name"
                              ns-prefix="ns1" ns-uri="www.example.org"/&gt;
&lt;/int-xml:xpath-filter&gt;

&lt;int-xml:xpath-filter id="filterWithTwoNamespaces"&gt;
    &lt;int-xml:xpath-expression expression="/ns1:name/ns2:type"&gt;
        &lt;map&gt;
            &lt;entry key="ns1" value="www.example.org/one"/&gt;
            &lt;entry key="ns2" value="www.example.org/two"/&gt;
        &lt;/map&gt;
    &lt;/int-xml:xpath-expression&gt;
&lt;/int-xml:xpath-filter&gt;

&lt;int-xml:xpath-filter id="filterWithNamespaceMapReference"&gt;
    &lt;int-xml:xpath-expression expression="/ns1:name/ns2:type"
                              namespace-map="defaultNamespaces"/&gt;
&lt;/int-xml:xpath-filter&gt;

&lt;util:map id="defaultNamespaces"&gt;
    &lt;util:entry key="ns1" value="www.example.org/one"/&gt;
    &lt;util:entry key="ns2" value="www.example.org/two"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-xpath-expressions-with-default-namespaces"><a class="anchor" href="#using-xpath-expressions-with-default-namespaces"></a>Using XPath Expressions with Default Namespaces</h5>
<div class="paragraph">
<p>When working with default namespaces, you may run into situations that behave differently than you might expect.
Assume we have the following XML document (which represents an order of two books):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;order&gt;
    &lt;orderItem&gt;
        &lt;isbn&gt;0321200683&lt;/isbn&gt;
        &lt;quantity&gt;2&lt;/quantity&gt;
    &lt;/orderItem&gt;
    &lt;orderItem&gt;
        &lt;isbn&gt;1590596439&lt;/isbn&gt;
        &lt;quantity&gt;1&lt;/quantity&gt;
    &lt;/orderItem&gt;
&lt;/order&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This document does not declare a namespace.
Therefore, applying the following XPath Expression works as expected:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-expression expression="/order/orderItem" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You might expect that the same expression also works for the following XML file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;order xmlns="http://www.example.org/orders"&gt;
	&lt;orderItem&gt;
		&lt;isbn&gt;0321200683&lt;/isbn&gt;
		&lt;quantity&gt;2&lt;/quantity&gt;
	&lt;/orderItem&gt;
	&lt;orderItem&gt;
		&lt;isbn&gt;1590596439&lt;/isbn&gt;
		&lt;quantity&gt;1&lt;/quantity&gt;
	&lt;/orderItem&gt;
&lt;/order&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example looks exactly the same as the previous example but declares a default namespace.</p>
</div>
<div class="paragraph">
<p>However, the previous XPath expression (<code>/order/orderItem</code>) fails in this case.</p>
</div>
<div class="paragraph">
<p>In order to solve this issue, you must provide a namespace prefix and a namespace URI either by setting the <code>ns-prefix</code> and <code>ns-uri</code> attributes or by setting the <code>namespace-map</code> attribute.
The namespace URI must match the namespace declared in your XML document.
In the preceding example, that is <code><a href="http://www.example.org/orders" class="bare">www.example.org/orders</a></code>.</p>
</div>
<div class="paragraph">
<p>You can, however, arbitrarily choose the namespace prefix.
In fact, providing an empty string actually works.
(However, null is not allowed.)
In the case of a namespace prefix consisting of an empty string, your Xpath expression must use a colon (":") to indicate the default namespace.
If you leave off the colon, the XPath expression does not match.
The following XPath Expression matches against the XML document in the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-expression expression="/:order/:orderItem"
    ns-prefix="" ns-uri="https://www.example.org/prodcuts"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also provide any other arbitrarily chosen namespace prefix.
The following XPath expression (which use the <code>myorder</code> namespace prefix) also matches:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-expression expression="/myorder:order/myorder:orderItem"
    ns-prefix="myorder" ns-uri="https://www.example.org/prodcuts"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The namespace URI is the really important piece of information, not the prefix.
The <a href="https://github.com/jaxen-xpath/jaxen">Jaxen</a> summarizes the point very well:</p>
</div>
<div class="quoteblock">
<blockquote>
In XPath 1.0, all unprefixed names are unqualified.
There is no requirement that the prefixes used in the XPath expression are the same as the prefixes used in the document being queried.
Only the namespace URIs need to match, not the prefixes.
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-transformation"><a class="anchor" href="#xml-transformation"></a>38.2. Transforming XML Payloads</h3>
<div class="paragraph">
<p>This section covers how to transform XML payloads</p>
</div>
<div class="sect3">
<h4 id="xml-transformation-beans"><a class="anchor" href="#xml-transformation-beans"></a>38.2.1. Configuring Transformers as Beans</h4>
<div class="paragraph">
<p>This section will explain the workings of the following transformers and how to configure them as beans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xml-unmarshalling-transformer">UnmarshallingTransformer</a></p>
</li>
<li>
<p><a href="#xml-marshalling-transformer">MarshallingTransformer</a></p>
</li>
<li>
<p><a href="#xml-xslt-payload-transformers">XsltPayloadTransformer</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of the XML transformers extend either <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/AbstractTransformer.html"><code>AbstractTransformer</code></a> or  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/AbstractPayloadTransformer.html"><code>AbstractPayloadTransformer</code></a> and therefore implement  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/Transformer.html"><code>Transformer</code></a>.
When configuring XML transformers as beans in Spring Integration, you would normally configure the <code>Transformer</code> in conjunction with a  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/MessageTransformingHandler.html"><code>MessageTransformingHandler</code></a>.
This lets the transformer be used as an endpoint.
Finally, we discuss the namespace support , which allows for configuring the transformers as elements in XML.</p>
</div>
<div class="sect4">
<h5 id="xml-unmarshalling-transformer"><a class="anchor" href="#xml-unmarshalling-transformer"></a>UnmarshallingTransformer</h5>
<div class="paragraph">
<p>An <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/UnmarshallingTransformer.html"><code>UnmarshallingTransformer</code></a> lets an XML <code>Source</code> be unmarshalled by using implementations of the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html">Spring OXM</a> <code>Unmarshaller</code>.
Spring&#8217;s Object/XML Mapping support provides several implementations that support marshalling and unmarshalling by using <a href="https://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">JAXB</a>, <a href="https://castor-data-binding.github.io/castor/reference-guide/reference/xml/xml-framework.html">Castor</a>, <a href="https://en.wikipedia.org/wiki/JiBX">JiBX</a>, and others.
The unmarshaller requires an instance of <code>Source</code>.
If the message payload is not an instance of <code>Source</code>, conversion is still attempted.
Currently, <code>String</code>, <code>File</code>, <code>byte[]</code> and <code>org.w3c.dom.Document</code> payloads are supported.
To create a custom conversion to a <code>Source</code>, you can inject an implementation of a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html"><code>SourceFactory</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not explicitly set a <code>SourceFactory</code>, the property on the <code>UnmarshallingTransformer</code> is, by default, set to a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html"><code>DomSourceFactory</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 5.0, the <code>UnmarshallingTransformer</code> also supports an <code>org.springframework.ws.mime.MimeMessage</code> as the incoming payload.
This can be useful when we receive a raw <code>WebServiceMessage</code> with MTOM attachments over SOAP .
See <a href="#mtom-support">MTOM Support</a> for more information.</p>
</div>
<div class="paragraph">
<p>The following example shows how to define an unmarshalling transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="unmarshallingTransformer" class="o.s.i.xml.transformer.UnmarshallingTransformer"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
            &lt;property name="contextPath" value="org.example" /&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xml-marshalling-transformer"><a class="anchor" href="#xml-marshalling-transformer"></a>Using <code>MarshallingTransformer</code></h5>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/MarshallingTransformer.html"><code>MarshallingTransformer</code></a> lets an object graph be converted into XML by using a Spring OXM <code>Marshaller</code>.
By default, the <code>MarshallingTransformer</code> returns a <code>DomResult</code>.
However, you can control the type of result by configuring an alternative <code>ResultFactory</code>, such as <code>StringResultFactory</code>.
In many cases, it is more convenient to transform the payload into an alternative XML format.
To do so, configure a <code>ResultTransformer</code>.
Spring integration provides two implementations, one that converts to <code>String</code> and another that converts to <code>Document</code>.
The following example configures a marshalling transformer that transforms to a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="marshallingTransformer" class="o.s.i.xml.transformer.MarshallingTransformer"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
            &lt;property name="contextPath" value="org.example"/&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="o.s.i.xml.transformer.ResultToDocumentTransformer"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the <code>MarshallingTransformer</code> passes the payload object to the <code>Marshaller</code>.
However, if its boolean <code>extractPayload</code> property is set to <code>false</code>, the entire <code>Message</code> instance is passed to the <code>Marshaller</code> instead.
That may be useful for certain custom implementations of the <code>Marshaller</code> interface, but, typically, the payload is the appropriate source object for marshalling when you delegate to any of the various <code>Marshaller</code> implementations.</p>
</div>
</div>
<div class="sect4">
<h5 id="xml-xslt-payload-transformers"><a class="anchor" href="#xml-xslt-payload-transformers"></a>XsltPayloadTransformer</h5>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html"><code>XsltPayloadTransformer</code></a> transforms XML payloads by using <a href="https://en.wikipedia.org/wiki/XSL_Transformations">Extensible Stylesheet Language Transformations</a> (XSLT).
The transformer&#8217;s constructor requires an instance of either <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html">Resource</a> or <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Templates.html">Templates</a> to be passed in.
Passing in a <code>Templates</code> instance allows for greater configuration of the <code>TransformerFactory</code> used to create the template instance.</p>
</div>
<div class="paragraph">
<p>As with the <a href="#xml-unmarshalling-transformer"><code>UnmarshallingTransformer</code></a>, the <code>XsltPayloadTransformer</code> does the actual XSLT transformation against instances of <code>Source</code>.
Therefore, if the message payload is not an instance of <code>Source</code>, conversion is still attempted.
<code>String</code> and <code>Document</code> payloads are supported directly.</p>
</div>
<div class="paragraph">
<p>To create a custom conversion to a <code>Source</code>, you can inject an implementation of a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html"><code>SourceFactory</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a <code>SourceFactory</code> is not set explicitly, the property on the <code>XsltPayloadTransformer</code> is, by default, set to a  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html"><code>DomSourceFactory</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the <code>XsltPayloadTransformer</code> creates a message with a <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html"><code>Result</code></a> payload, similar to the <code>XmlPayloadMarshallingTransformer</code>.
You can customize this by providing a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/ResultFactory.html"><code>ResultFactory</code></a> or a  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultTransformer.html"><code>ResultTransformer</code></a>.</p>
</div>
<div class="paragraph">
<p>The following example configures a bean that works as an XSLT payload transformer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="xsltPayloadTransformer" class="o.s.i.xml.transformer.XsltPayloadTransformer"&gt;
  &lt;constructor-arg value="classpath:org/example/xsl/transform.xsl"/&gt;
  &lt;constructor-arg&gt;
    &lt;bean class="o.s.i.xml.transformer.ResultToDocumentTransformer"/&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, you can specify the transformer factory class name by using a constructor argument.
You can do so by using the <code>transformer-factory-class</code> attribute when you use the namespace.</p>
</div>
</div>
<div class="sect4">
<h5 id="xml-using-result-transformers"><a class="anchor" href="#xml-using-result-transformers"></a>Using <code>ResultTransformer</code> Implementations</h5>
<div class="paragraph">
<p>Both the <code>MarshallingTransformer</code> and the <code>XsltPayloadTransformer</code> let you specify a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultTransformer.html"><code>ResultTransformer</code></a>.
Thus, if the marshalling or XSLT transformation returns a <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html"><code>Result</code></a>, you have the option to also use a <code>ResultTransformer</code> to transform the <code>Result</code> into another format.
Spring Integration provides two concrete <code>ResultTransformer</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.html"><code>ResultToDocumentTransformer</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultToStringTransformer.html"><code>ResultToStringTransformer</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the <code>MarshallingTransformer</code> always returns a <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html"><code>Result</code></a>.
By specifying a <code>ResultTransformer</code>, you can customize the type of payload returned.</p>
</div>
<div class="paragraph">
<p>The behavior is slightly more complex for the <code>XsltPayloadTransformer</code>.
By default, if the input payload is an instance of <code>String</code> or <a href="https://docs.oracle.com/javase/6/docs/api/org/w3c/dom/Document.html"><code>Document</code></a> the <code>resultTransformer</code> property is ignored.</p>
</div>
<div class="paragraph">
<p>However, if the input payload is a <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Source.html"><code>Source</code></a> or any other type, the <code>resultTransformer</code> property is applied.
Additionally, you can set the <code>alwaysUseResultFactory</code> property to <code>true</code>, which also causes the specified <code>resultTransformer</code> to be used.</p>
</div>
<div class="paragraph">
<p>For more information and examples, see <a href="#xml-using-result-transformers-namespace">Namespace Configuration and Result Transformers</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml-transformer-namespace"><a class="anchor" href="#xml-transformer-namespace"></a>38.2.2. Namespace Support for XML Transformers</h4>
<div class="paragraph">
<p>Namespace support for all XML transformers is provided in the Spring Integration XML namespace, a template for which was <a href="#xpath-namespace-support">shown earlier</a>.
The namespace support for transformers creates an instance of either <code>EventDrivenConsumer</code> or <code>PollingConsumer</code>, according to the type of the provided input channel.
The namespace support is designed to reduce the amount of XML configuration by allowing the creation of an endpoint and transformer that use one element.</p>
</div>
<div class="sect4">
<h5 id="using-an-unmarshallingtransformer"><a class="anchor" href="#using-an-unmarshallingtransformer"></a>Using an <code>UnmarshallingTransformer</code></h5>
<div class="paragraph">
<p>The namespace support for the <code>UnmarshallingTransformer</code> is shown below.
Since the namespace create an endpoint instance rather than a transformer, you can nest a poller within the element to control the polling of the input channel.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:unmarshalling-transformer id="defaultUnmarshaller"
    input-channel="input" output-channel="output"
    unmarshaller="unmarshaller"/&gt;

&lt;int-xml:unmarshalling-transformer id="unmarshallerWithPoller"
    input-channel="input" output-channel="output"
    unmarshaller="unmarshaller"&gt;
    &lt;int:poller fixed-rate="2000"/&gt;
&lt;int-xml:unmarshalling-transformer/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-a-marshallingtransformer"><a class="anchor" href="#using-a-marshallingtransformer"></a>Using a <code>MarshallingTransformer</code></h5>
<div class="paragraph">
<p>The namespace support for the marshalling transformer requires an <code>input-channel</code>, an <code>output-channel</code>, and a reference to a <code>marshaller</code>.
You can use the optional <code>result-type</code> attribute to control the type of result created.
Valid values are <code>StringResult</code> or <code>DomResult</code> (the default).
The following example configures a marshalling transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:marshalling-transformer
     input-channel="marshallingTransformerStringResultFactory"
     output-channel="output"
     marshaller="marshaller"
     result-type="StringResult" /&gt;

&lt;int-xml:marshalling-transformer
    input-channel="marshallingTransformerWithResultTransformer"
    output-channel="output"
    marshaller="marshaller"
    result-transformer="resultTransformer" /&gt;

&lt;bean id="resultTransformer" class="o.s.i.xml.transformer.ResultToStringTransformer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Where the provided result types do not suffice, you can provide a reference to a custom implementation of <code>ResultFactory</code> as an alternative to setting the <code>result-type</code> attribute by using the <code>result-factory</code> attribute.
The <code>result-type</code> and <code>result-factory</code> attributes  are mutually exclusive.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Internally, the <code>StringResult</code> and <code>DomResult</code> result types are represented by the <code>ResultFactory</code> implementations: <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/StringResultFactory.html"><code>StringResultFactory</code></a> and  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/DomResultFactory.html"><code>DomResultFactory</code></a> respectively.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-an-xsltpayloadtransformer"><a class="anchor" href="#using-an-xsltpayloadtransformer"></a>Using an <code>XsltPayloadTransformer</code></h5>
<div class="paragraph">
<p>Namespace support for the <code>XsltPayloadTransformer</code> lets you  either pass in a <code>Resource</code> (in order to create the <a href="https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Templates.html"><code>Templates</code></a> instance) or  pass in a pre-created <code>Templates</code> instance as a reference.
As with the marshalling transformer, you can control the type of the result output by specifying either the <code>result-factory</code> or the <code>result-type</code> attribute.
When you need to convert result before sending, you can use a <code>result-transformer</code> attribute to reference an implementation of <code>ResultTransformer</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you specify the <code>result-factory</code> or the <code>result-type</code> attribute, the <code>alwaysUseResultFactory</code> property on the underlying <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html"><code>XsltPayloadTransformer</code></a> is set to <code>true</code> by the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/config/XsltPayloadTransformerParser.html"><code>XsltPayloadTransformerParser</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example configures two XSLT transformers:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xslt-transformer id="xsltTransformerWithResource"
    input-channel="withResourceIn" output-channel="output"
    xsl-resource="org/springframework/integration/xml/config/test.xsl"/&gt;

&lt;int-xml:xslt-transformer id="xsltTransformerWithTemplatesAndResultTransformer"
    input-channel="withTemplatesAndResultTransformerIn" output-channel="output"
    xsl-templates="templates"
    result-transformer="resultTransformer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may need to have access to <code>Message</code> data, such as the <code>Message</code> headers, in order to assist with transformation.
For example, you may need to get access to certain <code>Message</code> headers and pass them on as parameters to a transformer (for example, <code>transformer.setParameter(..)</code>).
Spring Integration provides two convenient ways to accomplish this, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xslt-transformer id="paramHeadersCombo"
    input-channel="paramHeadersComboChannel" output-channel="output"
    xsl-resource="classpath:transformer.xslt"
    xslt-param-headers="testP*, *foo, bar, baz"&gt;

    &lt;int-xml:xslt-param name="helloParameter" value="hello"/&gt;
    &lt;int-xml:xslt-param name="firstName" expression="headers.fname"/&gt;
&lt;/int-xml:xslt-transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If message header names match one-to-one to parameter names, you can use the <code>xslt-param-headers</code>attribute.
In it, you can use wildcards for simple pattern matching.
It supports the following simple pattern styles: <code>xxx*</code>, <code><strong>xxx</code>, <code>*xxx</strong></code>, and <code>xxx*yyy</code>.</p>
</div>
<div class="paragraph">
<p>You can also configure individual XSLT parameters by using the <code>&lt;xslt-param/&gt;</code> element.
On that element, you can set the <code>expression</code> attributeor the <code>value</code> attribute.
The <code>expression</code> attribute should be any valid SpEL expression with the <code>Message</code> being the root object of the expression evaluation context.
The <code>value</code> attribute (as with any <code>value</code> in Spring beans) lets you specify simple scalar values.
You can also use property placeholders (such as <code>${some.value}</code>).
So, with the <code>expression</code> and <code>value</code> attributes, you can map XSLT parameters to any accessible part of the <code>Message</code> as well as any literal value.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, you can now specify the transformer factory class name by setting the <code>transformer-factory-class</code> attribute.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml-using-result-transformers-namespace"><a class="anchor" href="#xml-using-result-transformers-namespace"></a>38.2.3. Namespace Configuration and Result Transformers</h4>
<div class="paragraph">
<p>We cover using result transformers in <a href="#xml-using-result-transformers">Using <code>ResultTransformer</code> Implementations</a>.
The examples in this section use XML namespace configuration to illustrates several special use cases.
First, we define the <code>ResultTransformer</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans:bean id="resultToDoc" class="o.s.i.xml.transformer.ResultToDocumentTransformer"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This <code>ResultTransformer</code> accepts either a <code>StringResult</code> or a <code>DOMResult</code> as input and converts the input into a <code>Document</code>.</p>
</div>
<div class="paragraph">
<p>Now we can declare the transformer, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xslt-transformer input-channel="in" output-channel="fahrenheitChannel"
    xsl-resource="classpath:noop.xslt" result-transformer="resultToDoc"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the incoming message&#8217;s payload is of type <code>Source</code>, then, as a first step, the <code>Result</code> is determined by using the <code>ResultFactory</code>.
As we did not specify a <code>ResultFactory</code>, the default <code>DomResultFactory</code> is used, meaning that the transformation yields a <code>DomResult</code>.</p>
</div>
<div class="paragraph">
<p>However, as we specified a <code>ResultTransformer</code>, it is used and the resulting <code>Message</code> payload is of type <code>Document</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The specified <code>ResultTransformer</code> is ignored with <code>String</code> or <code>Document</code> payloads.
If the incoming message&#8217;s payload is of type <code>String</code>, the payload after the XSLT transformation is a <code>String</code>.
Similarly, if the incoming message&#8217;s payload is of type <code>Document</code>, the payload after the XSLT transformation is a`Document`.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the message payload is not a <code>Source</code>, a <code>String</code>, or a <code>Document</code>, as a fallback option, we try to create a`Source` by using the default  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html"><code>SourceFactory</code></a>.
As we did not specify a <code>SourceFactory</code> explicitly by using the <code>source-factory</code> attribute, the default  <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html"><code>DomSourceFactory</code></a> is used.
If successful, the XSLT transformation is executed as if the payload was of type <code>Source</code>, as described in the previous paragraphs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>DomSourceFactory</code> supports the creation of a <code>DOMSource</code> from a <code>Document</code>, a <code>File</code>, or a <code>String</code> payload.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next transformer declaration adds a <code>result-type</code> attribute that uses <code>StringResult</code> as its value.
The <code>result-type</code> is internally represented by the <code>StringResultFactory</code>.
Thus, you could have also added a reference to a <code>StringResultFactory</code>, by using the <code>result-factory</code> attribute, which would have been the same.
The following example shows that transformer declaration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xslt-transformer input-channel="in" output-channel="fahrenheitChannel"
		xsl-resource="classpath:noop.xslt" result-transformer="resultToDoc"
		result-type="StringResult"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Because we use a <code>ResultFactory</code>, the <code>alwaysUseResultFactory</code> property of the <code>XsltPayloadTransformer</code> class is implicitly set to <code>true</code>.
Consequently, the referenced <code>ResultToDocumentTransformer</code> is used.</p>
</div>
<div class="paragraph">
<p>Therefore, if you transform a payload of type <code>String</code>, the resulting payload is of type <a href="https://docs.oracle.com/javase/6/docs/api/org/w3c/dom/Document.html"><code>Document</code></a>.</p>
</div>
<div class="sect4">
<h5 id="xsltpayloadtransformer-and-xsloutput-methodtext"><a class="anchor" href="#xsltpayloadtransformer-and-xsloutput-methodtext"></a><code>XsltPayloadTransformer</code> and <code>&lt;xsl:output method="text"/&gt;</code></h5>
<div class="paragraph">
<p><code>&lt;xsl:output method="text"/&gt;</code> tells the XSLT template to produce only text content from the input source.
In this particular case, we have no reason to use a <code>DomResult</code>.
Therefore, the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html"><code>XsltPayloadTransformer</code></a> defaults to <code>StringResult</code> if the <a href="https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/Transformer.html#getOutputProperties()">output property</a> called <code>method</code> of the underlying <code>javax.xml.transform.Transformer</code> returns <code>text</code>.
This coercion is performed independently from the inbound payload type.
This behavior is available only you set the if the <code>result-type</code> attribute or the <code>result-factory</code> attribute for the <code>&lt;int-xml:xslt-transformer&gt;</code> component.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-xpath-transformer"><a class="anchor" href="#xml-xpath-transformer"></a>38.3. Transforming XML Messages with XPath</h3>
<div class="paragraph">
<p>When it comes to message transformation, XPath is a great way to transform messages that have XML payloads.
You can do so by defining XPath transformers with the  <code>&lt;xpath-transformer/&gt;</code> element.</p>
</div>
<div class="sect3">
<h4 id="simple-xpath-transformation"><a class="anchor" href="#simple-xpath-transformation"></a>38.3.1. Simple XPath Transformation</h4>
<div class="paragraph">
<p>Consider following transformer configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-transformer input-channel="inputChannel" output-channel="outputChannel"
      xpath-expression="/person/@name" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also consider the following <code>Message</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;?&gt; message =
  MessageBuilder.withPayload("&lt;person name='John Doe' age='42' married='true'/&gt;").build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After sending this message to the 'inputChannel', the XPath transformer configured earlier transforms this XML Message to a simple <code>Message</code> with a payload of 'John Doe', all based on the simple XPath Expression specified in the <code>xpath-expression</code> attribute.</p>
</div>
<div class="paragraph">
<p>XPath also lets you perform simple conversion of an extracted element to a desired type.
Valid return types are defined in <code>javax.xml.xpath.XPathConstants</code> and follow the conversion rules specified by the <code>javax.xml.xpath.XPath</code> interface.</p>
</div>
<div class="paragraph">
<p>The following constants are defined by the <code>XPathConstants</code> class: <code>BOOLEAN</code>, <code>DOM_OBJECT_MODEL</code>, <code>NODE</code>, <code>NODESET</code>, <code>NUMBER</code>, and <code>STRING</code>.</p>
</div>
<div class="paragraph">
<p>You can configure the desired type by using the <code>evaluation-type</code> attribute of the <code>&lt;xpath-transformer/&gt;</code> element, as the following example shows (twice):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-transformer input-channel="numberInput" xpath-expression="/person/@age"
                           evaluation-type="NUMBER_RESULT" output-channel="output"/&gt;

&lt;int-xml:xpath-transformer input-channel="booleanInput"
                           xpath-expression="/person/@married = 'true'"
                           evaluation-type="BOOLEAN_RESULT" output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="node-mappers"><a class="anchor" href="#node-mappers"></a>38.3.2. Node Mappers</h4>
<div class="paragraph">
<p>If you need to provide custom mapping for the node extracted by the XPath expression, you can provide a reference to the implementation of the <code>org.springframework.xml.xpath.NodeMapper</code> (an interface used by <code>XPathOperations</code> implementations for mapping <code>Node</code> objects on a per-node basis).
To provide a reference to a <code>NodeMapper</code>, you can use the <code>node-mapper</code> attribute, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-transformer input-channel="nodeMapperInput" xpath-expression="/person/@age"
                           node-mapper="testNodeMapper" output-channel="output"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows a <code>NodeMapper</code> implementation that works with the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class TestNodeMapper implements NodeMapper {
  public Object mapNode(Node node, int nodeNum) throws DOMException {
    return node.getTextContent() + "-mapped";
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml-payload-converter"><a class="anchor" href="#xml-payload-converter"></a>38.3.3. XML Payload Converter</h4>
<div class="paragraph">
<p>You can also use an implementation of the <code>org.springframework.integration.xml.XmlPayloadConverter</code> to provide more granular transformation.
The following example shows how to define one:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-transformer input-channel="customConverterInput"
                           output-channel="output" xpath-expression="/test/@type"
                           converter="testXmlPayloadConverter" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows an <code>XmlPayloadConverter</code> implementation that works with the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class TestXmlPayloadConverter implements XmlPayloadConverter {
  public Source convertToSource(Object object) {
    throw new UnsupportedOperationException();
  }
  //
  public Node convertToNode(Object object) {
    try {
      return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(
          new InputSource(new StringReader("&lt;test type='custom'/&gt;")));
    }
    catch (Exception e) {
      throw new IllegalStateException(e);
    }
  }
  //
  public Document convertToDocument(Object object) {
    throw new UnsupportedOperationException();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you do not provide this reference, the <code>DefaultXmlPayloadConverter</code> is used.
It should suffice in most cases, because it can convert from <code>Node</code>, <code>Document</code>, <code>Source</code>, <code>File</code>, <code>String</code>, <code>InputStream</code>, and <code>byte[]</code> payloads.
If you need to extend beyond the capabilities of that default implementation, an upstream <code>Transformer</code> is probably a better option than providing a reference to a custom implementation of this strategy here.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-xpath-splitting"><a class="anchor" href="#xml-xpath-splitting"></a>38.4. Splitting XML Messages</h3>
<div class="paragraph">
<p><code>XPathMessageSplitter</code> supports messages with either <code>String</code> or <code>Document</code> payloads.
The splitter uses the provided XPath expression to split the payload into a number of nodes.
By default, this results in each <code>Node</code> instance becoming the payload of a new message.
When each message should be a <code>Document</code>, you can set the <code>createDocuments</code> flag.
Where a <code>String</code> payload is passed in, the payload is converted and then split before being converted back to a number of <code>String</code> messages.
The XPath splitter implements <code>MessageHandler</code> and should therefore be configured in conjunction with an appropriate endpoint (see the namespace support example after the following example for a simpler configuration alternative).
The following example configures a bean that uses an <code>XPathMessageSplitter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="splittingEndpoint"
      class="org.springframework.integration.endpoint.EventDrivenConsumer"&gt;
    &lt;constructor-arg ref="orderChannel" /&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.springframework.integration.xml.splitter.XPathMessageSplitter"&gt;
            &lt;constructor-arg value="/order/items" /&gt;
            &lt;property name="documentBuilder" ref="customisedDocumentBuilder" /&gt;
            &lt;property name="outputChannel" ref="orderItemsChannel" /&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>XPath splitter namespace support lets you create a message endpoint with an input channel and output channel, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- Split the order into items and create a new message for each item node --&gt;
&lt;int-xml:xpath-splitter id="orderItemSplitter"
                       input-channel="orderChannel"
                       output-channel="orderItemsChannel"&gt;
    &lt;int-xml:xpath-expression expression="/order/items"/&gt;
&lt;/int-xml:xpath-splitter&gt;

&lt;!-- Split the order into items, create a new document for each item--&gt;
&lt;int-xml:xpath-splitter id="orderItemDocumentSplitter"
                       input-channel="orderChannel"
                       output-channel="orderItemsChannel"
                       create-documents="true"&gt;
    &lt;int-xml:xpath-expression expression="/order/items"/&gt;
    &lt;int:poller fixed-rate="2000"/&gt;
&lt;/int-xml:xpath-splitter&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>XPathMessageSplitter</code> exposes the <code>outputProperties</code> (such as <code>OutputKeys.OMIT_XML_DECLARATION</code>) property for an <code>javax.xml.transform.Transformer</code> instance when a request <code>payload</code> is not of type <code>org.w3c.dom.Node</code>.
The following example defines a property and uses it with the <code>output-properties</code> property:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;util:properties id="outputProperties"&gt;
	&lt;beans:prop key="#{T (javax.xml.transform.OutputKeys).OMIT_XML_DECLARATION}"&gt;yes&lt;/beans:prop&gt;
&lt;/util:properties&gt;

&lt;xpath-splitter input-channel="input"
             output-properties="outputProperties"&gt;
    &lt;xpath-expression expression="/orders/order"/&gt;
&lt;/xpath-splitter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with <code>version 4.2</code>, the <code>XPathMessageSplitter</code> exposes an <code>iterator</code> option as a <code>boolean</code> flag (defaults to <code>true</code>).
This allows the &#8220;streaming&#8221; of split nodes in the downstream flow.
With the <code>iterator</code> mode set to <code>true</code>, each node is transformed while iterating.
When <code>false</code>, all entries are first transformed, before the split nodes start being sent to the output channel.
(You can think of the difference as &#8220;transform, send, transform, send&#8221; versus &#8220;transform, transform, send, send&#8221;.)
See <a href="#splitter">Splitter</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="xml-xpath-routing"><a class="anchor" href="#xml-xpath-routing"></a>38.5. Routing XML Messages with XPath</h3>
<div class="paragraph">
<p>Similar to SpEL-based routers, Spring Integration provides support for routing messages based on XPath expressions, which lets you create a message endpoint with an input channel but no output channel.
Instead, one or more output channels are determined dynamically.
The following example shows how to create such a router:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-router id="orderTypeRouter" input-channel="orderChannel"&gt;
    &lt;int-xml:xpath-expression expression="/order/type"/&gt;
&lt;/int-xml:xpath-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For an overview of attributes that are common among Routers, see <a href="#router-common-parameters">Common Router Parameters</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, XPath expressions are evaluated as type <code>NODESET</code> and converted to a <code>List&lt;String&gt;</code> that represents channel names.
Typically, such a list contains a single channel name.
However, based on the results of an XPath Expression, the XPath router can also take on the characteristics of a recipient list router if the XPath expression returns more than one value.
In that case, the <code>List&lt;String&gt;</code> contains more than one channel name.
Consequently, messages are sent to all the channels in the list.</p>
</div>
<div class="paragraph">
<p>Thus, assuming that the XML file passed to the following router configuration contains many <code>responder</code> sub-elements that represent channel names, the message is sent to all of those channels:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- route the order to all responders--&gt;
&lt;int-xml:xpath-router id="responderRouter" input-channel="orderChannel"&gt;
    &lt;int-xml:xpath-expression expression="/request/responders"/&gt;
&lt;/int-xml:xpath-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the returned values do not represent the channel names directly, you can specify additional mapping parameters to map those returned values to actual channel names.
For example if the <code>/request/responders</code> expression results in two values (<code>responderA</code> and <code>responderB</code>), but you do not want to couple the responder names to channel names, you can provide additional mapping configuration, such as the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- route the order to all responders--&gt;
&lt;int-xml:xpath-router id="responderRouter" input-channel="orderChannel"&gt;
    &lt;int-xml:xpath-expression expression="/request/responders"/&gt;
    &lt;int-xml:mapping value="responderA" channel="channelA"/&gt;
    &lt;int-xml:mapping value="responderB" channel="channelB"/&gt;
&lt;/int-xml:xpath-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As already mentioned, the default evaluation type for XPath expressions is <code>NODESET</code>, which is converted to a <code>List&lt;String&gt;</code> of channel names, which handles single channel scenarios as well as multiple channel scenarios.</p>
</div>
<div class="paragraph">
<p>Nonetheless, certain XPath expressions may evaluate as type <code>String</code> from the very beginning.
Consider, for example, the following XPath Expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">name(./node())</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This expression returns the name of the root node.
If the default evaluation type <code>NODESET</code> is being used, it results in an exception.</p>
</div>
<div class="paragraph">
<p>For these scenarios, you can use the <code>evaluate-as-string</code> attribute, which lets you manage the evaluation type.
It is <code>FALSE</code> by default.
However, if you set it to <code>TRUE</code>, the <code>String</code> evaluation type is used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>XPath 1.0 specifies 4 data types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Node-sets</p>
</li>
<li>
<p>Strings</p>
</li>
<li>
<p>Number</p>
</li>
<li>
<p>Boolean</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the XPath Router evaluates expressions by using the optional <code>evaluate-as-string</code> attribute, the return value is determined by the <code>string()</code> function, as defined in the XPath specification.
This means that, if the expression selects multiple nodes, it return the string value of the first node.</p>
</div>
<div class="paragraph">
<p>For further information, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.w3.org/TR/xpath/">Specification: XML Path Language (XPath) Version 1.0</a></p>
</li>
<li>
<p><a href="https://www.w3.org/TR/xpath-functions-31">XPath specification - string() function</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, if we want to route based on the name of the root node, we can use the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-router id="xpathRouterAsString"
        input-channel="xpathStringChannel"
        evaluate-as-string="true"&gt;
    &lt;int-xml:xpath-expression expression="name(./node())"/&gt;
&lt;/int-xml:xpath-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xpath-routing-converter"><a class="anchor" href="#xpath-routing-converter"></a>38.5.1. XML Payload Converter</h4>
<div class="paragraph">
<p>For XPath Routers, you can also specify the Converter to use when converting payloads prior to XPath evaluation.
As such, the XPath Router supports custom implementations of the <code>XmlPayloadConverter</code> strategy, and when configuring an <code>xpath-router</code> element in XML, a reference to such an implementation may be provided via the <code>converter</code> attribute.</p>
</div>
<div class="paragraph">
<p>If this reference is not explicitly provided, the <code>DefaultXmlPayloadConverter</code> is used.
It should be sufficient in most cases, since it can convert from Node, Document, Source, File, and String typed payloads.
If you need to extend beyond the capabilities of that default implementation, then an upstream Transformer is generally a better option in most cases, rather than providing a reference to a custom implementation of this strategy here.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-xpath-header-enricher"><a class="anchor" href="#xml-xpath-header-enricher"></a>38.6. XPath Header Enricher</h3>
<div class="paragraph">
<p>The XPath header enricher defines a header enricher message transformer that evaluates an XPath expression against the message payload and inserts the result of the evaluation into a message header.</p>
</div>
<div class="paragraph">
<p>The following listing shows all the available configuration parameters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-header-enricher default-overwrite="true"    <i class="conum" data-value="1"></i><b>(1)</b>
                               id=""                       <i class="conum" data-value="2"></i><b>(2)</b>
                               input-channel=""            <i class="conum" data-value="3"></i><b>(3)</b>
                               output-channel=""           <i class="conum" data-value="4"></i><b>(4)</b>
                               should-skip-nulls="true"&gt;   <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;int:poller&gt;&lt;/int:poller&gt;                              <i class="conum" data-value="6"></i><b>(6)</b>
    &lt;int-xml:header name=""                                <i class="conum" data-value="7"></i><b>(7)</b>
                    evaluation-type="STRING_RESULT"        <i class="conum" data-value="8"></i><b>(8)</b>
                    header-type="int"                      <i class="conum" data-value="9"></i><b>(9)</b>
                    overwrite="true"                       <i class="conum" data-value="10"></i><b>(10)</b>
                    xpath-expression=""                    <i class="conum" data-value="11"></i><b>(11)</b>
                    xpath-expression-ref=""/&gt;              <i class="conum" data-value="12"></i><b>(12)</b>
&lt;/int-xml:xpath-header-enricher&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifies the default boolean value for whether to overwrite existing header values.
This takes effect only for child elements that do not provide their own 'overwrite' attribute.
If you do not set the 'default- overwrite' attribute, the specified header values do not overwrite any existing ones with the same header names.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ID for the underlying bean definition.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receiving message channel of this endpoint.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Channel to which enriched messages are sent.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Specifies whether null values, such as might be returned from an expression evaluation, should be skipped.
The default value is <code>true</code>.
If a null value should trigger removal of the corresponding header, set this to <code>false</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A poller to use with the header enricher.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The name of the header to be enriched.
Mandatory.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The result type expected from the XPath evaluation.
If you did not set a <code>header-type</code> attribute, this is the type of the header value.
The following values are allowed: <code>BOOLEAN_RESULT</code>, <code>STRING_RESULT</code>, <code>NUMBER_RESULT</code>, <code>NODE_RESULT</code>, and <code>NODE_LIST_RESULT</code>.
If not set, it defaults internally to <code>XPathEvaluationType.STRING_RESULT</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The fully qualified class name for the header value type.
The result of the XPath evaluation is converted to this type by <code>ConversionService</code>.
This allows, for example, a <code>NUMBER_RESULT</code> (a double) to be converted to an <code>Integer</code>.
The type can be declared as a primitive (such as <code>int</code>), but the result is always the equivalent wrapper class (such as <code>Integer</code>).
The same integration <code>ConversionService</code> discussed in <a href="#payload-type-conversion">Payload Type Conversion</a> is used for the conversion, so conversion to custom types is supported by adding a custom converter to the service.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Boolean value to indicate whether this header value should overwrite an existing header value for the same name if already present on the input <code>Message</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The XPath expression as a <code>String</code>.
You must set either this attribute or <code>xpath-expression-ref</code>, but not both.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The XPath expression reference.
You must set either this attribute or <code>xpath-expression</code>, but not both.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-xpath-filter"><a class="anchor" href="#xml-xpath-filter"></a>38.7. Using the XPath Filter</h3>
<div class="paragraph">
<p>This component defines an XPath-based message filter.
Internally, this components uses a <code>MessageFilter</code> that wraps an instance of <code>AbstractXPathMessageSelector</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See <a href="#filter">Filter</a> for further details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>to use the XPath filter you must, at a minimum, provide an XPath expression either by declaring the <code>xpath-expression</code> element or by referencing an XPath Expression in the <code>xpath-expression-ref</code> attribute.</p>
</div>
<div class="paragraph">
<p>If the provided XPath expression evaluates to a <code>boolean</code> value, no further configuration parameters are necessary.
However, if the XPath expression evaluates to a <code>String</code>, you should set the <code>match-value</code> attribute, against which the evaluation result is matched.</p>
</div>
<div class="paragraph">
<p><code>match-type</code> has three options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>exact</code>: Correspond to <code>equals</code> on <code>java.lang.String</code>.
The underlying implementation uses a <code>StringValueTestXPathMessageSelector</code></p>
</li>
<li>
<p><code>case-insensitive</code>: Correspond to <code>equals-ignore-case</code> on <code>java.lang.String</code>.
The underlying implementation uses a <code>StringValueTestXPathMessageSelector</code></p>
</li>
<li>
<p><code>regex</code>: Matches operations one <code>java.lang.String</code>.
The underlying implementation uses a <code>RegexTestXPathMessageSelector</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When providing a 'match-type' value of 'regex', the value provided with the <code>match-value</code> attribute must be a valid regular expression.</p>
</div>
<div class="paragraph">
<p>The following example shows all the available attributes for the <code>xpath-filter</code> element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:xpath-filter discard-channel=""                      <i class="conum" data-value="1"></i><b>(1)</b>
                      id=""                                   <i class="conum" data-value="2"></i><b>(2)</b>
                      input-channel=""                        <i class="conum" data-value="3"></i><b>(3)</b>
                      match-type="exact"                      <i class="conum" data-value="4"></i><b>(4)</b>
                      match-value=""                          <i class="conum" data-value="5"></i><b>(5)</b>
                      output-channel=""                       <i class="conum" data-value="6"></i><b>(6)</b>
                      throw-exception-on-rejection="false"    <i class="conum" data-value="7"></i><b>(7)</b>
                      xpath-expression-ref=""&gt;                <i class="conum" data-value="8"></i><b>(8)</b>
    &lt;int-xml:xpath-expression ... /&gt;                          <i class="conum" data-value="9"></i><b>(9)</b>
    &lt;int:poller ... /&gt;                                        <i class="conum" data-value="10"></i><b>(10)</b>
&lt;/int-xml:xpath-filter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Message channel where you want rejected messages to be sent.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ID for the underlying bean definition.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receiving message channel of this endpoint.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Type of match to apply between the XPath evaluation result and the <code>match-value</code>.
The default is <code>exact</code>.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>String value to be matched against the XPath evaluation result.
If you do not set this attribute, the XPath evaluation must produce a boolean result.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The channel to which messages that matched the filter criteria are dispatched.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>By default, this property is set to <code>false</code> and rejected messages (messages that did not match the filter criteria) are silently dropped.
However, if set to <code>true</code>, message rejection results in an error condition and an exception being propagated upstream to the caller.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Reference to an XPath expression instance to evaluate.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This child element sets the XPath expression to be evaluated.
If you do not include this element, you must set the <code>xpath-expression-ref</code> attribute.
Also, you can include only one <code>xpath-expression</code> element.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A poller to use with the XPath filter.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xpath-spel-function"><a class="anchor" href="#xpath-spel-function"></a>38.8. #xpath SpEL Function</h3>
<div class="paragraph">
<p>Spring Integration, since version 3.0, provides the built-in <code>#xpath</code> SpEL function, which invokes the <code>XPathUtils.evaluate(&#8230;&#8203;)</code> static method.
This method delegates to an <code>org.springframework.xml.xpath.XPathExpression</code>.
The following listing shows some usage examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;transformer expression="#xpath(payload, '/name')"/&gt;

&lt;filter expression="#xpath(payload, headers.xpath, 'boolean')"/&gt;

&lt;splitter expression="#xpath(payload, '//book', 'document_list')"/&gt;

&lt;router expression="#xpath(payload, '/person/@age', 'number')"&gt;
    &lt;mapping channel="output1" value="16"/&gt;
    &lt;mapping channel="output2" value="45"/&gt;
&lt;/router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>#xpath()</code> also supports a third optional parameter for converting the result of the XPath evaluation.
It can be one of the String constants (<code>string</code>, <code>boolean</code>, <code>number</code>, <code>node</code>, <code>node_list</code> and <code>document_list</code>) or an <code>org.springframework.xml.xpath.NodeMapper</code> instance.
By default, the <code>#xpath</code> SpEL function returns a <code>String</code> representation of the XPath evaluation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To enable the <code>#xpath</code> SpEL function, you can add the <code>spring-integration-xml.jar</code> to the classpath.
You need no declare any components from the Spring Integration XML Namespace.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information, see "`<a href="#spel">Spring Expression Language (SpEL)</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="xml-validating-filter"><a class="anchor" href="#xml-validating-filter"></a>38.9. XML Validating Filter</h3>
<div class="paragraph">
<p>The XML Validating Filter lets you validate incoming messages against provided schema instances.
The following schema types are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>xml-schema (<a href="https://www.w3.org/2001/XMLSchema" class="bare">www.w3.org/2001/XMLSchema</a>)</p>
</li>
<li>
<p>relax-ng (<a href="https://relaxng.org" class="bare">relaxng.org</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Messages that fail validation can either be silently dropped or be forwarded to a definable <code>discard-channel</code>.
Furthermore, you can configure this filter to throw an <code>Exception</code> in case validation fails.</p>
</div>
<div class="paragraph">
<p>The following listing shows all the available configuration parameters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xml:validating-filter discard-channel=""                    <i class="conum" data-value="1"></i><b>(1)</b>
                           id=""                                 <i class="conum" data-value="2"></i><b>(2)</b>
                           input-channel=""                      <i class="conum" data-value="3"></i><b>(3)</b>
                           output-channel=""                     <i class="conum" data-value="4"></i><b>(4)</b>
                           schema-location=""                    <i class="conum" data-value="5"></i><b>(5)</b>
                           schema-type="xml-schema"              <i class="conum" data-value="6"></i><b>(6)</b>
                           throw-exception-on-rejection="false"  <i class="conum" data-value="7"></i><b>(7)</b>
                           xml-converter=""                      <i class="conum" data-value="8"></i><b>(8)</b>
                           xml-validator=""&gt;                     <i class="conum" data-value="9"></i><b>(9)</b>
    &lt;int:poller .../&gt;                                            <i class="conum" data-value="10"></i><b>(10)</b>
&lt;/int-xml:validating-filter&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Message channel where you want rejected messages to be sent.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ID for the underlying bean definition.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The receiving message channel of this endpoint.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Message channel where you want accepted messages to be sent.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Sets the location of the schema to validate the message&#8217;s payload against.
Internally uses the <code>org.springframework.core.io.Resource</code> interface.
You can set this attribute or the <code>xml-validator</code> attribute but not both.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Sets the schema type.
Can be either <code>xml-schema</code> or <code>relax-ng</code>.
Optional.
If not set, it defaults to <code>xml-schema</code>, which internally translates to <code>org.springframework.xml.validation.XmlValidatorFactory#SCHEMA_W3C_XML</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>If <code>true</code>, a <code>MessageRejectedException</code> is thrown if validation fails for the provided Message&#8217;s payload.
Defaults to <code>false</code> if not set.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Reference to a custom <code>org.springframework.integration.xml.XmlPayloadConverter</code> strategy.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Reference to a custom <code>sorg.springframework.xml.validation.XmlValidator</code> strategy.
You can set this attribute or the <code>schema-location</code> attribute but not both.
Optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>A poller to use with the XPath filter.
Optional.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="xmpp"><a class="anchor" href="#xmpp"></a>39. XMPP Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides channel adapters for <a href="https://www.xmpp.org">XMPP</a>.
XMPP stands for &#8220;Extensible Messaging and Presence Protocol&#8221;.</p>
</div>
<div class="paragraph">
<p>XMPP describes a way for multiple agents to communicate with each other in a distributed system.
The canonical use case is to send and receive chat messages, though XMPP can be (and is) used for other kinds of applications.
XMPP describes a network of actors.
Within that network, actors may address each other directly and broadcast status changes (such as &#8220;presence&#8221;).</p>
</div>
<div class="paragraph">
<p>XMPP provides the messaging fabric that underlies some of the biggest instant messaging networks in the world, including Google Talk (GTalk, which is also available from within GMail) and Facebook Chat.
Many good open-source XMPP servers are available.
Two popular implementations are <a href="https://www.igniterealtime.org/projects/openfire/">Openfire</a> and <a href="https://www.ejabberd.im">ejabberd</a>.</p>
</div>
<div class="paragraph">
<p>Spring integration provides support for XMPP by providing XMPP adapters, which support sending and receiving both XMPP chat messages and presence changes from other entries in a client&#8217;s roster.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-xmpp&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-xmpp:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As with other adapters, the XMPP adapters come with support for a convenient namespace-based configuration.
To configure the XMPP namespace, include the following elements in the headers of your XML configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">xmlns:int-xmpp="http://www.springframework.org/schema/integration/xmpp"
xsi:schemaLocation="http://www.springframework.org/schema/integration/xmpp
	https://www.springframework.org/schema/integration/xmpp/spring-integration-xmpp.xsd"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-connection"><a class="anchor" href="#xmpp-connection"></a>39.1. XMPP Connection</h3>
<div class="paragraph">
<p>Before using inbound or outbound XMPP adapters to participate in the XMPP network, an actor must establish its XMPP connection.
All XMPP adapters connected to a particular account can share this connection object.
Typically this requires (at a minimum) <code>user</code>, <code>password</code>, and <code>host</code>.
To create a basic XMPP connection, you can use the convenience of the namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:xmpp-connection
    id="myConnection"
    user="user"
    password="password"
    host="host"
    port="port"
    resource="theNameOfTheResource"
    subscription-mode="accept_all"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For added convenience, you can rely on the default naming convention and omit the <code>id</code> attribute.
The default name (<code>xmppConnection</code>) is used for this connection bean.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the XMPP connection goes stale, reconnection attempts are made with an automatic login as long as the previous connection state was logged (authenticated).
We also register a <code>ConnectionListener</code>, which logs connection events if the <code>DEBUG</code> logging level is enabled.</p>
</div>
<div class="paragraph">
<p>The <code>subscription-mode</code> attribute initiates the roster listener to deal with incoming subscriptions from other users.
This functionality is not always available for the target XMPP servers.
For example, Google Cloud Messaging (GCM) and Firebase Cloud Messaging (FCM) fully disable it.
To switch off the roster listener for subscriptions, you can configure it with an empty string when using XML configuration (<code>subscription-mode=""</code>) or with <code>XmppConnectionFactoryBean.setSubscriptionMode(null)</code> when using Java Configuration.
Doing so disables the roster at the login phase as well.
See <a href="https://download.igniterealtime.org/smack/docs/latest/javadoc/org/jivesoftware/smack/roster/Roster.html#setRosterLoadedAtLogin-boolean-"><code>Roster.setRosterLoadedAtLogin(boolean)</code></a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-messages"><a class="anchor" href="#xmpp-messages"></a>39.2. XMPP Messages</h3>
<div class="paragraph">
<p>Spring Integration provides support for sending and receiving XMPP messages.
For receiving them, it offers an inbound message channel adapter.
For sending them, it offers an outbound message channel adapter.</p>
</div>
<div class="sect3">
<h4 id="xmpp-message-inbound-channel-adapter"><a class="anchor" href="#xmpp-message-inbound-channel-adapter"></a>39.2.1. Inbound Message Channel Adapter</h4>
<div class="paragraph">
<p>The Spring Integration adapters support receiving chat messages from other users in the system.
To do so, the inbound message channel adapter &#8220;logs in&#8221; as a user on your behalf and receives the messages sent to that user.
Those messages are then forwarded to your Spring Integration client.
The <code>inbound-channel-adapter</code> element provides Configuration support for the XMPP inbound message channel adapter.
The following example shows how to configure it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:inbound-channel-adapter id="xmppInboundAdapter"
	channel="xmppInbound"
	xmpp-connection="testConnection"
	payload-expression="getExtension('google:mobile:data').json"
	stanza-filter="stanzaFilter"
	auto-startup="true"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Along with the usual attributes (for a message channel adapter), this adapter also requires a reference to an XMPP Connection.</p>
</div>
<div class="paragraph">
<p>The XMPP inbound adapter is event-driven and a <code>Lifecycle</code> implementation.
When started, it registers a <code>PacketListener</code> that listens for incoming XMPP chat messages.
It forwards any received messages to the underlying adapter, which converts them to Spring Integration messages and sends them to the specified <code>channel</code>.
When stopped, it unregisters the <code>PacketListener</code>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3, the <code>ChatMessageListeningEndpoint</code> (and its <code>&lt;int-xmpp:inbound-channel-adapter&gt;</code>) supports the injection of a <code>org.jivesoftware.smack.filter.StanzaFilter</code> to be registered on the provided <code>XMPPConnection</code>, together with an internal <code>StanzaListener</code> implementation.
See the <a href="https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/XMPPConnection.html#addAsyncStanzaListener%28org.jivesoftware.smack.StanzaListener,%20org.jivesoftware.smack.filter.StanzaFilter%29">Javadoc</a> for more information.</p>
</div>
<div class="paragraph">
<p>Version 4.3 introduced the <code>payload-expression</code> attribute for the <code>ChatMessageListeningEndpoint</code>.
The incoming <code>org.jivesoftware.smack.packet.Message</code> represents a root object for the evaluation context.
This option is useful when you use <a href="#xmpp-extensions">XMPP extensions</a>.
For example, for the GCM protocol we can extract the body by using the following expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">payload-expression="getExtension('google:mobile:data').json"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example extracts the body for the XHTML protocol:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">payload-expression="getExtension(T(org.jivesoftware.smackx.xhtmlim.packet.XHTMLExtension).NAMESPACE).bodies[0]"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To simplify access to the extension in the XMPP Message, the <code>extension</code> variable is added into the <code>EvaluationContext</code>.
Note that it is added when only one extension is present in the message.
The preceding examples that show the <code>namespace</code> manipulations can be simplified to the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">payload-expression="#extension.json"
payload-expression="#extension.bodies[0]"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xmpp-message-outbound-channel-adapter"><a class="anchor" href="#xmpp-message-outbound-channel-adapter"></a>39.2.2. Outbound Message Channel Adapter</h4>
<div class="paragraph">
<p>You can also send chat messages to other users on XMPP by using the outbound message channel adapter.
The <code>outbound-channel-adapter</code> element provides configuration support for the XMPP outbound message channel adapter.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:outbound-channel-adapter id="outboundEventAdapter"
						channel="outboundEventChannel"
						xmpp-connection="testConnection"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The adapter expects its input to be (at a minimum) a payload of type <code>java.lang.String</code> and a header value for <code>XmppHeaders.CHAT_TO</code> that specifies to which user the message should be sent.
To create a message, you can use Java code similar to the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message&lt;String&gt; xmppOutboundMsg = MessageBuilder.withPayload("Hello, XMPP!" )
						.setHeader(XmppHeaders.CHAT_TO, "userhandle")
						.build();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also set the header by using the XMPP header-enricher support, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:header-enricher input-channel="input" output-channel="output"&gt;
	&lt;int-xmpp:chat-to value="test1@example.org"/&gt;
&lt;/int-xmpp:header-enricher&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.3, the packet extension support has been added to the <code>ChatMessageSendingMessageHandler</code> (the <code>&lt;int-xmpp:outbound-channel-adapter&gt;</code> in XML configuration).
Along with the regular <code>String</code> and <code>org.jivesoftware.smack.packet.Message</code> payload, now you can send a message with a payload of <code>org.jivesoftware.smack.packet.ExtensionElement</code> (which is populated to the <code>org.jivesoftware.smack.packet.Message.addExtension()</code>) instead of <code>setBody()</code>.
For convenience, we added an <code>extension-provider</code> option for the <code>ChatMessageSendingMessageHandler</code>.
It lets you inject <code>org.jivesoftware.smack.provider.ExtensionElementProvider</code>, which builds an <code>ExtensionElement</code> against the payload at runtime.
For this case, the payload must be a string in JSON or XML format, depending of the XEP protocol.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-presence"><a class="anchor" href="#xmpp-presence"></a>39.3. XMPP Presence</h3>
<div class="paragraph">
<p>XMPP also supports broadcasting state.
You can use this ability to let people who have you on their roster see your state changes.
This happens all the time with your IM clients.
You change your away status and set an away message, and everybody who has you on their roster sees your icon or username change to reflect this new state and might see your new &#8220;away&#8221; message.
If you would like to receive notifications or notify others of state changes, you can use Spring Integration&#8217;s &#8220;presence&#8221; adapters.</p>
</div>
<div class="sect3">
<h4 id="xmpp-roster-inbound-channel-adapter"><a class="anchor" href="#xmpp-roster-inbound-channel-adapter"></a>39.3.1. Inbound Presence Message Channel Adapter</h4>
<div class="paragraph">
<p>Spring Integration provides an inbound presence message channel adapter, which supports receiving presence events from other users in the system who are on your roster.
To do this, the adapter &#8220;logs in&#8221; as a user on your behalf, registers a <code>RosterListener</code>, and forwards received presence update events as messages to the channel identified by the <code>channel</code> attribute.
The payload of the message is a <code>org.jivesoftware.smack.packet.Presence</code> object (see <a href="https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html" class="bare">www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html</a>).</p>
</div>
<div class="paragraph">
<p>The <code>presence-inbound-channel-adapter</code> element provides configuration support for the XMPP inbound presence message channel adapter.
The following example configures an inbound presence message channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:presence-inbound-channel-adapter channel="outChannel"
		xmpp-connection="testConnection" auto-startup="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Along with the usual attributes, this adapter requires a reference to an XMPP Connection.
This adapter is event-driven and a <code>Lifecycle</code> implementation.
It registers a <code>RosterListener</code> when started and unregisters that <code>RosterListener</code> when stopped.</p>
</div>
</div>
<div class="sect3">
<h4 id="xmpp-roster-outbound-channel-adapter"><a class="anchor" href="#xmpp-roster-outbound-channel-adapter"></a>39.3.2. Outbound Presence Message Channel Adapter</h4>
<div class="paragraph">
<p>Spring Integration also supports sending presence events to be seen by other users in the network who happen to have you on their roster.
When you send a message to the outbound presence message channel adapter, it extracts the payload (which is expected to be of type <code>org.jivesoftware.smack.packet.Presence</code>) and sends it to the XMPP Connection, thus advertising your presence events to the rest of the network.</p>
</div>
<div class="paragraph">
<p>The <code>presence-outbound-channel-adapter</code> element provides configuration support for the XMPP outbound presence message channel adapter.
The following example shows how to configure an outbound presence message channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:presence-outbound-channel-adapter id="eventOutboundPresenceChannel"
	xmpp-connection="testConnection"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It can also be a polling consumer (if it receives messages from a pollable channel) in which case you would need to register a poller.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-xmpp:presence-outbound-channel-adapter id="pollingOutboundPresenceAdapter"
		xmpp-connection="testConnection"
		channel="pollingChannel"&gt;
	&lt;int:poller fixed-rate="1000" max-messages-per-poll="1"/&gt;
&lt;/int-xmpp:presence-outbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Like its inbound counterpart, it requires a reference to an XMPP Connection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you rely on the default naming convention for an XMPP Connection bean (<a href="#xmpp-connection">described earlier</a>) and you have only one XMPP Connection bean configured in your application context, you can omit the <code>xmpp-connection</code> attribute.
In that case, the bean with named <code>xmppConnection</code> is located and injected into the adapter.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-advanced"><a class="anchor" href="#xmpp-advanced"></a>39.4. Advanced Configuration</h3>
<div class="paragraph">
<p>Spring Integration&#8217;s XMPP support is based on the Smack 4.0 API (<a href="https://www.igniterealtime.org/projects/smack/" class="bare">www.igniterealtime.org/projects/smack/</a>), which allows more complex configuration of the XMPP Connection object.</p>
</div>
<div class="paragraph">
<p>As <a href="#xmpp-connection">stated earlier</a>, the <code>xmpp-connection</code> namespace support is designed to simplify basic connection configuration and supports only a few common configuration attributes.
However, the <code>org.jivesoftware.smack.ConnectionConfiguration</code> object defines about 20 attributes, and adding namespace support for all of them offers no real value.
So, for more complex connection configurations, you can configure an instance of our <code>XmppConnectionFactoryBean</code> as a regular bean and inject a <code>org.jivesoftware.smack.ConnectionConfiguration</code> as a constructor argument to that <code>FactoryBean</code>.
You can specify every property you need directly on that <code>ConnectionConfiguration</code> instance.
(A bean definition with the 'p' namespace would work well.)
This way, you can directly set SSL (or any other attributes).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="xmppConnection" class="o.s.i.xmpp.XmppConnectionFactoryBean"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="org.jivesoftware.smack.ConnectionConfiguration"&gt;
            &lt;constructor-arg value="myServiceName"/&gt;
            &lt;property name="socketFactory" ref="..."/&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;int:channel id="outboundEventChannel"/&gt;

&lt;int-xmpp:outbound-channel-adapter id="outboundEventAdapter"
    channel="outboundEventChannel"
    xmpp-connection="xmppConnection"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The Smack API also offers static initializers, which can be helpful.
For more complex cases (such as registering a SASL mechanism), you may need to execute certain static initializers.
One of those static initializers is <code>SASLAuthentication</code>, which lets you register supported SASL mechanisms.
For that level of complexity, we recommend using Spring Java configuration for the XMPP connection configuration.
That way, you can configure the entire component through Java code and execute all other necessary Java code, including static initializers, at the appropriate time.
The following exampe shows how to configure an XMPP connection with an SASL (Simple Authentication and Security Layer) in Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class CustomConnectionConfiguration {
  @Bean
  public XMPPConnection xmppConnection() {
	SASLAuthentication.supportSASLMechanism("EXTERNAL", 0); // static initializer

	ConnectionConfiguration config = new ConnectionConfiguration("localhost", 5223);
	config.setTrustorePath("path_to_truststore.jks");
	config.setSecurityEnabled(true);
	config.setSocketFactory(SSLSocketFactory.getDefault());
	return new XMPPConnection(config);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For more information on using Java for application context configuration, see the following section in the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-java">Spring Reference Manual</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-message-headers"><a class="anchor" href="#xmpp-message-headers"></a>39.5. XMPP Message Headers</h3>
<div class="paragraph">
<p>The Spring Integration XMPP Adapters automatically map standard XMPP properties.
By default, these properties are copied to and from Spring Integration <code>MessageHeaders</code> by using
<a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/xmpp/support/DefaultXmppHeaderMapper.html"><code>DefaultXmppHeaderMapper</code></a>.</p>
</div>
<div class="paragraph">
<p>Any user-defined headers are not copied to or from an XMPP Message, unless explicitly specified by the <code>requestHeaderNames</code> or <code>replyHeaderNames</code> properties of the <code>DefaultXmppHeaderMapper</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When mapping user-defined headers, the values can also contain simple wildcard patterns (such "thing*" or "*thing").
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Starting with version 4.1, <code>AbstractHeaderMapper</code> (a superclass of <code>DefaultXmppHeaderMapper</code>) lets you configure the <code>NON_STANDARD_HEADERS</code> token for the <code>requestHeaderNames</code> property (in addition to <code>STANDARD_REQUEST_HEADERS</code>), to map all user-defined headers.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.xmpp.XmppHeaders</code> class identifies the default headers to be used by the <code>DefaultXmppHeaderMapper</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>xmpp_from</code></p>
</li>
<li>
<p><code>xmpp_subject</code></p>
</li>
<li>
<p><code>xmpp_thread</code></p>
</li>
<li>
<p><code>xmpp_to</code></p>
</li>
<li>
<p><code>xmpp_type</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Starting with version 4.3, you can negate patterns in the header mappings by preceding the pattern with <code>!</code>.
Negated patterns get priority, so a list such as <code>STANDARD_REQUEST_HEADERS,thing1,thing*,!thing2,!thing3,qux,!thing1</code> does not map <code>thing1</code>, <code>thing2</code>,or <code>thing3</code>.
That list does map the standard headers plus <code>thing4</code> and <code>qux</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have a user-defined header that begins with <code>!</code> that you do wish to map, can escape it with <code>\</code> thus: <code>STANDARD_REQUEST_HEADERS,\!myBangHeader</code>.
In that example, the standard request headers and <code>!myBangHeader</code> are mapped.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="xmpp-extensions"><a class="anchor" href="#xmpp-extensions"></a>39.6. XMPP Extensions</h3>
<div class="paragraph">
<p>Extensions put the &#8220;Extensible&#8221; in the &#8220;Extensible Messaging and Presence Protocol&#8221;.</p>
</div>
<div class="paragraph">
<p>XMPP is based around XML, a data format that supports a concept known as namespacing.
Through namespacing, you can add bits to XMPP that are not defined in the original specifications.
The XMPP specification deliberately describes only a set of core features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How a client connects to a server</p>
</li>
<li>
<p>Encryption (SSL/TLS)</p>
</li>
<li>
<p>Authentication</p>
</li>
<li>
<p>How servers can communicate with each other to relay messages</p>
</li>
<li>
<p>A few other basic building blocks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once you have implemented this, you have an XMPP client and can send any kind of data you like.
However, you may need to do more than the basics.
For example, you might need to include formatting (bold, italic, and so on) in a message, which is not defined in the core XMPP specification.
Well, you can make up a way to do that, but, unless everyone else does it the same way you do, no other software can interpret it (they ignore namespaces they cannot understand).</p>
</div>
<div class="paragraph">
<p>To solve that problem, the XMPP Standards Foundation (XSF) publishes a series of extra documents, known as <a href="https://xmpp.org/extensions/xep-0001.html">XMPP Enhancement Proposals</a> (XEPs).
In general, each XEP describes a particular activity (from message formatting to file transfers, multi-user chats, and many more).
They also provide a standard format for everyone to use for that activity.</p>
</div>
<div class="paragraph">
<p>The Smack API provides many XEP implementations with its <code>extensions</code> and <code>experimental</code> <a href="https://www.igniterealtime.org/builds/smack/docs/latest/documentation/extensions/index.html">projects</a>.
Starting with Spring Integration version 4.3, you can use any XEP with the existing XMPP channel adapters.</p>
</div>
<div class="paragraph">
<p>To be able to process XEPs or any other custom XMPP extensions, you must provide the Smack&#8217;s <code>ProviderManager</code> pre-configuration.
You can do so with <code>static</code> Java code, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ProviderManager.addIQProvider("element", "namespace", new MyIQProvider());
ProviderManager.addExtensionProvider("element", "namespace", new MyExtProvider());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use a  <code>.providers</code> configuration file in the specific instance and access it with a JVM argument, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">-Dsmack.provider.file=file:///c:/my/provider/mycustom.providers</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>mycustom.providers</code> file might be as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0"?&gt;
&lt;smackProviders&gt;
&lt;iqProvider&gt;
    &lt;elementName&gt;query&lt;/elementName&gt;
    &lt;namespace&gt;jabber:iq:time&lt;/namespace&gt;
    &lt;className&gt;org.jivesoftware.smack.packet.Time&lt;/className&gt;
&lt;/iqProvider&gt;

&lt;iqProvider&gt;
    &lt;elementName&gt;query&lt;/elementName&gt;
    &lt;namespace&gt;https://jabber.org/protocol/disco#items&lt;/namespace&gt;
    &lt;className&gt;org.jivesoftware.smackx.provider.DiscoverItemsProvider&lt;/className&gt;
&lt;/iqProvider&gt;

&lt;extensionProvider&gt;
    &lt;elementName&gt;subscription&lt;/elementName&gt;
    &lt;namespace&gt;https://jabber.org/protocol/pubsub&lt;/namespace&gt;
    &lt;className&gt;org.jivesoftware.smackx.pubsub.provider.SubscriptionProvider&lt;/className&gt;
&lt;/extensionProvider&gt;
&lt;/smackProviders&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For example, the most popular XMPP messaging extension is <a href="https://developers.google.com/cloud-messaging/">Google Cloud Messaging</a> (GCM).
The Smack library provides <code>org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider</code> for that purposes.
By default, it registers that class with the <code>smack-experimental</code> jar in the classpath by using the <code>experimental.providers</code> resource, as the following Maven example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- GCM JSON payload --&gt;
&lt;extensionProvider&gt;
    &lt;elementName&gt;gcm&lt;/elementName&gt;
    &lt;namespace&gt;google:mobile:data&lt;/namespace&gt;
    &lt;className&gt;org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider&lt;/className&gt;
&lt;/extensionProvider&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also, the <code>GcmPacketExtension</code> lets the target messaging protocol parse incoming packets and build outgoing packets, as the following examples show:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GcmPacketExtension gcmExtension = (GcmPacketExtension) xmppMessage.getExtension(GcmPacketExtension.NAMESPACE);
String message = gcmExtension.getJson());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GcmPacketExtension packetExtension = new GcmPacketExtension(gcmJson);
Message smackMessage = new Message();
smackMessage.addExtension(packetExtension);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See <a href="#xmpp-message-inbound-channel-adapter">Inbound Message Channel Adapter</a> and <a href="#xmpp-message-outbound-channel-adapter">Outbound Message Channel Adapter</a> earlier in this chapter for more information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zookeeper"><a class="anchor" href="#zookeeper"></a>40. Zookeeper Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Version 4.2 added <a href="https://zookeeper.apache.org/">Zookeeper</a> support to the framework in version 4.2, which consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#zk-metadata-store">A metadata store</a></p>
</li>
<li>
<p><a href="#zk-lock-registry">A lock registry</a></p>
</li>
<li>
<p><a href="#zk-leadership">Leadership event handling</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-zookeeper&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-zookeeper:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zk-metadata-store"><a class="anchor" href="#zk-metadata-store"></a>40.1. Zookeeper Metadata Store</h3>
<div class="paragraph">
<p>You ca use the <code>ZookeeperMetadataStore</code> where any <code>MetadataStore</code> is needed, such as for persistent file list filters.
See <a href="#metadata-store">Metadata Store</a> for more information.
The following example configures a Zookeeper metadata store with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="client" class="org.springframework.integration.zookeeper.config.CuratorFrameworkFactoryBean"&gt;
    &lt;constructor-arg value="${connect.string}" /&gt;
&lt;/bean&gt;

&lt;bean id="meta" class="org.springframework.integration.zookeeper.metadata.ZookeeperMetadataStore"&gt;
    &lt;constructor-arg ref="client" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to configure a Zookeeper metadata store with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public MetadataStore zkStore(CuratorFramework client) {
    return new ZookeeperMetadataStore(client);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zk-lock-registry"><a class="anchor" href="#zk-lock-registry"></a>40.2. Zookeeper Lock Registry</h3>
<div class="paragraph">
<p>The <code>ZookeeperLockRegistry</code> can be used where any <code>LockRegistry</code> is needed, such as when using an aggregator in a clustered environment with a shared <code>MessageStore</code>.</p>
</div>
<div class="paragraph">
<p>A <code>LockRegistry</code> is used to &#8220;look up&#8221; a lock based on a key (the aggregator uses <code>correlationId</code>).
By default, locks in the <code>ZookeeperLockRegistry</code> are maintained in zookeeper under the following path: <code>/SpringIntegration-LockRegistry/</code>.
You can customize the path by providing an implementation of <code>ZookeeperLockRegistry.KeyToPathStrategy</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface KeyToPathStrategy {

    String pathFor(String key);

    boolean bounded();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If the strategy returns <code>true</code> from <code>isBounded</code>, unused locks do not need to be harvested.
For unbounded strategies (such as the default), you need to periodically invoke <code>expireUnusedOlderThan(long age)</code> to remove old unused locks from memory.</p>
</div>
</div>
<div class="sect2">
<h3 id="zk-leadership"><a class="anchor" href="#zk-leadership"></a>40.3. Zookeeper Leadership Event Handling</h3>
<div class="paragraph">
<p>The following example uses XML to configure an application for leader election in Zookeeper:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-zk:leader-listener client="client" path="/siNamespace" role="cluster" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>client</code> is a reference to a <code>CuratorFramework</code> bean.
A <code>CuratorFrameworkFactoryBean</code> is available.
When a leader is elected, an <code>OnGrantedEvent</code> is published for the role <code>cluster</code>.
Any endpoints in that role are started.
When leadership is revoked, an <code>OnRevokedEvent</code> is published for the role <code>cluster</code>.
Any endpoints in that role are stopped.
See <a href="#endpoint-roles">Endpoint Roles</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can use Java configuration to create an instance of the leader initiator, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public LeaderInitiatorFactoryBean leaderInitiator(CuratorFramework client) {
    return new LeaderInitiatorFactoryBean()
                .setClient(client)
                .setPath("/siTest/")
                .setRole("cluster");
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="spring-integration-appendices" class="sect0"><a class="anchor" href="#spring-integration-appendices"></a>Appendices</h1>
<div class="openblock partintro">
<div class="content">
<div id="spring-integration-adapters-advanced" class="paragraph">
<p>The appendices cover advanced topics and additional resources.</p>
</div>
<div class="paragraph">
<p>The last appendix covers the history of Spring Integration.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spel"><a class="anchor" href="#spel"></a>Appendix A: Spring Expression Language (SpEL)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can configure many Spring Integration components by using expressions written in the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/expressions.html">Spring Expression Language</a>.</p>
</div>
<div class="paragraph">
<p>In most cases, the <code>#root</code> object is the <code>Message</code>, which has two properties (<code>headers</code> and <code>payload</code>) that allow such expressions as <code>payload</code>, <code>payload.thing</code>, <code>headers['my.header']</code>, and so on.</p>
</div>
<div class="paragraph">
<p>In some cases, additional variables are provided.
For example, <code>&lt;int-http:inbound-gateway/&gt;</code> provides <code>#requestParams</code> (parameters from the HTTP request) and <code>#pathVariables</code> (values from path placeholders in the URI).</p>
</div>
<div class="paragraph">
<p>For all SpEL expressions, a <code>BeanResolver</code> is available to enable references to any bean in the application context (for example, <code>@myBean.foo(payload)</code>).
In addition, two <code>PropertyAccessors</code> are available.
A <code>MapAccessor</code> enables accessing values in a <code>Map</code> by using a key and a <code>ReflectivePropertyAccessor</code>, which allows access to fields and JavaBean compliant properties (by using getters and setters).
This is how you can access the <code>Message</code> headers and payload properties.</p>
</div>
<div class="sect2">
<h3 id="spel-customization"><a class="anchor" href="#spel-customization"></a>A.1. SpEL Evaluation Context Customization</h3>
<div class="paragraph">
<p>Starting with Spring Integration 3.0, you can add additional <code>PropertyAccessor</code> instances to the SpEL evaluation contexts used by the framework.
The framework provides the (read-only) <code>JsonPropertyAccessor</code>, which you can use to access fields from a <code>JsonNode</code> or JSON in a <code>String</code>.
You can also create your own <code>PropertyAccessor</code> if you have specific needs.</p>
</div>
<div class="paragraph">
<p>In addition, you can add custom functions.
Custom functions are <code>static</code> methods declared on a class.
Functions and property accessors are available in any SpEL expression used throughout the framework.</p>
</div>
<div class="paragraph">
<p>The following configuration shows how to directly configure the <code>IntegrationEvaluationContextFactoryBean</code> with custom property accessors and functions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="integrationEvaluationContext"
			class="org.springframework.integration.config.IntegrationEvaluationContextFactoryBean"&gt;
	&lt;property name="propertyAccessors"&gt;
		&lt;util:map&gt;
			&lt;entry key="things"&gt;
				&lt;bean class="things.MyCustomPropertyAccessor"/&gt;
			&lt;/entry&gt;
		&lt;/util:map&gt;
	&lt;/property&gt;
	&lt;property name="functions"&gt;
		&lt;map&gt;
			&lt;entry key="barcalc" value="#{T(things.MyFunctions).getMethod('calc', T(things.MyThing))}"/&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For convenience, Spring Integration provides namespace support for both property accessors and functions, as described in the following sections.
The framework automatically configures the factory bean on your behalf.</p>
</div>
<div class="paragraph">
<p>This factory bean definition overrides the default <code>integrationEvaluationContext</code> bean definition.
It adds the custom accessor and one custom function to the list (which also includes the standard accessors <a href="#spel">mentioned earlier</a>).</p>
</div>
<div class="paragraph">
<p>Note that custom functions are static methods.
In the preceding example, the custom function is a static method called <code>calc</code> on a class called <code>MyFunctions</code> and takes a single parameter of type <code>MyThing</code>.</p>
</div>
<div class="paragraph">
<p>Suppose you have a <code>Message</code> with a payload that has a type of <code>MyThing</code>.
Further suppose that you need to perform some action to create an object called <code>MyObject</code> from <code>MyThing</code> and then invoke a custom function called <code>calc</code> on that object.</p>
</div>
<div class="paragraph">
<p>The standard property accessors do not know how to get a <code>MyObject</code> from a <code>MyThing</code>, so you could write and configure a custom property accessor to do so.
As a result, your final expression might be <code>"#barcalc(payload.myObject)"</code>.</p>
</div>
<div class="paragraph">
<p>The factory bean has another property (<code>typeLocator</code>), which lets you customize the <code>TypeLocator</code> used during SpEL evaluation.
You might need to do so running in some environments that use a non-standard <code>ClassLoader</code>.
In the following example, SpEL expressions always use the bean factory&#8217;s class loader:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="integrationEvaluationContext"
		class="org.springframework.integration.config.IntegrationEvaluationContextFactoryBean"&gt;
	&lt;property name="typeLocator"&gt;
		&lt;bean class="org.springframework.expression.spel.support.StandardTypeLocator"&gt;
			&lt;constructor-arg value="#{beanFactory.beanClassLoader}"/&gt;
		&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spel-functions"><a class="anchor" href="#spel-functions"></a>A.2. SpEL Functions</h3>
<div class="paragraph">
<p>Spring Integration provides namespace support to let you create SpEL custom functions.
You can specify <code>&lt;spel-function/&gt;</code> components to provide <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/expressions.html#expressions-ref-functions">custom SpEL functions</a> to the <code>EvaluationContext</code> used throughout the framework.
Instead of configuring the factory bean shown earlier, you can add one or more of these components, and the framework automatically adds them to the default <code>integrationEvaluationContext</code> factory bean.</p>
</div>
<div class="paragraph">
<p>For example, suppose you have a useful static method to evaluate XPath.
The following example shows how you can create a custom function to use that method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:spel-function id="xpath"
	class="com.something.test.XPathUtils" method="evaluate(java.lang.String, java.lang.Object)"/&gt;

&lt;int:transformer input-channel="in" output-channel="out"
		 expression="#xpath('//things/@mythings', payload)" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the preceding example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The default <code>IntegrationEvaluationContextFactoryBean</code> bean with an ID of <code>integrationEvaluationContext</code> is registered with the application context.</p>
</li>
<li>
<p>The <code>&lt;spel-function/&gt;</code> is parsed and added to the <code>functions</code> <code>Map</code> of <code>integrationEvaluationContext</code> as a map entry with its <code>id</code> as the key and the static <code>Method</code> as the value.</p>
</li>
<li>
<p>The <code>integrationEvaluationContext</code> factory bean creates a new <code>StandardEvaluationContext</code> instance, and it is configured with the default <code>PropertyAccessor</code> instances, a <code>BeanResolver</code>, and the custom functions.</p>
</li>
<li>
<p>That <code>EvaluationContext</code> instance is injected into the <code>ExpressionEvaluatingTransformer</code> bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To provide a SpEL Function by using Java configuration, you can declare a <code>SpelFunctionFactoryBean</code> bean for each function.
The following example shows how to create a custom function:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SpelFunctionFactoryBean xpath() {
    return new SpelFunctionFactoryBean(XPathUtils.class, "evaluate");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SpEL functions declared in a parent context are also made available in any child contexts.
Each context has its own instance of the <code>integrationEvaluationContext</code> factory bean, because each needs a different <code>BeanResolver</code>, but the function declarations are inherited and can be overridden by declaring a SpEL function with the same name.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="built-in-spel-functions"><a class="anchor" href="#built-in-spel-functions"></a>A.2.1. Built-in SpEL Functions</h4>
<div class="paragraph">
<p>Spring Integration provides the folloiwng  standard functions, which are registered with the application context automatically on start up:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>#jsonPath</code>: Evaluates a 'jsonPath' on a specified object.
This function invokes <code>JsonPathUtils.evaluate(&#8230;&#8203;)</code>, which delegates to the <a href="https://code.google.com/p/json-path">Jayway JsonPath library</a>.
The following listing shows some usage examples:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;transformer expression="#jsonPath(payload, '$.store.book[0].author')"/&gt;

&lt;filter expression="#jsonPath(payload,'$..book[2].isbn') matches '\d-\d{3}-\d{5}-\d'"/&gt;

&lt;splitter expression="#jsonPath(payload, '$.store.book')"/&gt;

&lt;router expression="#jsonPath(payload, headers.jsonPath)"&gt;
	&lt;mapping channel="output1" value="reference"/&gt;
	&lt;mapping channel="output2" value="fiction"/&gt;
&lt;/router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>#jsonPath</code> also supports a third (optional) parameter: an array of <a href="https://github.com/jayway/JsonPath/blob/master/json-path/src/main/java/com/jayway/jsonpath/Filter.java"><code>com.jayway.jsonpath.Filter</code></a>, which can be provided by a reference to a bean or bean method (for example).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using this function requires the Jayway JsonPath library (<code>json-path.jar</code>) to be on the classpath.
Otherwise the <code>#jsonPath</code> SpEL function is not registered.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information regarding JSON see 'JSON Transformers' in <a href="#transformer">Transformer</a>.</p>
</div>
</li>
<li>
<p><code>#xpath</code>: To evaluate an 'xpath' on some provided object.
For more information regarding XML and XPath, see <a href="#xml">XML Support - Dealing with XML Payloads</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spel-property-accessors"><a class="anchor" href="#spel-property-accessors"></a>A.3. Property Accessors</h3>
<div class="paragraph">
<p>Spring Integration provides namespace support to let you create SpEL custom <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/expression/PropertyAccessor.html"><code>PropertyAccessor</code></a> implementations.
You can use the <code>&lt;spel-property-accessors/&gt;</code> component to provide a list of custom <code>PropertyAccessor</code> instances to the <code>EvaluationContext</code> used throughout the framework.
Instead of configuring the factory bean shown earlier, you can add one or more of these components, and the framework automatically adds the accessors to the default <code>integrationEvaluationContext</code> factory bean.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:spel-property-accessors&gt;
	&lt;bean id="jsonPA" class="org.springframework.integration.json.JsonPropertyAccessor"/&gt;
	&lt;ref bean="fooPropertyAccessor"/&gt;
&lt;/int:spel-property-accessors&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, two custom <code>PropertyAccessor</code> instances are injected into the <code>EvaluationContext</code> (in the order in which they are declared).</p>
</div>
<div class="paragraph">
<p>To provide <code>PropertyAccessor</code> instances by using Java Configuration, you should declare a <code>SpelPropertyAccessorRegistrar</code> bean with a name of <code>spelPropertyAccessorRegistrar</code> (dictated by the <code>IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME</code> constant).
The following example shows how to configure two custom <code>PropertyAccessor</code> instances with Java:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SpelPropertyAccessorRegistrar spelPropertyAccessorRegistrar() {
    return new SpelPropertyAccessorRegistrar(new JsonPropertyAccessor())
                    .add(fooPropertyAccessor());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Custom <code>PropertyAccessor</code> instances declared in a parent context are also made available in any child contexts.
They are placed at the end of result list (but before the default <code>org.springframework.context.expression.MapAccessor</code> and <code>o.s.expression.spel.support.ReflectivePropertyAccessor</code>).
If you declare a <code>PropertyAccessor</code> with the same bean ID in a child context, it overrides the parent accessor.
Beans declared within a <code>&lt;spel-property-accessors/&gt;</code> must have an 'id' attribute.
The final order of usage is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The accessors in the current context, in the order in which they are declared</p>
</li>
<li>
<p>Any accessors from parent contexts, in order</p>
</li>
<li>
<p>The <code>MapAccessor</code></p>
</li>
<li>
<p>The <code>ReflectivePropertyAccessor</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="message-publishing"><a class="anchor" href="#message-publishing"></a>Appendix B: Message Publishing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The (Aspect-oriented Programming) AOP message publishing feature lets you construct and send a message as a by-product of a method invocation.
For example, imagine you have a component and, every time the state of this component changes, you want to be notified by a message.
The easiest way to send such notifications is to send a message to a dedicated channel, but how would you connect the method invocation that changes the state of the object to a message sending process, and how should the notification message be structured?
The AOP message publishing feature handles these responsibilities with a configuration-driven approach.</p>
</div>
<div class="sect2">
<h3 id="message-publishing-config"><a class="anchor" href="#message-publishing-config"></a>B.1. Message Publishing Configuration</h3>
<div class="paragraph">
<p>Spring Integration provides two approaches: XML configuration and annotation-driven (Java) configuration.</p>
</div>
<div class="sect3">
<h4 id="publisher-annotation"><a class="anchor" href="#publisher-annotation"></a>B.1.1. Annotation-driven Configuration with the <code>@Publisher</code> Annotation</h4>
<div class="paragraph">
<p>The annotation-driven approach lets you annotate any method with the <code>@Publisher</code> annotation to specify a 'channel' attribute.
Starting with version 5.1, to switch this functionality on, you must use the <code>@EnablePublisher</code> annotation on some <code>@Configuration</code> class.
See <a href="#configuration-enable-integration">Configuration and <code>@EnableIntegration</code></a> for more information.
The message is constructed from the return value of the method invocation and sent to the channel specified by the 'channel' attribute.
To further manage message structure, you can also use a combination of both <code>@Payload</code> and <code>@Header</code> annotations.</p>
</div>
<div class="paragraph">
<p>Internally, this message publishing feature of Spring Integration uses both Spring AOP by defining <code>PublisherAnnotationAdvisor</code> and the Spring Expression Language (SpEL), giving you considerable flexibility and control over the structure of the <code>Message</code> it publishes.</p>
</div>
<div class="paragraph">
<p>The <code>PublisherAnnotationAdvisor</code> defines and binds the following variables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>#return</code>: Binds to a return value, letting you reference it or its attributes (for example, <code>#return.something</code>, where 'something' is an attribute of the object bound to <code>#return</code>)</p>
</li>
<li>
<p><code>#exception</code>: Binds to an exception if one is thrown by the method invocation</p>
</li>
<li>
<p><code>#args</code>: Binds to method arguments so that you can extract individual arguments by name (for example, <code>#args.fname</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Publisher
public String defaultPayload(String fname, String lname) {
  return fname + " " + lname;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the message is constructed with the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The message payload is the return type and value of the method.
This is the default.</p>
</li>
<li>
<p>A newly constructed message is sent to a default publisher channel that is configured with an annotation post processor (covered later in this section).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example is the same as the preceding example, except that it does not use a default publishing channel:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Publisher(channel="testChannel")
public String defaultPayload(String fname, @Header("last") String lname) {
  return fname + " " + lname;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Instead of using a default publishing channel, we specify the publishing channel by setting the 'channel' attribute of the <code>@Publisher</code> annotation.
We also add a <code>@Header</code> annotation, which results in the message header named 'last' having the same value as the 'lname' method parameter.
That header is added to the newly constructed message.</p>
</div>
<div class="paragraph">
<p>The following example is almost identical to the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Publisher(channel="testChannel")
@Payload
public String defaultPayloadButExplicitAnnotation(String fname, @Header String lname) {
  return fname + " " + lname;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The only difference is that we use a <code>@Payload</code> annotation on the method to explicitly specify that the return value of the method should be used as the payload of the message.</p>
</div>
<div class="paragraph">
<p>The following example expands on the previous configuration by using the Spring Expression Language in the <code>@Payload</code> annotation to further instruct the framework about how the message should be constructed:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Publisher(channel="testChannel")
@Payload("#return + #args.lname")
public String setName(String fname, String lname, @Header("x") int num) {
  return fname + " " + lname;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the message is a concatenation of the return value of the method invocation and the 'lname' input argument.
The Message header named 'x' has its value determined by the 'num' input argument.
That header is added to the newly constructed message.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Publisher(channel="testChannel")
public String argumentAsPayload(@Payload String fname, @Header String lname) {
  return fname + " " + lname;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, you see another usage of the <code>@Payload</code> annotation.
Here, we annotate a method argument that becomes the payload of the newly constructed message.</p>
</div>
<div class="paragraph">
<p>As with most other annotation-driven features in Spring, you need to register a post-processor (<code>PublisherAnnotationBeanPostProcessor</code>).
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean class="org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For a more concise configuration, you can instead use namespace support, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:annotation-config&gt;
    &lt;int:enable-publisher default-publisher-channel="defaultChannel"/&gt;
&lt;/int:annotation-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For Java configuration, you must use the <code>@EnablePublisher</code> annotation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
@EnablePublisher("defaultChannel")
public class IntegrationConfiguration {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 5.1.3, the <code>&lt;int:enable-publisher&gt;</code> component, as well as the <code>@EnablePublisher</code> annotation have the <code>proxy-target-class</code> and <code>order</code> attributes for tuning the <code>ProxyFactory</code> configuration.</p>
</div>
<div class="paragraph">
<p>Similar to other Spring annotations (<code>@Component</code>, <code>@Scheduled</code>, and so on), you can also use <code>@Publisher</code> as a meta-annotation.
This means that you can define your own annotations that are treated in the same way as the <code>@Publisher</code> itself.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Publisher(channel="auditChannel")
public @interface Audit {
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, we define the <code>@Audit</code> annotation, which is itself annotated with <code>@Publisher</code>.
Also note that you can define a <code>channel</code> attribute on the meta-annotation to encapsulate where messages are sent inside of this annotation.
Now you can annotate any method with the <code>@Audit</code> annotation, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Audit
public String test() {
 return "Hello";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, every invocation of the <code>test()</code> method results in a message with a payload created from its return value.
Each message is sent tothe channel named <code>auditChannel</code>.
One of the benefits of this technique is that you can avoid the duplication of the same channel name across multiple annotations.
You also can provide a level of indirection between your own, potentially domain-specific, annotations and those provided by the framework.</p>
</div>
<div class="paragraph">
<p>You can also annotate the class, which lets you apply the properties of this annotation on every public method of that class, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Audit
static class BankingOperationsImplimplementsBankingOperations{

public String debit(String amount) {
  . . .

}

publicString credit(String amount) {
  . . .
}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-based-interceptor"><a class="anchor" href="#aop-based-interceptor"></a>B.1.2. XML-based Approach with the <code>&lt;publishing-interceptor&gt;</code> element</h4>
<div class="paragraph">
<p>The XML-based approach lets you configure the same AOP-based message publishing functionality as a namespace-based configuration of a <code>MessagePublishingInterceptor</code>.
It certainly has some benefits over the annotation-driven approach, since it lets you use AOP pointcut expressions, thus possibly intercepting multiple methods at once or intercepting and publishing methods to which you do not have the source code.</p>
</div>
<div class="paragraph">
<p>To configure message publishing with XML, you need only do the following two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide configuration for <code>MessagePublishingInterceptor</code> by using the <code>&lt;publishing-interceptor&gt;</code> XML element.</p>
</li>
<li>
<p>Provide AOP configuration to apply the <code>MessagePublishingInterceptor</code> to managed objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to configure a <code>publishing-interceptor</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;aop:config&gt;
  &lt;aop:advisor advice-ref="interceptor" pointcut="bean(testBean)" /&gt;
&lt;/aop:config&gt;
&lt;publishing-interceptor id="interceptor" default-channel="defaultChannel"&gt;
  &lt;method pattern="echo" payload="'Echoing: ' + #return" channel="echoChannel"&gt;
    &lt;header name="things" value="something"/&gt;
  &lt;/method&gt;
  &lt;method pattern="repl*" payload="'Echoing: ' + #return" channel="echoChannel"&gt;
    &lt;header name="things" expression="'something'.toUpperCase()"/&gt;
  &lt;/method&gt;
  &lt;method pattern="echoDef*" payload="#return"/&gt;
&lt;/publishing-interceptor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;publishing-interceptor&gt;</code> configuration looks rather similar to the annotation-based approach, and it also uses the power of the Spring Expression Language.</p>
</div>
<div class="paragraph">
<p>In the preceding example, the execution of the <code>echo</code> method of a <code>testBean</code> renders a <code>Message</code> with the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>Message</code> payload is of type <code>String</code> with the following content: <code>Echoing: [value]</code>, where <code>value</code> is the value returned by an executed method.</p>
</li>
<li>
<p>The <code>Message</code> has a header with a name of <code>things</code> and a value of <code>something</code>.</p>
</li>
<li>
<p>The <code>Message</code> is sent to <code>echoChannel</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The second method is very similar to the first.
Here, every method that begins with 'repl' renders a <code>Message</code> with the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>Message</code> payload is the same as in the preceding sample.</p>
</li>
<li>
<p>The <code>Message</code> has a header named <code>things</code> whose value is the result of the SpEL expression <code>'something'.toUpperCase()</code>.</p>
</li>
<li>
<p>The <code>Message</code> is sent to <code>echoChannel</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The second method, mapping the execution of any method that begins with <code>echoDef</code>, produces a <code>Message</code> with the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>Message</code> payload is the value returned by an executed method.</p>
</li>
<li>
<p>Since the <code>channel</code> attribute is not provided, the <code>Message</code> is sent to the <code>defaultChannel</code> defined by the <code>publisher</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For simple mapping rules you can rely on the <code>publisher</code> defaults, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;publishing-interceptor id="anotherInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example maps the return value of every method that matches the pointcut expression to a payload and is sent to a <code>default-channel</code>.
If you do not specify the <code>defaultChannel</code> (as the preceding example does not do), the messages are sent to the global <code>nullChannel</code> (the equivalent of <code>/dev/null</code>).</p>
</div>
<div class="sect4">
<h5 id="asynchronous-publishing"><a class="anchor" href="#asynchronous-publishing"></a>Asynchronous Publishing</h5>
<div class="paragraph">
<p>Publishing occurs in the same thread as your component&#8217;s execution.
So, by default, it is synchronous.
This means that the entire message flow has to wait until the publisher&#8217;s flow completes.
However, developers often want the complete opposite: to use this message-publishing feature to initiate asynchronous flows.
For example, you might host a service (HTTP, WS, and so on) which receives a remote request.
You may want to send this request internally into a process that might take a while.
However you may also want to reply to the user right away.
So, instead of sending inbound requests for processing to the output channel (the conventional way), you can use 'output-channel' or a 'replyChannel' header to send a simpleacknowledgment-like reply back to the caller while using the message-publisher feature to initiate a complex flow.</p>
</div>
<div class="paragraph">
<p>The service in the following example receives a complex payload (which needs to be sent further for processing), but it also needs to reply to the caller with a simple acknowledgment:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String echo(Object complexPayload) {
 return "ACK";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>So, instead of hooking up the complex flow to the output channel, we use the message-publishing feature instead.
We configure it to create a new message, by using the input argument of the service method (shown in the preceding example), and send that to the 'localProcessChannel'.
To make sure this flow is asynchronous, all we need to do is send it to any type of asynchronous channel (<code>ExecutorChannel</code> in the next example).
The following example shows how to an asynchronous <code>publishing-interceptor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="inputChannel" output-channel="outputChannel" ref="sampleservice"/&gt;

&lt;bean id="sampleservice" class="test.SampleService"/&gt;

&lt;aop:config&gt;
  &lt;aop:advisor advice-ref="interceptor" pointcut="bean(sampleservice)" /&gt;
&lt;/aop:config&gt;

&lt;int:publishing-interceptor id="interceptor" &gt;
  &lt;int:method pattern="echo" payload="#args[0]" channel="localProcessChannel"&gt;
    &lt;int:header name="sample_header" expression="'some sample value'"/&gt;
  &lt;/int:method&gt;
&lt;/int:publishing-interceptor&gt;

&lt;int:channel id="localProcessChannel"&gt;
  &lt;int:dispatcher task-executor="executor"/&gt;
&lt;/int:channel&gt;

&lt;task:executor id="executor" pool-size="5"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Another way of handling this type of scenario is with a wire-tap.
See <a href="#channel-wiretap">Wire Tap</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduled-producer"><a class="anchor" href="#scheduled-producer"></a>B.1.3. Producing and Publishing Messages Based on a Scheduled Trigger</h4>
<div class="paragraph">
<p>In the preceding sections, we looked at the message-publishing feature, which constructs and publishes messages as by-products of method invocations.
However, in those cases, you are still responsible for invoking the method.
Spring Integration 2.0 added support for scheduled message producers and publishers with the new <code>expression</code> attribute on the 'inbound-channel-adapter' element.
You can schedule based on several triggers, any one of which can be configured on the 'poller' element.
Currently, we support <code>cron</code>, <code>fixed-rate</code>, <code>fixed-delay</code> and any custom trigger implemented by you and referenced by the 'trigger' attribute value.</p>
</div>
<div class="paragraph">
<p>As mentioned earlier, support for scheduled producers and publishers is provided via the <code>&lt;inbound-channel-adapter&gt;</code> XML element.
Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="fixedDelayProducer"
       expression="'fixedDelayTest'"
       channel="fixedDelayChannel"&gt;
    &lt;int:poller fixed-delay="1000"/&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example creates an inbound channel adapter that constructs a <code>Message</code>, with its payload being the result of the expression defined in the <code>expression</code> attribute.
Such messages are created and sent every time the delay specified by the <code>fixed-delay</code> attribute occurs.</p>
</div>
<div class="paragraph">
<p>The following example is similar to the preceding example, except that it uses the <code>fixed-rate</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="fixedRateProducer"
       expression="'fixedRateTest'"
       channel="fixedRateChannel"&gt;
    &lt;int:poller fixed-rate="1000"/&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>fixed-rate</code> attribute lets you send messages at a fixed rate (measuring from the start time of each task).</p>
</div>
<div class="paragraph">
<p>The following example shows how you can apply a Cron trigger with a value specified in the <code>cron</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="cronProducer"
       expression="'cronTest'"
       channel="cronChannel"&gt;
    &lt;int:poller cron="7 6 5 4 3 ?"/&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to insert additional headers into the message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="headerExpressionsProducer"
       expression="'headerExpressionsTest'"
       channel="headerExpressionsChannel"
       auto-startup="false"&gt;
    &lt;int:poller fixed-delay="5000"/&gt;
    &lt;int:header name="foo" expression="6 * 7"/&gt;
    &lt;int:header name="bar" value="x"/&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The additional message headers can take scalar values or the results of evaluating Spring expressions.</p>
</div>
<div class="paragraph">
<p>If you need to implement your own custom trigger, you can use the <code>trigger</code> attribute to provide a reference to any spring configured bean that implementsthe <code>org.springframework.scheduling.Trigger</code> interface.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="triggerRefProducer"
       expression="'triggerRefTest'" channel="triggerRefChannel"&gt;
    &lt;int:poller trigger="customTrigger"/&gt;
&lt;/int:inbound-channel-adapter&gt;

&lt;beans:bean id="customTrigger" class="o.s.scheduling.support.PeriodicTrigger"&gt;
    &lt;beans:constructor-arg value="9999"/&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transactions"><a class="anchor" href="#transactions"></a>Appendix C: Transaction Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers Spring Integration&#8217;s support for transactions.
It covers the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#understanding-transaction">Understanding Transactions in Message flows</a></p>
</li>
<li>
<p><a href="#transaction-boundaries">Transaction Boundaries</a></p>
</li>
<li>
<p><a href="#transaction-synchronization">Transaction Synchronization</a></p>
</li>
<li>
<p><a href="#pseudo-transactions">Pseudo Transactions</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="understanding-transaction"><a class="anchor" href="#understanding-transaction"></a>C.1. Understanding Transactions in Message flows</h3>
<div class="paragraph">
<p>Spring Integration exposes several hooks to address the transactional needs of your message flows.
To better understand these hooks and how you can benefit from them, we must first revisit the six mechanisms that you can use to initiate message flows and see how you can address the transactional needs of these flows within each of these mechanisms.</p>
</div>
<div class="paragraph">
<p>The following six mechanisms initiate a message flow (details for each are provided throughout this manual):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gateway proxy: A basic messaging gateway.</p>
</li>
<li>
<p>Message channel: Direct interactions with <code>MessageChannel</code> methods (for example, <code>channel.send(message)</code>).</p>
</li>
<li>
<p>Message publisher: The way to initiate a message flow as the by-product of method invocations on Spring beans.</p>
</li>
<li>
<p>Inbound channel adapters and gateways: The way to initiate a message flow based on connecting third-party system with the Spring Integration messaging system (for example, <code>[JmsMessage] &#8594; Jms Inbound Adapter[SI Message] &#8594; SI Channel</code>).</p>
</li>
<li>
<p>Scheduler: The way to initiate a message flow based on scheduling events distributed by a pre-configured scheduler.</p>
</li>
<li>
<p>Poller: Similar to the scheduler, this is the way to initiate message flow based on scheduling or interval-based events distributed by a pre-configured poller.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We can split these six mechanisms into two general categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Message flows initiated by a user process: Example scenarios in this category would be invoking a gateway method or explicitly sending a <code>Message</code> to a <code>MessageChannel</code>.
In other words, these message flows depend on a third party process (such as some code that you wrote) to be initiated.</p>
</li>
<li>
<p>Message flows initiated by a daemon process: Example scenarios in this category include a Poller polling a message queue to initiate a new message flow with the polled message or a scheduler scheduling the process by creating a new message and initiating a message flow at a predefined time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Clearly thegateway proxy, <code>MessageChannel.send(&#8230;&#8203;)</code> and <code>MessagePublisher</code> all belong to the first category, and inbound adapters and gateways, scheduler, and poller belong to the second category.</p>
</div>
<div class="paragraph">
<p>So, how can you address transactional needs in various scenarios within each category, and is there a need for Spring Integration to provide something explicit with regard to transactions for a particular scenario?
Or can you use Spring&#8217;s transaction support instead?</p>
</div>
<div class="paragraph">
<p>Spring itself provides first class support for transaction management.
So our goal here is not to provide something new but rather use Spring to benefit from its existing support for transactions.
In other words, as a framework, we must expose hooks to Spring&#8217;s transaction management functionality.
However, since Spring Integration configuration is based on Spring configuration, we need not always expose these hooks, because Spring already exposes them .
After all, every Spring Integration component is a Spring Bean.</p>
</div>
<div class="paragraph">
<p>With this goal in mind, we can again consider the two scenarios: messgae flows initiated by a user process and message flows initiated by a daemon.</p>
</div>
<div class="paragraph">
<p>Message flows that are initiated by a user process and configured in a Spring application context are subject to the usual transactional configuration of such processes.
Therefore they need not be explicitly configured by Spring Integration to support transactions.
The transaction could and should be initiated through Spring&#8217;s standard transaction support.
The Spring Integration message flow naturally honors the transactional semantics of the components, because it is itself configured by Spring.
For example, a gateway or service activator method could be annotated with <code>@Transactional</code>, or a <code>TransactionInterceptor</code> could be defined in an XML configuration with a pointcut expression that pointa to specific methods that should be transactional.
The bottom line is that you have full control over transaction configuration and boundaries in these scenarios.</p>
</div>
<div class="paragraph">
<p>However, things are a bit different when it comes to message flows initiated by a daemon process.
Although configured by the developer, these flows do not directly involve a human or some other process to be initiated.
These are trigger-based flows that are initiated by a trigger process (a daemon process) based on the configuration of the process.
For example, we could have a scheduler initiate a message flow every Friday night.
We can also configure a trigger that initiates a message flow every second and so on.
As a result, we need a way to let these trigger-based processes know of our intention to make the resulting message flows be transactional, so that a Transaction context can be created whenever a new message flow is initiated.
In other words, we need to expose some transaction configuration, but only enough to delegate to the transaction support already provided by Spring (as we do in other scenarios).</p>
</div>
<div class="sect3">
<h4 id="transaction-poller"><a class="anchor" href="#transaction-poller"></a>C.1.1. Poller Transaction Support</h4>
<div class="paragraph">
<p>Spring Integration provides transactional support for pollers.
Pollers are a special type of component because, within a poller task, we can call <code>receive()</code> against a resource that is itself transactional, thus including the <code>receive()</code> call in the the boundaries of the transaction, which lets it be rolled back in case of a task failure.
If we were to add the same support for channels, the added transactions would affect all downstream components starting with the <code>send()</code> call.
That provides a rather wide scope for transaction demarcation without any strong reason, especially when Spring already provides several ways to address the transactional needs of any component downstream.
However the <code>receive()</code> method beingincludedin a transaction boundary is the &#8220;strong reason&#8221; for pollers.</p>
</div>
<div class="paragraph">
<p>Any time you configure a Poller, you can provide transactional configuration by using the <code>transactional</code> child element and its attributes,as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller max-messages-per-poll="1" fixed-rate="1000"&gt;
    &lt;transactional transaction-manager="txManager"
                   isolation="DEFAULT"
                   propagation="REQUIRED"
                   read-only="true"
                   timeout="1000"/&gt;
&lt;/poller&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration looks similar to a native Spring transaction configuration.
You must still provide a reference to a transaction manager and either specify transaction attributes or rely on defaults (for example, if the 'transaction-manager' attribute is not specified, it defaults to the bean named 'transactionManager').
Internally, the process is wrapped in Spring&#8217;s native transaction, where <code>TransactionInterceptor</code> is responsible for handling transactions.
For more information on how to configure a transaction manager, the types of transaction managers (such as JTA, Datasource, and others), and other details related to transaction configuration, see the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction">Spring Framework Reference Guide</a>.</p>
</div>
<div class="paragraph">
<p>With the preceding configuration, all message flows initiated by this poller are transactional.
For more information and details on a poller&#8217;s transactional configuration, see <a href="#jdbc-polling-transactions">Polling and Transactions</a>.</p>
</div>
<div class="paragraph">
<p>Along with transactions, you might need to address several more cross-cutting concerns when you run a poller.
To help with that, the poller element accepts an <code>&lt;advice-chain&gt;</code> child element, which lets you define a custom chain of advice instances to be applied on the Poller.
(See <a href="#pollable-message-source">Pollable Message Source</a> for more details.)
In Spring Integration 2.0, the Poller went through a refactoring effort and now uses a proxy mechanism to address transactional concerns as well as other cross-cutting concerns.
One of the significant changes evolving from this effort is that we made the <code>&lt;transactional&gt;</code> and <code>&lt;advice-chain&gt;</code> elements be mutually exclusive.
The rationale behind this is that, if you need more than one advice and one of them is Transaction advice, you can include it in the <code>&lt;advice-chain&gt;</code> with the same convenience as before but with much more control, since you now have an option to position the advice in the desired order.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:poller max-messages-per-poll="1" fixed-rate="10000"&gt;
  &lt;advice-chain&gt;
    &lt;ref bean="txAdvice"/&gt;
    &lt;ref bean="someAotherAdviceBean" /&gt;
    &lt;beans:bean class="foo.bar.SampleAdvice"/&gt;
  &lt;/advice-chain&gt;
&lt;/poller&gt;

&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  &lt;tx:attributes&gt;
    &lt;tx:method name="get*" read-only="true"/&gt;
    &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example shows a basic XML-based configuration of Spring Transaction advice (<code>txAdvice</code>) and included it within the <code>&lt;advice-chain&gt;</code> defined by the Poller.
If you need to address only the transactional concerns of the poller, you can still use the <code>&lt;transactional&gt;</code> element as a convenience.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-boundaries"><a class="anchor" href="#transaction-boundaries"></a>C.2. Transaction Boundaries</h3>
<div class="paragraph">
<p>Another important factor is the boundaries of Transactions within a Message flow.
When a transaction is started, the transaction context is bound to the current thread.
So regardless of how many endpoints and channels you have in your Message flow your transaction context will be preserved as long as you are ensuring that the flow continues on the same thread.
As soon as you break it by introducing a <em>Pollable Channel</em> or <em>Executor Channel</em> or initiate a new thread manually in some service, the Transactional boundary will be broken as well.
Essentially the Transaction will END right there, and if a successful handoff has transpired between the threads, the flow would be considered a success and a COMMIT signal would be sent even though the flow will continue and might still result in an Exception somewhere downstream.
If such a flow were synchronous, that Exception could be thrown back to the initiator of the Message flow who is also the initiator of the transactional context and the transaction would result in a ROLLBACK.
The middle ground is to use transactional channels at any point where a thread boundary is being broken.
For example, you can use a Queue-backed Channel that delegates to a transactional MessageStore strategy, or you could use a JMS-backed channel.</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-synchronization"><a class="anchor" href="#transaction-synchronization"></a>C.3. Transaction Synchronization</h3>
<div class="paragraph">
<p>In some environments, it help to synchronize operations with a transaction that encompasses the entire flow.
For example, consider a <code>&lt;file:inbound-channel-adapter/&gt;</code> at the start of a flow that performs a number of database updates.
If the transaction commits, we might want to move the file to a <code>success</code> directory, while we might want to move it to a <code>failure</code> directory if the transaction rolls back.</p>
</div>
<div class="paragraph">
<p>Spring Integration 2.2 introduced the capability of synchronizing these operations with a transaction.
In addition, you can configure a <code>PseudoTransactionManager</code> if you do not have a 'real' transaction but still want to perform different actions on success or failure.
For more information, see <a href="#pseudo-transactions">Pseudo Transactions</a>.</p>
</div>
<div class="paragraph">
<p>The following listing shows the key strategy interfaces for this feature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface TransactionSynchronizationFactory {

    TransactionSynchronization create(Object key);
}

public interface TransactionSynchronizationProcessor {

    void processBeforeCommit(IntegrationResourceHolder holder);

    void processAfterCommit(IntegrationResourceHolder holder);

    void processAfterRollback(IntegrationResourceHolder holder);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The factory is responsible for creating a <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronization.html"><code>TransactionSynchronization</code></a> object.
You can implement your own or use the one provided by the framework: <code>DefaultTransactionSynchronizationFactory</code>.
This implementation returns a <code>TransactionSynchronization</code> that delegates to a default implementation of <code>TransactionSynchronizationProcessor</code>: <code>ExpressionEvaluatingTransactionSynchronizationProcessor</code>.
This processor supports three SpEL expressions: <code>beforeCommitExpression</code>, <code>afterCommitExpression</code>, and <code>afterRollbackExpression</code>.</p>
</div>
<div class="paragraph">
<p>These actions should be self-explanatory to those familiar with transactions.
In each case, the <code>#root</code> variable is the original <code>Message</code>.
In some cases, other SpEL variables are made available, depending on the <code>MessageSource</code> being polled by the poller.
For example, the <code>MongoDbMessageSource</code> provides the <code>#mongoTemplate</code> variable, which references the message source&#8217;s <code>MongoTemplate</code>.
Similarly, the <code>RedisStoreMessageSource</code> provides the <code>#store</code> variable, which references the <code>RedisStore</code> created by the poll.</p>
</div>
<div class="paragraph">
<p>To enable the feature for a particular poller, you can provide a reference to the <code>TransactionSynchronizationFactory</code> on the poller&#8217;s <code>&lt;transactional/&gt;</code> element by using the <code>synchronization-factory</code> attribute.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.0, Spring Integration provides <code>PassThroughTransactionSynchronizationFactory</code>, which is applied by default to polling endpoints when no <code>TransactionSynchronizationFactory</code> is configured but an advice of type <code>TransactionInterceptor</code> exists in the advice chain.
When using any out-of-the-box <code>TransactionSynchronizationFactory</code> implementation, polling endpoints bind a polled message to the current transactional context and provide it as a <code>failedMessage</code> in a <code>MessagingException</code> if an exception is thrown after the transaction advice.
When using a custom transaction advice that does not implement <code>TransactionInterceptor</code>, you can explicitly configure a <code>PassThroughTransactionSynchronizationFactory</code> to achieve this behavior.
In either case, the <code>MessagingException</code> becomes the payload of the <code>ErrorMessage</code> that is sent to the <code>errorChannel</code>, and the cause is the raw exception thrown by the advice.
Previously, the <code>ErrorMessage</code> had a payload that was the raw exception thrown by the advice and did not provide a reference to the <code>failedMessage</code> information, making it difficult to determine the reasons for the transaction commit problem.</p>
</div>
<div class="paragraph">
<p>To simplify configuration of these components, Spring Integration provides namespace support for the default factory.
The following example shows how to use the namespace to configure a file inbound channel adapter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-file:inbound-channel-adapter id="inputDirPoller"
    channel="someChannel"
    directory="/foo/bar"
    filter="filter"
    comparator="testComparator"&gt;
    &lt;int:poller fixed-rate="5000"&gt;
        &lt;int:transactional transaction-manager="transactionManager" synchronization-factory="syncFactory" /&gt;
    &lt;/int:poller&gt;
&lt;/int-file:inbound-channel-adapter&gt;

&lt;int:transaction-synchronization-factory id="syncFactory"&gt;
    &lt;int:after-commit expression="payload.renameTo(new java.io.File('/success/' + payload.name))"
        channel="committedChannel" /&gt;
    &lt;int:after-rollback expression="payload.renameTo(new java.io.File('/failed/' + payload.name))"
        channel="rolledBackChannel" /&gt;
&lt;/int:transaction-synchronization-factory&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The result of the SpEL evaluation is sent as the payload to either <code>committedChannel</code> or <code>rolledBackChannel</code> (in this case, this would be <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code>&#8201;&#8212;&#8201;the result of the <code>java.io.File.renameTo()</code> method call).</p>
</div>
<div class="paragraph">
<p>If you wish to send the entire payload for further Spring Integration processing, use the 'payload' expression.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is important to understand that this synchronizes the actions with a transaction.
It does not make a resource that is not inherently transactional actually be transactional.
Instead, the transaction (be it JDBC or otherwise) is started before the poll and either committed or rolled back when the flow completes, followed by the synchronized action.</p>
</div>
<div class="paragraph">
<p>If you provide a custom <code>TransactionSynchronizationFactory</code>, it is responsible for creating a resource synchronization that causes the bound resource to be unbound automatically when the transaction completes.
The default <code>TransactionSynchronizationFactory</code> does so by returning a subclass of <code>ResourceHolderSynchronization</code>, with the default <code>shouldUnbindAtCompletion()</code> returning <code>true</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the <code>after-commit</code> and <code>after-rollback</code> expressions, <code>before-commit</code> is also supported.
In that case, if the evaluation (or downstream processing) throws an exception, the transaction is rolled back instead of being committed.</p>
</div>
</div>
<div class="sect2">
<h3 id="pseudo-transactions"><a class="anchor" href="#pseudo-transactions"></a>C.4. Pseudo Transactions</h3>
<div class="paragraph">
<p>After reading the <a href="#transaction-synchronization">Transaction Synchronization</a> section, you might think it would be useful to take these 'success' or 'failure' actions when a flow completes, even if there is no &#8220;real&#8221; transactional resources (such as JDBC) downstream of the poller.
For example, consider a &#8220;&lt;file:inbound-channel-adapter/&gt;&#8221; followed by an &#8220;&lt;ftp:outbout-channel-adapter/&gt;&#8221;.
Neither of these components is transactional, but we might want to move the input file to different directories, based on the success or failure of the FTP transfer.</p>
</div>
<div class="paragraph">
<p>To provide this functionality, the framework provides a <code>PseudoTransactionManager</code>, enabling the above configuration even when there is no real transactional resource involved.
If the flow completes normally, the <code>beforeCommit</code> and <code>afterCommit</code> synchronizations are called.
On failure, the <code>afterRollback</code> synchronization is called.
Because it is not a real transaction, no actual commit or rollback occurs.
The pseudo transaction is a vehicle used to enable the synchronization features.</p>
</div>
<div class="paragraph">
<p>To use a <code>PseudoTransactionManager</code>, you can define it as a &lt;bean/&gt;, in the same way you would configure a real transaction manager.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="transactionManager" class="o.s.i.transaction.PseudoTransactionManager" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="security"><a class="anchor" href="#security"></a>Appendix D: Security in Spring Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Security is one of the important functions in any modern enterprise (or cloud) application.
Moreover, it is critical for distributed systems, such as those built on Enterprise Integration Patterns.
Messaging independence and loose coupling let target systems communicate with each other with any type of data in the message&#8217;s <code>payload</code>.
We can either trust all those messages or secure our service against &#8220;infecting&#8221; messages.</p>
</div>
<div class="paragraph">
<p>Spring Integration, together with <a href="https://projects.spring.io/spring-security/">Spring Security</a>, provides a simple and comprehensive way to secure message channels, as well as other part of the integration solution.</p>
</div>
<div class="paragraph">
<p>You need to include this dependency into your project:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-security&lt;/artifactId&gt;
    &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.integration:spring-integration-security:5.1.5.RELEASE"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="securing-channels"><a class="anchor" href="#securing-channels"></a>D.1. Securing channels</h3>
<div class="paragraph">
<p>Spring Integration provides the <code>ChannelSecurityInterceptor</code> interceptor, which extends <code>AbstractSecurityInterceptor</code> and intercepts send and receive calls on the channel.
Access decisions are then made with reference to a <code>ChannelSecurityMetadataSource</code>, which provides the metadata that describes the send and receive access policies for certain channels.
The interceptor requires that a valid <code>SecurityContext</code> has been established by authenticating with Spring Security.
See the <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/">Spring Security Reference Guide</a> for details.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides Namespace support to allow easy configuration of security constraints.
This support consists of the secured channels tag, which allows definition of one or more channel name patterns in conjunction with a definition of the security configuration for send and receive.
The pattern is a <code>java.util.regexp.Pattern</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to configure a bean that includes security and how to set up policies with patterns:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:int="http://www.springframework.org/schema/integration"
   xmlns:int-security="http://www.springframework.org/schema/integration/security"
  xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:security="http://www.springframework.org/schema/security"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      https://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/security
      https://www.springframework.org/schema/security/spring-security.xsd
      http://www.springframework.org/schema/integration
      https://www.springframework.org/schema/integration/spring-integration.xsd
      http://www.springframework.org/schema/integration/security
      https://www.springframework.org/schema/integration/security/spring-integration-security.xsd"&gt;

&lt;int-security:secured-channels&gt;
    &lt;int-security:access-policy pattern="admin.*" send-access="ROLE_ADMIN"/&gt;
    &lt;int-security:access-policy pattern="user.*" receive-access="ROLE_USER"/&gt;
&lt;/int-security:secured-channels&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, the <code>secured-channels</code> namespace element expects a bean named <code>authenticationManager</code> (which implements <code>AuthenticationManager</code>) and a bean named <code>accessDecisionManager</code> (which implements <code>AccessDecisionManager</code>).
Where this is not the case, references to the appropriate beans can be configured as attributes of the <code>secured-channels</code> element, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int-security:secured-channels access-decision-manager="customAccessDecisionManager"
                              authentication-manager="customAuthenticationManager"&gt;
    &lt;int-security:access-policy pattern="admin.*" send-access="ROLE_ADMIN"/&gt;
    &lt;int-security:access-policy pattern="user.*" receive-access="ROLE_USER"/&gt;
&lt;/int-security:secured-channels&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.2, the <code>@SecuredChannel</code> annotation is available for Java configuration in <code>@Configuration</code> classes.</p>
</div>
<div class="paragraph">
<p>The following example shows the Java equivalent of the preceding XML examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class ContextConfiguration {

    @Bean
    @SecuredChannel(interceptor = "channelSecurityInterceptor", sendAccess = "ROLE_ADMIN")
    public SubscribableChannel adminChannel() {
    	return new DirectChannel();
    }

    @Bean
    @SecuredChannel(interceptor = "channelSecurityInterceptor", receiveAccess = "ROLE_USER")
    public SubscribableChannel userChannel() {
    	return new DirectChannel();
    }

    @Bean
    public ChannelSecurityInterceptor channelSecurityInterceptor(
            AuthenticationManager authenticationManager,
    		AccessDecisionManager accessDecisionManager) {
    	ChannelSecurityInterceptor channelSecurityInterceptor = new ChannelSecurityInterceptor();
    	channelSecurityInterceptor.setAuthenticationManager(authenticationManager);
    	channelSecurityInterceptor.setAccessDecisionManager(accessDecisionManager);
    	return channelSecurityInterceptor;
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-context-propagation"><a class="anchor" href="#security-context-propagation"></a>D.2. Security Context Propagation</h3>
<div class="paragraph">
<p>To be sure that our interaction with the application is secure, according to its security system rules, we should supply some security context with an authentication (principal) object.
The Spring Security project provides a flexible, canonical mechanism to authenticate our application clients over HTTP, WebSocket, or SOAP protocols (as can be done for any other integration protocol with a simple Spring Security extension).
It also provides a <code>SecurityContext</code> for further authorization checks on the application objects, such as message channels.
By default, the <code>SecurityContext</code> is tied to the execution state of the current <code>Thread</code> by using the (<code>ThreadLocalSecurityContextHolderStrategy</code>).
It is accessed by an AOP (Aspect-oriented Programming) interceptor on secured methods to check (for example) whether that <code>principal</code> of the invocation has sufficient permissions to call that method.
This works well with the current thread.
Often, though, processing logic can be performed on another thread, on several threads, or even on external systems.</p>
</div>
<div class="paragraph">
<p>Standard thread-bound behavior is easy to configure if our application is built on the Spring Integration components
and its message channels.
In this case, the secured objects can be any service activator or transformer, secured with a
<code>MethodSecurityInterceptor</code> in their <code>&lt;request-handler-advice-chain&gt;</code> (see <a href="#message-handler-advice-chain">Adding Behavior to Endpoints</a>) or even <code>MessageChannel</code> (see <a href="#securing-channels">Securing channels</a>, earlier).
When using <code>DirectChannel</code> communication, the <code>SecurityContext</code> is automatically available, because the downstream flow runs on the current thread.
However, in the cases of the <code>QueueChannel</code>, <code>ExecutorChannel</code>, and <code>PublishSubscribeChannel</code> with an <code>Executor</code>, messages are transferred from one thread to another (or several) by the nature of those channels.
In order to support such scenarios, we have two choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transfer an <code>Authentication</code> object within the message headers and extract and authenticate it on the other side before secured object access.</p>
</li>
<li>
<p>Propagate the <code>SecurityContext</code> to the thread that receives the transferred message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Version 4.2 introduced <code>SecurityContext</code> propagation.
It is implemented as a <code>SecurityContextPropagationChannelInterceptor</code>, which you can add to any <code>MessageChannel</code> or configure as a <code>@GlobalChannelInterceptor</code>.
The logic of this interceptor is based on the <code>SecurityContext</code> extraction from the current thread (from the <code>preSend()</code> method) and its populating to another thread from the <code>postReceive()</code> (<code>beforeHandle()</code>) method.
Actually, this interceptor is an extension of the more generic <code>ThreadStatePropagationChannelInterceptor</code>, which wraps the message to send with the state to propagate in an internal <code>Message&lt;?&gt;</code> extension (<code>MessageWithThreadState&lt;S&gt;</code>) on one side and extracts the original message and the state to propagate on the other side.
You can extend the <code>ThreadStatePropagationChannelInterceptor</code> for any context propagation use case, and <code>SecurityContextPropagationChannelInterceptor</code> is a good example of doing so.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The logic of the <code>ThreadStatePropagationChannelInterceptor</code> is based on message modification (it returns an internal <code>MessageWithThreadState</code> object to send).
Consequently, you should be careful when combining this interceptor with any other that can also modify messages (for example, through the <code>MessageBuilder.withPayload(&#8230;&#8203;)&#8230;&#8203;build()</code>).
The state to propagate may be lost.
In most cases, to overcome the issue, you can order the interceptors for the channel and ensure the <code>ThreadStatePropagationChannelInterceptor</code> is the last one in the stack.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Propagation and population of <code>SecurityContext</code> is just one half of the work.
Since the message is not an owner of the threads in the message flow and we should be sure that we are secure against any incoming messages, we have to clean up the <code>SecurityContext</code> from <code>ThreadLocal</code>.
The <code>SecurityContextPropagationChannelInterceptor</code> provides the <code>afterMessageHandled()</code> interceptor method implementation.
It cleans up operation by freeing the thread at the end of invocation from that propagated principal.
This means that, when the thread that processes the handed-off message finishes processing the message (successful or otherwise), the context is cleared so that it cannot inadvertently be used when processing another message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When working with an <a href="#async-gateway">asynchronous gateway</a>, you should use an appropriate <code>AbstractDelegatingSecurityContextSupport</code> implementation from Spring Security <a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/concurrency.html">Concurrency Support</a>, to let security context propagation be ensured over gateway invocation.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
@IntegrationComponentScan
public class ContextConfiguration {

    @Bean
    public AsyncTaskExecutor securityContextExecutor() {
        return new DelegatingSecurityContextAsyncTaskExecutor(
                         new SimpleAsyncTaskExecutor());
    }

}

...

@MessagingGateway(asyncExecutor = "securityContextExecutor")
public interface SecuredGateway {

    @Gateway(requestChannel = "queueChannel")
    Future&lt;String&gt; send(String payload);

}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Appendix E: Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration offers a number of configuration options.
Which option you choose depends upon your particular needs and at what level you prefer to work.
As with the Spring framework in general, you can mix and match the various techniques to suit the problem at hand.
For example, you can choose the XSD-based namespace for the majority of configuration and combine it with a handful of objects that you configure with annotations.
As much as possible, the two provide consistent naming.
The XML elements defined by the XSD schema match the names of the annotations, and the attributes of those XML elements match the names of annotation properties.
You can also use the API directly, but we expect most developers to choose one of the higher-level options or a combination of the namespace-based and annotation-driven configuration.</p>
</div>
<div class="sect2">
<h3 id="configuration-namespace"><a class="anchor" href="#configuration-namespace"></a>E.1. Namespace Support</h3>
<div class="paragraph">
<p>You can configure Spring Integration components with XML elements that map directly to the terminology and concepts of enterprise integration.
In many cases, the element names match those of the <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a> book.</p>
</div>
<div class="paragraph">
<p>To enable Spring Integration&#8217;s core namespace support within your Spring configuration files, add the following namespace reference and schema mapping in your top-level 'beans' element:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <strong>xmlns:int="http://www.springframework.org/schema/integration"</strong>
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           <strong>http://www.springframework.org/schema/integration</strong>
           <strong>https://www.springframework.org/schema/integration/spring-integration.xsd</strong>"&gt;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(We have emphasized the lines that are particular to Spring Integration.)</p>
</div>
<div class="paragraph">
<p>You can choose any name after "xmlns:".
We use <code>int</code> (short for Integration) for clarity, but you might prefer another abbreviation.
On the other hand, if you use an XML editor or IDE support, the availability of auto-completion may convince you to keep the longer name for clarity.
Alternatively, you can create configuration files that use the Spring Integration schema as the primary namespace, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre><strong>&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"</strong>
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:beans="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd
           <strong>http://www.springframework.org/schema/integration</strong>
           <strong>https://www.springframework.org/schema/integration/spring-integration.xsd</strong>"&gt;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(We have emphasized the lines that are particular to Spring Integration.)</p>
</div>
<div class="paragraph">
<p>When using this alternative, no prefix is necessary for the Spring Integration elements.
On the other hand, if you define a generic Spring bean within the same configuration file, the bean element requires a prefix (<code>&lt;beans:bean &#8230;&#8203;/&gt;</code>).
Since it is generally a good idea to modularize the configuration files themselves (based on responsibility or architectural layer), you may find it appropriate to use the latter approach in the integration-focused configuration files, since generic beans are seldom necessary within those files.
For the purposes of this documentation, we assume the integration namespace is the primary.</p>
</div>
<div class="paragraph">
<p>Spring Integration provides many other namespaces.
In fact, each adapter type (JMS, file, and so on) that provides namespace support defines its elements within a separate schema.
In order to use these elements, add the necessary namespaces with an <code>xmlns</code> entry and the corresponding <code>schemaLocation</code> mapping.
For example, the following root element shows several of these namespace declarations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:int="http://www.springframework.org/schema/integration"
  xmlns:int-file="http://www.springframework.org/schema/integration/file"
  xmlns:int-jms="http://www.springframework.org/schema/integration/jms"
  xmlns:int-mail="http://www.springframework.org/schema/integration/mail"
  xmlns:int-rmi="http://www.springframework.org/schema/integration/rmi"
  xmlns:int-ws="http://www.springframework.org/schema/integration/ws"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    https://www.springframework.org/schema/integration/spring-integration.xsd
    http://www.springframework.org/schema/integration/file
    https://www.springframework.org/schema/integration/file/spring-integration-file.xsd
    http://www.springframework.org/schema/integration/jms
    https://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd
    http://www.springframework.org/schema/integration/mail
    https://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd
    http://www.springframework.org/schema/integration/rmi
    https://www.springframework.org/schema/integration/rmi/spring-integration-rmi.xsd
    http://www.springframework.org/schema/integration/ws
    https://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd"&gt;
 ...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This reference manual provides specific examples of the various elements in their corresponding chapters.
Here, the main thing to recognize is the consistency of the naming for each namespace URI and schema location.</p>
</div>
</div>
<div class="sect2">
<h3 id="namespace-taskscheduler"><a class="anchor" href="#namespace-taskscheduler"></a>E.2. Configuring the Task Scheduler</h3>
<div class="paragraph">
<p>In Spring Integration, the <code>ApplicationContext</code> plays the central role of a message bus, and you need to consider only a couple of configuration options.
First, you may want to control the central <code>TaskScheduler</code> instance.
You can do so by providing a single bean named <code>taskScheduler</code>.
This is also defined as a constant, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, Spring Integration relies on an instance of <code>ThreadPoolTaskScheduler</code>, as described in the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html">Task Execution and Scheduling</a> section of the Spring Framework reference manual.
That default <code>TaskScheduler</code> starts up automatically with a pool of ten threads, but see <a href="#global-properties">Global Properties</a>.
If you provide your own <code>TaskScheduler</code> instance instead, you can set the 'autoStartup' property to <code>false</code> or provide your own pool size value.</p>
</div>
<div class="paragraph">
<p>When polling consumers provide an explicit task executor reference in their configuration, the invocation of the handler methods happens within that executor&#8217;s thread pool and not the main scheduler pool.
However, when no task executor is provided for an endpoint&#8217;s poller, it is invoked by one of the main scheduler&#8217;s threads.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Do not run long-running tasks on poller threads.
Use a task executor instead.
If you have a lot of polling endpoints, you can cause thread starvation, unless you increase the pool size.
Also, polling consumers have a default <code>receiveTimeout</code> of one second.
Since the poller thread blocks for this time, we recommend that you use a task executor when many such endpoints exist, again to avoid starvation.
Alternatively, you can reduce the <code>receiveTimeout</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An endpoint is a Polling Consumer if its input channel is one of the queue-based (that is, pollable) channels.
Event-driven consumers are those having input channels that have dispatchers instead of queues (in other words, they are subscribable).
Such endpoints have no poller configuration, since their handlers are invoked directly.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When running in a JEE container, you may need to use Spring&#8217;s <code>TimerManagerTaskScheduler</code>, as described <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/scheduling.html#scheduling-task-scheduler-implementations">here</a>, instead of the default <code>taskScheduler</code>.
To do so, define a bean with the appropriate JNDI name for your environment, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="taskScheduler" class="o.s.scheduling.commonj.TimerManagerTaskScheduler"&gt;
    &lt;property name="timerManagerName" value="tm/MyTimerManager" /&gt;
    &lt;property name="resourceRef" value="true" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next section describes what happens if exceptions occur within the asynchronous invocations.</p>
</div>
</div>
<div class="sect2">
<h3 id="namespace-errorhandler"><a class="anchor" href="#namespace-errorhandler"></a>E.3. Error Handling</h3>
<div class="paragraph">
<p>As described in the <a href="#overview">overview</a> at the very beginning of this manual, one of the main motivations behind a message-oriented framework such as Spring Integration is to promote loose coupling between components.
The message channel plays an important role, in that producers and consumers do not have to know about each other.
However, the advantages also have some drawbacks.
Some things become more complicated in a loosely coupled environment, and one example is error handling.</p>
</div>
<div class="paragraph">
<p>When sending a message to a channel, the component that ultimately handles that message may or may not be operating within the same thread as the sender.
If using a simple default <code>DirectChannel</code> (when the <code>&lt;channel&gt;</code> element that has no <code>&lt;queue&gt;</code> child element and no 'task-executor' attribute),
the message handling occurs in the same thread that sends the initial message.
In that case, if an <code>Exception</code> is thrown, it can be caught by the sender (or it may propagate past the sender if it is an uncaught <code>RuntimeException</code>).
So far, everything is fine.
This is the same behavior as an exception-throwing operation in a normal call stack.</p>
</div>
<div class="paragraph">
<p>A message flow that runs on a caller thread might be invoked through a messaging gateway (see <a href="#gateway">Messaging Gateways</a>) or a <code>MessagingTemplate</code> (see <a href="#channel-template"><code>MessagingTemplate</code></a>).
In either case, the default behavior is to throw any exceptions to the caller.
For the messaging gateway, see <a href="#gateway-error-handling">Error Handling</a> for details about how the exception is thrown and how to configure the gateway to route the errors to an error channel instead.
When using a <code>MessagingTemplate</code> or sending to a <code>MessageChannel</code> directly, exceptions are always thrown to the caller.</p>
</div>
<div class="paragraph">
<p>When adding asynchronous processing, things become rather more complicated.
For instance, if the 'channel' element does provide a 'queue' child element, the component that handles the message operates in a different thread than the sender.
The same is true when an <code>ExecutorChannel</code> is used.
The sender may have dropped the <code>Message</code> into the channel and moved on to other things.
There is no way for the <code>Exception</code> to be thrown directly back to that sender by using standard <code>Exception</code> throwing techniques.
Instead, handling errors for asynchronous processes requires that the error-handling mechanism also be asynchronous.</p>
</div>
<div class="paragraph">
<p>Spring Integration supports error handling for its components by publishing errors to a message channel.
Specifically, the <code>Exception</code> becomes the payload of a Spring Integration <code>ErrorMessage</code>.
That <code>Message</code> is then sent to a message channel that is resolved in a way that is similar to the 'replyChannel' resolution.
First, if the request <code>Message</code> being handled at the time the <code>Exception</code> occurred contains an 'errorChannel' header (the header name is defined in the <code>MessageHeaders.ERROR_CHANNEL</code> constant), the <code>ErrorMessage</code> is sent to that channel.
Otherwise, the error handler sends to a &#8220;global&#8221; channel whose bean name is <code>errorChannel</code> (this is also defined as a constant: <code>IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME</code>).</p>
</div>
<div class="paragraph">
<p>A default <code>errorChannel</code> bean is created internally by the Framework.
However, you can define your own if you want to control the settings.
The following example shows how to define an error channel backed by a queue with a capacity of 500:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:channel id="errorChannel"&gt;
    &lt;int:queue capacity="500"/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default error channel is a <code>PublishSubscribeChannel</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The most important thing to understand here is that the messaging-based error handling applies only to exceptions that are thrown by a Spring Integration task that is executing within a <code>TaskExecutor</code>.
This does not apply to exceptions thrown by a handler that operates within the same thread as the sender (for example, through a <code>DirectChannel</code> as described earlier in this section).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When exceptions occur in a scheduled poller task&#8217;s execution, those exceptions are wrapped in <code>ErrorMessage</code> instances and sent to the 'errorChannel' as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable global error handling, register a handler on that channel.
For example, you can configure Spring Integration&#8217;s <code>ErrorMessageExceptionTypeRouter</code> as the handler of an endpoint that is subscribed to the 'errorChannel'.
That router can then spread the error messages across multiple channels, based on the <code>Exception</code> type.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.3.10, Spring Integration provides the <code>ErrorMessagePublisher</code> and the <code>ErrorMessageStrategy</code>.
You can use them as a general mechanism for publishing <code>ErrorMessage</code> instances.
You can call or extend them in any error handling scenarios.
The <code>ErrorMessageSendingRecoverer</code> extends this class as a <code>RecoveryCallback</code> implementation that can be used with retry, such as the
<a href="#retry-advice"><code>RequestHandlerRetryAdvice</code></a>.
The <code>ErrorMessageStrategy</code> is used to build an <code>ErrorMessage</code> based on the provided exception and an <code>AttributeAccessor</code> context.
It can be injected into any <code>MessageProducerSupport</code> or <code>MessagingGatewaySupport</code>.
The <code>requestMessage</code> is stored under <code>ErrorMessageUtils.INPUT_MESSAGE_CONTEXT_KEY</code> in the <code>AttributeAccessor</code> context.
The <code>ErrorMessageStrategy</code> can use that <code>requestMessage</code> as the <code>originalMessage</code> property of the <code>ErrorMessage</code> it creates.
The <code>DefaultErrorMessageStrategy</code> does exactly that.</p>
</div>
</div>
<div class="sect2">
<h3 id="global-properties"><a class="anchor" href="#global-properties"></a>E.4. Global Properties</h3>
<div class="paragraph">
<p>Certain global framework properties can be overridden by providing a properties file on the classpath.</p>
</div>
<div class="paragraph">
<p>The default properties can be found in <code>/META-INF/spring.integration.default.properties</code> in the <code>spring-integration-core</code> jar.
You can see them on GitHub <a href="https://github.com/spring-projects/spring-integration/blob/master/spring-integration-core/src/main/resources/META-INF/spring.integration.default.properties">here</a>.
The following listing shows the default values:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.integration.channels.autoCreate=true <i class="conum" data-value="1"></i><b>(1)</b>
spring.integration.channels.maxUnicastSubscribers=0x7fffffff <i class="conum" data-value="2"></i><b>(2)</b>
spring.integration.channels.maxBroadcastSubscribers=0x7fffffff <i class="conum" data-value="3"></i><b>(3)</b>
spring.integration.taskScheduler.poolSize=10 <i class="conum" data-value="4"></i><b>(4)</b>
spring.integration.messagingTemplate.throwExceptionOnLateReply=false <i class="conum" data-value="5"></i><b>(5)</b>
spring.integration.readOnly.headers= <i class="conum" data-value="6"></i><b>(6)</b>
spring.integration.endpoints.noAutoStartup= <i class="conum" data-value="7"></i><b>(7)</b>
spring.integration.postProcessDynamicBeans=false <i class="conum" data-value="8"></i><b>(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When true, <code>input-channel</code> instances are automatically declared as <code>DirectChannel</code> instances when not explicitly found in the application context.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sets the default number of subscribers allowed on, for example, a <code>DirectChannel</code>.
It can be used to avoid inadvertently subscribing multiple endpoints to the same channel.
You can override it on individual channels by setting the <code>max-subscribers</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This property provides the default number of subscribers allowed on, for example, a <code>PublishSubscribeChannel</code>.
It can be used to avoid inadvertently subscribing more than the expected number of endpoints to the same channel.
You can override it on individual channels by setting the <code>max-subscribers</code> attribute.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The number of threads available in the default <code>taskScheduler</code> bean.
See <a href="#namespace-taskscheduler">Configuring the Task Scheduler</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When <code>true</code>, messages that arrive at a gateway reply channel throw an exception when the gateway is not expecting a reply (because the sending thread has timed out or already received a reply).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>A comma-separated list of message header names that should not be populated into <code>Message</code> instances during a header copying operation.
The list is used by the <code>DefaultMessageBuilderFactory</code> bean and propagated to the <code>IntegrationMessageHeaderAccessor</code> instances (see <a href="#message-header-accessor"><code>MessageHeaderAccessor</code> API</a>) used to build messages via <code>MessageBuilder</code> (see <a href="#message-builder">The <code>MessageBuilder</code> Helper Class</a>).
By default, only <code>MessageHeaders.ID</code> and <code>MessageHeaders.TIMESTAMP</code> are not copied during message building.
Since version 4.3.2.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>A comma-separated list of <code>AbstractEndpoint</code> bean names patterns (<code>xxx*</code>, <code><strong>xxx</code>, <code>*xxx</strong></code> or <code>xxx*yyy</code>) that should not be started automatically during application startup.
You can manually start these endpoints later by their bean name through a <code>Control Bus</code> (see <a href="#control-bus">Control Bus</a>), by their role with the <code>SmartLifecycleRoleController</code> (see <a href="#endpoint-roles">Endpoint Roles</a>), or by <code>Lifecycle</code> bean injection.
You can explicitly override the effect of this global property by specifying <code>auto-startup</code> XML annotation or the <code>autoStartup</code> annotation attribute or by calling <code>AbstractEndpoint.setAutoStartup()</code> in the bean definition.
Since version 4.3.12.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>A boolean flag to indicate that <code>BeanPostProcessor</code> instances should post-process beans registered at runtime (for example, message channels created by <code>IntegrationFlowContext</code> can be supplied with global channel interceptors).
Since version 4.3.15.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>These properties can be overridden by adding a <code>/META-INF/spring.integration.properties</code> file to the classpath.
You need not provide all the properties&#8201;&#8212;&#8201;only those that you want to override.</p>
</div>
<div class="paragraph">
<p>Starting with version 5.1, all the merged global properties are printed in the logs after application context startup when a <code>DEBUG</code> logic level is turned on for the <code>org.springframework.integration</code> category.
The output looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Spring Integration global properties:

spring.integration.endpoints.noAutoStartup=fooService*
spring.integration.taskScheduler.poolSize=20
spring.integration.channels.maxUnicastSubscribers=0x7fffffff
spring.integration.channels.autoCreate=true
spring.integration.channels.maxBroadcastSubscribers=0x7fffffff
spring.integration.readOnly.headers=
spring.integration.messagingTemplate.throwExceptionOnLateReply=true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations"><a class="anchor" href="#annotations"></a>E.5. Annotation Support</h3>
<div class="paragraph">
<p>In addition to the XML namespace support for configuring message endpoints, you can also use annotations.
First, Spring Integration provides the class-level <code>@MessageEndpoint</code> as a stereotype annotation, meaning that it is itself annotated with Spring&#8217;s <code>@Component</code> annotation and is therefore automatically recognized as a bean definition by Spring&#8217;s component scanning.</p>
</div>
<div class="paragraph">
<p>Even more important are the various method-level annotations.
They indicate that the annotated method is capable of handling a message.
The following example demonstrates both class-level and method-level annotations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessageEndpoint
public class FooService {

    @ServiceActivator
    public void processMessage(Message message) {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Exactly what it means for the method to &#8220;handle&#8221; the Message depends on the particular annotation.
Annotations available in Spring Integration include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Aggregator</code> (see <a href="#aggregator">Aggregator</a>)</p>
</li>
<li>
<p><code>@Filter</code> (see <a href="#filter">Filter</a>)</p>
</li>
<li>
<p><code>@Router</code> (see <a href="#router">Routers</a>)</p>
</li>
<li>
<p><code>@ServiceActivator</code> (see <a href="#service-activator">Service Activator</a>)</p>
</li>
<li>
<p><code>@Splitter</code> (see <a href="#splitter">Splitter</a>)</p>
</li>
<li>
<p><code>@Transformer</code> (see <a href="#transformer">Transformer</a>)</p>
</li>
<li>
<p><code>@InboundChannelAdapter</code> (see <a href="#channel-adapter">Channel Adapter</a>)</p>
</li>
<li>
<p><code>@BridgeFrom</code> (see <a href="#bridge-annot">Configuring a Bridge with Java Configuration</a>)</p>
</li>
<li>
<p><code>@BridgeTo</code> (see <a href="#bridge-annot">Configuring a Bridge with Java Configuration</a>)</p>
</li>
<li>
<p><code>@MessagingGateway</code> (see <a href="#gateway">Messaging Gateways</a>)</p>
</li>
<li>
<p><code>@IntegrationComponentScan</code> (see <a href="#configuration-enable-integration">Configuration and <code>@EnableIntegration</code></a>)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use XML configuration in combination with annotations, the <code>@MessageEndpoint</code> annotation is not required.
If you want to configure a POJO reference from the <code>ref</code> attribute of a <code>&lt;service-activator/&gt;</code> element, you can provide only the method-level annotations.
In that case, the annotation prevents ambiguity even when no method-level attribute exists on the <code>&lt;service-activator/&gt;</code> element.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In most cases, the annotated handler method should not require the <code>Message</code> type as its parameter.
Instead, the method parameter type can match the message&#8217;s payload type, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ThingService {

    @ServiceActivator
    public void bar(Thing thing) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the method parameter should be mapped from a value in the <code>MessageHeaders</code>, another option is to use the parameter-level <code>@Header</code> annotation.
In general, methods annotated with the Spring Integration annotations can accept the <code>Message</code> itself, the message payload, or a header value (with <code>@Header</code>) as the parameter.
In fact, the method can accept a combination, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ThingService {

    @ServiceActivator
    public void otherThing(String payload, @Header("x") int valueX, @Header("y") int valueY) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use the  <code>@Headers</code> annotation to provide all of the message headers as a <code>Map</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ThingService {

    @ServiceActivator
    public void otherThing(String payload, @Headers Map&lt;String, Object&gt; headerMap) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The value of the annotation can also be a SpEL expression (for example, <code>someHeader.toUpperCase()</code>), which is useful when you wish to manipulate the header value before injecting it.
It also provides an optional <code>required</code> property, which specifies whether the attribute value must be available within
the headers.
The default value for the <code>required</code> property is <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For several of these annotations, when a message-handling method returns a non-null value, the endpoint tries to send a reply.
This is consistent across both configuration options (namespace and annotations) in that such an endpoint&#8217;s output channel is used (if available), and the <code>REPLY_CHANNEL</code> message header value is used as a fallback.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The combination of output channels on endpoints and the reply channel message header enables a pipeline approach, where multiple components have an output channel and the final component allows the reply message to be forwarded to the reply channel (as specified in the original request message).
In other words, the final component depends on the information provided by the original sender and can dynamically support any number of clients as a result.
This is an example of the <a href="https://www.enterpriseintegrationpatterns.com/ReturnAddress.html">return address</a> pattern.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the examples shown here, these annotations also support the <code>inputChannel</code> and <code>outputChannel</code> properties, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class ThingService {

    @ServiceActivator(inputChannel="input", outputChannel="output")
    public void otherThing(String payload, @Headers Map&lt;String, Object&gt; headerMap) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The processing of these annotations creates the same beans as the corresponding XML components&#8201;&#8212;&#8201;<code>AbstractEndpoint</code> instances and <code>MessageHandler</code> instances (or <code>MessageSource</code> instances for the inbound channel adapter).
See <a href="#annotations_on_beans">Annotations on <code>@Bean</code> Methods</a>.
The bean names are generated from the following pattern: <code>[componentName].[methodName].[decapitalizedAnnotationClassShortName]</code>
(for example, for the preceding example the bean name is <code>thingService.otherThing.serviceActivator</code>) for the <code>AbstractEndpoint</code> and the same name with an additional <code>.handler</code> (<code>.source</code>) suffix for the <code>MessageHandler</code> (<code>MessageSource</code>) bean.
The <code>MessageHandler</code> instances (<code>MessageSource</code> instances) are also eligible to be tracked by <a href="#message-history">the message history</a>.</p>
</div>
<div class="paragraph">
<p>Starting with version 4.0, all messaging annotations provide <code>SmartLifecycle</code> options (<code>autoStartup</code> and <code>phase</code>) to allow endpoint lifecycle control on application context initialization.
They default to <code>true</code> and <code>0</code>, respectively.
To change the state of an endpoint (such as ` start()` or <code>stop()</code>), you can obtain a reference to the endpoint bean by using the <code>BeanFactory</code> (or autowiring) and invoke the methods.
Alternatively, you can send a command message to the <code>Control Bus</code> (see <a href="#control-bus">Control Bus</a>).
For these purposes, you should use the <code>beanName</code> mentioned earlier in the preceding paragraph.</p>
</div>
<div class="sect3">
<h4 id="configuration-using-poller-annotation"><a class="anchor" href="#configuration-using-poller-annotation"></a>E.5.1. Using the <code>@Poller</code> Annotation</h4>
<div class="paragraph">
<p>Before Spring Integration 4.0, messaging annotations required that the <code>inputChannel</code> be a reference to a <code>SubscribableChannel</code>.
For <code>PollableChannel</code> instances, an <code>&lt;int:bridge/&gt;</code> element was needed to configure an <code>&lt;int:poller/&gt;</code> and make the composite endpoint be a <code>PollingConsumer</code>.
Version 4.0 introduced the <code>@Poller</code> annotation to allow the configuration of <code>poller</code> attributes directly on the messaging annotations, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AnnotationService {

    @Transformer(inputChannel = "input", outputChannel = "output",
        poller = @Poller(maxMessagesPerPoll = "${poller.maxMessagesPerPoll}", fixedDelay = "${poller.fixedDelay}"))
    public String handle(String payload) {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@Poller</code> annotation provides only simple <code>PollerMetadata</code> options.
You can configure the <code>@Poller</code> annotation&#8217;s attributes (<code>maxMessagesPerPoll</code>, <code>fixedDelay</code>, <code>fixedRate</code>, and <code>cron</code>) with property placeholders.
Also, starting with version 5.1, the <code>receiveTimeout</code> option for <code>PollingConsumer</code> s is also provided.
If it is necessary to provide more polling options (for example, <code>transaction</code>, <code>advice-chain</code>, <code>error-handler</code>, and others), you should configure the <code>PollerMetadata</code> as a generic bean and use its bean name as the <code>@Poller</code> 's <code>value</code> attribute.
In this case, no other attributes are allowed (they must be specified on the <code>PollerMetadata</code> bean).
Note, if <code>inputChannel</code> is a <code>PollableChannel</code> and no <code>@Poller</code> is configured, the default <code>PollerMetadata</code> is used (if it is present in the application context).
To declare the default poller by using a <code>@Configuration</code> annotation, use code similar to the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean(name = PollerMetadata.DEFAULT_POLLER)
public PollerMetadata defaultPoller() {
    PollerMetadata pollerMetadata = new PollerMetadata();
    pollerMetadata.setTrigger(new PeriodicTrigger(10));
    return pollerMetadata;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the default poller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AnnotationService {

    @Transformer(inputChannel = "aPollableChannel", outputChannel = "output")
    public String handle(String payload) {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use a named poller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PollerMetadata myPoller() {
    PollerMetadata pollerMetadata = new PollerMetadata();
    pollerMetadata.setTrigger(new PeriodicTrigger(1000));
    return pollerMetadata;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows an endpoint that uses the default poller:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AnnotationService {

    @Transformer(inputChannel = "aPollableChannel", outputChannel = "output"
                           poller = @Poller("myPoller"))
    public String handle(String payload) {
         ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Starting with version 4.3.3, the <code>@Poller</code> annotation has the <code>errorChannel</code> attribute for easier configuration of the underlying <code>MessagePublishingErrorHandler</code>.
This attribute plays the same role as <code>error-channel</code> in the <code>&lt;poller&gt;</code> XML component.
See <a href="#endpoint-namespace">Endpoint Namespace Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-inboundchanneladapter-annotation"><a class="anchor" href="#using-the-inboundchanneladapter-annotation"></a>E.5.2. Using the <code>@InboundChannelAdapter</code> Annotation</h4>
<div class="paragraph">
<p>Version 4.0 introduced the <code>@InboundChannelAdapter</code> method-level annotation.
It produces a <code>SourcePollingChannelAdapter</code> integration component based on a <code>MethodInvokingMessageSource</code> for the annotated method.
This annotation is an analogue of the <code>&lt;int:inbound-channel-adapter&gt;</code> XML component and has the same restrictions: The method cannot have parameters, and the return type must not be <code>void</code>.
It has two attributes: <code>value</code> (the required <code>MessageChannel</code> bean name) and <code>poller</code> (an optional <code>@Poller</code> annotation, as <a href="#configuration-using-poller-annotation">described earlier</a>).
If you need to provide some <code>MessageHeaders</code>, use a <code>Message&lt;?&gt;</code> return type and use a <code>MessageBuilder</code> to build the <code>Message&lt;?&gt;</code>.
Using a <code>MessageBuilder</code> lets you configure the <code>MessageHeaders</code>.
The following example shows how to use an <code>@InboundChannelAdapter</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@InboundChannelAdapter("counterChannel")
public Integer count() {
    return this.counter.incrementAndGet();
}

@InboundChannelAdapter(value = "fooChannel", poller = @Poller(fixed-rate = "5000"))
public String foo() {
    return "foo";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Version 4.3 introduced the <code>channel</code> alias for the <code>value</code> annotation attribute, to provide better source code readability.
Also, the target <code>MessageChannel</code> bean is resolved in the <code>SourcePollingChannelAdapter</code> by the provided name (set by the <code>outputChannelName</code> option) on the first <code>receive()</code> call, not during the initialization phase.
It allows &#8220;late binding&#8221; logic: The target <code>MessageChannel</code> bean from the consumer perspective is created and registered a bit later than the <code>@InboundChannelAdapter</code> parsing phase.</p>
</div>
<div class="paragraph">
<p>The first example requires that the default poller has been declared elsewhere in the application context.</p>
</div>
<div class="paragraph">
<p>Using the <code>@MessagingGateway</code> Annotation</p>
</div>
<div class="paragraph">
<p>See <a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-integrationcomponentscan-annotation"><a class="anchor" href="#using-the-integrationcomponentscan-annotation"></a>E.5.3. Using the <code>@IntegrationComponentScan</code> Annotation</h4>
<div class="paragraph">
<p>The standard Spring Framework <code>@ComponentScan</code> annotation does not scan interfaces for stereotype <code>@Component</code> annotations.
To overcome this limitation and allow the configuration of <code>@MessagingGateway</code> (see <a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a>), we introduced the <code>@IntegrationComponentScan</code> mechanism.
This annotation must be placed with a <code>@Configuration</code> annotation and be customized to define its scanning options,
such as <code>basePackages</code> and <code>basePackageClasses</code>.
In this case, all discovered interfaces annotated with <code>@MessagingGateway</code> are parsed and registered as <code>GatewayProxyFactoryBean</code> instances.
All other class-based components are parsed by the standard <code>@ComponentScan</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="meta-annotations"><a class="anchor" href="#meta-annotations"></a>E.6. Messaging Meta-Annotations</h3>
<div class="paragraph">
<p>Starting with version 4.0, all messaging annotations can be configured as meta-annotations and all user-defined messaging annotations can define the same attributes to override their default values.
In addition, meta-annotations can be configured hierarchically, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@ServiceActivator(inputChannel = "annInput", outputChannel = "annOutput")
public @interface MyServiceActivator {

    String[] adviceChain = { "annAdvice" };
}

@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@MyServiceActivator
public @interface MyServiceActivator1 {

    String inputChannel();

    String outputChannel();
}
...

@MyServiceActivator1(inputChannel = "inputChannel", outputChannel = "outputChannel")
public Object service(Object payload) {
   ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Configuring meta-annotations hierarchically lets users set defaults for various attributes and enables isolation of framework Java dependencies to user annotations, avoiding their use in user classes.
If the framework finds a method with a user annotation that has a framework meta-annotation, it is treated as if the method were annotated directly with the framework annotation.</p>
</div>
<div class="sect3">
<h4 id="annotations_on_beans"><a class="anchor" href="#annotations_on_beans"></a>E.6.1. Annotations on <code>@Bean</code> Methods</h4>
<div class="paragraph">
<p>Starting with version 4.0, you can configure messaging annotations on <code>@Bean</code> method definitions in <code>@Configuration</code> classes, to produce message endpoints based on the beans, not the methods.
It is useful when <code>@Bean</code> definitions are &#8220;out-of-the-box&#8221; <code>MessageHandler</code> instances (<code>AggregatingMessageHandler</code>, <code>DefaultMessageSplitter</code>, and others), <code>Transformer</code> instances (<code>JsonToObjectTransformer</code>, <code>ClaimCheckOutTransformer</code>, and others), and <code>MessageSource</code> instances (<code>FileReadingMessageSource</code>, <code>RedisStoreMessageSource</code>, and others).
The following example shows how to use messaging annotations with <code>@Bean</code> annotations:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class MyFlowConfiguration {

    @Bean
    @InboundChannelAdapter(value = "inputChannel", poller = @Poller(fixedDelay = "1000"))
    public MessageSource&lt;String&gt; consoleSource() {
        return CharacterStreamReadingMessageSource.stdin();
    }

    @Bean
    @Transformer(inputChannel = "inputChannel", outputChannel = "httpChannel")
    public ObjectToMapTransformer toMapTransformer() {
        return new ObjectToMapTransformer();
    }

    @Bean
    @ServiceActivator(inputChannel = "httpChannel")
    public MessageHandler httpHandler() {
    HttpRequestExecutingMessageHandler handler = new HttpRequestExecutingMessageHandler("http://foo/service");
        handler.setExpectedResponseType(String.class);
        handler.setOutputChannelName("outputChannel");
        return handler;
    }

    @Bean
    @ServiceActivator(inputChannel = "outputChannel")
    public LoggingHandler loggingHandler() {
        return new LoggingHandler("info");
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Version 5.0 introduced support for a <code>@Bean</code> annotated with <code>@InboundChannelAdapter</code> that returns <code>java.util.function.Supplier</code>, which can produce either a POJO or a <code>Message</code>.
The followig example shows how to use that combination:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableIntegration
public class MyFlowConfiguration {

    @Bean
    @InboundChannelAdapter(value = "inputChannel", poller = @Poller(fixedDelay = "1000"))
    public Supplier&lt;String&gt; pojoSupplier() {
        return () -&gt; "foo";
    }

    @Bean
    @InboundChannelAdapter(value = "inputChannel", poller = @Poller(fixedDelay = "1000"))
    public Supplier&lt;Message&lt;String&gt;&gt; messageSupplier() {
        return () -&gt; new GenericMessage&lt;&gt;("foo");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The meta-annotation rules work on <code>@Bean</code> methods as well (the <code>@MyServiceActivator</code> annotation <a href="#meta-annotations">described earlier</a> can be applied to a <code>@Bean</code> definition).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you use these annotations on consumer <code>@Bean</code> definitions, if the bean definition returns an appropriate <code>MessageHandler</code> (depending on the annotation type), you must set attributes (such as <code>outputChannel</code>, <code>requiresReply</code>, <code>order</code>, and others), on the <code>MessageHandler</code> <code>@Bean</code> definition itself.
Only the following annotation attributes are used: <code>adviceChain</code>, <code>autoStartup</code>, <code>inputChannel</code>, <code>phase</code>, and <code>poller</code>.
All other attributes are for the handler.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The bean names are generated with the following algorithm:
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>MessageHandler</code> (<code>MessageSource</code>) <code>@Bean</code> gets its own standard name from the method name or <code>name</code> attribute on the <code>@Bean</code>.
This works as though there were no messaging annotation on the <code>@Bean</code> method.</p>
</li>
<li>
<p>The <code>AbstractEndpoint</code> bean name is generated with the following pattern: <code>[configurationComponentName].[methodName].[decapitalizedAnnotationClassShortName]</code>.
For example, the <code>SourcePollingChannelAdapter</code> endpoint for the <code>consoleSource()</code> definition <a href="#annotations_on_beans">shown earlier</a> gets a bean name of <code>myFlowConfiguration.consoleSource.inboundChannelAdapter</code>.
See also <a href="#endpoint-bean-names">Endpoint Bean Names</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using these annotations on <code>@Bean</code> definitions, the <code>inputChannel</code> must reference a declared bean.
Channels are not automatically declared in this case.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With Java configuration, you can use any <code>@Conditional</code> (for example, <code>@Profile</code>) definition on the <code>@Bean</code> method level to skip the bean registration for some conditional reason.
The following example shows how to do so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ServiceActivator(inputChannel = "skippedChannel")
@Profile("thing")
public MessageHandler skipped() {
    return System.out::println;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Together with the existing Spring container logic, the messaging endpoint bean (based on the <code>@ServiceActivator</code> annotation), is also not registered.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="creating-a-bridge-with-annotations"><a class="anchor" href="#creating-a-bridge-with-annotations"></a>E.6.2. Creating a Bridge with Annotations</h4>
<div class="paragraph">
<p>Starting with version 4.0, Java configuration provides the <code>@BridgeFrom</code> and <code>@BridgeTo</code> <code>@Bean</code> method annotations to mark <code>MessageChannel</code> beans in <code>@Configuration</code> classes.
These really exists for completeness, providing a convenient mechanism to declare a <code>BridgeHandler</code> and its message endpoint configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PollableChannel bridgeFromInput() {
    return new QueueChannel();
}

@Bean
@BridgeFrom(value = "bridgeFromInput", poller = @Poller(fixedDelay = "1000"))
public MessageChannel bridgeFromOutput() {
    return new DirectChannel();
}
@Bean
public QueueChannel bridgeToOutput() {
    return new QueueChannel();
}

@Bean
@BridgeTo("bridgeToOutput")
public MessageChannel bridgeToInput() {
    return new DirectChannel();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use these annotations as meta-annotations as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="advising-annotated-endpoints"><a class="anchor" href="#advising-annotated-endpoints"></a>E.6.3. Advising Annotated Endpoints</h4>
<div class="paragraph">
<p>See <a href="#advising-with-annotations">Advising Endpoints Using Annotations</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="message-mapping-rules"><a class="anchor" href="#message-mapping-rules"></a>E.7. Message Mapping Rules and Conventions</h3>
<div class="paragraph">
<p>Spring Integration implements a flexible facility to map messages to methods and their arguments without providing extra configuration, by relying on some default rules and defining certain conventions.
The examples in the following sections articulate the rules.</p>
</div>
<div class="sect3">
<h4 id="sample-scenarios"><a class="anchor" href="#sample-scenarios"></a>E.7.1. Sample Scenarios</h4>
<div class="paragraph">
<p>The following example shows a single un-annotated parameter (object or primitive) that is not a <code>Map</code> or a <code>Properties</code> object with a non-void return type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String doSomething(Object o);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The input parameter is amessage payload.
If the parameter type is not compatible witha message payload,an attempt is made to convert it by using a conversion service provided by Spring 3.0.
The return value is incorporated as a payload of the returned message.</p>
</div>
<div class="paragraph">
<p>The following example shows a single un-annotated parameter(object or primitive)that is not a <code>Map</code> or a <code>Properties</code> with a <code>Message</code> return type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Message doSomething(Object o);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The input parameter isa message payload.
If the parameter type is not compatible witha message payload,an attempt is made to convert it by using a conversion service provided by Spring 3.0.
The return value is a newly constructed message that is sent to the next destination.</p>
</div>
<div class="paragraph">
<p>The followig example shows a single parameter that is a message (or one of its subclasses) with an arbitrary object or primitive return type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public int doSomething(Message msg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The input parameter isitself a <code>Message</code>.
The return value becomes a payload of the <code>Message</code> that is sent to the next destination.</p>
</div>
<div class="paragraph">
<p>The following example shows a single parameter that is a <code>Message</code> (or one of its subclasses) with a <code>Message</code> (or one of its subclasses) as the return type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Message doSomething(Messagemsg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The input parameter isitself a <code>Message</code>.
The return value is a newly constructed <code>Message</code> that is sent to the next destination.</p>
</div>
<div class="paragraph">
<p>The following example shows a single parameter of type <code>Map</code> or <code>Properties</code> with a <code>Message</code> as the return type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Message doSomething(Map m);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This one is a bit interesting.
Although, at first, it might seem like an easy mapping straight to message headers, preference is always given to a <code>Message</code> payload.
This means that if a <code>Message</code> payload is of type <code>Map</code>, this input argument represents a <code>Message</code> payload.
However, if the <code>Message</code> payload is not of type <code>Map</code>, the conversion service does not try to convert the payload, and the input argument is mapped to message headers.</p>
</div>
<div class="paragraph">
<p>The following example shows two parameters, where one of them is an arbitrary type (an object or a primitive) that is not a <code>Map</code> or a <code>Properties</code> object and the other is of type <code>Map</code> or <code>Properties</code> type (regardless of the return):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Message doSomething(Map h, &lt;T&gt; t);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This combination contains two input parameters where one of them is of type <code>Map</code>.
The non-<code>Map</code> parameters (regardless of the order) are mapped to a <code>Message</code> payload and the <code>Map</code> or <code>Properties</code> (regardless of the order) is mapped tomessage headers, giving you a nice POJO way of interacting with <code>Message</code> structure.</p>
</div>
<div class="paragraph">
<p>The following example shows no parameters (regardless of the return):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String doSomething();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This message handler method is invoked based on the Message sent to the input channel to which this handler is connected.
However no <code>Message</code> data is mapped, thus making the <code>Message</code> act as event or trigger to invoke the handler.
The output is mapped according to the rules <a href="#message-mapping-rules">described earlier</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows no parameters and a void return:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void soSomething();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This example is the same as the previous example, but it produces no output.</p>
</div>
</div>
<div class="sect3">
<h4 id="annotation-based-mapping"><a class="anchor" href="#annotation-based-mapping"></a>E.7.2. Annotation-based Mapping</h4>
<div class="paragraph">
<p>Annotation-based mapping is the safest and least ambiguous approach to map messages to methods.
The following example shows how to explicitly map a method to a header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String doSomething(@Payload String s,@Header("someheader") String b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see later on, without an annotation this signature would result in an ambiguous condition.
However, by explicitly mapping the first argument to a <code>Message</code> payload and the second argument to a value of the <code>someheader</code> message header, we avoid any ambiguity.</p>
</div>
<div class="paragraph">
<p>The following example is nearly identical to the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String doSomething(@Payload String s, @RequestParam("something") String b)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> or any other non-Spring Integration mapping annotation is irrelevantand is therefore ignored, leaving the second parameter unmapped.
Although the second parameter could easily be mapped to a payload, there can only be one payload.
Therefore, the annotations keep this method from being ambiguous.</p>
</div>
<div class="paragraph">
<p>The following example shows another similar method that would be ambiguous were it not for annotations to clarify the intent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String foo(String s, @Header("foo") String b)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The only difference is that the first argument is implicitly mapped to the message payload.</p>
</div>
<div class="paragraph">
<p>The following example shows yet another signature that would definitely be treated as ambiguous without annotations, because it has more than two arguments:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String soSomething(@Headers Map m, @Header("something") Map f, @Header("someotherthing") String bar)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This example would be especially problematic, because two of its arguments are <code>Map</code> instances.
However, with annotation-based mapping, the ambiguity is easily avoided.
In this example the first argument is mapped to all the message headers, while the second and third argument map to the values of the message headers named 'something' and 'someotherthing'.
The payload is not being mapped to any argument.</p>
</div>
</div>
<div class="sect3">
<h4 id="complex-scenarios"><a class="anchor" href="#complex-scenarios"></a>E.7.3. Complex Scenarios</h4>
<div class="paragraph">
<p>The following example uses multiple parameters:</p>
</div>
<div class="paragraph">
<p>Multiple parameters can create a lot of ambiguity with regards to determining the appropriate mappings.
The general advice is to annotate your method parameters with <code>@Payload</code>, <code>@Header</code>, and <code>@Headers</code>.
The examples in this section show ambiguous conditions that result in an exception being raised.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String doSomething(String s, int i)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The two parameters are equal in weight.
Therefore, there is no way to determine which one is a payload.</p>
</div>
<div class="paragraph">
<p>The following example shows a similar problem, only with three parameters:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String foo(String s, Map m, String b)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Although the Map could be easily mapped to message headers, there is no way to determine what to do with the two String parameters.</p>
</div>
<div class="paragraph">
<p>The following example shows another ambiguous method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String foo(Map m, Map f)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Although one might argue that one <code>Map</code> could be mapped to the message payload and the other one to the message headers, we cannot rely on the order.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Any method signature with more than one method argument that is not (Map, &lt;T&gt;) and with unannotated parameters results in an ambiguous condition and triggers an exception.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next set of examples each show mutliple methods that result in ambiguity.</p>
</div>
<div class="paragraph">
<p>Message handlers with multiple methods are mapped based on the same rules that are described earlier (in the examples).
However, some scenarios might still look confusing.</p>
</div>
<div class="paragraph">
<p>The following example shows multiple methods with legal (mappable and unambiguous) signatures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Something {
    public String doSomething(String str, Map m);

    public String doSomething(Map m);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>(Whether the methods have the same name or different names makes no difference).
The <code>Message</code> could be mapped to either method.
The first method would be invoked when the message payload could be mapped to <code>str</code>and the message headers could be mapped to <code>m</code>.
The second method could also be a candidate by mapping only the message headers to <code>m</code>.
To make matters worse, both methods have the same name.
At first, that might look ambiguous because of the following configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activatorinput-channel="input"output-channel="output"method="doSomething"&gt;
    &lt;beanclass="org.things.Something"/&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It works because mappings are based on the payload first and everything else next.
In other words, the method whose first argument can be mapped to a payload takes precedence over all other methods.</p>
</div>
<div class="paragraph">
<p>Now consider an alternate example, which produces a truly ambiguous condition:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Something {
    public String doSomething(String str, Map m);

    public String doSomething(String str);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Both methods have signatures that could be mapped to a message payload.
They also have the same name.
Such handler methods will trigger an exception.
However, if the method names were different, you could influence the mapping with a <code>method</code> attribute (shown in the next example).
The following example shows the same example with two different method names:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Something {
    public String doSomething(String str, Map m);

    public String doSomethingElse(String str);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>method</code> attribute to dictate the mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activatorinput-channel="input"output-channel="output"method="doSomethingElse"&gt;
    &lt;beanclass="org.bar.Foo"/&gt;
&lt;/int:service-activator&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the configuration explicitly maps the <code>doSomethingElse</code> method, we have eliminated the ambiguity.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>Appendix F: Testing support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Integration provides a number of utilities and annotations to help you test your application.
Testing support is presented by two modules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-integration-test-support</code> contains core items and shared utilities</p>
</li>
<li>
<p><code>spring-integration-test</code> provides mocking and application context configuration components for integration tests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>spring-integration-test-support</code> (<code>spring-integration-test</code> in versions before 5.0) provides basic, standalone utilities, rules, and matchers for unit testing.
(it also has no dependencies on Spring Integration itself and is used internally in Framework tests).
<code>spring-integration-test</code> aims to help with integration testing and provides a comprehensive high-level API to mock integration components and verify the behavior of individual components, including whole integration flows or only parts of them.</p>
</div>
<div class="paragraph">
<p>A thorough treatment of testing in the enterprise is beyond the scope of this reference manual.
See the <a href="https://www.enterpriseintegrationpatterns.com/docs/TestDrivenEAI.pdf">&#8220;Test-Driven Development in Enterprise Integration Projects&#8221;</a> paper, by Gregor Hohpe and Wendy Istvanick, for a source of ideas and principles for testing your target integration solution.</p>
</div>
<div class="paragraph">
<p>The Spring Integration Test Framework and test utilities are fully based on existing JUnit, Hamcrest, and Mockito libraries.
The application context interaction is based on the <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/htmlsingle/#testing">Spring test framework</a>.
See the documentation for those projects for further information.</p>
</div>
<div class="paragraph">
<p>Thanks to the canonical implementation of the EIP in Spring Integration Framework and its first-class citizens (such as <code>MessageChannel</code>, <code>Endpoint</code> and <code>MessageHandler</code>), abstractions, and loose coupling principles, you can implement integration solutions of any complexity.
With the Spring Integration API for the flow definitions, you can improve, modify or even replace some part of the flow without impacting (mostly) other components in the integration solution.
Testing such an integration solution is still a challenge, both from an end-to-end approach and from an in-isolation approach.
Several existing tools can help to test or mock some integration protocols, and they work well with Spring Integration channel adapters.
Examples of such tools include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring <code>MockMVC</code> and its <code>MockRestServiceServer</code> can be used for testing HTTP.</p>
</li>
<li>
<p>Some RDBMS vendors provide embedded data bases for JDBC or JPA support.</p>
</li>
<li>
<p>ActiveMQ can be embedded for testing JMS or STOMP protocols.</p>
</li>
<li>
<p>There are tools for embedded MongoDB and Redis.</p>
</li>
<li>
<p>Tomcat and Jetty have embedded libraries to test real HTTP, Web Services, or WebSockets.</p>
</li>
<li>
<p>The <code>FtpServer</code> and <code>SshServer</code> from the Apache Mina project can be used for testing the FTP and SFTP protocols.</p>
</li>
<li>
<p>Gemfire and Hazelcast can be run as real-data grid nodes in the tests.</p>
</li>
<li>
<p>The Curator Framework provides a <code>TestingServer</code> for Zookeeper interaction.</p>
</li>
<li>
<p>Apache Kafka provides admin tools to embed a Kafka Broker in the tests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of these tools and libraries are used in Spring Integration tests.
Also, from the GitHub <a href="https://github.com/spring-projects/spring-integration">repository</a> (in the <code>test</code> directory of each module), you can discover ideas for how to build your own tests for integration solutions.</p>
</div>
<div class="paragraph">
<p>The rest of this chapter describes the testing tools and utilities provided by Spring Integration.</p>
</div>
<div class="sect2">
<h3 id="testing-utilities"><a class="anchor" href="#testing-utilities"></a>F.1. Testing Utilities</h3>
<div class="paragraph">
<p>The <code>spring-integration-test-support</code> module provides utilities and helpers for unit testing.</p>
</div>
<div class="sect3">
<h4 id="testutils"><a class="anchor" href="#testutils"></a>F.1.1. TestUtils</h4>
<div class="paragraph">
<p>The <code>TestUtils</code> class is mostly used for properties assertions in JUnit tests, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void loadBalancerRef() {
    MessageChannel channel = channels.get("lbRefChannel");
    LoadBalancingStrategy lbStrategy = TestUtils.getPropertyValue(channel,
                 "dispatcher.loadBalancingStrategy", LoadBalancingStrategy.class);
    assertTrue(lbStrategy instanceof SampleLoadBalancingStrategy);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>TestUtils.getPropertyValue()</code> is based on Spring&#8217;s <code>DirectFieldAccessor</code> and provides the ability to get a value from the target private property.
As shown in the preceding example, it also supports nested properties access by using dotted notation.</p>
</div>
<div class="paragraph">
<p>The <code>createTestApplicationContext()</code> factory method produces a <code>TestApplicationContext</code> instance with the supplied Spring Integration environment.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/util/TestUtils.html">Javadoc</a> of other <code>TestUtils</code> methods for more information about this class.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-socketutils-class"><a class="anchor" href="#using-the-socketutils-class"></a>F.1.2. Using the <code>SocketUtils</code> Class</h4>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/util/SocketUtils.html"><code>SocketUtils</code> class</a> provides several methods that select one or more random ports for exposing server-side components without conflicts, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="socketUtils" class="org.springframework.integration.test.util.SocketUtils" /&gt;

&lt;int-syslog:inbound-channel-adapter id="syslog"
            channel="sysLogs"
            port="#{socketUtils.findAvailableUdpSocket(1514)}" /&gt;

&lt;int:channel id="sysLogs"&gt;
    &lt;int:queue/&gt;
&lt;/int:channel&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how the preceding configuration is used from the unit test:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired @Qualifier("syslog.adapter")
private UdpSyslogReceivingChannelAdapter adapter;

@Autowired
private PollableChannel sysLogs;
...
@Test
public void testSimplestUdp() throws Exception {
    int port = TestUtils.getPropertyValue(adapter1, "udpAdapter.port", Integer.class);
    byte[] buf = "&lt;157&gt;JUL 26 22:08:35 WEBERN TESTING[70729]: TEST SYSLOG MESSAGE".getBytes("UTF-8");
    DatagramPacket packet = new DatagramPacket(buf, buf.length,
                              new InetSocketAddress("localhost", port));
    DatagramSocket socket = new DatagramSocket();
    socket.send(packet);
    socket.close();
    Message&lt;?&gt; message = foo.receive(10000);
    assertNotNull(message);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This technique is not foolproof.
Some other process could be allocated the &#8220;free&#8221; port before your test opens it.
It is generally more preferable to use server port <code>0</code>, let the operating system select the port for you, and then discover the selected port in your test.
We have converted most framework tests to use this preferred technique.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-onlyoncetrigger"><a class="anchor" href="#using-onlyoncetrigger"></a>F.1.3. Using <code>OnlyOnceTrigger</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/util/OnlyOnceTrigger.html"><code>OnlyOnceTrigger</code></a> is useful for polling endpoints when you need to produce only one test message and verify the behavior without impacting other period messages.
The following example shows how to configure <code>OnlyOnceTrigger</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="testTrigger" class="org.springframework.integration.test.util.OnlyOnceTrigger" /&gt;

&lt;int:poller id="jpaPoller" trigger="testTrigger"&gt;
    &lt;int:transactional transaction-manager="transactionManager" /&gt;
&lt;/int:poller&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use the preceding configuration of <code>OnlyOnceTrigger</code> for testing:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
@Qualifier("jpaPoller")
PollerMetadata poller;

@Autowired
OnlyOnceTrigger testTrigger;
...
@Test
@DirtiesContext
public void testWithEntityClass() throws Exception {
    this.testTrigger.reset();
    ...
    JpaPollingChannelAdapter jpaPollingChannelAdapter = new JpaPollingChannelAdapter(jpaExecutor);

    SourcePollingChannelAdapter adapter = JpaTestUtils.getSourcePollingChannelAdapter(
    		jpaPollingChannelAdapter, this.outputChannel, this.poller, this.context,
    		this.getClass().getClassLoader());
    adapter.start();
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="support-components"><a class="anchor" href="#support-components"></a>F.1.4. Support Components</h4>
<div class="paragraph">
<p>The <code>org.springframework.integration.test.support</code> package contains various abstract classes that you should implement in target tests</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractRequestResponseScenarioTests.html"><code>AbstractRequestResponseScenarioTests</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractResponseValidator.html"><code>AbstractResponseValidator</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/LogAdjustingTestSupport.html"><code>LogAdjustingTestSupport</code></a> (Deprecated)</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/MessageValidator.html"><code>MessageValidator</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/PayloadValidator.html"><code>PayloadValidator</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/RequestResponseScenario.html"><code>RequestResponseScenario</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/SingleRequestResponseScenarioTests.html"><code>SingleRequestResponseScenarioTests</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="test-junit-rules"><a class="anchor" href="#test-junit-rules"></a>F.1.5. JUnit Rules and Conditions</h4>
<div class="paragraph">
<p>The <code>LongRunningIntegrationTest</code> JUnit 4 test rule is present to indicate if test should be run if <code>RUN_LONG_INTEGRATION_TESTS</code> environment or system property is set to <code>true</code>.
Otherwise it is skipped.
For the same reason since version 5.1, a <code>@LongRunningTest</code> conditional annotation is provided for JUnit 5 tests.</p>
</div>
</div>
<div class="sect3">
<h4 id="hamcrest-and-mockito-matchers"><a class="anchor" href="#hamcrest-and-mockito-matchers"></a>F.1.6. Hamcrest and Mockito Matchers</h4>
<div class="paragraph">
<p>The <code>org.springframework.integration.test.matcher</code> package contains several <code>Matcher</code> implementations to assert <code>Message</code> and its properties in unit tests.
The following example shows how to use one such matcher (<code>PayloadMatcher</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.integration.test.matcher.PayloadMatcher.hasPayload;
...
@Test
public void transform_withFilePayload_convertedToByteArray() throws Exception {
    Message&lt;?&gt; result = this.transformer.transform(message);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasPayload(is(instanceOf(byte[].class))));
    assertThat(result, hasPayload(SAMPLE_CONTENT.getBytes(DEFAULT_ENCODING)));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>MockitoMessageMatchers</code> factory can be used for mocks for stubbing and verifications, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static final Date SOME_PAYLOAD = new Date();

static final String SOME_HEADER_VALUE = "bar";

static final String SOME_HEADER_KEY = "test.foo";
...
Message&lt;?&gt; message = MessageBuilder.withPayload(SOME_PAYLOAD)
                .setHeader(SOME_HEADER_KEY, SOME_HEADER_VALUE)
                .build();
MessageHandler handler = mock(MessageHandler.class);
handler.handleMessage(message);
verify(handler).handleMessage(messageWithPayload(SOME_PAYLOAD));
verify(handler).handleMessage(messageWithPayload(is(instanceOf(Date.class))));
...
MessageChannel channel = mock(MessageChannel.class);
when(channel.send(messageWithHeaderEntry(SOME_HEADER_KEY, is(instanceOf(Short.class)))))
        .thenReturn(true);
assertThat(channel.send(message), is(false));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-context"><a class="anchor" href="#test-context"></a>F.2. Spring Integration and the Test Context</h3>
<div class="paragraph">
<p>Typically, tests for Spring applications use the Spring Test Framework.
Since Spring Integration is based on the Spring Framework foundation, everything we can do with the Spring Test Framework also applies when testing integration flows.
The <code>org.springframework.integration.test.context</code> package provides some components for enhancing the test context for integration needs.
First of all, we configure our test class with a <code>@SpringIntegrationTest</code> annotation to enable the Spring Integration Test Framework, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringIntegrationTest(noAutoStartup = {"inboundChannelAdapter", "*Source*"})
public class MyIntegrationTests {

    @Autowired
    private MockIntegrationContext mockIntegrationContext;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@SpringIntegrationTest</code> annotation populates a <code>MockIntegrationContext</code> bean, which you can autowire to the test class to access its methods.
With the <code>noAutoStartup</code> option, the Spring Integration Test Framework prevents endpoints that are normally <code>autoStartup=true</code> from starting.
The endpoints are matched to the provided patterns, which support the following simple pattern styles: <code>xxx*</code>, <code><strong>xxx</code>, <code>*xxx</strong></code>, and <code>xxx*yyy</code>.</p>
</div>
<div class="paragraph">
<p>This is useful when we would like to not have real connections to the target systems from inbound channel adapters (for example an AMQP Inbound Gateway, JDBC Polling Channel Adapter, WebSocket Message Producer in client mode, and so on).</p>
</div>
<div class="paragraph">
<p>The <code>MockIntegrationContext</code> is meant to be used in the target test cases for modifications to beans in the real application context.
For example, endpoints that have <code>autoStartup</code> overridden to <code>false</code> can be replaced with mocks, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testMockMessageSource() {
    MessageSource&lt;String&gt; messageSource = () -&gt; new GenericMessage&lt;&gt;("foo");

    this.mockIntegrationContext.substituteMessageSourceFor("mySourceEndpoint", messageSource);

    Message&lt;?&gt; receive = this.results.receive(10_000);
    assertNotNull(receive);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>mySourceEndpoint</code> refers here to the bean name of the <code>SourcePollingChannelAdapter</code> for which we replace the real <code>MessageSource</code> with our mock.
Similarly the <code>MockIntegrationContext.substituteMessageHandlerFor()</code> expects a bean name for the <code>IntegrationConsumer</code>, which wraps a <code>MessageHandler</code> as an endpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After test is performed you can restore the state of endpoint beans to the real configuration using <code>MockIntegrationContext.resetBeans()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@After
public void tearDown() {
    this.mockIntegrationContext.resetBeans();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/context/MockIntegrationContext.html">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="testing-mocks"><a class="anchor" href="#testing-mocks"></a>F.3. Integration Mocks</h3>
<div class="paragraph">
<p>The <code>org.springframework.integration.test.mock</code> package offers tools and utilities for mocking, stubbing, and verification of activity on Spring Integration components.
The mocking functionality is fully based on and compatible with the well known Mockito Framework.
(The current Mockito transitive dependency is on version 2.5.x or higher.)</p>
</div>
<div class="sect3">
<h4 id="mockintegration"><a class="anchor" href="#mockintegration"></a>F.3.1. MockIntegration</h4>
<div class="paragraph">
<p>The <code>MockIntegration</code> factory provides an API to build mocks for Spring Integration beans that are parts of the integration flow (<code>MessageSource</code>, <code>MessageProducer</code>, <code>MessageHandler</code>, and <code>MessageChannel</code>).
You can use the target mocks during the configuration phase as well as in the target test method to replace the real endpoints before performing verifications and assertions, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:inbound-channel-adapter id="inboundChannelAdapter" channel="results"&gt;
    &lt;bean class="org.springframework.integration.test.mock.MockIntegration" factory-method="mockMessageSource"&gt;
        &lt;constructor-arg value="a"/&gt;
        &lt;constructor-arg&gt;
            &lt;array&gt;
                &lt;value&gt;b&lt;/value&gt;
                &lt;value&gt;c&lt;/value&gt;
            &lt;/array&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/int:inbound-channel-adapter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to use Java Configuration to achieve the same configuration as the preceding example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@InboundChannelAdapter(channel = "results")
@Bean
public MessageSource&lt;Integer&gt; testingMessageSource() {
    return MockIntegration.mockMessageSource(1, 2, 3);
}
...
StandardIntegrationFlow flow = IntegrationFlows
        .from(MockIntegration.mockMessageSource("foo", "bar", "baz"))
        .&lt;String, String&gt;transform(String::toUpperCase)
        .channel(out)
        .get();
IntegrationFlowRegistration registration = this.integrationFlowContext.registration(flow)
        .register();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For this purpose, the aforementioned <code>MockIntegrationContext</code> should be used from the test, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.mockIntegrationContext.substituteMessageSourceFor("mySourceEndpoint",
        MockIntegration.mockMessageSource("foo", "bar", "baz"));
Message&lt;?&gt; receive = this.results.receive(10_000);
assertNotNull(receive);
assertEquals("FOO", receive.getPayload());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike the Mockito <code>MessageSource</code> mock object, the <code>MockMessageHandler</code> is a regular <code>AbstractMessageProducingHandler</code> extension with a chain API to stub handling for incoming messages.
The <code>MockMessageHandler</code> provides <code>handleNext(Consumer&lt;Message&lt;?&gt;&gt;)</code> to specify a one-way stub for the next request message.
It is used to mock message handlers that do not produce replies.
<code>handleNextAndReply(Function&lt;Message&lt;?&gt;, ?&gt;)</code> is provided for performing the same stub logic for the next request message and producing a reply for it.
They can be chained to simulate any arbitrary request-reply scenarios for all expected request messages variants.
These consumers and functions are applied to the incoming messages, one at a time from the stack, until the last, which is then used for all remaining messages.
The behavior is similar to the Mockito <code>Answer</code> or <code>doReturn()</code> API.</p>
</div>
<div class="paragraph">
<p>In addition, you can supply a Mockito <code>ArgumentCaptor&lt;Message&lt;?&gt;&gt;</code> to the <code>MockMessageHandler</code> in a constructor argument.
Each request message for the <code>MockMessageHandler</code> is captured by that <code>ArgumentCaptor</code>.
During the test, you can use its <code>getValue()</code> and <code>getAllValues()</code> methods to verify and assert those request messages.</p>
</div>
<div class="paragraph">
<p>The <code>MockIntegrationContext</code> provides a <code>substituteMessageHandlerFor()</code> API that lets you replace the actual configured <code>MessageHandler</code> with a <code>MockMessageHandler</code> in the endpoint under test.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical usage scenario:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ArgumentCaptor&lt;Message&lt;?&gt;&gt; messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);

MessageHandler mockMessageHandler =
        mockMessageHandler(messageArgumentCaptor)
                .handleNextAndReply(m -&gt; m.getPayload().toString().toUpperCase());

this.mockIntegrationContext.substituteMessageHandlerFor("myService.serviceActivator",
                               mockMessageHandler);
GenericMessage&lt;String&gt; message = new GenericMessage&lt;&gt;("foo");
this.myChannel.send(message);
Message&lt;?&gt; received = this.results.receive(10000);
assertNotNull(received);
assertEquals("FOO", received.getPayload());
assertSame(message, messageArgumentCaptor.getValue());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/mock/MockIntegration.html"><code>MockIntegration</code></a> and <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/test/mock/MockMessageHandler.html"><code>MockMessageHandler</code></a> Javadoc for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-other-resources"><a class="anchor" href="#testing-other-resources"></a>F.4. Other Resources</h3>
<div class="paragraph">
<p>As well as exploring the test cases in the framework itself, the <a href="https://github.com/spring-projects/spring-integration-samples">Spring Integration Samples repository</a> has some sample applications specifically made to show testing, such as <code>testing-examples</code> and <code>advanced-testing-examples</code>.
In some cases, the samples themselves have comprehensive end-to-end tests, such as the <code>file-split-ftp</code> sample.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="samples"><a class="anchor" href="#samples"></a>Appendix G: Spring Integration Samples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of Spring Integration 2.0, the Spring Integration distribution nolonger includes the samples.
Instead, we have switched to a much simpler collaborative model that should promote better community participation and, ideally, more contributions.
Samples now have a dedicated Git repository and a dedicated JIRA Issue Tracking system.
Sample development also has its own lifecycle, which is not dependent on the lifecycle of the framework releases, although the repository is still tagged with each major release for compatibility reasons.</p>
</div>
<div class="paragraph">
<p>The great benefit to the community is that we can now add more samples and make them available to you right away without waiting for the next release.
Having its own JIRA that is not tied to the the actual framework is also a great benefit.
You now have a dedicated place to suggest samples as well as report issues with existing samples.
You can also submit a sample to us as an attachment through JIRA or, better, through the collaborative model that Git promotes.
If we believe your sample adds value, we would be more then glad to add it to the 'samples' repository, properly crediting you as the author.</p>
</div>
<div class="sect2">
<h3 id="samples-get"><a class="anchor" href="#samples-get"></a>G.1. Where to Get Samples</h3>
<div class="paragraph">
<p>The Spring Integration Samples project is hosted on <a href="https://github.com/SpringSource/spring-integration-samples/">GitHub</a>.
You can find the repository at:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/SpringSource/spring-integration-samples">https://github.com/SpringSource/spring-integration-samples</a></p>
</div>
<div class="paragraph">
<p>In order to check out or clone the samples, you must have a Git client installed on your system.
There are several GUI-based products available for many platforms (such as <a href="https://eclipse.org/egit/">EGit</a> for the Eclipse IDE).
A simple Google search can help you find them.
You can also use the command line interface for &lt;<a href="https://git-scm.com/,Git&gt;" class="bare">git-scm.com/,Git&gt;</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need more information on how to install or use Git, visit: <a href="https://git-scm.com/">https://git-scm.com/</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To clone (check out) the Spring Integration samples repository by using the Git command line tool, issue the following command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">$ git clonehttps://github.com/SpringSource/spring-integration-samples.git</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding command clones the entire samples repository into a directory named <code>spring-integration-samples</code> within the working directory where you issued that <code>git</code> command.
Since the samples repository is a live repository, you might want to perform periodic pulls (updates) to get new samples and updates to the existing samples.
To do so, issue the following <code>git pull</code> command:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">$ git pull</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="submitting-samples-or-sample-requests"><a class="anchor" href="#submitting-samples-or-sample-requests"></a>G.2. Submitting Samples or Sample Requests</h3>
<div class="paragraph">
<p>You can submit both new samples and requests for samples.
We greatly appreciate any effort toward improving the samples, including the sharing of good ideas.</p>
</div>
<div class="sect3">
<h4 id="samples-how-can-i-contribute"><a class="anchor" href="#samples-how-can-i-contribute"></a>G.2.1. How Can I Contribute My Own Samples?</h4>
<div class="paragraph">
<p>Github is for social coding: if you want to submit your own code examples to the Spring Integration Samples project, we encourage contributions through <a href="https://help.github.com/send-pull-requests/">pull requests</a> from <a href="https://help.github.com/fork-a-repo/">forks</a> of this repository.
If you want to contribute code this way, please reference, if possible, a <a href="https://jira.springframework.org/browse/INTSAMPLES">JIRA ticket</a> that provides some details regarding your sample.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Sign the contributor license agreement</div>
<div class="paragraph">
<p>Very important: Before we can accept your Spring Integration sample, we need you to sign the SpringSource contributor license agreement (CLA).
Signing the contributor&#8217;s agreement does not grant anyone commit rights to the main repository, but it does mean that we can accept your contributions, and you will get an author credit if we do.
In order to read and sign the CLA, go to:</p>
</div>
<div class="paragraph">
<p><a href="https://support.springsource.com/spring_committer_signup" class="bare">support.springsource.com/spring_committer_signup</a></p>
</div>
<div class="paragraph">
<p>From the <strong>Project</strong> drop down, select <strong>Spring Integration</strong>.
The Project Lead is Gary Russell.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="code-contribution-process"><a class="anchor" href="#code-contribution-process"></a>G.2.2. Code Contribution Process</h4>
<div class="paragraph">
<p>For the actual code contribution process, read the the Contributor Guidelines for Spring Integration.
They apply for the samples project as well.
You can find them at <a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md" class="bare">github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md</a></p>
</div>
<div class="paragraph">
<p>This process ensures that every commit gets peer-reviewed.
As a matter of fact, the core committers follow the exact same rules.
We gratefully look forward to your Spring Integration samples!</p>
</div>
</div>
<div class="sect3">
<h4 id="sample-requests"><a class="anchor" href="#sample-requests"></a>G.2.3. Sample Requests</h4>
<div class="paragraph">
<p>As <a href="#samples-how-can-i-contribute">mentioned earlier</a>, the Spring Integration Samples project has a dedicated JIRA issue tracking system.
To submit new sample requests, visit the JIRA Issue Tracking system at <a href="https://jira.springframework.org/browse/INTSAMPLES" class="bare">jira.springframework.org/browse/INTSAMPLES</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="samples-structure"><a class="anchor" href="#samples-structure"></a>G.3. Samples Structure</h3>
<div class="paragraph">
<p>Starting with Spring Integration 2.0, the structure of the samples has changed.
With plans for more samples, we realized that not all samples have the same goals.
They all share the common goal of showing you how to apply and work with the Spring Integration framework.
However, they differ in that some samples concentrate on a technical use case, while others focus on a business use case.
Also, some samples are about showcasing various techniques that could be applied to address certain scenarios (both technical and business).
The new categorization of samples lets us better organize them based on the problem each sample addresses while giving you a simpler way of finding the right sample for your needs.</p>
</div>
<div class="paragraph">
<p>Currently there are four categories.
Within the samples repository, each category has its own directory, which is named after the category name:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Basic (<code>samples/basic</code>)</dt>
<dd>
<p>This is a good place to get started.
The samples here are technically motivated and demonstrate the bare minimum with regard to configuration and code.
These should help you to get started quickly by introducing you to the basic concepts, API, and configuration of Spring Integration as well as Enterprise Integration Patterns (EIP).
For example, if you are looking for an answer on how to implement and wire a service activator to a message channel, how to use a messaging gateway as a facade to your message exchange, or how to get started with MAIL, TCP/UDP or other modules, this is the right place to find a good sample.
The bottom line is <code>samples/basic</code> is a good place to get started.</p>
</dd>
<dt class="hdlist1">Intermediate (<code>samples/intermediate</code>)</dt>
<dd>
<p>This category targets developers who are already familiar with the Spring Integration framework (beyond getting started) but need some more guidance while resolving themore advanced technical problems they might encounter after switching to a messaging architecture.
For example, if you are looking for an answer on how to handle errors in various message exchange scenarios or how to properly configure the aggregator for a situation where some messages do not ever arrive for aggregation, or any other issue that goes beyond a basic implementation and configuration of a particular component and exposes &#8220;what else&#8221; types of problems, this is the right place to find these type of samples.</p>
</dd>
<dt class="hdlist1">Advanced (<code>samples/advanced</code>)</dt>
<dd>
<p>This category targets developers who are very familiar with the Spring Integration framework but are looking to extend it to address a specific custom need by using Spring Integration&#8217;s public API.
For example, if you are looking for samples showing you how to implement a custom channel or consumer (event-based or polling-based) or you are trying to figure out the most appropriate way to implement a custom bean parser on top of the Spring Integrationbean parserhierarchy (perhaps when implementing your own namespace and schema for a custom component), this is the right place to look.
Here you can also find samples that will help you with adapter development.
Spring Integration comes with an extensive library of adapters to let you connect remote systems with the Spring Integration messaging framework.
However, you might need to integrate with a system for which the core framework does not provide an adapter.
If so, you might decide to implement your own (please consider contributing it).
This category would include samples showing you how.</p>
</dd>
<dt class="hdlist1">Applications (<code>samples/applications</code>)</dt>
<dd>
<p>This category targets developers and architects who have a good understanding of message-driven architecture and EIP and an above-average understanding of Spring and Spring Integration who are looking for samples that address a particular business problem.
In other words, the emphasis of the samples in this category is business use cases and how they can be solved with a message-driven architecture and Spring Integration in particular.
For example, if you want to see how a loan broker or travel agent process could be implemented and automated with Spring Integration, this is the right place to find these types of samples.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Spring Integration is a community-driven framework.
Therefore community participation is IMPORTANT.
That includes samples.
If you cannot find what you are looking for, let us know!
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="samples-impl"><a class="anchor" href="#samples-impl"></a>G.4. Samples</h3>
<div class="paragraph">
<p>Currently, Spring Integration comes with quite a few samples and you can only expect more.
To help you better navigate through them, each sample comes with its own <code>readme.txt</code> file which covers several details about the sample (for example, what EIP patterns it addresses, what problem it is trying to solve, how to run the sample, and other details).
However, certain samples require a more detailed and sometimes graphical explanation.
In this section, you can find details on samples that we believe require special attention.</p>
</div>
<div class="sect3">
<h4 id="samples-loan-broker"><a class="anchor" href="#samples-loan-broker"></a>G.4.1. Loan Broker</h4>
<div class="paragraph">
<p>This section covers the loan broker sample application that is included in the Spring Integration samples.This sample is inspired by one of the samples featured in Gregor Hohpe and Bobby Woolf&#8217;sbook, <a href="https://www.enterpriseintegrationpatterns.com/"><em>Enterprise Integration Patterns</em></a>.</p>
</div>
<div class="paragraph">
<p>The following diagram shows the entire process:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/loan-broker-eip.png" alt="loan broker eip">
</div>
<div class="title">Figure 10. Loan Broker Sample</div>
</div>
<div class="paragraph">
<p>At the core of an EIP architecture are the very simple yet powerful concepts of pipes, filters, and, of course: messages.
Endpoints (filters) are connected with one another via channels (pipes).
Producing endpoints send messages to the channel, and the consuming endpoint retrieves the messages.
This architecture is meant to define various mechanisms that describe how information is exchanged between the endpoints, without any awareness of what those endpoints are or what information they are exchanging.
Thus, it provides for a very loosely coupled and flexible collaboration model while also decoupling integration concerns from business concerns.
EIP extends this architecture by further defining:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The types of pipes (point-to-point channel, publish-subscribe channel, channel adapter, and others)</p>
</li>
<li>
<p>The core filters and patterns around how filters collaborate with pipes (Message router, splitters and aggregators, various message transformation patterns, and others)</p>
</li>
</ul>
</div>
<div id="samples-loan-broker-requirements" class="paragraph">
<p>Chapter 9 of the EIP book nicely describes the details and variations of this use case, but here is the brief summary: While shopping for the best loan quote, a consumer subscribes to the services of a loan broker, which handles such details as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer pre-screening (for example, obtaining and reviewing the consumer&#8217;s Credit history)</p>
</li>
<li>
<p>Determining the most appropriate banks (for example, based on the consumer&#8217;s credit history or score)</p>
</li>
<li>
<p>Sending a loan quote request to each selected bank</p>
</li>
<li>
<p>Collecting responses from each bank</p>
</li>
<li>
<p>Filtering responses and determining the best quotes, based on consumer&#8217;s requirements.</p>
</li>
<li>
<p>Pass the Loan quotes back to the consumer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The real process of obtaining a loan quote is generally a bit more complex.
However, since our goal is to demonstrate how Enterprise Integration Patterns are realized and implemented within Spring Integration, the use case has been simplified to concentrate only on the integration aspects of the process.
It is not an attempt to give you advice in consumer finances.</p>
</div>
<div class="paragraph">
<p>By engaging a loan broker, the consumer is isolated from the details of the loan broker&#8217;s operations, and each loan broker&#8217;s operations may defer from one another to maintain competitive advantage, so whatever we assemble and implement must be flexible so that any changes could be introduced quickly and painlessly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The loan broker sample does not actually talk to any 'imaginary' Banks or Credit bureaus.
Those services are stubbed out.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Our goal here is to assemble, orchestrate, and test the integration aspects of the process as a whole.
Only then can we start thinking about wiring such processes to the real services.
At that time, the assembled process and its configuration do not change regardless of the number of banks with which a particular loan broker deals or the type of communication media (or protocols) used (JMS, WS, TCP, and so on) to communicate with these banks.</p>
</div>
<div class="sect4">
<h5 id="design"><a class="anchor" href="#design"></a>Design</h5>
<div class="paragraph">
<p>As you analyze the <a href="#samples-loan-broker-requirements">six requirements</a> listed earlier, you can see that they are all integration concerns.
For example, in the consumer pre-screening step, we need to gather additional information about the consumer and the consumer&#8217;s desires and enrich the loan request with additional meta-information.
We then have to filter such information to select the most appropriate list of banks and so on.
Enrich, filter, and select are all integration concerns for which EIP defines a solution in the form of patterns.
Spring Integration provides an implementation of these patterns.</p>
</div>
<div class="paragraph">
<p>The following image shows a representation of a messaging gateway:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/gateway.jpg" alt="gateway">
</div>
<div class="title">Figure 11. Messaging Gateway</div>
</div>
<div class="paragraph">
<p>The messaging gateway pattern provides a simple mechanism to access messaging systems, including our loan broker.
In Spring Integration, you can define the gateway as a plain old java interface (you need not provide an implementation), configure it with the XML <code>&lt;gateway&gt;</code> element or with an annotation in Java, and use it as you would any other Spring bean.
Spring Integration takes care of delegating and mapping method invocations to the messaging infrastructure by generating a message (the payload is mapped to an input parameter of the method) and sending it to the designated channel.
The following example shows how to define such a gateway with XML:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:gateway id="loanBrokerGateway"
  default-request-channel="loanBrokerPreProcessingChannel"
  service-interface="org.springframework.integration.samples.loanbroker.LoanBrokerGateway"&gt;
  &lt;int:method name="getBestLoanQuote"&gt;
    &lt;int:header name="RESPONSE_TYPE" value="BEST"/&gt;
  &lt;/int:method&gt;
&lt;/int:gateway&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Our current gateway provides two methods that could be invoked.
One that returns the best single quote and another one that returns all quotes.
Somehow, downstream, we need to know what type of reply the caller needs.
The best way to achieve this in messaging architecture is to enrich the content of the message with some metadata that describes your intentions.
Content Enricher is one of the patterns that addresses this.
Spring Integration does, as a convenience, provide a separate configuration element to enrich message headers with arbitrary data (described later)
However, since the <code>gateway</code> element is responsible for constructing the initial message, it includes ability to enrich the newly created message with arbitrary message headers.
In our example, we add a <code>RESPONSE_TYPE</code> header with a value of <code>BEST</code> whenever the <code>getBestQuote()</code> method is invoked.
For other methods, we do not add any header.
Now we can check downstream for the existence of this header.
Based on its presence and its value, we can determine what type of reply the caller wants.</p>
</div>
<div class="paragraph">
<p>Based on the use case, we also know tat some pre-screening steps need to be performed, such as getting and evaluating the consumer&#8217;s credit score, because some premiere banks only accept quote requests from consumers that meet a minimum credit score requirement.
So it would be nice if the message would be enriched with such information before it is forwarded to the banks.
It would also be nice if, when several processes need to be completed to provide such meta-information, those processes could be grouped in a single unit.
In our use case, we need to determine the credit score and, based on the credit score and some rule, select a list of message channels (bank channels) to which to send quote request.</p>
</div>
</div>
<div class="sect4">
<h5 id="composed-message-processor"><a class="anchor" href="#composed-message-processor"></a>Composed Message Processor</h5>
<div class="paragraph">
<p>The composed message processor pattern describes rules around building endpoints that maintain control over message flow, which consists of multiple message processors.
In Spring Integration, the composed message processor pattern is implemented by the <code>&lt;chain&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>The following image shows the chain pattern:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/chain.png" alt="chain">
</div>
<div class="title">Figure 12. Chain</div>
</div>
<div class="paragraph">
<p>The preceding image shows that we have a chain with an inner header-enricher element that further enriches the content of the message with the <code>CREDIT_SCORE</code> header and the value (which is determined by the call to a credit service&#8201;&#8212;&#8201;a simple POJO spring bean identified by 'creditBureau' name).
Then it delegates to the message router.</p>
</div>
<div class="paragraph">
<p>The following image shows the message router pattern:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/bank-router.jpg" alt="bank router">
</div>
<div class="title">Figure 13. Message Router</div>
</div>
<div class="paragraph">
<p>Spring Integration offers several implementations of the message routing pattern.
In this case, we use a router that determines a list of channels based on evaluating an expression (in Spring Expression Language) that looks at the credit score (determined in the previous step) and selects the list of channels from the <code>Map</code> bean with an <code>id</code> of <code>banks</code> whose values are <code>premier</code> or <code>secondary</code>, based on the value of credit score.
Once the list of channels is selected, the message is routed to those channels.</p>
</div>
<div class="paragraph">
<p>Now, one last thing the loan broker needs to receive the loan quotes form the banks, aggregate them by consumer (we do not want to show quotes from one consumer to another), assemble the response based on the consumer&#8217;s selection criteria (single best quote or all quotes) and send the reply to the consumer.</p>
</div>
<div class="paragraph">
<p>The following image shows the message aggregator pattern:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/quotes-aggregator.jpg" alt="quotes aggregator">
</div>
<div class="title">Figure 14. Message Aggregator</div>
</div>
<div class="paragraph">
<p>An aggregator pattern describes an endpoint that groups related messages into a single message.
Criteria and rules can be provided to determine an aggregation and correlation strategy.
Spring Integration provides several implementations of the aggregator pattern as well as a convenient namespace-based configuration.</p>
</div>
<div class="paragraph">
<p>The following example shows how to define an aggregator:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:aggregator id="quotesAggregator"
      input-channel="quotesAggregationChannel"
      method="aggregateQuotes"&gt;
  &lt;beans:bean class="org.springframework.integration.samples.loanbroker.LoanQuoteAggregator"/&gt;
&lt;/int:aggregator&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Our Loan Broker defines a 'quotesAggregator' bean with the <code>&lt;aggregator&gt;</code> element, which provides a default aggregation and correlation strategy.
The default correlation strategy correlates messages based on the <code>correlationId</code> header (see <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html">the correlation identifier pattern in the EIP book</a>).
Note that we never provided the value for this header.
It was automatically set earlier by the router, when it generated a separate message for each bank channel.</p>
</div>
<div class="paragraph">
<p>Once the messages are correlated, they are released to the actual aggregator implementation.
Although Spring Integration provides a default aggregator, its strategy (gather the list of payloads from all messages and construct a new message with this list as its payload) does not satisfy our requirement.
Having all the results in the message is a problem, because our consumer might require a single best quote or all quotes.
To communicate the consumer&#8217;s intention, earlier in the process we set the <code>RESPONSE_TYPE</code> header.
Now we have to evaluate this header and return either all the quotes (the default aggregation strategy would work) or the best quote (the default aggregation strategy does not work because we have to determine which loan quote is the best).</p>
</div>
<div class="paragraph">
<p>In a more realistic application, selecting the best quote might be based on complex criteria that might influence the complexity of the aggregator implementation and configuration.
For now, though, we are making it simple.
If the consumer wants the best quote, we select a quote with the lowest interest rate.
To accomplish that, the <code>LoanQuoteAggregator</code> class sorts all the quotes by interest rate and returns the first one.
The <code>LoanQuote</code> class implements <code>Comparable</code> to compare quotes based on the rate attribute.
Once the response message is created, it is sent to the default reply channel of the messaging gateway (and, thus, to the consumer) that started the process.
Our consumer got the loan quote!</p>
</div>
<div class="paragraph">
<p>In conclusion, a rather complex process was assembled based on POJO (that is existing or legacy) logic and a light-weight, embeddable messaging framework (Spring Integration) with a loosely coupled programming model intended to simplify integration of heterogeneous systems without requiring a heavy-weight ESB-like engine or a proprietary development and deployment environment.
As a developer, you should not need to port your Swing or console-based application to an ESB-like server or implement proprietary interfaces just because you have an integration concern.</p>
</div>
<div class="paragraph">
<p>This sample and the other samples in this section are built on top of Enterprise Integration Patterns.
You can consider them to be &#8220;building blocks&#8221; for your solution.
They are not intended to be complete solutions.
Integration concerns exist in all types of application (whether server-based or not).
Our goal is to make is so that integrating applications does not require changes in design, testing, and deployment strategy.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="samples-cafe"><a class="anchor" href="#samples-cafe"></a>G.4.2. The Cafe Sample</h4>
<div class="paragraph">
<p>This section covers the cafe sample application that is included in the Spring Integration samples.This sample is inspired by another sample featured in Gregor Hohpe&#8217;s<a href="https://www.enterpriseintegrationpatterns.com/ramblings.html">Ramblings</a>.</p>
</div>
<div class="paragraph">
<p>The domain is that of a cafe, and  the following diagram depicts the basic flow:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/cafe-eip.png" alt="cafe eip">
</div>
<div class="title">Figure 15. Cafe Sample</div>
</div>
<div class="paragraph">
<p>The <code>Order</code> object may contain multiple <code>OrderItems</code>.
Once the order is placed, a splitter breaks the composite order message into a single message for each drink.
Each of these is then processed by a router that determines whether the drink is hot or cold (by checking the <code>OrderItem</code> object&#8217;s 'isIced' property).
The <code>Barista</code> prepares each drink, but hot and cold drink preparation are handled by two distinct methods: 'prepareHotDrink' and 'prepareColdDrink'.
The prepared drinks are then sent to the <code>Waiter</code> where they are aggregated into a <code>Delivery</code> object.</p>
</div>
<div class="paragraph">
<p>The following listing shows the XML configuration:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:int="http://www.springframework.org/schema/integration"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:beans="http://www.springframework.org/schema/beans"
 xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
  https://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/integration
  https://www.springframework.org/schema/integration/spring-integration.xsd
  http://www.springframework.org/schema/integration/stream
  https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd"&gt;

    &lt;int:gateway id="cafe" service-interface="o.s.i.samples.cafe.Cafe"/&gt;

    &lt;int:channel  id="orders"/&gt;
    &lt;int:splitter input-channel="orders" ref="orderSplitter"
                  method="split" output-channel="drinks"/&gt;

    &lt;int:channel id="drinks"/&gt;
    &lt;int:router  input-channel="drinks"
                 ref="drinkRouter" method="resolveOrderItemChannel"/&gt;

    &lt;int:channel id="coldDrinks"&gt;&lt;int:queue capacity="10"/&gt;&lt;/int:channel&gt;
    &lt;int:service-activator input-channel="coldDrinks" ref="barista"
                           method="prepareColdDrink" output-channel="preparedDrinks"/&gt;

    &lt;int:channel id="hotDrinks"&gt;&lt;int:queue capacity="10"/&gt;&lt;/int:channel&gt;
    &lt;int:service-activator input-channel="hotDrinks" ref="barista"
                           method="prepareHotDrink" output-channel="preparedDrinks"/&gt;

    &lt;int:channel id="preparedDrinks"/&gt;
    &lt;int:aggregator input-channel="preparedDrinks" ref="waiter"
                    method="prepareDelivery" output-channel="deliveries"/&gt;

    &lt;int-stream:stdout-channel-adapter id="deliveries"/&gt;

    &lt;beans:bean id="orderSplitter"
                class="org.springframework.integration.samples.cafe.xml.OrderSplitter"/&gt;

    &lt;beans:bean id="drinkRouter"
                class="org.springframework.integration.samples.cafe.xml.DrinkRouter"/&gt;

    &lt;beans:bean id="barista" class="o.s.i.samples.cafe.xml.Barista"/&gt;
    &lt;beans:bean id="waiter"  class="o.s.i.samples.cafe.xml.Waiter"/&gt;

    &lt;int:poller id="poller" default="true" fixed-rate="1000"/&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each message endpoint connects to input channels, output channels, or both.
Each endpoint manages its own lifecycle (by default, endpoints start automatically upon initialization, to prevent that, add the <code>auto-startup</code> attribute with a value of <code>false</code>).
Most importantly, notice that the objects are simple POJOs with strongly typed method arguments.
The following example shows the Splitter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OrderSplitter {
    public List&lt;OrderItem&gt; split(Order order) {
        return order.getItems();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the case of the router, the return value does not have to be a <code>MessageChannel</code> instance (although it can be).
In this example, a <code>String</code> value that holds the channel name is returned instead, as the following listing shows.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class DrinkRouter {
    public String resolveOrderItemChannel(OrderItem orderItem) {
        return (orderItem.isIced()) ? "coldDrinks" : "hotDrinks";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, turning back to the XML, you can see that there are two <code>&lt;service-activator&gt;</code> elements.
Each of these is delegating to the same <code>Barista</code> instance but with different methods (<code>prepareHotDrink</code> or <code>prepareColdDrink</code>), each corresponding to one of the two channels where order items have been routed.
The following listing shows the Barista class (which contains the <code>prepareHotDrink</code> and <code>prepareColdDrink</code> methods)</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Barista {

    private long hotDrinkDelay = 5000;
    private long coldDrinkDelay = 1000;

    private AtomicInteger hotDrinkCounter = new AtomicInteger();
    private AtomicInteger coldDrinkCounter = new AtomicInteger();

    public void setHotDrinkDelay(long hotDrinkDelay) {
        this.hotDrinkDelay = hotDrinkDelay;
    }

    public void setColdDrinkDelay(long coldDrinkDelay) {
        this.coldDrinkDelay = coldDrinkDelay;
    }

    public Drink prepareHotDrink(OrderItem orderItem) {
        try {
            Thread.sleep(this.hotDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + " prepared hot drink #" + hotDrinkCounter.incrementAndGet()
                    + " for order #" + orderItem.getOrder().getNumber()
                    + ": " + orderItem);
            return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        }
    }

    public Drink prepareColdDrink(OrderItem orderItem) {
        try {
            Thread.sleep(this.coldDrinkDelay);
            System.out.println(Thread.currentThread().getName()
                    + " prepared cold drink #" + coldDrinkCounter.incrementAndGet()
                    + " for order #" + orderItem.getOrder().getNumber() + ": "
                    + orderItem);
            return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),
                    orderItem.isIced(), orderItem.getShots());
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see from the preceding code excerpt, the <code>Barista</code> methods have different delays (the hot drinks take five times as long to prepare).
This simulates work being completed at different rates.
When the <code>CafeDemo</code> 'main' method runs, it loops 100 times and sends a single hot drink and a single cold drink each time.
It actually sends the messages by invoking the 'placeOrder' method on the <code>Cafe</code> interface.
In the earlier XML configuration, you can see that the <code>&lt;gateway&gt;</code> element is specified.
This triggers the creation of a proxy that implements the given service interface and connects it to a channel.
The channel name is provided on the <code>@Gateway</code> annotation of the <code>Cafe</code> interface, as the following interface definition shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Cafe {

    @Gateway(requestChannel="orders")
    void placeOrder(Order order);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, have a look at the <code>main()</code> method of the <code>CafeDemo</code> itself:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    AbstractApplicationContext context = null;
    if (args.length &gt; 0) {
        context = new FileSystemXmlApplicationContext(args);
    }
    else {
        context = new ClassPathXmlApplicationContext("cafeDemo.xml", CafeDemo.class);
    }
    Cafe cafe = context.getBean("cafe", Cafe.class);
    for (int i = 1; i &lt;= 100; i++) {
        Order order = new Order(i);
        order.addItem(DrinkType.LATTE, 2, false);
        order.addItem(DrinkType.MOCHA, 3, true);
        cafe.placeOrder(order);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To run this sample as well as eight others, refer to the <code>README.txt</code> within the <code>samples</code> directory of the main distribution (as described at <a href="#samples">the beginning of this chapter</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you run <code>cafeDemo</code>, you can see that the cold drinks are initially prepared more quickly than the hot drinks.
Because there is an aggregator, the cold drinks are effectively limited by the rate of the hot drink preparation.
This is to be expected, based on their respective delays of 1000 and 5000 milliseconds.
However, by configuring a poller with a concurrent task executor, you can dramatically change the results.
For example, you could use a thread pool executor with five workers for the hot drink barista while keeping the cold drink barista as it is.
The following listing configures such an arrangement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;int:service-activator input-channel="hotDrinks"
                     ref="barista"
                     method="prepareHotDrink"
                     output-channel="preparedDrinks"/&gt;

  &lt;int:service-activator input-channel="hotDrinks"
                     ref="barista"
                     method="prepareHotDrink"
                     output-channel="preparedDrinks"&gt;
      &lt;int:poller task-executor="pool" fixed-rate="1000"/&gt;
  &lt;/int:service-activator&gt;

  &lt;task:executor id="pool" pool-size="5"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Also, notice that the worker thread name is displayed with each invocation.
You can see that the hot drinks are prepared by the task-executor threads.
If you provide a much shorter poller interval (such as 100 milliseconds), you can see that it occasionally throttles the input by forcing the task scheduler (the caller) to invoke the operation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In addition to experimenting with the poller&#8217;s concurrency settings, you can also add the 'transactional' child element and then refer to any <code>PlatformTransactionManager</code> instance within the context.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="samples-xml-messaging"><a class="anchor" href="#samples-xml-messaging"></a>G.4.3. The XML Messaging Sample</h4>
<div class="paragraph">
<p>The XML messaging sample in <code>basic/xml</code> shows how to use some of the provided components that deal with XML payloads.
The sample uses the idea of processing an order for books represented as XML.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This sample shows that the namespace prefix can be whatever you want.
While we usually use, <code>int-xml</code> for integration XML components, the sample uses <code>si-xml</code>.
(<code>int</code> is short for &#8220;Integration&#8221;, and <code>si</code> is short for &#8220;Spring Integration&#8221;.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First, the order is split into a number of messages, each one representing a single order item from the XPath splitter component.
The following listing shows the configuration of the splitter:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;si-xml:xpath-splitter id="orderItemSplitter" input-channel="ordersChannel"
              output-channel="stockCheckerChannel" create-documents="true"&gt;
      &lt;si-xml:xpath-expression expression="/orderNs:order/orderNs:orderItem"
                                namespace-map="orderNamespaceMap" /&gt;
  &lt;/si-xml:xpath-splitter&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A service activator then passes the message into a stock checker POJO.
The order item document is enriched with information from the stock checker about the order item stock level.
This enriched order item message is then used to route the message.
In the case where the order item is in stock, the message is routed to the warehouse.
The following listing configures the <code>xpath-router</code> that routes the messages:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;si-xml:xpath-router id="instockRouter" input-channel="orderRoutingChannel" resolution-required="true"&gt;
    &lt;si-xml:xpath-expression expression="/orderNs:orderItem/@in-stock" namespace-map="orderNamespaceMap" /&gt;
    &lt;si-xml:mapping value="true" channel="warehouseDispatchChannel"/&gt;
    &lt;si-xml:mapping value="false" channel="outOfStockChannel"/&gt;
&lt;/si-xml:xpath-router&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When the order item is not in stock, the message is transformed with XSLT into a format suitable for sending to the supplier.
The following listing configures the XSLT transformer:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;si-xml:xslt-transformer input-channel="outOfStockChannel"
  output-channel="resupplyOrderChannel"
  xsl-resource="classpath:org/springframework/integration/samples/xml/bigBooksSupplierTransformer.xsl"/&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a>Appendix H: Additional Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The definitive source of information about Spring Integration is the <a href="https://projects.spring.io/spring-integration/">Spring Integration Home</a> at <a href="https://spring.io">https://spring.io</a>.
That site serves as a hub of information and is the best place to find up-to-date announcements about the project as well as links to articles, blogs, and new sample applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="history"><a class="anchor" href="#history"></a>Appendix I: Change History</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="migration-4.3-5.0"><a class="anchor" href="#migration-4.3-5.0"></a>I.1. Changes between 4.3 and 5.0</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.3-to-5.0-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="x5.0-new-components"><a class="anchor" href="#x5.0-new-components"></a>I.2. New Components</h3>
<div class="paragraph">
<p>Version 5.0 added a number of new components.</p>
</div>
<div class="sect3">
<h4 id="java-dsl-2"><a class="anchor" href="#java-dsl-2"></a>I.2.1. Java DSL</h4>
<div class="paragraph">
<p>The separate <a href="https://github.com/spring-projects/spring-integration-java-dsl">Spring Integration Java DSL</a> project has now been merged into the core Spring Integration project.
The <code>IntegrationComponentSpec</code> implementations for channel adapters and gateways are distributed to their specific modules.
See <a href="#java-dsl">Java DSL</a> for more information about Java DSL support.
See also the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.3-to-5.0-Migration-Guide#java-dsl">4.3 to 5.0 Migration Guide</a> for the required steps to move to Spring Integration 5.0.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-support"><a class="anchor" href="#testing-support"></a>I.2.2. Testing Support</h4>
<div class="paragraph">
<p>We created a new Spring Integration Test Framework to help with testing Spring Integration applications.
Now, with the <code>@SpringIntegrationTest</code> annotation on test classes and the <code>MockIntegration</code> factory, you can make your JUnit tests for integration flows somewhat easier.</p>
</div>
<div class="paragraph">
<p>See <a href="#testing">Testing support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="mongodb-outbound-gateway-2"><a class="anchor" href="#mongodb-outbound-gateway-2"></a>I.2.3. MongoDB Outbound Gateway</h4>
<div class="paragraph">
<p>The new <code>MongoDbOutboundGateway</code> lets you make queries to the database on demand by sending a message to its request channel.</p>
</div>
<div class="paragraph">
<p>See <a href="#mongodb-outbound-gateway">MongoDB Outbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-gateways-and-channel-adapters"><a class="anchor" href="#webflux-gateways-and-channel-adapters"></a>I.2.4. WebFlux Gateways and Channel Adapters</h4>
<div class="paragraph">
<p>We introduced the new WebFlux support module for Spring WebFlux Framework gateways and channel adapters.</p>
</div>
<div class="paragraph">
<p>See <a href="#webflux">WebFlux Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="content-type-conversion-2"><a class="anchor" href="#content-type-conversion-2"></a>I.2.5. Content Type Conversion</h4>
<div class="paragraph">
<p>Now that we use the new <code>InvocableHandlerMethod</code>-based infrastructure for service method invocations, we can perform <code>contentType</code> conversion from the payload to a target method argument.</p>
</div>
<div class="paragraph">
<p>See <a href="#content-type-conversion">Content Type Conversion</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="errormessagepublisher-and-errormessagestrategy"><a class="anchor" href="#errormessagepublisher-and-errormessagestrategy"></a>I.2.6. <code>ErrorMessagePublisher</code> and <code>ErrorMessageStrategy</code></h4>
<div class="paragraph">
<p>We added <code>ErrorMessagePublisher</code> and the <code>ErrorMessageStrategy</code> for creating <code>ErrorMessage</code> instances.</p>
</div>
<div class="paragraph">
<p>See <a href="#namespace-errorhandler">Error Handling</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-metadata-store-2"><a class="anchor" href="#jdbc-metadata-store-2"></a>I.2.7. JDBC Metadata Store</h4>
<div class="paragraph">
<p>We added a JDBC implementation of the <code>MetadataStore</code> implementation.
This is useful when you need to ensure transactional boundaries for metadata.</p>
</div>
<div class="paragraph">
<p>See <a href="#jdbc-metadata-store">JDBC Metadata Store</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x5.0-general"><a class="anchor" href="#x5.0-general"></a>I.3. General Changes</h3>
<div class="paragraph">
<p>Spring Integration is now fully based on Spring Framework <code>5.0</code> and Project Reactor <code>3.1</code>.
Previous Project Reactor versions are no longer supported.</p>
</div>
<div class="sect3">
<h4 id="core-changes"><a class="anchor" href="#core-changes"></a>I.3.1. Core Changes</h4>
<div class="paragraph">
<p>The <code>@Poller</code> annotation now has the <code>errorChannel</code> attribute for easier configuration of the underlying <code>MessagePublishingErrorHandler</code>.
See <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
<div class="paragraph">
<p>All the request-reply endpoints (based on <code>AbstractReplyProducingMessageHandler</code>) can now start transactions and, therefore, make the whole downstream flow transactional.
See <a href="#tx-handle-message-advice">Transaction Support</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>SmartLifecycleRoleController</code> now provides methods to obtain status of endpoints in roles.
See <a href="#endpoint-roles">Endpoint Roles</a> for more information.</p>
</div>
<div class="paragraph">
<p>By default, POJO methods are now invoked by using an <code>InvocableHandlerMethod</code>, but you can configure them to use SpEL, as before.
See <a href="#pojo-invocation">POJO Method invocation</a> for more information.</p>
</div>
<div class="paragraph">
<p>When targeting POJO methods as message handlers, you can now mark one of the service methods with the <code>@Default</code> annotation to provide a fallback mechanism for non-matched conditions.
See <a href="#service-activator-namespace">Configuring Service Activator</a> for more information.</p>
</div>
<div class="paragraph">
<p>We added a simple <code>PassThroughTransactionSynchronizationFactory</code> to always store a polled message in the current transaction context.
That message is used as a <code>failedMessage</code> property of the <code>MessagingException</code>, which wraps any raw exception thrown during transaction completion.
See <a href="#transaction-synchronization">Transaction Synchronization</a> for more information.</p>
</div>
<div class="paragraph">
<p>The aggregator expression-based <code>ReleaseStrategy</code> now evaluates the expression against the <code>MessageGroup</code> instead of just the collection of <code>Message&lt;?&gt;</code>.
See <a href="#aggregator-spel">Aggregators and Spring Expression Language (SpEL)</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now supply the <code>ObjectToMapTransformer</code> with a customized <code>JsonObjectMapper</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#aggregator-spel">Aggregators and Spring Expression Language (SpEL)</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>@GlobalChannelInterceptor</code> annotation and <code>&lt;int:channel-interceptor&gt;</code> now support negative patterns (via <code>!</code> prepending) for component names matching.
See <a href="#global-channel-configuration-interceptors">Global Channel Interceptor Configuration</a> for more information.</p>
</div>
<div class="paragraph">
<p>When a candidate failed to acquire the lock, the <code>LockRegistryLeaderInitiator</code> now emits a new <code>OnFailedToAcquireMutexEvent</code> through <code>DefaultLeaderEventPublisher</code>.
See <code><a href="#leadership-event-handling">Leadership Event Handling</a></code> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="gateway-changes"><a class="anchor" href="#gateway-changes"></a>I.3.2. Gateway Changes</h4>
<div class="paragraph">
<p>When the gateway method has a <code>void</code> return type and an error channel is provided, the gateway now correctly sets the <code>errorChannel</code> header.
Previously, the header was not populated.
This caused synchronous downstream flows (running on the calling thread) to send the exception to the configured channel, but an exception on an asynchronous downstream flow would be sent to the default <code>errorChannel</code> instead.</p>
</div>
<div class="paragraph">
<p>The <code>RequestReplyExchanger</code> interface now has a <code>throws MessagingException</code> clause to meet the proposed messages exchange contract.</p>
</div>
<div class="paragraph">
<p>You can now specify the request and reply timeouts with SpEL expressions.
See <a href="#gateway">Messaging Gateways</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="aggregator-performance-changes"><a class="anchor" href="#aggregator-performance-changes"></a>I.3.3. Aggregator Performance Changes</h4>
<div class="paragraph">
<p>By default, aggregators now use a <code>SimpleSequenceSizeReleaseStrategy</code>, which is more efficient, especially with large groups.
Empty groups are now scheduled for removal after <code>empty-group-min-timeout</code>.
See <a href="#aggregator">Aggregator</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="splitter-changes"><a class="anchor" href="#splitter-changes"></a>I.3.4. Splitter Changes</h4>
<div class="paragraph">
<p>The splitter component can now handle and split Java <code>Stream</code> and Reactive Streams <code>Publisher</code> objects.
If the output channel is a <code>ReactiveStreamsSubscribableChannel</code>, the <code>AbstractMessageSplitter</code> builds a <code>Flux</code> for subsequent iteration instead of a regular <code>Iterator</code>, independent of the object being split.
In addition, <code>AbstractMessageSplitter</code> provides <code>protected obtainSizeIfPossible()</code> methods to allow determination of the size of the <code>Iterable</code> and <code>Iterator</code> objects, if that is possible.
See <a href="#splitter">Splitter</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-changes"><a class="anchor" href="#jms-changes"></a>I.3.5. JMS Changes</h4>
<div class="paragraph">
<p>Previously, Spring Integration JMS XML configuration used a default bean name of <code>connectionFactory</code> for the JMS connection factory, letting the property be omitted from component definitions.
We renamed it to <code>jmsConnectionFactory</code>, which is the bean name used by Spring Boot to auto-configure the JMS connection factory bean.</p>
</div>
<div class="paragraph">
<p>If your application relies on the previous behavior, you can rename your <code>connectionFactory</code> bean to <code>jmsConnectionFactory</code> or specifically configure your components to use your bean by using its current name.
See <a href="#jms">JMS Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="mail-changes"><a class="anchor" href="#mail-changes"></a>I.3.6. Mail Changes</h4>
<div class="paragraph">
<p>Some inconsistencies with rendering IMAP mail content have been resolved.
See <a href="#imap-format-important">the note in the &#8220;Mail-receiving Channel Adapter&#8221; section</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="feed-changes"><a class="anchor" href="#feed-changes"></a>I.3.7. Feed Changes</h4>
<div class="paragraph">
<p>Instead of the <code>com.rometools.fetcher.FeedFetcher</code>, which is deprecated in ROME, we introduced a new <code>Resource</code> property for the <code>FeedEntryMessageSource</code>.
See <a href="#feed">Feed Adapter</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="file-changes"><a class="anchor" href="#file-changes"></a>I.3.8. File Changes</h4>
<div class="paragraph">
<p>We introduced the new <code>FileHeaders.RELATIVE_PATH</code> message header to represent relative path in <code>FileReadingMessageSource</code>.</p>
</div>
<div class="paragraph">
<p>The tail adapter now supports <code>idleEventInterval</code> to emit events when there is no data in the file during that period.</p>
</div>
<div class="paragraph">
<p>The flush predicates for the <code>FileWritingMessageHandler</code> now have an additional parameter.</p>
</div>
<div class="paragraph">
<p>The file outbound channel adapter and gateway (<code>FileWritingMessageHandler</code>) now support the <code>REPLACE_IF_MODIFIED</code> <code>FileExistsMode</code>.</p>
</div>
<div class="paragraph">
<p>They also now support setting file permissions on the newly written file.</p>
</div>
<div class="paragraph">
<p>A new <code>FileSystemMarkerFilePresentFileListFilter</code> is now available.
See <a href="#file-incomplete">Dealing With Incomplete Data</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>FileSplitter</code> now provides a <code>firstLineAsHeader</code> option to carry the first line of content as a header in the messages emitted for the remaining lines.</p>
</div>
<div class="paragraph">
<p>See <a href="#files">File Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="ftp-and-sftp-changes"><a class="anchor" href="#ftp-and-sftp-changes"></a>I.3.9. FTP and SFTP Changes</h4>
<div class="paragraph">
<p>The inbound channel adapters now have a property called <code>max-fetch-size</code>, which is used to limit the number of files fetched during a poll when no files are currently in the local directory.
By default, they also are configured with a <code>FileSystemPersistentAcceptOnceFileListFilter</code> in the <code>local-filter</code>.</p>
</div>
<div class="paragraph">
<p>You can also provide a custom <code>DirectoryScanner</code> implementation to inbound channel adapters by setting the newly introduced <code>scanner</code> attribute.</p>
</div>
<div class="paragraph">
<p>You can now configure the regex and pattern filters to always pass directories.
This can be useful when you use recursion in the outbound gateways.</p>
</div>
<div class="paragraph">
<p>By default, all the inbound channel adapters (streaming and synchronization-based) now use an appropriate <code>AbstractPersistentAcceptOnceFileListFilter</code> implementation to prevent duplicate downloads of remote files.</p>
</div>
<div class="paragraph">
<p>The FTP and SFTP outbound gateways now support the <code>REPLACE_IF_MODIFIED</code> <code>FileExistsMode</code> when fetching remote files.</p>
</div>
<div class="paragraph">
<p>The FTP and SFTP streaming inbound channel adapters now add remote file information in a message header.</p>
</div>
<div class="paragraph">
<p>The FTP and SFTP outbound channel adapters (as well as the <code>PUT</code> command for outbound gateways) now support <code>InputStream</code> as <code>payload</code>, too.</p>
</div>
<div class="paragraph">
<p>The inbound channel adapters can now build file trees locally by using a newly introduced <code>RecursiveDirectoryScanner</code>.
See the <code>scanner</code> option in the <a href="#ftp-inbound">FTP Inbound Channel Adapter</a> section for injection.
Also, you can now switch these adapters to the <code>WatchService</code> instead.</p>
</div>
<div class="paragraph">
<p>We added The <code>NLST</code> command to the <code>AbstractRemoteFileOutboundGateway</code> to perform the list files names remote command.</p>
</div>
<div class="paragraph">
<p>You can now supply the <code>FtpOutboundGateway</code> with <code>workingDirExpression</code> to change the FTP client working directory for the current request message.</p>
</div>
<div class="paragraph">
<p>The <code>RemoteFileTemplate</code> is supplied now with the <code>invoke(OperationsCallback&lt;F, T&gt; action)</code> to perform several <code>RemoteFileOperations</code> calls in the scope of the same, thread-bounded, <code>Session</code>.</p>
</div>
<div class="paragraph">
<p>We added new filters for detecting incomplete remote files.</p>
</div>
<div class="paragraph">
<p>The <code>FtpOutboundGateway</code> and <code>SftpOutboundGateway</code> now support an option to remove the remote file after a successful transfer by using the <code>GET</code> or <code>MGET</code> commands.</p>
</div>
<div class="paragraph">
<p>See <a href="#ftp">FTP/FTPS Adapters</a> and <a href="#sftp">SFTP Adapters</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="integration-properties"><a class="anchor" href="#integration-properties"></a>I.3.10. Integration Properties</h4>
<div class="paragraph">
<p>Version 4.3.2 added a new <code>spring.integration.readOnly.headers</code> global property to let you customize the list of headers that should not be copied to a newly created <code>Message</code> by the <code>MessageBuilder</code>.
See <a href="#global-properties">Global Properties</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="stream-changes"><a class="anchor" href="#stream-changes"></a>I.3.11. Stream Changes</h4>
<div class="paragraph">
<p>We added a new option on the <code>CharacterStreamReadingMessageSource</code> to let it be used to &#8220;pipe&#8221; stdin and publish an application event when the pipe is closed.
See <a href="#stream-reading">Reading from Streams</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="barrier-changes"><a class="anchor" href="#barrier-changes"></a>I.3.12. Barrier Changes</h4>
<div class="paragraph">
<p>The <code>BarrierMessageHandler</code> now supports a discard channel to which late-arriving trigger messages are sent.
See <a href="#barrier">Thread Barrier</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="amqp-changes"><a class="anchor" href="#amqp-changes"></a>I.3.13. AMQP Changes</h4>
<div class="paragraph">
<p>The AMQP outbound endpoints now support setting a delay expression when you use the RabbitMQ Delayed Message Exchange plugin.</p>
</div>
<div class="paragraph">
<p>The inbound endpoints now support the Spring AMQP <code>DirectMessageListenerContainer</code>.</p>
</div>
<div class="paragraph">
<p>Pollable AMQP-backed channels now block the poller thread for the poller&#8217;s configured <code>receiveTimeout</code> (default: one second).</p>
</div>
<div class="paragraph">
<p>Headers, such as <code>contentType</code>, that are added to message properties by the message converter are now used in the final message.
Previously, it depended on the converter type as to which headers and message properties appeared in the final message.
To override the headers set by the converter, set the <code>headersMappedLast</code> property to <code>true</code>.
See <a href="#amqp">AMQP Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="http-changes"><a class="anchor" href="#http-changes"></a>I.3.14. HTTP Changes</h4>
<div class="paragraph">
<p>By default, the <code>DefaultHttpHeaderMapper.userDefinedHeaderPrefix</code> property is now an empty string instead of <code>X-</code>.
See <a href="#http-header-mapping">HTTP Header Mappings</a> for more information.</p>
</div>
<div class="paragraph">
<p>By default, <code>uriVariablesExpression</code> now uses a <code>SimpleEvaluationContext</code> (since 5.0.4).</p>
</div>
<div class="paragraph">
<p>See <a href="#mapping-uri-variables">Mapping URI Variables</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="mqtt-changes"><a class="anchor" href="#mqtt-changes"></a>I.3.15. MQTT Changes</h4>
<div class="paragraph">
<p>Inbound messages are now mapped with the <code>RECEIVED_TOPIC</code>, <code>RECEIVED_QOS</code>, and <code>RECEIVED_RETAINED</code> headers to avoid inadvertent propagation to outbound messages when an application relays messages.</p>
</div>
<div class="paragraph">
<p>The outbound channel adapter now supports expressions for the topic, qos, and retained properties.
The defaults remain the same.
See <a href="#mqtt">MQTT Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="stomp-changes"><a class="anchor" href="#stomp-changes"></a>I.3.16. STOMP Changes</h4>
<div class="paragraph">
<p>We changed the STOMP module to use <code>ReactorNettyTcpStompClient</code>, based on the Project Reactor <code>3.1</code> and <code>reactor-netty</code> extension.
We renamed <code>Reactor2TcpStompSessionManager</code> to <code>ReactorNettyTcpStompSessionManager</code>, according to the <code>ReactorNettyTcpStompClient</code> foundation.
See <a href="#stomp">STOMP Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="web-services-changes"><a class="anchor" href="#web-services-changes"></a>I.3.17. Web Services Changes</h4>
<div class="paragraph">
<p>You can now supply <code>WebServiceOutboundGateway</code> instances with an externally configured <code>WebServiceTemplate</code> instances.</p>
</div>
<div class="paragraph">
<p><code>DefaultSoapHeaderMapper</code> can now map a <code>javax.xml.transform.Source</code> user-defined header to a SOAP header element.</p>
</div>
<div class="paragraph">
<p>Simple WebService inbound and outbound gateways can now deal with the complete <code>WebServiceMessage</code> as a <code>payload</code>, allowing the manipulation of MTOM attachments.</p>
</div>
<div class="paragraph">
<p>See <a href="#ws">Web Services Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis-changes"><a class="anchor" href="#redis-changes"></a>I.3.18. Redis Changes</h4>
<div class="paragraph">
<p>The <code>RedisStoreWritingMessageHandler</code> is supplied now with additional <code>String</code>-based setters for SpEL expressions (for convenience with Java configuration).
You can now configure the <code>zsetIncrementExpression</code> on the <code>RedisStoreWritingMessageHandler</code> as well.
In addition, this property has been changed from <code>true</code> to <code>false</code> since the <code>INCR</code> option on <code>ZADD</code> Redis command is optional.</p>
</div>
<div class="paragraph">
<p>You can now supply the <code>RedisInboundChannelAdapter</code> with an <code>Executor</code> for executing Redis listener invokers.
In addition, the received messages now contain a <code>RedisHeaders.MESSAGE_SOURCE</code> header to indicate the source of the message (topic or pattern).</p>
</div>
<div class="paragraph">
<p>See <a href="#redis">Redis Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcp-changes"><a class="anchor" href="#tcp-changes"></a>I.3.19. TCP Changes</h4>
<div class="paragraph">
<p>We added a new <code>ThreadAffinityClientConnectionFactory</code> to bind TCP connections to threads.</p>
</div>
<div class="paragraph">
<p>You can now configure the TCP connection factories to support <code>PushbackInputStream</code> instances, letting deserializers &#8220;unread&#8221; (push back) bytes after &#8220;reading ahead&#8221;.</p>
</div>
<div class="paragraph">
<p>We added a <code>ByteArrayElasticRawDeserializer</code> without <code>maxMessageSize</code> to control and buffer incoming data as needed.</p>
</div>
<div class="paragraph">
<p>See <a href="#ip">TCP and UDP Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="gemfire-changes"><a class="anchor" href="#gemfire-changes"></a>I.3.20. Gemfire Changes</h4>
<div class="paragraph">
<p>The <code>GemfireMetadataStore</code> now implements <code>ListenableMetadataStore</code>, letting you listen to cache events by providing <code>MetadataStoreListener</code> instances to the store.
See <a href="#gemfire">Pivotal GemFire and Apache Geode Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-changes"><a class="anchor" href="#jdbc-changes"></a>I.3.21. JDBC Changes</h4>
<div class="paragraph">
<p>The <code>JdbcMessageChannelStore</code> now provides a setter for <code>ChannelMessageStorePreparedStatementSetter</code>, letting you customize message insertion in the store.</p>
</div>
<div class="paragraph">
<p>The <code>ExpressionEvaluatingSqlParameterSourceFactory</code> now provides a setter for <code>sqlParameterTypes</code>, letting you customize the SQL types of the parameters.</p>
</div>
<div class="paragraph">
<p>See <a href="#jdbc">JDBC Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="metrics-changes"><a class="anchor" href="#metrics-changes"></a>I.3.22. Metrics Changes</h4>
<div class="paragraph">
<p><a href="https://micrometer.io/">Micrometer</a> application monitoring is now supported (since version 5.0.2).
See <a href="#micrometer-integration">Micrometer Integration</a> for more information.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Changes were made to the Micrometer <code>Meters</code> in version 5.0.3 to make them more suitable for use in dimensional systems.
Further changes were made in 5.0.4.
If you usie Micrometer, we recommend a minimum of version 5.0.4.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="endpointid-annotations"><a class="anchor" href="#endpointid-annotations"></a>I.3.23. <code>@EndpointId</code> Annotations</h4>
<div class="paragraph">
<p>Introduced in version 5.0.4, this annotation provides control over bean naming when you use Java configuration.
See <a href="#endpoint-bean-names">Endpoint Bean Names</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-4.2-4.3"><a class="anchor" href="#migration-4.2-4.3"></a>I.4. Changes between 4.2 and 4.3</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.2-to-4.3-Migration-Guide">Migration Guide</a>
for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">Wiki</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="x4.3-new-components"><a class="anchor" href="#x4.3-new-components"></a>I.5. New Components</h3>
<div class="paragraph">
<p>Version 4.3 added a number of new components.</p>
</div>
<div class="sect3">
<h4 id="amqp-async-outbound-gateway-2"><a class="anchor" href="#amqp-async-outbound-gateway-2"></a>I.5.1. AMQP Async Outbound Gateway</h4>
<div class="paragraph">
<p>See <a href="#amqp-async-outbound-gateway">Asynchronous Outbound Gateway</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="messagegroupfactory"><a class="anchor" href="#messagegroupfactory"></a>I.5.2. <code>MessageGroupFactory</code></h4>
<div class="paragraph">
<p>We introduced the <code>MessageGroupFactory</code> strategy to allow control over <code>MessageGroup</code> instances in <code>MessageGroupStore</code> logic.
We added <code>SimpleMessageGroupFactory</code> implementation for the <code>SimpleMessageGroup</code>, with the <code>GroupType.HASH_SET</code> as the default
factory for the standard <code>MessageGroupStore</code> implementations.
See <a href="#message-store">Message Store</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="persistentmessagegroup"><a class="anchor" href="#persistentmessagegroup"></a>I.5.3. <code>PersistentMessageGroup</code></h4>
<div class="paragraph">
<p>We added the <code>PersistentMessageGroup</code> (lazy-load proxy) implementation for persistent <code>MessageGroupStore</code> instances,
which return this instance for the <code>getMessageGroup()</code> when their <code>lazyLoadMessageGroups</code> is <code>true</code> (the default).
See <a href="#message-store">Message Store</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="ftp-and-sftp-streaming-inbound-channel-adapters"><a class="anchor" href="#ftp-and-sftp-streaming-inbound-channel-adapters"></a>I.5.4. FTP and SFTP Streaming Inbound Channel Adapters</h4>
<div class="paragraph">
<p>We added inbound channel adapters that return an <code>InputStream</code> for each file, letting you retrieve remote files without writing them to the local file system.
See <a href="#ftp-streaming">FTP Streaming Inbound Channel Adapter</a> and <a href="#sftp-streaming">SFTP Streaming Inbound Channel Adapter</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="streamtransformer"><a class="anchor" href="#streamtransformer"></a>I.5.5. <code>StreamTransformer</code></h4>
<div class="paragraph">
<p>We added <code>StreamTransformer</code> to transform an <code>InputStream</code> payload to either a <code>byte[]</code> or a <code>String</code>.
See <a href="#stream-transformer">Stream Transformer</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="integration-graph-2"><a class="anchor" href="#integration-graph-2"></a>I.5.6. Integration Graph</h4>
<div class="paragraph">
<p>We added <code>IntegrationGraphServer</code>, together with the <code>IntegrationGraphController</code> REST service, to expose the runtime model of a Spring Integration application as a graph.
See <a href="#integration-graph">Integration Graph</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-lock-registry-2"><a class="anchor" href="#jdbc-lock-registry-2"></a>I.5.7. JDBC Lock Registry</h4>
<div class="paragraph">
<p>We added <code>JdbcLockRegistry</code> for distributed locks shared through a database table.
See <a href="#jdbc-lock-registry">JDBC Lock Registry</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="leaderinitiator-for-lockregistry"><a class="anchor" href="#leaderinitiator-for-lockregistry"></a>I.5.8. <code>LeaderInitiator</code> for <code>LockRegistry</code></h4>
<div class="paragraph">
<p>We added <code>LeaderInitiator</code> implementation based on the <code>LockRegistry</code> strategy.
See <a href="#leadership-event-handling">Leadership Event Handling</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x4.3-general"><a class="anchor" href="#x4.3-general"></a>I.6. General Changes</h3>
<div class="paragraph">
<p>This section describes general changes that version 4.3 brought to Spring Integration.</p>
</div>
<div class="sect3">
<h4 id="core-changes-2"><a class="anchor" href="#core-changes-2"></a>I.6.1. Core Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the core of Spring Integration.</p>
</div>
<div class="sect4">
<h5 id="outbound-gateway-within-a-chain"><a class="anchor" href="#outbound-gateway-within-a-chain"></a>Outbound Gateway within a Chain</h5>
<div class="paragraph">
<p>Previously, you could specify a <code>reply-channel</code> on an outbound gateway within a chain.
It was completely ignored.
The gateway&#8217;s reply goes to the next chain element or, if the gateway is the last element, to the chain&#8217;s output channel.
This condition is now detected and disallowed.
If you have such a configuration, remove the <code>reply-channel</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-service-activator"><a class="anchor" href="#asynchronous-service-activator"></a>Asynchronous Service Activator</h5>
<div class="paragraph">
<p>We added an option to make the service activator be synchronous.
See <a href="#async-service-activator">Asynchronous Service Activator</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="messaging-annotation-support-changes"><a class="anchor" href="#messaging-annotation-support-changes"></a>Messaging Annotation Support changes</h5>
<div class="paragraph">
<p>The messaging annotation support does not require a <code>@MessageEndpoint</code> (or any other <code>@Component</code>) annotation declaration on the class level.
To restore the previous behavior, set the <code>spring.integration.messagingAnnotations.require.componentAnnotation</code> of
<code>spring.integration.properties</code> to <code>true</code>.
See <a href="#global-properties">Global Properties</a> and <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-changes-2"><a class="anchor" href="#mail-changes-2"></a>I.6.2. Mail Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration Mail functionality.</p>
</div>
<div class="sect4">
<h5 id="customizable-user-flag"><a class="anchor" href="#customizable-user-flag"></a>Customizable User Flag</h5>
<div class="paragraph">
<p>The customizable <code>userFlag</code> (added in 4.2.2 to provide customization of the flag used to denote that the mail has been
seen) is now available in the XML namespace.
See <a href="#imap-seen">Marking IMAP Messages When <code>\Recent</code> Is Not Supported</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="mail-message-mapping"><a class="anchor" href="#mail-message-mapping"></a>Mail Message Mapping</h5>
<div class="paragraph">
<p>You can now map inbound mail messages with the <code>MessageHeaders</code> containing the mail headers and the payload containing the email content.
Previously, the payload was always the raw <code>MimeMessage</code>.
See <a href="#mail-mapping">Inbound Mail Message Mapping</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-changes-2"><a class="anchor" href="#jms-changes-2"></a>I.6.3. JMS Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration JMS functionality.</p>
</div>
<div class="sect4">
<h5 id="header-mapper"><a class="anchor" href="#header-mapper"></a>Header Mapper</h5>
<div class="paragraph">
<p>The <code>DefaultJmsHeaderMapper</code> now maps the standard <code>correlationId</code> header as a message property by invoking its <code>toString()</code> method.
See <a href="#jms-header-mapping">Mapping Message Headers to and from JMS Message</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-gateway"><a class="anchor" href="#asynchronous-gateway"></a>Asynchronous Gateway</h5>
<div class="paragraph">
<p>The JMS outbound gateway now has an <code>async</code> property.
See <a href="#jms-async-gateway">Async Gateway</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aggregator-changes"><a class="anchor" href="#aggregator-changes"></a>I.6.4. Aggregator Changes</h4>
<div class="paragraph">
<p>There is a change in behavior when a POJO aggregator releases a collection of <code>Message&lt;?&gt;</code> objects.
This is rare, but, if your application does that, you need to make a small change to your POJO.
See this <a href="#agg-message-collection">[agg-message-collection]</a> note for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcpudp-changes"><a class="anchor" href="#tcpudp-changes"></a>I.6.5. TCP/UDP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration TCP/UDP functionality.</p>
</div>
<div class="sect4">
<h5 id="events"><a class="anchor" href="#events"></a>Events</h5>
<div class="paragraph">
<p>A new <code>TcpConnectionServerListeningEvent</code> is emitted when a server connection factory is started.
See <a href="#tcp-events">TCP Connection Events</a> for more information.</p>
</div>
<div class="paragraph">
<p>You can now use the <code>destination-expression</code> and <code>socket-expression</code> attributes on <code>&lt;int-ip:udp-outbound-channel-adapter&gt;</code>.
See <a href="#udp-adapters">UDP Adapters</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="stream-deserializers"><a class="anchor" href="#stream-deserializers"></a>Stream Deserializers</h5>
<div class="paragraph">
<p>The various deserializers that cannot allocate the final buffer until the whole message has been assembled now support pooling the raw buffer into which the data is received rather than creating and discarding a buffer for each message.
See <a href="#tcp-connection-factories">TCP Connection Factories</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="tcp-message-mapper"><a class="anchor" href="#tcp-message-mapper"></a>TCP Message Mapper</h5>
<div class="paragraph">
<p>The message mapper now, optionally, sets a configured content type header.
See <a href="#ip-msg-headers">IP Message Headers</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="file-changes-2"><a class="anchor" href="#file-changes-2"></a>I.6.6. File Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration File functionality.</p>
</div>
<div class="sect4">
<h5 id="destination-directory-creation"><a class="anchor" href="#destination-directory-creation"></a>Destination Directory Creation</h5>
<div class="paragraph">
<p>The generated file name for the <code>FileWritingMessageHandler</code> can represent a sub-path to save the desired directory structure for a file in the target directory.
See <a href="#file-writing-file-names">Generating File Names</a> for more information.</p>
</div>
<div class="paragraph">
<p>The <code>FileReadingMessageSource</code> now hides the <code>WatchService</code> directory scanning logic in the inner class.
We added the <code>use-watch-service</code> and <code>watch-events</code> options to enable this behavior.
We deprecated the top-level <code>WatchServiceDirectoryScanner</code> because of inconsistency around the API.
See <a href="#watch-service-directory-scanner"><code>WatchServiceDirectoryScanner</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="buffer-size"><a class="anchor" href="#buffer-size"></a>Buffer Size</h5>
<div class="paragraph">
<p>When writing files, you can now specify the buffer size.</p>
</div>
</div>
<div class="sect4">
<h5 id="appending-and-flushing"><a class="anchor" href="#appending-and-flushing"></a>Appending and Flushing</h5>
<div class="paragraph">
<p>You can now avoid flushing files when appending and use a number of strategies to flush the data during idle periods.
See <a href="#file-flushing">Flushing Files When Using <code>APPEND_NO_FLUSH</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="preserving-timestamps"><a class="anchor" href="#preserving-timestamps"></a>Preserving Timestamps</h5>
<div class="paragraph">
<p>You can now configure the outbound channel adapter to set the destination file&#8217;s <code>lastmodified</code> timestamp.
See <a href="#file-timestamps">File Timestamps</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="splitter-changes-2"><a class="anchor" href="#splitter-changes-2"></a>Splitter Changes</h5>
<div class="paragraph">
<p>The <code>FileSplitter</code> now automatically closes an FTP or SFTP session when the file is completely read.
This applies when the outbound gateway returns an <code>InputStream</code> or when you use the new FTP or SFTP streaming channel adapters.
We also introduced a new <code>markers-json</code> option to convert <code>FileSplitter.FileMarker</code> to JSON <code>String</code> for relaxed downstream network interaction.
See <a href="#file-splitter">File Splitter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="file-filters"><a class="anchor" href="#file-filters"></a>File Filters</h5>
<div class="paragraph">
<p>We added <code>ChainFileListFilter</code> as an alternative to <code>CompositeFileListFilter</code>.
See <a href="#file-reading">Reading Files</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="amqp-changes-2"><a class="anchor" href="#amqp-changes-2"></a>I.6.7. AMQP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration AMQP functionality.</p>
</div>
<div class="sect4">
<h5 id="content-type-message-converter"><a class="anchor" href="#content-type-message-converter"></a>Content Type Message Converter</h5>
<div class="paragraph">
<p>The outbound endpoints now support a <code>RabbitTemplate</code> configured with a <code>ContentTypeDelegatingMessageConverter</code> such
that you can choose the converter based on the message content type.
See <a href="#content-type-conversion-outbound">Outbound Message Conversion</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-for-delayed-message-handling"><a class="anchor" href="#headers-for-delayed-message-handling"></a>Headers for Delayed Message Handling</h5>
<div class="paragraph">
<p>Spring AMQP 1.6 adds support for <a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/">delayed message exchanges</a>.
Header mapping now supports the headers (<code>amqp_delay</code> and <code>amqp_receivedDelay</code>) used by this feature.</p>
</div>
</div>
<div class="sect4">
<h5 id="amqp-backed-channels"><a class="anchor" href="#amqp-backed-channels"></a>AMQP-Backed Channels</h5>
<div class="paragraph">
<p>AMQP-backed channels now support message mapping.
See <a href="#amqp-channels">AMQP-backed Message Channels</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis-changes-2"><a class="anchor" href="#redis-changes-2"></a>I.6.8. Redis Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration Redis functionality.</p>
</div>
<div class="sect4">
<h5 id="list-pushpop-direction"><a class="anchor" href="#list-pushpop-direction"></a>List Push/Pop Direction</h5>
<div class="paragraph">
<p>Previously, the queue channel adapters always used the Redis list in a fixed direction, pushing to the left end and reading from the right end.
You can now configure the reading and writing direction with the <code>rightPop</code> and <code>leftPush</code> options for the
<code>RedisQueueMessageDrivenEndpoint</code> and <code>RedisQueueOutboundChannelAdapter</code>, respectively.
See <a href="#redis-queue-inbound-channel-adapter">Redis Queue Inbound Channel Adapter</a> and <a href="#redis-queue-outbound-channel-adapter">Redis Queue Outbound Channel Adapter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="queue-inbound-gateway-default-serializer"><a class="anchor" href="#queue-inbound-gateway-default-serializer"></a>Queue Inbound Gateway Default Serializer</h5>
<div class="paragraph">
<p>The default serializer in the inbound gateway has been changed to a <code>JdkSerializationRedisSerializer</code> for compatibility with the outbound gateway.
See <a href="#redis-queue-inbound-gateway">Redis Queue Inbound Gateway</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http-changes-2"><a class="anchor" href="#http-changes-2"></a>I.6.9. HTTP Changes</h4>
<div class="paragraph">
<p>Previously, with requests that had a body (such as <code>POST</code>) that had no <code>content-type</code> header, the body was ignored.
With this release, the content type of such requests is considered to be <code>application/octet-stream</code> as recommended
by RFC 2616.
See <a href="#http-inbound">Http Inbound Components</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>uriVariablesExpression</code> now uses a <code>SimpleEvaluationContext</code> by default (since 4.3.15).
See <a href="#mapping-uri-variables">Mapping URI Variables</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="sftp-changes"><a class="anchor" href="#sftp-changes"></a>I.6.10. SFTP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration SFTP functionality.</p>
</div>
<div class="sect4">
<h5 id="factory-bean"><a class="anchor" href="#factory-bean"></a>Factory Bean</h5>
<div class="paragraph">
<p>We added a new factory bean to simplify the configuration of Jsch proxies for SFTP.
See <a href="#sftp-proxy-factory-bean">Proxy Factory Bean</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="chmod-changes"><a class="anchor" href="#chmod-changes"></a><code>chmod</code> Changes</h5>
<div class="paragraph">
<p>The SFTP outbound gateway (for <code>put</code> and <code>mput</code> commands) and the SFTP outbound channel adapter now support the <code>chmod</code> attribute to change the remote file permissions after uploading.
See <code><a href="#sftp-outbound">SFTP Outbound Channel Adapter</a></code> and <code><a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a></code> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ftp-changes"><a class="anchor" href="#ftp-changes"></a>I.6.11. FTP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration FTP functionality.</p>
</div>
<div class="sect4">
<h5 id="session-changes"><a class="anchor" href="#session-changes"></a>Session Changes</h5>
<div class="paragraph">
<p>The <code>FtpSession</code> now supports <code>null</code> for the <code>list()</code> and <code>listNames()</code> methods, since underlying FTP Client can use it.
With that, you can now configure the <code>FtpOutboundGateway</code> without the <code>remoteDirectory</code> expression.
You can also configure the <code>&lt;int-ftp:inbound-channel-adapter&gt;</code> without <code>remote-directory</code> or <code>remote-directory-expression</code>.
See <a href="#ftp">FTP/FTPS Adapters</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="router-changes"><a class="anchor" href="#router-changes"></a>I.6.12. Router Changes</h4>
<div class="paragraph">
<p>The <code>ErrorMessageExceptionTypeRouter</code> now supports the <code>Exception</code> superclass mappings to avoid duplication for the same channel in case of multiple inheritors.
For this purpose, the <code>ErrorMessageExceptionTypeRouter</code> loads mapping classes during initialization to fail-fast for a <code>ClassNotFoundException</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#router">Routers</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="header-mapping"><a class="anchor" href="#header-mapping"></a>I.6.13. Header Mapping</h4>
<div class="paragraph">
<p>This section describes the changes to header mapping between version 4.2 and 4.3.</p>
</div>
<div class="sect4">
<h5 id="general"><a class="anchor" href="#general"></a>General</h5>
<div class="paragraph">
<p>AMQP, WS, and XMPP header mappings (such as <code>request-header-mapping</code> and <code>reply-header-mapping</code>) now support negated patterns.
See <a href="#amqp-message-headers">AMQP Message Headers</a>, <a href="#ws-message-headers">WS Message Headers</a>, and <a href="#xmpp-message-headers">XMPP Message Headers</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="amqp-header-mapping"><a class="anchor" href="#amqp-header-mapping"></a>AMQP Header Mapping</h5>
<div class="paragraph">
<p>Previously, only standard AMQP headers were mapped by default.
You had to explicitly enable mapping of user-defined headers.
With this release, all headers are mapped by default.
In addition, the inbound <code>amqp_deliveryMode</code> header is no longer mapped by default.
See <a href="#amqp-message-headers">AMQP Message Headers</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="groovy-scripts"><a class="anchor" href="#groovy-scripts"></a>I.6.14. Groovy Scripts</h4>
<div class="paragraph">
<p>You can now configure groovy scripts with the <code>compile-static</code> hint or any other <code>CompilerConfiguration</code> options.
See <a href="#groovy-config">Groovy Configuration</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="inboundchanneladapter-changes"><a class="anchor" href="#inboundchanneladapter-changes"></a>I.6.15. <code>@InboundChannelAdapter</code> Changes</h4>
<div class="paragraph">
<p>The <code>@InboundChannelAdapter</code> now has an alias <code>channel</code> attribute for the regular <code>value</code>.
In addition, the target <code>SourcePollingChannelAdapter</code> components can now resolve the target <code>outputChannel</code> bean from its provided name (<code>outputChannelName</code> options) in a late-binding manner.
See <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="xmpp-changes"><a class="anchor" href="#xmpp-changes"></a>I.6.16. XMPP Changes</h4>
<div class="paragraph">
<p>The XMPP channel adapters now support the XMPP Extensions (XEP).
See <a href="#xmpp-extensions">XMPP Extensions</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="wiretap-late-binding"><a class="anchor" href="#wiretap-late-binding"></a>I.6.17. WireTap Late Binding</h4>
<div class="paragraph">
<p>The <code>WireTap</code> <code>ChannelInterceptor</code> now can accept a <code>channelName</code> that is resolved to the target <code>MessageChannel</code>
later, during the first active interceptor operation.
See <a href="#channel-wiretap">Wire Tap</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="channelmessagestorequeryprovider-changes"><a class="anchor" href="#channelmessagestorequeryprovider-changes"></a>I.6.18. <code>ChannelMessageStoreQueryProvider</code> Changes</h4>
<div class="paragraph">
<p>The <code>ChannelMessageStoreQueryProvider</code> now supports H2 databases.
See <a href="#jdbc-message-store-channels">Backing Message Channels</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-changes"><a class="anchor" href="#websocket-changes"></a>I.6.19. WebSocket Changes</h4>
<div class="paragraph">
<p>The <code>ServerWebSocketContainer</code> now exposes an <code>allowedOrigins</code> option, and <code>SockJsServiceOptions</code> exposes a <code>suppressCors</code> option.
See <a href="#web-sockets">WebSockets Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-4.1-4.2"><a class="anchor" href="#migration-4.1-4.2"></a>I.7. Changes between 4.1 and 4.2</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.1-to-4.2-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="x4.2-new-components"><a class="anchor" href="#x4.2-new-components"></a>I.8. New Components</h3>
<div class="paragraph">
<p>Version 4.2 added a number of new components.</p>
</div>
<div class="sect3">
<h4 id="x4.2-JMX"><a class="anchor" href="#x4.2-JMX"></a>I.8.1. Major Management/JMX Rework</h4>
<div class="paragraph">
<p>We added a new <code>MetricsFactory</code> strategy interface.
This change, together with other changes in the JMX and management infrastructure, provides much more control over management configuration and runtime performance.</p>
</div>
<div class="paragraph">
<p>However, this has some important implications for (some) user environments.</p>
</div>
<div class="paragraph">
<p>For complete details, see <a href="#metrics-management">Metrics and Management</a> and <a href="#jmx-42-improvements">JMX Improvements</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-mongodb-metadata-store"><a class="anchor" href="#x4.2-mongodb-metadata-store"></a>I.8.2. MongoDB Metadata Store</h4>
<div class="paragraph">
<p>The <code>MongoDbMetadataStore</code> is now available.
For more information, see <a href="#mongodb-metadata-store">MongoDB Metadata Store</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-secured-channel-annotation"><a class="anchor" href="#x4.2-secured-channel-annotation"></a>I.8.3. SecuredChannel Annotation</h4>
<div class="paragraph">
<p>We introduced the <code>@SecuredChannel</code> annotation, replacing the deprecated <code>ChannelSecurityInterceptorFactoryBean</code>.
For more information, see <a href="#security">Security in Spring Integration</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-security-context-propagation"><a class="anchor" href="#x4.2-security-context-propagation"></a>I.8.4. <code>SecurityContext</code> Propagation</h4>
<div class="paragraph">
<p>We introduced the <code>SecurityContextPropagationChannelInterceptor</code> for the <code>SecurityContext</code> propagation from one message flow&#8217;s thread to another.
For more information, see <a href="#security">Security in Spring Integration</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-file-splitter"><a class="anchor" href="#x4.2-file-splitter"></a>I.8.5. FileSplitter</h4>
<div class="paragraph">
<p>In 4.1.2, we added <code>FileSplitter</code>, which splits text files into lines.
It now has full support in the <code>int-file:</code> namespace.
See <a href="#file-splitter">File Splitter</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-zk"><a class="anchor" href="#x4.2-zk"></a>I.8.6. Zookeeper Support</h4>
<div class="paragraph">
<p>We added Zookeeper support to the framework to assist when running on a clustered or multi-host environment.
The change impacts the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ZookeeperMetadataStore</code></p>
</li>
<li>
<p><code>ZookeeperLockRegistry</code></p>
</li>
<li>
<p>Zookeeper Leadership</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#zookeeper">Zookeeper Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-barrier"><a class="anchor" href="#x4.2-barrier"></a>I.8.7. Thread Barrier</h4>
<div class="paragraph">
<p>A new thread <code>&lt;int:barrier/&gt;</code> component is available, letting a thread be suspended until some asynchronous event occurs.
See <a href="#barrier">Thread Barrier</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-stomp"><a class="anchor" href="#x4.2-stomp"></a>I.8.8. STOMP Support</h4>
<div class="paragraph">
<p>We added STOMP support to the framework as an inbound and outbound channel adapters pair.
See <a href="#stomp">STOMP Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-codec"><a class="anchor" href="#x4.2-codec"></a>I.8.9. Codec</h4>
<div class="paragraph">
<p>A new <code>Codec</code> abstraction has been introduced, to encode and decode objects to and from <code>byte[]</code>.
We added an implementation that uses Kryo.
We also added codec-based transformers and message converters.
See <a href="#codec">Codec</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-prepared-statement-setter"><a class="anchor" href="#x4.2-prepared-statement-setter"></a>I.8.10. Message PreparedStatement Setter</h4>
<div class="paragraph">
<p>A new <code>MessagePreparedStatementSetter</code> functional interface callback is available for the <code>JdbcMessageHandler</code> (<code>&lt;int-jdbc:outbound-gateway&gt;</code> and <code>&lt;int-jdbc:outbound-channel-adapter&gt;</code>) as an alternative to using <code>SqlParameterSourceFactory</code> to populate parameters on the <code>PreparedStatement</code> with the <code>requestMessage</code> context.
See <a href="#jdbc-outbound-channel-adapter">Outbound Channel Adapter</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x4.2-general"><a class="anchor" href="#x4.2-general"></a>I.9. General Changes</h3>
<div class="paragraph">
<p>This section describes general changes from version 4.1 to version 4.2.</p>
</div>
<div class="sect3">
<h4 id="x4.2-wire-tap"><a class="anchor" href="#x4.2-wire-tap"></a>I.9.1. WireTap</h4>
<div class="paragraph">
<p>As an alternative to the existing <code>selector</code> attribute, the <code>&lt;wire-tap/&gt;</code> element now supports the <code>selector-expression</code> attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-file-changes"><a class="anchor" href="#x4.2-file-changes"></a>I.9.2. File Changes</h4>
<div class="paragraph">
<p>See <a href="#files">File Support</a> for more information about these changes.</p>
</div>
<div class="sect4">
<h5 id="appending-new-lines"><a class="anchor" href="#appending-new-lines"></a>Appending New Lines</h5>
<div class="paragraph">
<p>The <code>&lt;int-file:outbound-channel-adapter&gt;</code> and <code>&lt;int-file:outbound-gateway&gt;</code> now support an <code>append-new-line</code> attribute.
If set to <code>true</code>, a new line is appended to the file after a message is written.
The default attribute value is <code>false</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ignoring-hidden-files"><a class="anchor" href="#ignoring-hidden-files"></a>Ignoring Hidden Files</h5>
<div class="paragraph">
<p>We added the <code>ignore-hidden</code> attribute for the <code>&lt;int-file:inbound-channel-adapter&gt;</code> to let you set whether to pick up hidden files from the source directory.
It defaults to <code>true</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="writing-inputstream-payloads"><a class="anchor" href="#writing-inputstream-payloads"></a>Writing <code>InputStream</code> Payloads</h5>
<div class="paragraph">
<p>The <code>FileWritingMessageHandler</code> now also accepts <code>InputStream</code> as a valid message payload type.</p>
</div>
</div>
<div class="sect4">
<h5 id="headdirectoryscanner"><a class="anchor" href="#headdirectoryscanner"></a><code>HeadDirectoryScanner</code></h5>
<div class="paragraph">
<p>You can now use the <code>HeadDirectoryScanner</code> with other <code>FileListFilter</code> implementations.</p>
</div>
</div>
<div class="sect4">
<h5 id="last-modified-filter"><a class="anchor" href="#last-modified-filter"></a>Last Modified Filter</h5>
<div class="paragraph">
<p>We added the <code>LastModifiedFileListFilter</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="watch-service-directory-scanner-2"><a class="anchor" href="#watch-service-directory-scanner-2"></a>Watch Service Directory Scanner</h5>
<div class="paragraph">
<p>We added the <code>WatchServiceDirectoryScanner</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="persistent-file-list-filter-changes"><a class="anchor" href="#persistent-file-list-filter-changes"></a>Persistent File List Filter Changes</h5>
<div class="paragraph">
<p>The <code>AbstractPersistentFileListFilter</code> has a new property (<code>flushOnUpdate</code>) which, when set to <code>true</code>, calls <code>flush()</code> on the metadata store if it implements <code>Flushable</code> (for example, <code>PropertiesPersistingMetadataStore</code>).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-class-package-change"><a class="anchor" href="#x4.2-class-package-change"></a>I.9.3. Class Package Change</h4>
<div class="paragraph">
<p>We moved the <code>ScatterGatherHandler</code> class from the <code>org.springframework.integration.handler</code> to the <code>org.springframework.integration.scattergather</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="tcp-changes-2"><a class="anchor" href="#tcp-changes-2"></a>I.9.4. TCP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration TCP functionality.</p>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-serializers"><a class="anchor" href="#x4.2-tcp-serializers"></a>TCP Serializers</h5>
<div class="paragraph">
<p>The TCP <code>Serializers</code> no longer <code>flush()</code> the <code>OutputStream</code>.
This is now done by the <code>TcpNxxConnection</code> classes.
If you use the serializers directly within your code, you may have to <code>flush()</code> the <code>OutputStream</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-server-exceptions"><a class="anchor" href="#x4.2-tcp-server-exceptions"></a>Server Socket Exceptions</h5>
<div class="paragraph">
<p><code>TcpConnectionServerExceptionEvent</code> instances are now published whenever an unexpected exception occurs on a TCP server socket (also added to 4.1.3 and 4.0.7).
See <a href="#tcp-events">TCP Connection Events</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-server-port"><a class="anchor" href="#x4.2-tcp-server-port"></a>TCP Server Port</h5>
<div class="paragraph">
<p>If you configure a TCP server socket factory to listen on a random port, you can now obtain the actual port chosen by the OS by using <code>getPort()</code>.
<code>getServerSocketAddress()</code> is also available.</p>
</div>
<div class="paragraph">
<p>See "<a href="#tcp-connection-factories">TCP Connection Factories</a>" for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-gw-rto"><a class="anchor" href="#x4.2-tcp-gw-rto"></a>TCP Gateway Remote Timeout</h5>
<div class="paragraph">
<p>The <code>TcpOutboundGateway</code> now supports <code>remote-timeout-expression</code> as an alternative to the existing <code>remote-timeout</code> attribute.
This allows setting the timeout based on each message.</p>
</div>
<div class="paragraph">
<p>Also, the <code>remote-timeout</code> no longer defaults to the same value as <code>reply-timeout</code>, which has a completely different meaning.</p>
</div>
<div class="paragraph">
<p>See <a href="#tcp-ob-gateway-attributes">TCP Outbound Gateway Attributes</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-ssl"><a class="anchor" href="#x4.2-tcp-ssl"></a>TCP SSLSession Available for Header Mapping</h5>
<div class="paragraph">
<p><code>TcpConnection</code> implementations now support <code>getSslSession()</code> to let you extract information from the session to add to message headers.
See <a href="#ip-msg-headers">IP Message Headers</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.2-tcp-events"><a class="anchor" href="#x4.2-tcp-events"></a>TCP Events</h5>
<div class="paragraph">
<p>New events are now published whenever a correlation exception occurs&#8201;&#8212;&#8201;such as sending a message to a non-existent socket.</p>
</div>
<div class="paragraph">
<p>The <code>TcpConnectionEventListeningMessageProducer</code> is deprecated.
Use the generic event adapter instead.</p>
</div>
<div class="paragraph">
<p>See <a href="#tcp-events">TCP Connection Events</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-inbound-channel-adapter-annotation"><a class="anchor" href="#x4.2-inbound-channel-adapter-annotation"></a>I.9.5. <code>@InboundChannelAdapter</code> Changes</h4>
<div class="paragraph">
<p>Previously, the <code>@Poller</code> on an inbound channel adapter defaulted the <code>maxMessagesPerPoll</code> attribute to <code>-1</code> (infinity).
This was inconsistent with the XML configuration of <code>&lt;inbound-channel-adapter/&gt;</code>, which defaults to <code>1</code>.
The annotation now defaults this attribute to <code>1</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-api-changes"><a class="anchor" href="#x4.2-api-changes"></a>I.9.6. API Changes</h4>
<div class="paragraph">
<p><code>o.s.integration.util.FunctionIterator</code> now requires a <code>o.s.integration.util.Function</code> instead of a <code>reactor.function.Function</code>.
This was done to remove an unnecessary hard dependency on Reactor.
Any uses of this iterator need to change the import.</p>
</div>
<div class="paragraph">
<p>Reactor is still supported for functionality such as the <code>Promise</code> gateway.
The dependency was removed for those users who do not need it.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-jms-changes"><a class="anchor" href="#x4.2-jms-changes"></a>I.9.7. JMS Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration TCP functionality.</p>
</div>
<div class="sect4">
<h5 id="reply-listener-lazy-initialization"><a class="anchor" href="#reply-listener-lazy-initialization"></a>Reply Listener Lazy Initialization</h5>
<div class="paragraph">
<p>You can now configure the reply listener in JMS outbound gateways to be initialized on-demand and stopped after an idle period, instead of being controlled by the gateway&#8217;s lifecycle.
See <a href="#jms-outbound-gateway">Outbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="conversion-errors-in-message-driven-endpoints"><a class="anchor" href="#conversion-errors-in-message-driven-endpoints"></a>Conversion Errors in Message-Driven Endpoints</h5>
<div class="paragraph">
<p>The <code>error-channel</code> is now used for the conversion errors.
In previous versions, they caused transaction rollback and message redelivery.</p>
</div>
<div class="paragraph">
<p>See <a href="#jms-message-driven-channel-adapter">Message-driven Channel Adapter</a> and <a href="#jms-inbound-gateway">Inbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="default-acknowledge-mode"><a class="anchor" href="#default-acknowledge-mode"></a>Default Acknowledge Mode</h5>
<div class="paragraph">
<p>When using an implicitly defined <code>DefaultMessageListenerContainer</code>, the default <code>acknowledge</code> is now <code>transacted</code>.
We recommend using <code>transacted</code> when using this container, to avoid message loss.
This default now applies to the message-driven inbound adapter and the inbound gateway.
It was already the default for JMS-backed channels.</p>
</div>
<div class="paragraph">
<p>See <a href="#jms-message-driven-channel-adapter">Message-driven Channel Adapter</a> and <a href="#jms-inbound-gateway">Inbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="shared-subscriptions"><a class="anchor" href="#shared-subscriptions"></a>Shared Subscriptions</h5>
<div class="paragraph">
<p>We added Namespace support for shared subscriptions (JMS 2.0) to message-driven endpoints and the <code>&lt;int-jms:publish-subscribe-channel&gt;</code>.
Previously, you had to wire up listener containers as <code>&lt;bean/&gt;</code> declarations to use shared connections.</p>
</div>
<div class="paragraph">
<p>See <a href="#jms">JMS Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-conditional-pollers"><a class="anchor" href="#x4.2-conditional-pollers"></a>I.9.8. Conditional Pollers</h4>
<div class="paragraph">
<p>We now provide much more flexibility for dynamic polling.</p>
</div>
<div class="paragraph">
<p>See <a href="#conditional-pollers">Conditional Pollers for Message Sources</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-amqp-changes"><a class="anchor" href="#x4.2-amqp-changes"></a>I.9.9. AMQP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration AMQP functionality.</p>
</div>
<div class="sect4">
<h5 id="publisher-confirmations"><a class="anchor" href="#publisher-confirmations"></a>Publisher Confirmations</h5>
<div class="paragraph">
<p>The <code>&lt;int-amqp:outbound-gateway&gt;</code> now supports <code>confirm-correlation-expression</code>, <code>confirm-ack-channel</code>, and <code>confirm-nack-channel</code> attributes (which have a purpose similar to that of <code>&lt;int-amqp:outbound-channel-adapter&gt;</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="correlation-data"><a class="anchor" href="#correlation-data"></a>Correlation Data</h5>
<div class="paragraph">
<p>For both the outbound channel adapter and the inbound gateway, if the correlation data is a <code>Message&lt;?&gt;</code>, it becomes the basis of the message on the ack or nack channel, with the additional header(s) added.
Previously, any correlation data (including <code>Message&lt;?&gt;</code>) was returned as the payload of the ack or nack message.</p>
</div>
</div>
<div class="sect4">
<h5 id="inbound-gateway-properties"><a class="anchor" href="#inbound-gateway-properties"></a>Inbound Gateway Properties</h5>
<div class="paragraph">
<p>The <code>&lt;int-amqp:inbound-gateway&gt;</code> now exposes the <code>amqp-template</code> attribute to allow more control over an external bean for the reply <code>RabbitTemplate</code>.
You can also provide your own <code>AmqpTemplate</code> implementation.
In addition, you can use <code>default-reply-to</code> if the request message does not have a <code>replyTo</code> property.</p>
</div>
<div class="paragraph">
<p>See <a href="#amqp">AMQP Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-xpath-splitter"><a class="anchor" href="#x4.2-xpath-splitter"></a>I.9.10. XPath Splitter Improvements</h4>
<div class="paragraph">
<p>The <code>XPathMessageSplitter</code> (<code>&lt;int-xml:xpath-splitter&gt;</code>) now allows the configuration of <code>output-properties</code> for the internal <code>javax.xml.transform.Transformer</code> and supports an <code>Iterator</code> mode (defaults to <code>true</code>) for the XPath evaluation <code>org.w3c.dom.NodeList</code> result.</p>
</div>
<div class="paragraph">
<p>See <a href="#xml-xpath-splitting">Splitting XML Messages</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-http-changes"><a class="anchor" href="#x4.2-http-changes"></a>I.9.11. HTTP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration HTTP functionality.</p>
</div>
<div class="sect4">
<h5 id="cors"><a class="anchor" href="#cors"></a>CORS</h5>
<div class="paragraph">
<p>The HTTP inbound endpoints (<code>&lt;int-http:inbound-channel-adapter&gt;</code> and <code>&lt;int-http:inbound-gateway&gt;</code>) now allow the
configuration of Cross-origin Resource Sharing (CORS).</p>
</div>
<div class="paragraph">
<p>See <a href="#http-cors">Cross-origin Resource Sharing (CORS) Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="inbound-gateway-timeout"><a class="anchor" href="#inbound-gateway-timeout"></a>Inbound Gateway Timeout</h5>
<div class="paragraph">
<p>You can configure the HTTP inbound gate way to return a status code that you specify when a request times out.
The default is now <code>500 Internal Server Error</code> instead of <code>200 OK</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#http-response-statuscode">Response Status Code</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="form-data"><a class="anchor" href="#form-data"></a>Form Data</h5>
<div class="paragraph">
<p>We added documentation for proxying <code>multipart/form-data</code> requests.
See <a href="#http">HTTP Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-gw"><a class="anchor" href="#x4.2-gw"></a>I.9.12. Gateway Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration Gateway functionality.</p>
</div>
<div class="sect4">
<h5 id="gateway-methods-can-return-completablefuture"><a class="anchor" href="#gateway-methods-can-return-completablefuture"></a>Gateway Methods can Return <code>CompletableFuture&lt;?&gt;</code></h5>
<div class="paragraph">
<p>When using Java 8, gateway methods can now return <code>CompletableFuture&lt;?&gt;</code>.
See <a href="#gw-completable-future"><code>CompletableFuture</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="messaginggateway-annotation"><a class="anchor" href="#messaginggateway-annotation"></a>MessagingGateway Annotation</h5>
<div class="paragraph">
<p>The request and reply timeout properties are now <code>String</code> instead of <code>Long</code> to allow configuration with property placeholders or SpEL.
See <a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.2-aggregator-changes"><a class="anchor" href="#x4.2-aggregator-changes"></a>I.9.13. Aggregator Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration aggregator functionality.</p>
</div>
<div class="sect4">
<h5 id="aggregator-performance"><a class="anchor" href="#aggregator-performance"></a>Aggregator Performance</h5>
<div class="paragraph">
<p>This release includes some performance improvements for aggregating components (aggregator, resequencer, and others), by more efficiently removing messages from groups when they are released.
New methods (<code>removeMessagesFromGroup</code>) have been added to the message store.
Set the <code>removeBatchSize</code> property (default: <code>100</code>) to adjust the number of messages deleted in each operation.
Currently, the JDBC, Redis, and MongoDB message stores support this property.</p>
</div>
</div>
<div class="sect4">
<h5 id="output-message-group-processor"><a class="anchor" href="#output-message-group-processor"></a>Output Message Group Processor</h5>
<div class="paragraph">
<p>When using a <code>ref</code> or inner bean for the aggregator, you can now directly bind a <code>MessageGroupProcessor</code>.
In addition, we added a <code>SimpleMessageGroupProcessor</code> that returns the collection of messages in the group.
When an output processor produces a collection of <code>Message&lt;?&gt;</code>, the aggregator releases those messages individually.
Configuring the <code>SimpleMessageGroupProcessor</code> makes the aggregator a message barrier, where messages are held up until they all arrive and are then released individually.
See <a href="#aggregator">Aggregator</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ftp-and-sftp-changes-2"><a class="anchor" href="#ftp-and-sftp-changes-2"></a>I.9.14. FTP and SFTP Changes</h4>
<div class="paragraph">
<p>This section describes general changes to the Spring Integration FTP and SFTP functionality.</p>
</div>
<div class="sect4">
<h5 id="inbound-channel-adapters"><a class="anchor" href="#inbound-channel-adapters"></a>Inbound Channel Adapters</h5>
<div class="paragraph">
<p>You can now specify a <code>remote-directory-expression</code> on the inbound channel adapters, to determine the directory at runtime.
See <a href="#ftp">FTP/FTPS Adapters</a> and <a href="#sftp">SFTP Adapters</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="gateway-partial-results"><a class="anchor" href="#gateway-partial-results"></a>Gateway Partial Results</h5>
<div class="paragraph">
<p>When you use FTP or SFTP outbound gateways to operate on multiple files (with <code>mget</code> and <code>mput</code>), an exception can
occur after part of the request is completed.
If such a condition occurs, a <code>PartialSuccessException</code> that contains the partial results is thrown.
See <a href="#ftp-outbound-gateway">FTP Outbound Gateway</a> and <a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="delegating-session-factory"><a class="anchor" href="#delegating-session-factory"></a>Delegating Session Factory</h5>
<div class="paragraph">
<p>We added a delegating session factory, enabling the selection of a particular session factory based on some thread context value.</p>
</div>
<div class="paragraph">
<p>See <a href="#ftp-dsf">Delegating Session Factory</a> and <a href="#sftp-dsf">Delegating Session Factory</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="default-sftp-session-factory"><a class="anchor" href="#default-sftp-session-factory"></a>Default Sftp Session Factory</h5>
<div class="paragraph">
<p>Previously, the <code>DefaultSftpSessionFactory</code> unconditionally allowed connections to unknown hosts.
This is now configurable (default: <code>false</code>).</p>
</div>
<div class="paragraph">
<p>The factory now requires a configured <code>knownHosts</code>, file unless the <code>allowUnknownKeys</code> property is <code>true</code> (default: <code>false</code>).</p>
</div>
<div class="paragraph">
<p>See <a href="#sftp-unk-keys">[sftp-unk-keys]</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="message-session-callback"><a class="anchor" href="#message-session-callback"></a>Message Session Callback</h5>
<div class="paragraph">
<p>We introduced the <code>MessageSessionCallback&lt;F, T&gt;</code> to perform any custom <code>Session</code> operations with the <code>requestMessage</code> context in the <code>&lt;int-(s)ftp:outbound-gateway/&gt;</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="#ftp-session-callback">Using <code>MessageSessionCallback</code></a> and <a href="#sftp-session-callback">MessageSessionCallback</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-changes-2"><a class="anchor" href="#websocket-changes-2"></a>I.9.15. Websocket Changes</h4>
<div class="paragraph">
<p>We added <code>WebSocketHandlerDecoratorFactory</code> support to the <code>ServerWebSocketContainer</code> to allow chained customization for the internal <code>WebSocketHandler</code>.
See <a href="#web-sockets-namespace">WebSockets Namespace Support</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="application-event-adapters-changes"><a class="anchor" href="#application-event-adapters-changes"></a>I.9.16. Application Event Adapters changes</h4>
<div class="paragraph">
<p>The <code>ApplicationEvent</code> adapters can now operate with <code>payload</code> as an <code>event</code> to directly allow omitting custom <code>ApplicationEvent</code> extensions.
For this purpose, we introduced the <code>publish-payload</code> boolean attribute has been introduced on the <code>&lt;int-event:outbound-channel-adapter&gt;</code>.
See <a href="#applicationevent">Spring <code>ApplicationEvent</code> Support</a> for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-4.0-4.1"><a class="anchor" href="#migration-4.0-4.1"></a>I.10. Changes between 4.0 and 4.1</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.0-to-4.1-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
<div class="sect3">
<h4 id="new-components"><a class="anchor" href="#new-components"></a>I.10.1. New Components</h4>
<div class="paragraph">
<p>Version 4.1 added a number of new components.</p>
</div>
<div class="sect4">
<h5 id="x4.1-promise-gateway"><a class="anchor" href="#x4.1-promise-gateway"></a>Promise&lt;?&gt; Gateway</h5>
<div class="paragraph">
<p>The messaging gateway methods now support a Reactor <code>Promise</code> return type.
See <a href="#async-gateway">Asynchronous Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-web-socket-adapters"><a class="anchor" href="#x4.1-web-socket-adapters"></a>WebSocket support</h5>
<div class="paragraph">
<p>The <code>WebSocket</code> module is now available.
It is fully based on the Spring WebSocket and Spring Messaging modules and provides an <code>&lt;inbound-channel-adapter&gt;</code> and an <code>&lt;outbound-channel-adapter&gt;</code>.
See <a href="#web-sockets">WebSockets Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-scatter-gather"><a class="anchor" href="#x4.1-scatter-gather"></a>Scatter-Gather Enterprise Integration Pattern</h5>
<div class="paragraph">
<p>We implemented the scatter-gather enterprise integration pattern.
See <a href="#scatter-gather">Scatter-Gather</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-Routing-Slip"><a class="anchor" href="#x4.1-Routing-Slip"></a>Routing Slip Pattern</h5>
<div class="paragraph">
<p>We added the routing slip EIP pattern implementation.
See <a href="#routing-slip">Routing Slip</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-idempotent-receiver"><a class="anchor" href="#x4.1-idempotent-receiver"></a>Idempotent Receiver Pattern</h5>
<div class="paragraph">
<p>We added the idempotent receiver enterprise integration pattern implementation by adding the <code>&lt;idempotent-receiver&gt;</code> component in XML or the <code>IdempotentReceiverInterceptor</code> and <code>IdempotentReceiver</code> annotations for Java configuration.
See <a href="#idempotent-receiver">Idempotent Receiver Enterprise Integration Pattern</a> and the <a href="https://docs.spring.io/spring-integration/api/index.html">Javadoc</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-BoonJsonObjectMapper"><a class="anchor" href="#x4.1-BoonJsonObjectMapper"></a>Boon <code>JsonObjectMapper</code></h5>
<div class="paragraph">
<p>We added the Boon <code>JsonObjectMapper</code> for the JSON transformers.
See <a href="#transformer">Transformer</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-redis-queue-gateways"><a class="anchor" href="#x4.1-redis-queue-gateways"></a>Redis Queue Gateways</h5>
<div class="paragraph">
<p>We added the <code>&lt;redis-queue-inbound-gateway&gt;</code> and <code>&lt;redis-queue-outbound-gateway&gt;</code> components.
See <a href="#redis-queue-inbound-gateway">Redis Queue Inbound Gateway</a> and <a href="#redis-queue-outbound-gateway">Redis Queue Outbound Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-PollSkipAdvice"><a class="anchor" href="#x4.1-PollSkipAdvice"></a><code>PollSkipAdvice</code></h5>
<div class="paragraph">
<p>We added the <code>PollSkipAdvice</code>, which you can use within the <code>&lt;advice-chain&gt;</code> of the <code>&lt;poller&gt;</code> to determine if the current poll should be suppressed (skipped) by some condition that you implement with <code>PollSkipStrategy</code>.
See <a href="#polling-consumer">Poller</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.1-general"><a class="anchor" href="#x4.1-general"></a>I.10.2. General Changes</h4>
<div class="paragraph">
<p>This section describes general changes from version 4.0 to version 4.1.</p>
</div>
<div class="sect4">
<h5 id="x4.1-amqp-inbound-missing-queues"><a class="anchor" href="#x4.1-amqp-inbound-missing-queues"></a>AMQP Inbound Endpoints, Channel</h5>
<div class="paragraph">
<p>Elements that use a message listener container (inbound endpoints and channel) now support the <code>missing-queues-fatal</code> attribute.
See <a href="#amqp">AMQP Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-amqp-outbound-lazy-connect"><a class="anchor" href="#x4.1-amqp-outbound-lazy-connect"></a>AMQP Outbound Endpoints</h5>
<div class="paragraph">
<p>The AMQP outbound endpoints support a new property called <code>lazy-connect</code> (default: <code>true</code>).
When <code>true</code>, the connection to the broker is not established until the first message arrives (assuming there are no inbound endpoints, which always try to establish the connection during startup).
When set to <code>false</code>, an attempt to establish the connection is made during application startup.
See <a href="#amqp">AMQP Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-sms-copy-on-get"><a class="anchor" href="#x4.1-sms-copy-on-get"></a>SimpleMessageStore</h5>
<div class="paragraph">
<p>The <code>SimpleMessageStore</code> no longer makes a copy of the group when calling <code>getMessageGroup()</code>.
See <a href="#sms-caution">Caution about <code>SimpleMessageStore</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-ws-encode-uri"><a class="anchor" href="#x4.1-ws-encode-uri"></a>Web Service Outbound Gateway: <code>encode-uri</code></h5>
<div class="paragraph">
<p>The <code>&lt;ws:outbound-gateway/&gt;</code> now provides an <code>encode-uri</code> attribute to allow disabling the encoding of the URI object before sending the request.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-http-status-code"><a class="anchor" href="#x4.1-http-status-code"></a>Http Inbound Channel Adapter and Status Code</h5>
<div class="paragraph">
<p>The <code>&lt;http:inbound-channel-adapter&gt;</code> can now be configured with a <code>status-code-expression</code> to override the default <code>200 OK</code> status.
See <a href="#http-namespace">HTTP Namespace Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-mqtt"><a class="anchor" href="#x4.1-mqtt"></a>MQTT Adapter Changes</h5>
<div class="paragraph">
<p>You can now configure the MQTT channel adapters to connect to multiple servers&#8201;&#8212;&#8201;for example, to support High Availability (HA).
See <a href="#mqtt">MQTT Support</a> for more information.</p>
</div>
<div class="paragraph">
<p>The MQTT message-driven channel adapter now supports specifying the QoS setting for each subscription.
See <a href="#mqtt-inbound">Inbound (Message-driven) Channel Adapter</a> for more information.</p>
</div>
<div class="paragraph">
<p>The MQTT outbound channel adapter now supports asynchronous sends, avoiding blocking until delivery is confirmed.
See <a href="#mqtt-outbound">Outbound Channel Adapter</a> for more information.</p>
</div>
<div class="paragraph">
<p>It is now possible to programmatically subscribe to and unsubscribe from topics at runtime.
See <a href="#mqtt-inbound">Inbound (Message-driven) Channel Adapter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-sftp"><a class="anchor" href="#x4.1-sftp"></a>FTP and SFTP Adapter Changes</h5>
<div class="paragraph">
<p>The FTP and SFTP outbound channel adapters now support appending to remote files and taking specific actions when a remote file already exists.
The remote file templates now also supports this, as well as <code>rmdir()</code> and <code>exists()</code>.
In addition, the remote file templates provide access to the underlying client object, enabling access to low-level APIs.</p>
</div>
<div class="paragraph">
<p>See <a href="#ftp">FTP/FTPS Adapters</a> and <a href="#sftp">SFTP Adapters</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-splitter-iterator"><a class="anchor" href="#x4.1-splitter-iterator"></a>Splitter and Iterator</h5>
<div class="paragraph">
<p><code>Splitter</code> components now support an <code>Iterator</code> as the result object for producing output messages.
See <a href="#splitter">Splitter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-aggregator"><a class="anchor" href="#x4.1-aggregator"></a>Aggregator</h5>
<div class="paragraph">
<p><code>Aggregator</code> instancess now support a new attribute <code>expire-groups-upon-timeout</code>.
See <a href="#aggregator">Aggregator</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-content-enricher-improvement"><a class="anchor" href="#x4.1-content-enricher-improvement"></a>Content Enricher Improvements</h5>
<div class="paragraph">
<p>We added a <code>null-result-expression</code> attribute, which is evaluated and returned if <code>&lt;enricher&gt;</code> returns <code>null</code>.
You can add it in <code>&lt;header&gt;</code> and <code>&lt;property&gt;</code>.
See <a href="#content-enricher">Content Enricher</a> for more information.</p>
</div>
<div class="paragraph">
<p>We added an <code>error-channel</code> attribute, which is used to handle an error flow if an <code>Exception</code> occurs downstream of the <code>request-channel</code>.
This lets you return an alternative object to use for enrichment.
See <a href="#content-enricher">Content Enricher</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-header-channel-registry"><a class="anchor" href="#x4.1-header-channel-registry"></a>Header Channel Registry</h5>
<div class="paragraph">
<p>The <code>&lt;header-enricher/&gt;</code> element&#8217;s <code>&lt;header-channels-to-string/&gt;</code> child element can now override the header channel registry&#8217;s default time for retaining channel mappings.
See <a href="#header-channel-registry">Header Channel Registry</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-orderly-shutdown"><a class="anchor" href="#x4.1-orderly-shutdown"></a>Orderly Shutdown</h5>
<div class="paragraph">
<p>We made improvements to the orderly shutdown algorithm.
See <a href="#jmx-shutdown">Orderly Shutdown</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-recipientListRouter"><a class="anchor" href="#x4.1-recipientListRouter"></a>Management for <code>RecipientListRouter</code></h5>
<div class="paragraph">
<p>The <code>RecipientListRouter</code> now provides several management operations to configure recipients at runtime.
With that, you can now configure the <code>&lt;recipient-list-router&gt;</code> without any <code>&lt;recipient&gt;</code> from the start.
See <a href="#recipient-list-router-management"><code>RecipientListRouterManagement</code></a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-AbstractHeaderMapper-changes"><a class="anchor" href="#x4.1-AbstractHeaderMapper-changes"></a>AbstractHeaderMapper: NON_STANDARD_HEADERS token</h5>
<div class="paragraph">
<p>The <code>AbstractHeaderMapper</code> implementation now provides the additional <code>NON_STANDARD_HEADERS</code> token to map any user-defined headers, which are not mapped by default.
See <a href="#amqp-message-headers">AMQP Message Headers</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-amqp-channels"><a class="anchor" href="#x4.1-amqp-channels"></a>AMQP Channels: <code>template-channel-transacted</code></h5>
<div class="paragraph">
<p>We introduced the <code>template-channel-transacted</code> attribute for AMQP <code>MessageChannel</code> instances.
See <a href="#amqp-channels">AMQP-backed Message Channels</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-syslog"><a class="anchor" href="#x4.1-syslog"></a>Syslog Adapter</h5>
<div class="paragraph">
<p>The default syslog message converter now has an option to retain the original message in the payload while still setting the headers.
See <a href="#syslog-inbound-adapter">Syslog Inbound Channel Adapter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-async-gateway"><a class="anchor" href="#x4.1-async-gateway"></a>Asynchronous Gateway</h5>
<div class="paragraph">
<p>In addition to the <code>Promise</code> return type <a href="#x4.1-promise-gateway">mentioned earlier</a>, gateway methods may now return a <code>ListenableFuture</code>, introduced in Spring Framework 4.0.
You can also disable asynchronous processing in the gateway, letting a downstream flow directly return a <code>Future</code>.
See <a href="#async-gateway">Asynchronous Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-aggregator-advice-chain"><a class="anchor" href="#x4.1-aggregator-advice-chain"></a>Aggregator Advice Chain</h5>
<div class="paragraph">
<p><code>Aggregator</code> and <code>Resequencer</code> now support <code>&lt;expire-advice-chain/&gt;</code> and <code>&lt;expire-transactional/&gt;</code> child elements to advise the <code>forceComplete</code> operation.
See <a href="#aggregator-config">[aggregator-config]</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-script-outbound-channel-adapter"><a class="anchor" href="#x4.1-script-outbound-channel-adapter"></a>Outbound Channel Adapter and Scripts</h5>
<div class="paragraph">
<p>The <code>&lt;int:outbound-channel-adapter/&gt;</code> now supports the <code>&lt;script/&gt;</code> child element.
The underlying script must have a <code>void</code> return type or return <code>null</code>.
See <a href="#groovy">Groovy support</a> and <a href="#scripting">Scripting Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-reseq"><a class="anchor" href="#x4.1-reseq"></a>Resequencer Changes</h5>
<div class="paragraph">
<p>When a message group in a resequencer times out (using <code>group-timeout</code> or a <code>MessageGroupStoreReaper</code>), late arriving messages are now, by default, discarded immediately.
See <a href="#resequencer">Resequencer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-Optional-Parameter"><a class="anchor" href="#x4.1-Optional-Parameter"></a>Optional POJO method parameter</h5>
<div class="paragraph">
<p>Spring Integration now consistently handles the Java 8&#8217;s <code>Optional</code> type.
See <a href="#service-activator-namespace">Configuring Service Activator</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-queue-channel-queue.typ"><a class="anchor" href="#x4.1-queue-channel-queue.typ"></a><code>QueueChannel</code> backed Queue type</h5>
<div class="paragraph">
<p>The <code>QueueChannel</code> backed <code>Queue type</code> has been changed from <code>BlockingQueue</code> to the more generic <code>Queue</code>.
This change allows the use of any external <code>Queue</code> implementation (for example, Reactor&#8217;s <code>PersistentQueue</code>).
See <a href="#channel-configuration-queuechannel"><code>QueueChannel</code> Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-channel-interceptor"><a class="anchor" href="#x4.1-channel-interceptor"></a><code>ChannelInterceptor</code> Changes</h5>
<div class="paragraph">
<p>The <code>ChannelInterceptor</code> now supports additional <code>afterSendCompletion()</code> and <code>afterReceiveCompletion()</code> methods.
See <a href="#channel-interceptors">Channel Interceptors</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.1-mail-peek"><a class="anchor" href="#x4.1-mail-peek"></a>IMAP PEEK</h5>
<div class="paragraph">
<p>Since version 4.1.1 there is a change of behavior if you explicitly set the <code>mail.[protocol].peek</code> JavaMail property to <code>false</code> (where <code>[protocol]</code> is <code>imap</code> or <code>imaps</code>).
See <a href="#imap-peek">Important: IMAP PEEK</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-3.0-4.0"><a class="anchor" href="#migration-3.0-4.0"></a>I.11. Changes between 3.0 and 4.0</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-3.0-to-4.0-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
<div class="sect3">
<h4 id="x4.0-new-components"><a class="anchor" href="#x4.0-new-components"></a>I.11.1. New Components</h4>
<div class="paragraph">
<p>Version 4.0 added a number of new components.</p>
</div>
<div class="sect4">
<h5 id="x4.0-mqtt"><a class="anchor" href="#x4.0-mqtt"></a>MQTT Channel Adapters</h5>
<div class="paragraph">
<p>The MQTT channel adapters (previously available in the Spring Integration Extensions repository) are now available as part of the normal Spring Integration distribution.
See <a href="#mqtt">MQTT Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-enable-configuration"><a class="anchor" href="#x4.0-enable-configuration"></a><code>@EnableIntegration</code></h5>
<div class="paragraph">
<p>We added the <code>@EnableIntegration</code> annotation to permit declaration of standard Spring Integration beans when using <code>@Configuration</code> classes.
See <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-component-scan"><a class="anchor" href="#x4.0-component-scan"></a><code>@IntegrationComponentScan</code></h5>
<div class="paragraph">
<p>We added the <code>@IntegrationComponentScan</code> annotation to permit classpath scanning for Spring Integration-specific components.
See <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-message-history"><a class="anchor" href="#x4.0-message-history"></a>&#8220;@EnableMessageHistory&#8221;</h5>
<div class="paragraph">
<p>You can now enable message history with the <code>@EnableMessageHistory</code> annotation in a <code>@Configuration</code> class.
In addition, a JMX MBean can modify the message history settings.
Also, <code>MessageHistory</code> can track auto-created <code>MessageHandler</code> instances for annotated endpoints (such as <code>@ServiceActivator</code>, <code>@Splitter</code>, and others).
For more information, see <a href="#message-history">Message History</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-messaging-gateway"><a class="anchor" href="#x4.0-messaging-gateway"></a><code>@MessagingGateway</code></h5>
<div class="paragraph">
<p>You can now configure messaging gateway interfaces with the <code>@MessagingGateway</code> annotation.
It is an analogue of the <code>&lt;int:gateway/&gt;</code> XML element.
For more information, see <a href="#messaging-gateway-annotation"><code>@MessagingGateway</code> Annotation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-boot"><a class="anchor" href="#x4.0-boot"></a>Spring Boot <code>@EnableAutoConfiguration</code></h5>
<div class="paragraph">
<p>As well as the <code>@EnableIntegration</code> annotation mentioned earlier, we introduced a hook to allow the Spring Integration infrastructure beans to be configured with Spring Boot&#8217;s <code>@EnableAutoConfiguration</code> annotation.
For more information, see <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html">&#8220;Auto-configuration&#8221;</a> in the Spring Boot Reference Guide.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-global-channel-interceptor"><a class="anchor" href="#x4.0-global-channel-interceptor"></a><code>@GlobalChannelInterceptor</code></h5>
<div class="paragraph">
<p>As well as the <code>@EnableIntegration</code> annotation mentioned above, we introduced the <code>@GlobalChannelInterceptor</code> annotation.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-integration-converter"><a class="anchor" href="#x4.0-integration-converter"></a><code>@IntegrationConverter</code></h5>
<div class="paragraph">
<p>We introduced the <code>@IntegrationConverter</code> annotation as an analogue of the <code>&lt;int:converter/&gt;</code> component.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-enable-publisher"><a class="anchor" href="#x4.0-enable-publisher"></a><code>@EnablePublisher</code></h5>
<div class="paragraph">
<p>We added the <code>@EnablePublisher</code> annotation to allow the specification of a <code>default-publisher-channel</code> for <code>@Publisher</code> annotations.
See <a href="#annotations">Annotation Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-redis-cms"><a class="anchor" href="#x4.0-redis-cms"></a>Redis Channel Message Stores</h5>
<div class="paragraph">
<p>We added a Redis <code>MessageGroupStore</code> that is optimized for use when backing a <code>QueueChannel</code> for persistence.
For more information, see <a href="#redis-cms">Redis Channel Message Stores</a>.</p>
</div>
<div class="paragraph">
<p>We added a Redis <code>ChannelPriorityMessageStore</code>.
You can use it to retrieve messages by priority.
For more information, see <a href="#redis-cms">Redis Channel Message Stores</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-priority-channel-mondodb"><a class="anchor" href="#x4.0-priority-channel-mondodb"></a>MongodDB Channel Message Store</h5>
<div class="paragraph">
<p>The MongoDB support now provides the <code>MongoDbChannelMessageStore</code>, which is a channel-specific <code>MessageStore</code> implementation.
With <code>priorityEnabled = true</code>, you can use it in <code>&lt;int:priority-queue&gt;</code> elements to achieve priority order polling of persisted messages.
For more information see <a href="#mongodb-priority-channel-message-store">MongoDB Channel Message Store</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-MBeanExport-annotation"><a class="anchor" href="#x4.0-MBeanExport-annotation"></a><code>@EnableIntegrationMBeanExport</code></h5>
<div class="paragraph">
<p>You can now enable the <code>IntegrationMBeanExporter</code> with the <code>@EnableIntegrationMBeanExport</code> annotation in a <code>@Configuration</code> class.
For more information, see <a href="#jmx-mbean-exporter">MBean Exporter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-channel-security-interceptor"><a class="anchor" href="#x4.0-channel-security-interceptor"></a><code>ChannelSecurityInterceptorFactoryBean</code></h5>
<div class="paragraph">
<p><code>ChannelSecurityInterceptorFactoryBean</code> now supports configuration of Spring Security for message channels that use <code>@Configuration</code> classes.
For more information, see <a href="#security">Security in Spring Integration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-redis-outbound-gateway"><a class="anchor" href="#x4.0-redis-outbound-gateway"></a>Redis Command Gateway</h5>
<div class="paragraph">
<p>The Redis support now provides the <code>&lt;outbound-gateway&gt;</code> component to perform generic Redis commands by using the <code>RedisConnection#execute</code> method.
For more information, see <a href="#redis-outbound-gateway">Redis Outbound Command Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-redis-gemfire-lock-registry"><a class="anchor" href="#x4.0-redis-gemfire-lock-registry"></a><code>RedisLockRegistry</code> and <code>GemfireLockRegistry</code></h5>
<div class="paragraph">
<p>The <code>RedisLockRegistry</code> and <code>GemfireLockRegistry</code> are now available to support global locks visible to multiple application instances and servers.
These can be used with aggregating message handlers across multiple application instances such that group release occurs on only one instance.
For more information, see <a href="#redis-lock-registry">Redis Lock Registry</a>, <a href="#gemfire-lock-registry">Gemfire Lock Registry</a>, and <a href="#aggregator">Aggregator</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-poller-annotation"><a class="anchor" href="#x4.0-poller-annotation"></a><code>@Poller</code></h5>
<div class="paragraph">
<p>Annotation-based messaging configuration can now have a <code>poller</code> attribute.
This means that methods annotated with <code>@ServiceActivator</code>, <code>@Aggregator</code>, and similar annotations can now use an <code>inputChannel</code> that is a reference to a <code>PollableChannel</code>.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-inbound-channel-adapter-annotation"><a class="anchor" href="#x4.0-inbound-channel-adapter-annotation"></a><code>@InboundChannelAdapter</code> and <code>SmartLifecycle</code> for Annotated Endpoints</h5>
<div class="paragraph">
<p>We added the <code>@InboundChannelAdapter</code> method annotation.
It is an analogue of the <code>&lt;int:inbound-channel-adapter&gt;</code> XML component.
In addition, all messaging annotations now provide <code>SmartLifecycle</code> options.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-twitter-sog"><a class="anchor" href="#x4.0-twitter-sog"></a>Twitter Search Outbound Gateway</h5>
<div class="paragraph">
<p>We added a new twitter endpoint: <code>&lt;int-twitter-search-outbound-gateway/&gt;</code>.
Unlike the search inbound adapter, which polls by using the same search query each time, the outbound gateway allows on-demand customized queries.
For more information, see <a href="https://github.com/spring-projects/spring-integration-extensions/tree/master/spring-integration-social-twitter">Spring Integration Social Twitter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-gemfire-metadata"><a class="anchor" href="#x4.0-gemfire-metadata"></a>Gemfire Metadata Store</h5>
<div class="paragraph">
<p>We added the <code>GemfireMetadataStore</code>, letting it be used, for example, in an <code>AbstractPersistentAcceptOnceFileListFilter</code> implementation in a multiple application instance or server environment.
For more information, see <a href="#metadata-store">Metadata Store</a>, <a href="#file-reading">Reading Files</a>, <a href="#ftp-inbound">FTP Inbound Channel Adapter</a>, and <a href="#sftp-inbound">SFTP Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-bridge-annotations"><a class="anchor" href="#x4.0-bridge-annotations"></a><code>@BridgeFrom</code> and <code>@BridgeTo</code> Annotations</h5>
<div class="paragraph">
<p>We introduced <code>@BridgeFrom</code> and <code>@BridgeTo</code> <code>@Bean</code> method annotations to mark <code>MessageChannel</code> beans in <code>@Configuration</code> classes.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-meta-messaging-annotations"><a class="anchor" href="#x4.0-meta-messaging-annotations"></a>Meta-messaging Annotations</h5>
<div class="paragraph">
<p>Messaging annotations (<code>@ServiceActivator</code>, <code>@Router</code>, <code>@MessagingGateway</code>, and others) can now be configured as meta-annotations for user-defined messaging annotations.
In addition, the user-defined annotations can have the same attributes (<code>inputChannel</code>, <code>@Poller</code>, <code>autoStartup</code>, and others).
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x4.0-general"><a class="anchor" href="#x4.0-general"></a>I.11.2. General Changes</h4>
<div class="paragraph">
<p>This section describes general changes from version 3.0 to version 4.0.</p>
</div>
<div class="sect4">
<h5 id="requires-spring-framework-4-0"><a class="anchor" href="#requires-spring-framework-4-0"></a>Requires Spring Framework 4.0</h5>
<div class="paragraph">
<p>We moved the core messaging abstractions (<code>Message</code>, <code>MessageChannel</code>, and others) to the Spring Framework <code>spring-messaging</code> module.
Developers who reference these classes directly in their code need to make changes, as described in the first section of the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-3.0-to-4.0-Migration-Guide">3.0 to 4.0 Migration Guide</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-xpath-header-enricher-header-type"><a class="anchor" href="#x4.0-xpath-header-enricher-header-type"></a>Header Type for XPath Header Enricher</h5>
<div class="paragraph">
<p>We introduced the <code>header-type</code> attribute for the <code>header</code> child element of the <code>&lt;int-xml:xpath-header-enricher&gt;</code>.
This attribute provides the target type for the header value (to which the result of the XPath expression evaluation is converted).
For more information see <a href="#xml-xpath-header-enricher">XPath Header Enricher</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-object-to-json-transformer-result-type"><a class="anchor" href="#x4.0-object-to-json-transformer-result-type"></a>Object To JSON Transformer: Node Result</h5>
<div class="paragraph">
<p>We introduced the <code>result-type</code> attribute for the <code>&lt;int:object-to-json-transformer&gt;</code>.
This attribute provides the target type for the result of mapping an object to JSON.
It supports <code>STRING</code> (the default) and <code>NODE</code>.
For more information see <a href="#transformer-xpath-spel-function">[transformer-xpath-spel-function]</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-jms-header-mapping"><a class="anchor" href="#x4.0-jms-header-mapping"></a>JMS Header Mapping</h5>
<div class="paragraph">
<p>The <code>DefaultJmsHeaderMapper</code> now maps an incoming <code>JMSPriority</code> header to the Spring Integration <code>priority</code> header.
Previously, <code>priority</code> was only considered for outbound messages.
For more information, see <a href="#jms-header-mapping">Mapping Message Headers to and from JMS Message</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-jms-ob"><a class="anchor" href="#x4.0-jms-ob"></a>JMS Outbound Channel Adapter</h5>
<div class="paragraph">
<p>The JMS outbound channel adapter now supports the <code>session-transacted</code> attribute (default: <code>false</code>).
Previously, you had to inject a customized <code>JmsTemplate</code> to use transactions.
See <a href="#jms-outbound-channel-adapter">Outbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-jms-ib"><a class="anchor" href="#x4.0-jms-ib"></a>JMS Inbound Channel Adapter</h5>
<div class="paragraph">
<p>The JMS inbound channel adapter now supports the <code>session-transacted</code> attribute (default: <code>false</code>).
Previously, you had to inject a customized <code>JmsTemplate</code> to use transactions.
The adapter allowed 'transacted' in the <code>acknowledgeMode</code>, which was incorrect and didn&#8217;t work.
This value is no longer allowed.
See <a href="#jms-inbound-channel-adapter">Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-datatype-channel"><a class="anchor" href="#x4.0-datatype-channel"></a>Datatype Channels</h5>
<div class="paragraph">
<p>You can now specify a <code>MessageConverter</code> to be used when converting (if necessary) payloads to one of the accepted <code>datatype</code> instances in a Datatype channel.
For more information, see <a href="#channel-datatype-channel">Datatype Channel Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-retry-config"><a class="anchor" href="#x4.0-retry-config"></a>Simpler Retry Advice Configuration</h5>
<div class="paragraph">
<p>We added simplified namespace support to configure a <code>RequestHandlerRetryAdvice</code>.
For more information, see <a href="#retry-config">Configuring the Retry Advice</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-release-strategy-group-timeout"><a class="anchor" href="#x4.0-release-strategy-group-timeout"></a>Correlation Endpoint: Time-based Release Strategy</h5>
<div class="paragraph">
<p>We added the mutually exclusive <code>group-timeout</code> and <code>group-timeout-expression</code> attributes to <code>&lt;int:aggregator&gt;</code> and <code>&lt;int:resequencer&gt;</code>.
These attributes allow forced completion of a partial <code>MessageGroup</code>, provided the <code>ReleaseStrategy</code> does not release a group and no further messages arrive within the time specified.
For more information, see <a href="#aggregator-config">[aggregator-config]</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-redis-metadata"><a class="anchor" href="#x4.0-redis-metadata"></a>Redis Metadata Store</h5>
<div class="paragraph">
<p>The <code>RedisMetadataStore</code> now implements <code>ConcurrentMetadataStore</code>, letting it be used, for example, in an <code>AbstractPersistentAcceptOnceFileListFilter</code> implementation in a multiple application instance or server environment.
For more information, see <a href="#redis-metadata-store">Redis Metadata Store</a>, <a href="#file-reading">Reading Files</a>, <a href="#ftp-inbound">FTP Inbound Channel Adapter</a>, and <a href="#sftp-inbound">SFTP Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-jdbc-cs"><a class="anchor" href="#x4.0-jdbc-cs"></a><code>JdbcChannelMessageStore</code> and <code>PriorityChannel</code></h5>
<div class="paragraph">
<p>T`JdbcChannelMessageStore` now implements <code>PriorityCapableChannelMessageStore</code>, letting it be used as a <code>message-store</code> reference for <code>priority-queue</code> instances.
For more information, see <a href="#jdbc-message-store-channels">Backing Message Channels</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-amqp"><a class="anchor" href="#x4.0-amqp"></a>AMQP Endpoints Delivery Mode</h5>
<div class="paragraph">
<p>Spring AMQP, by default, creates persistent messages on the broker.
You can override this behavior by setting the <code>amqp_deliveryMode</code> header or customizing the mappers.
We added a convenient <code>default-delivery-mode</code> attribute to the adapters to provide easier configuration of this important setting.
For more information, see <a href="#amqp-outbound-channel-adapter">Outbound Channel Adapter</a> and <a href="#amqp-outbound-gateway">Outbound Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-ftp"><a class="anchor" href="#x4.0-ftp"></a>FTP Timeouts</h5>
<div class="paragraph">
<p>The <code>DefaultFtpSessionFactory</code> now exposes the <code>connectTimeout</code>, <code>defaultTimeout</code>, and <code>dataTimeout</code> properties, avoiding the need to subclass the factory to set these common properties.
The <code>postProcess*</code> methods are still available for more advanced configuration.
See <a href="#ftp-session-factory">FTP Session Factory</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-twitter-status-updating"><a class="anchor" href="#x4.0-twitter-status-updating"></a>Twitter: <code>StatusUpdatingMessageHandler</code></h5>
<div class="paragraph">
<p>The <code>StatusUpdatingMessageHandler</code> (<code>&lt;int-twitter:outbound-channel-adapter&gt;</code>) now supports the <code>tweet-data-expression</code> attribute to build a <code>org.springframework.social.twitter.api.TweetData</code> object for updating the timeline status.
This feature allows, for example, attaching an image.
See <a href="https://github.com/spring-projects/spring-integration-extensions/tree/master/spring-integration-social-twitter">Spring Integration Social Twitter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-jpa-id-expression"><a class="anchor" href="#x4.0-jpa-id-expression"></a>JPA Retrieving Gateway: <code>id-expression</code></h5>
<div class="paragraph">
<p>We introduced the <code>id-expression</code> attribute for <code>&lt;int-jpa:retrieving-outbound-gateway&gt;</code> to perform <code>EntityManager.find(Class entityClass, Object primaryKey)</code>.
See <a href="#jpa-retrieving-outbound-gateway">Retrieving Outbound Gateway</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-tcp-deserializer-events"><a class="anchor" href="#x4.0-tcp-deserializer-events"></a>TCP Deserialization Events</h5>
<div class="paragraph">
<p>When one of the standard deserializers encounters a problem decoding the input stream to a message, it now emits a <code>TcpDeserializationExceptionEvent</code>, letting applications examine the data at the point at which the exception occurred.
See <a href="#tcp-events">TCP Connection Events</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x4.0-bean-messaging-annotations"><a class="anchor" href="#x4.0-bean-messaging-annotations"></a>Messaging Annotations on <code>@Bean</code> Definitions</h5>
<div class="paragraph">
<p>You can now configure messaging annotations (<code>@ServiceActivator</code>, <code>@Router</code>, <code>@InboundChannelAdapter</code>, and others) on <code>@Bean</code> definitions in <code>@Configuration</code> classes.
For more information, see <a href="#annotations">Annotation Support</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-2.2-3.0"><a class="anchor" href="#migration-2.2-3.0"></a>I.12. Changes Between 2.2 and 3.0</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.2-to-3.0-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
<div class="sect3">
<h4 id="x3.0-new-components"><a class="anchor" href="#x3.0-new-components"></a>I.12.1. New Components</h4>
<div class="paragraph">
<p>Version 3.0 added a number of new components.</p>
</div>
<div class="sect4">
<h5 id="x3.0-request-mapping"><a class="anchor" href="#x3.0-request-mapping"></a>HTTP Request Mapping</h5>
<div class="paragraph">
<p>The HTTP module now provides powerful request mapping support for inbound endpoints.
We replaced the <code>UriPathHandlerMapping</code> class with <code>IntegrationRequestMappingHandlerMapping</code>, which is registered under the bean name of <code>integrationRequestMappingHandlerMapping</code> in the application context.
Upon parsing of the HTTP inbound endpoint, either a new <code>IntegrationRequestMappingHandlerMapping</code> bean is registered or an existing bean is reused.
To achieve flexible request mapping configuration, Spring Integration provides the <code>&lt;request-mapping/&gt;</code> child element for <code>&lt;http:inbound-channel-adapter/&gt;</code> and the <code>&lt;http:inbound-gateway/&gt;</code>.
Both HTTP inbound endpoints are now fully based on the request mapping infrastructure that was introduced with Spring MVC 3.1.
For example, multiple paths are supported on a single inbound endpoint.
For more information see <a href="#http-namespace">HTTP Namespace Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-spel-customization"><a class="anchor" href="#x3.0-spel-customization"></a>Spring Expression Language (SpEL) Configuration</h5>
<div class="paragraph">
<p>We added a new <code>IntegrationEvaluationContextFactoryBean</code> to allow configuration of custom <code>PropertyAccessor</code> implementations and functions for use in SpEL expressions throughout the framework.
For more information, see <a href="#spel">Spring Expression Language (SpEL)</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-spel-functions"><a class="anchor" href="#x3.0-spel-functions"></a>SpEL Functions Support</h5>
<div class="paragraph">
<p>To customize the SpEL <code>EvaluationContext</code> with static <code>Method</code> functions, we introduced the <code>&lt;spel-function/&gt;</code> component.
We also added two built-in functions: <code>#jsonPath</code> and <code>#xpath</code>.
For more information, see <a href="#spel-functions">SpEL Functions</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-spel-property-accessors"><a class="anchor" href="#x3.0-spel-property-accessors"></a>SpEL PropertyAccessors Support</h5>
<div class="paragraph">
<p>To customize the SpEL <code>EvaluationContext</code> with <code>PropertyAccessor</code> implementations, we added the <code>&lt;spel-property-accessors/&gt;</code> component.
For more information, see <a href="#spel-property-accessors">Property Accessors</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-redis-new-components"><a class="anchor" href="#x3.0-redis-new-components"></a>Redis: New Components</h5>
<div class="paragraph">
<p>We added a new Redis-based <a href="https://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/store/MetadataStore.html"><code>MetadataStore</code></a> implementation.
You can use the <code>RedisMetadataStore</code> to maintain the state of a <code>MetadataStore</code> across application restarts.
This new <code>MetadataStore</code> implementation can be used with adapters, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Twitter inbound adapters</p>
</li>
<li>
<p>Feed inbound channel adapter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We added new queue-based components.
We added the <code>&lt;int-redis:queue-inbound-channel-adapter/&gt;</code> and <code>&lt;int-redis:queue-outbound-channel-adapter/&gt;</code> components to perform 'right pop' and 'left push' operations, respectively, on a Redis List.</p>
</div>
<div class="paragraph">
<p>For more information, &#8220;see <a href="#redis">Redis Support</a>&#8221;.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-hcr"><a class="anchor" href="#x3.0-hcr"></a>Header Channel Registry</h5>
<div class="paragraph">
<p>You can now instruct the framework to store reply channels and error channels in a registry for later resolution.
This is useful for cases where the <code>replyChannel</code> or <code>errorChannel</code> might be lost (for example, when serializing a message).
See <a href="#header-enricher">Header Enricher</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-configurable-mongo-MS"><a class="anchor" href="#x3.0-configurable-mongo-MS"></a>MongoDB support: New <code>ConfigurableMongoDbMessageStore</code></h5>
<div class="paragraph">
<p>In addition to the existing <code>eMongoDbMessageStore</code>, we introduced a new <code>ConfigurableMongoDbMessageStore</code>.
This provides a more robust and flexible implementation of <code>MessageStore</code> for MongoDB.
It does not have backward compatibility with the existing store, but we recommend using it for new applications.
Existing applications can use it, but messages in the old store are not available.
See <a href="#mongodb">MongoDb Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-syslog"><a class="anchor" href="#x3.0-syslog"></a>Syslog Support</h5>
<div class="paragraph">
<p>Building on the 2.2 <code>SyslogToMapTransformer</code>, Spring Integration 3.0 introduces <code>UDP</code> and <code>TCP</code> inbound channel adapters especially tailored for receiving SYSLOG messages.
For more information, see <a href="#syslog">Syslog Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-tail"><a class="anchor" href="#x3.0-tail"></a><code>tail</code> Support</h5>
<div class="paragraph">
<p>We added file inbound channel adapters that use the <code>tail</code> command to generate messages when lines are added to the end of text files.
See <a href="#file-tailing">'tail&#8217;ing Files</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-jmx"><a class="anchor" href="#x3.0-jmx"></a>JMX Support</h5>
<div class="paragraph">
<p>We added <code>&lt;int-jmx:tree-polling-channel-adapter/&gt;</code>.
This adapter queries the JMX MBean tree and sends a message with a payload that is the graph of objects that match the query.
By default, the MBeans are mapped to primitives and simple Objects (such as <code>Map</code>, <code>List</code>, and arrays).
It permits simple transformation to, for example, JSON.</p>
</div>
<div class="paragraph">
<p>The <code>IntegrationMBeanExporter</code> now allows the configuration of a custom <code>ObjectNamingStrategy</code> by using the <code>naming-strategy</code> attribute.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#jmx">JMX Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-tcp-events"><a class="anchor" href="#x3.0-tcp-events"></a>TCP/IP Connection Events and Connection Management</h5>
<div class="paragraph">
<p><code>TcpConnection</code> instances now emit <code>ApplicationEvent</code> instances (specifically <code>TcpConnectionEvent</code> instances) when connections are opened or closed or when an exception occurs.
This change lets applications be informed of changes to TCP connections by using the normal Spring <code>ApplicationListener</code> mechanism.</p>
</div>
<div class="paragraph">
<p>We renamed <code>AbstractTcpConnection</code> to <code>TcpConnectionSupport</code>.
Custom connections that are subclasses of this class can use its methods to publish events.
Similarly, we renamed <code>AbstractTcpConnectionInterceptor</code> to <code>TcpConnectionInterceptorSupport</code>.</p>
</div>
<div class="paragraph">
<p>In addition, we added <code>&lt;int-ip:tcp-connection-event-inbound-channel-adapter/&gt;</code>.
By default, this adapter sends all <code>TcpConnectionEvent</code> instances to a <code>Channel</code>.</p>
</div>
<div class="paragraph">
<p>Further, the TCP connection factories now provide a new method called <code>getOpenConnectionIds()</code>, which returns a list of identifiers for all open connections.
It lets applications broadcast to all open connections, among other uses.</p>
</div>
<div class="paragraph">
<p>Finally, the connection factories also provide a new method called <code>closeConnection(String connectionId)</code>, which lets applications explicitly close a connection by using its ID.</p>
</div>
<div class="paragraph">
<p>For more information see <a href="#tcp-events">TCP Connection Events</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-inbound-script"><a class="anchor" href="#x3.0-inbound-script"></a>Inbound Channel Adapter Script Support</h5>
<div class="paragraph">
<p>The <code>&lt;int:inbound-channel-adapter/&gt;</code> now supports using <code>&lt;expression/&gt;</code> and <code>&lt;script/&gt;</code> child elements to create a <code>MessageSource</code>.
See <a href="#channel-adapter-expressions-and-scripts">Channel Adapter Expressions and Scripts</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-content-enricher-headers"><a class="anchor" href="#x3.0-content-enricher-headers"></a>Content Enricher: Headers Enrichment Support</h5>
<div class="paragraph">
<p>The content enricher now provides configuration for <code>&lt;header/&gt;</code> child elements, to enrich the outbound message with headers based on the reply message from the underlying message flow.
For more information see <a href="#payload-enricher">Payload Enricher</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x3.0-general"><a class="anchor" href="#x3.0-general"></a>I.12.2. General Changes</h4>
<div class="paragraph">
<p>This section describes general changes from version 2.2 to version 3.0.</p>
</div>
<div class="sect4">
<h5 id="x3.0-message-id"><a class="anchor" href="#x3.0-message-id"></a>Message ID Generation</h5>
<div class="paragraph">
<p>Previously, message IDs were generated by using the JDK <code>UUID.randomUUID()</code> method.
With this release, the default mechanism has been changed to use a more efficient and significantly faster algorithm.
In addition, we added the ability to change the strategy used to generate message IDs.
For more information see <a href="#message-id-generation">Message ID Generation</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-gateway"><a class="anchor" href="#x3.0-gateway"></a>&#8220;&lt;gateway&gt;&#8221; Changes</h5>
<div class="paragraph">
<p>You can now set common headers across all gateway methods, and we added more options for adding information to the message about which method was invoked.</p>
</div>
<div class="paragraph">
<p>You can now entirely customize the way that gateway method calls are mapped to messages.</p>
</div>
<div class="paragraph">
<p>The <code>GatewayMethodMetadata</code> is now a public class.
It lets you programmatically configure the <code>GatewayProxyFactoryBean</code> from Java.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#gateway">Messaging Gateways</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-http-endpointss"><a class="anchor" href="#x3.0-http-endpointss"></a>HTTP Endpoint Changes</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Outbound Endpoint <code>encode-uri</code></strong>: <code>&lt;http:outbound-gateway/&gt;</code> and <code>&lt;http:outbound-channel-adapter/&gt;</code> now provide an <code>encode-uri</code> attribute to allow disabling the encoding of the URI object before sending the request.</p>
</li>
<li>
<p><strong>Inbound Endpoint <code>merge-with-default-converters</code></strong>: <code>&lt;http:inbound-gateway/&gt;</code> and <code>&lt;http:inbound-channel-adapter/&gt;</code> now have a <code>merge-with-default-converters</code> attribute to include the list of default <code>HttpMessageConverter</code> instances after the custom message converters.</p>
</li>
<li>
<p><strong><code>If-Modified-Since</code> and <code>If-Unmodified-Since</code> HTTP Headers</strong>: Previously, the <code>If-Modified-Since</code> and <code>If-Unmodified-Since</code> HTTP headers were incorrectly processed within from and to HTTP headers mapped in the <code>DefaultHttpHeaderMapper</code>.
Now, in addition to correcting that issue, <code>DefaultHttpHeaderMapper</code> provides date parsing from formatted strings for any HTTP headers that accept date-time values.</p>
</li>
<li>
<p><strong>Inbound Endpoint Expression Variables</strong>: In addition to the existing <code>#requestParams</code> and <code>#pathVariables</code>, the <code>&lt;http:inbound-gateway/&gt;</code> and <code>&lt;http:inbound-channel-adapter/&gt;</code> now support additional useful variables: <code>#matrixVariables</code>, <code>#requestAttributes</code>, <code>#requestHeaders</code>, and <code>#cookies</code>.
These variables are available in both payload and header expressions.</p>
</li>
<li>
<p><strong>Outbound Endpoint 'uri-variables-expression'</strong>: HTTP outbound endpoints now support the <code>uri-variables-expression</code> attribute to specify an <code>Expression</code> to evaluate a <code>Map</code> for all URI variable placeholders within URL template.
This allows selection of a different map of expressions based on the outgoing message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="#http">HTTP Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-json-transformers"><a class="anchor" href="#x3.0-json-transformers"></a>Jackson Support (JSON)</h5>
<div class="ulist">
<ul>
<li>
<p>A new abstraction for JSON conversion has been introduced.
Implementations for Jackson 1.x and Jackson 2 are currently provided, with the version being determined by presence on the classpath.
Previously, only Jackson 1.x was supported.</p>
</li>
<li>
<p>The <code>ObjectToJsonTransformer</code> and <code>JsonToObjectTransformer</code> now emit/consume headers containing type information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see &#8220;JSON Transformers&#8221; in <a href="#transformer">Transformer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-id-for-chain-sub-components"><a class="anchor" href="#x3.0-id-for-chain-sub-components"></a>Chain Elements <code>id</code> Attribute</h5>
<div class="paragraph">
<p>Previously, the <code>id</code> attribute for elements within a <code>&lt;chain&gt;</code> was ignored and, in some cases, disallowed.
Now, the <code>id</code> attribute is allowed for all elements within a <code>&lt;chain&gt;</code>.
The bean names of chain elements is a combination of the surrounding chain&#8217;s <code>id</code> and the <code>id</code> of the element itself.
For example: 'myChain$child.myTransformer.handler'.
For more information see, <a href="#chain">Message Handler Chain</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-corr-endpoint-empty-groups"><a class="anchor" href="#x3.0-corr-endpoint-empty-groups"></a>Aggregator 'empty-group-min-timeout' property</h5>
<div class="paragraph">
<p>The <code>AbstractCorrelatingMessageHandler</code> provides a new property called <code>empty-group-min-timeout</code> to allow empty group expiry to run on a longer schedule than expiring partial groups.
Empty groups are not removed from the <code>MessageStore</code> until they have not been modified for at least this number of milliseconds.
For more information, see <a href="#aggregator-config">[aggregator-config]</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-filelistfilter"><a class="anchor" href="#x3.0-filelistfilter"></a>Persistent File List Filters (file, (S)FTP)</h5>
<div class="paragraph">
<p>New <code>FileListFilter</code> implementations that use a persistent <code>MetadataStore</code> are now available.
You can use these to prevent duplicate files after a system restart.
See <a href="#file-reading">Reading Files</a>, <a href="#ftp-inbound">FTP Inbound Channel Adapter</a>, and <a href="#sftp-inbound">SFTP Inbound Channel Adapter</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-scripting-variables"><a class="anchor" href="#x3.0-scripting-variables"></a>Scripting Support: Variables Changes</h5>
<div class="paragraph">
<p>We introduced a new <code>variables</code> attribute for scripting components.
In addition, variable bindings are now allowed for inline scripts.
See <a href="#groovy">Groovy support</a> and <a href="#scripting">Scripting Support</a> for more information.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-direct-channel-lb-ref"><a class="anchor" href="#x3.0-direct-channel-lb-ref"></a>Direct Channel Load Balancing configuration</h5>
<div class="paragraph">
<p>Previously, when configuring <code>LoadBalancingStrategy</code> on the channel&#8217;s <code>dispatcher</code> child element, the only available option was to use a pre-defined enumeration of values which did not let developers set a custom implementation of the <code>LoadBalancingStrategy</code>.
You can now use <code>load-balancer-ref</code> to provide a reference to a custom implementation of the <code>LoadBalancingStrategy</code>.
For more information, see <a href="#channel-implementations-directchannel"><code>DirectChannel</code></a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-pub-sub"><a class="anchor" href="#x3.0-pub-sub"></a>PublishSubscribeChannel Behavior</h5>
<div class="paragraph">
<p>Previously, sending to a &lt;publish-subscribe-channel/&gt; that had no subscribers would return a <code>false</code> result.
If used in conjunction with a <code>MessagingTemplate</code>, this would result in an exception being thrown.
Now, the <code>PublishSubscribeChannel</code> has a property called <code>minSubscribers</code> (default: <code>0</code>).
If the message is sent to at least the minimum number of subscribers, the send operation is deemed to be successful (even if the number is zero).
If an application expects to get an exception under these conditions, set the minimum subscribers to at least 1.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0--s-ftp-changes"><a class="anchor" href="#x3.0--s-ftp-changes"></a>FTP, SFTP and FTPS Changes</h5>
<div class="paragraph">
<p>The FTP, SFTP and FTPS endpoints no longer cache sessions by default.</p>
</div>
<div class="paragraph">
<p>We removed the deprecated <code>cached-sessions</code> attribute from all endpoints.
Previously, the embedded caching mechanism controlled by this attribute&#8217;s value did not provide a way to limit the size of the cache, which could grow indefinitely.
Release 2.1 introduced <code>CachingConnectionFactory</code>, and it became the preferred (and is now the only) way to cache sessions.</p>
</div>
<div class="paragraph">
<p><code>CachingConnectionFactory</code> now provides a new method: <code>resetCache()</code>.
This method immediately closes idle sessions and causes in-use sessions to be closed as and when they are returned to the cache.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultSftpSessionFactory</code> (in conjunction with a <code>CachingSessionFactory</code>) now supports multiplexing channels over a single SSH connection (SFTP Only).</p>
</div>
<div class="sect5">
<h6 id="ftp-sftp-and-ftps-inbound-adapters"><a class="anchor" href="#ftp-sftp-and-ftps-inbound-adapters"></a>FTP, SFTP and FTPS Inbound Adapters</h6>
<div class="paragraph">
<p>Previously, there was no way to override the default filter used to process files retrieved from a remote server.
The <code>filter</code> attribute determines which files are retrieved, but the <code>FileReadingMessageSource</code> uses an <code>AcceptOnceFileListFilter</code>.
This means that, if a new copy of a file is retrieved with the same name as a previously copied file, no message was sent from the adapter.</p>
</div>
<div class="paragraph">
<p>With this release, a new attribute <code>local-filter</code> lets you override the default filter (for example, with an <code>AcceptAllFileListFilter</code> or some other custom filter).</p>
</div>
<div class="paragraph">
<p>If you want the behavior of the <code>AcceptOnceFileListFilter</code> to be maintained across JVM executions, you can now configure a custom filter that retains state, perhaps on the file system.</p>
</div>
<div class="paragraph">
<p>Inbound channel adapters now support the <code>preserve-timestamp</code> attribute, which sets the local file modified timestamp to the timestamp from the server (default: <code>false</code>).</p>
</div>
</div>
<div class="sect5">
<h6 id="ftp-sftp-and-ftps-gateways"><a class="anchor" href="#ftp-sftp-and-ftps-gateways"></a>FTP, SFTP, and FTPS Gateways</h6>
<div class="paragraph">
<p>The gateways now support the <code>mv</code> command, enabling the renaming of remote files.</p>
</div>
<div class="paragraph">
<p>The gateways now support recursive <code>ls</code> and <code>mget</code> commands, enabling the retrieval of a remote file tree.</p>
</div>
<div class="paragraph">
<p>The gateways now support <code>put</code> and <code>mput</code> commands, enabling sending files to the remote server.</p>
</div>
<div class="paragraph">
<p>The <code>local-filename-generator-expression</code> attribute is now supported, enabling the naming of local files during retrieval.
By default, the same name as the remote file is used.</p>
</div>
<div class="paragraph">
<p>The <code>local-directory-expression</code> attribute is now supported, enabling the naming of local directories during retrieval (based on the remote directory).</p>
</div>
</div>
<div class="sect5">
<h6 id="remote-file-template"><a class="anchor" href="#remote-file-template"></a>Remote File Template</h6>
<div class="paragraph">
<p>A new higher-level abstraction (<code>RemoteFileTemplate</code>) is provided over the <code>Session</code> implementations used by the FTP and SFTP modules.
While it is used internally by endpoints, you can also use this abstraction programmatically.
Like all Spring <code>*Template</code> implementations, it reliably closes the underlying session while allowing low level access to the session.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#ftp">FTP/FTPS Adapters</a> and <a href="#sftp">SFTP Adapters</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-outbound-gateway-requires-reply"><a class="anchor" href="#x3.0-outbound-gateway-requires-reply"></a>'requires-reply' Attribute for Outbound Gateways</h5>
<div class="paragraph">
<p>All outbound gateways (such as <code>&lt;jdbc:outbound-gateway/&gt;</code> or <code>&lt;jms:outbound-gateway/&gt;</code>) are designed for 'request-reply' scenarios.
A response is expected from the external service and is published to the <code>reply-channel</code> or the <code>replyChannel</code> message header.
However, there are some cases where the external system might not always return a result (for example,
a <code>&lt;jdbc:outbound-gateway/&gt;</code> when a SELECT ends with an empty <code>ResultSet</code> or perhaps a one-way web service).
Consequently, developers needed an option to configure whether or not a reply is required.
For this purpose, we introduced the <code>requires-reply</code> attribute for outbound gateway components.
In most cases, the default value for <code>requires-reply</code> is <code>true</code>.
If there is no result, a <code>ReplyRequiredException</code> is thrown.
Changing the value to <code>false</code> means that, if an external service does not return anything, the message flow ends at that point, similar to an outbound channel adapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The WebService outbound gateway has an additional attribute called <code>ignore-empty-responses</code>.
It is used to treat an empty <code>String</code> response as if no response were received.
By default, it is <code>true</code>, but you can set it to <code>false</code> to allow the application to receive an empty <code>String</code> in the reply message payload.
When the attribute is <code>true</code>, an empty string is treated as no response for the purposes of the <code>requires-reply</code> attribute.
By default, <code>requires-reply</code> is false for the WebService outbound gateway.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that the <code>requiresReply</code> property was previously present but set to <code>false</code> in the <code>AbstractReplyProducingMessageHandler</code>, and there was no way to configure it on outbound gateways by using the XML namespace.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Previously, a gateway receiving no reply would silently end the flow (with a DEBUG log message).
By default, with this change, an exception is now thrown by most gateways.
To revert to the previous behavior, set <code>requires-reply</code> to <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-amqp-mapping"><a class="anchor" href="#x3.0-amqp-mapping"></a>AMQP Outbound Gateway Header Mapping</h5>
<div class="paragraph">
<p>Previously, the &lt;int-amqp:outbound-gateway/&gt; mapped headers before invoking the message converter, and the converter could overwrite headers such as <code>content-type</code>.
The outbound adapter maps the headers after the conversion, which means headers like <code>content-type</code> from the outbound <code>Message</code> (if present) are used.</p>
</div>
<div class="paragraph">
<p>Starting with this release, the gateway now maps the headers after the message conversion, consistent with the adapter.
If your application relies on the previous behavior (where the converter&#8217;s headers overrode the mapped headers), you either need to filter those headers (before the message reaches the gateway) or set them appropriately.
The headers affected by the <code>SimpleMessageConverter</code> are <code>content-type</code> and <code>content-encoding</code>.
Custom message converters may set other headers.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-stored-proc-sql-return-type"><a class="anchor" href="#x3.0-stored-proc-sql-return-type"></a>Stored Procedure Components Improvements</h5>
<div class="paragraph">
<p>For more complex database-specific types not supported by the standard <code>CallableStatement.getObject</code> method, we introduced two new additional attributes to the <code>&lt;sql-parameter-definition/&gt;</code> element with OUT-direction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type-name</code></p>
</li>
<li>
<p><code>return-type</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>row-mapper</code> attribute of the stored procedure inbound channel adapter <code>&lt;returning-resultset/&gt;</code> child element now supports a reference to a <code>RowMapper</code> bean definition.
Previously, it contained only a class name (which is still supported).</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#stored-procedures">Stored Procedures</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-ws-outbound-uri-substitution"><a class="anchor" href="#x3.0-ws-outbound-uri-substitution"></a>Web Service Outbound URI Configuration</h5>
<div class="paragraph">
<p>The web service outbound gateway 'uri' attribute now supports <code>&lt;uri-variable/&gt;</code> substitution for all URI schemes supported by Spring Web Services.
For more information, see <a href="#outbound-uri">Outbound URI Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-redis"><a class="anchor" href="#x3.0-redis"></a>Redis Adapter Changes</h5>
<div class="paragraph">
<p>The Redis inbound channel adapter can now use a <code>null</code> value for the <code>serializer</code> property, with the raw data being the message payload.</p>
</div>
<div class="paragraph">
<p>The Redis outbound channel adapter now has the <code>topic-expression</code> property to determine the Redis topic for the <code>Message</code> at runtime.</p>
</div>
<div class="paragraph">
<p>The Redis inbound channel adapter, in addition to the existing <code>topics</code> attribute, now has the <code>topic-patterns</code> attribute.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#redis">Redis Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-advising-filters"><a class="anchor" href="#x3.0-advising-filters"></a>Advising Filters</h5>
<div class="paragraph">
<p>Previously, when a <code>&lt;filter/&gt;</code> had a <code>&lt;request-handler-advice-chain/&gt;</code>, the discard action was all performed within the scope of the advice chain (including any downstream flow on the <code>discard-channel</code>).
The filter element now has an attribute called <code>discard-within-advice</code> (default: <code>true</code>) to allow the discard action to be performed after the advice chain completes.
See <a href="#advising-filters">Advising Filters</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-annotation-advice"><a class="anchor" href="#x3.0-annotation-advice"></a>Advising Endpoints using Annotations</h5>
<div class="paragraph">
<p>Request handler advice chains can now be configured using annotations.
See <a href="#advising-with-annotations">Advising Endpoints Using Annotations</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-o-t-s-t"><a class="anchor" href="#x3.0-o-t-s-t"></a>ObjectToStringTransformer Improvements</h5>
<div class="paragraph">
<p>This transformer now correctly transforms <code>byte[]</code> and <code>char[]</code> payloads to <code>String</code>.
For more information, see <a href="#transformer">Transformer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-jpa-changes"><a class="anchor" href="#x3.0-jpa-changes"></a>JPA Support Changes</h5>
<div class="paragraph">
<p>Payloads to persist or merge can now be of type <code><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html">java.lang.Iterable</a></code>.</p>
</div>
<div class="paragraph">
<p>In that case, each object returned by the <code>Iterable</code> is treated as an entity and persisted or merged by using the underlying <code>EntityManager</code>.
Null values returned by the iterator are ignored.</p>
</div>
<div class="paragraph">
<p>The JPA adapters now have additional attributes to optionally flush and clear entities from the associated persistence context after performing persistence operations.</p>
</div>
<div class="paragraph">
<p>Retrieving gateways had no mechanism to specify the first record to be retrieved, which is a common use case.
The retrieving gateways now support specifying this parameter by adding the <code>first-result</code> and <code>first-result-expression</code> attributes to the gateway definition.
For more information, see <a href="#jpa-retrieving-outbound-gateway">Retrieving Outbound Gateway</a>.</p>
</div>
<div class="paragraph">
<p>The JPA retrieving gateway and inbound adapter now have an attribute to specify the maximum number of results in a result set as an expression.
In addition, we introduced the <code>max-results</code> attribute to replace <code>max-number-of-results</code>, which has been deprecated.
<code>max-results</code> and <code>max-results-expression</code> are used to provide the maximum number of results or an expression to compute the maximum number of results, respectively, in the result set.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#jpa">JPA Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-dalay-expression"><a class="anchor" href="#x3.0-dalay-expression"></a>Delayer: delay expression</h5>
<div class="paragraph">
<p>Previously, the <code>&lt;delayer&gt;</code> provided a <code>delay-header-name</code> attribute to determine the delay value at runtime.
In complex cases, the <code>&lt;delayer&gt;</code> had to be preceded with a <code>&lt;header-enricher&gt;</code>.
Spring Integration 3.0 introduced the <code>expression</code> attribute and <code>expression</code> child element for dynamic delay determination.
The <code>delay-header-name</code> attribute is now deprecated, because you can specify the header evaluation in the <code>expression</code>.
In addition, we introduced the <code>ignore-expression-failures</code> to control the behavior when an expression evaluation fails.
For more information, see <a href="#delayer">Delayer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-jdbc-mysql-v5_6_4"><a class="anchor" href="#x3.0-jdbc-mysql-v5_6_4"></a>JDBC Message Store Improvements</h5>
<div class="paragraph">
<p>Spring Integration 3.0 adds a new set of DDL scripts for MySQL version 5.6.4 and higher.
Now MySQL supports fractional seconds and is thus improving the FIFO ordering when polling from a MySQL-based message store.
For more information, see <a href="#jdbc-message-store-generic">The Generic JDBC Message Store</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-event-for-imap-idle"><a class="anchor" href="#x3.0-event-for-imap-idle"></a>IMAP Idle Connection Exceptions</h5>
<div class="paragraph">
<p>Previously, if an IMAP idle connection failed, it was logged, but there was no mechanism to inform an application.
Such exceptions now generate <code>ApplicationEvent</code> instances.
Applications can obtain these events by using an <code>&lt;int-event:inbound-channel-adapter&gt;</code> or any <code>ApplicationListener</code> configured to receive an <code>ImapIdleExceptionEvent</code> (or one of its super classes).</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-tcp-headers"><a class="anchor" href="#x3.0-tcp-headers"></a>Message Headers and TCP</h5>
<div class="paragraph">
<p>The TCP connection factories now enable the configuration of a flexible mechanism to transfer selected headers (as well as the payload) over TCP.
A new <code>TcpMessageMapper</code> enables the selection of the headers, and you need to configure an appropriate serializer or deserializer to write the resulting <code>Map</code> to the TCP stream.
We added a <code>MapJsonSerializer</code> as a convenient mechanism to transfer headers and payload over TCP.
For more information, see <a href="#ip-headers">Transferring Headers</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-jms-mdca-te"><a class="anchor" href="#x3.0-jms-mdca-te"></a>JMS Message Driven Channel Adapter</h5>
<div class="paragraph">
<p>Previously, when configuring a <code>&lt;message-driven-channel-adapter/&gt;</code>, if you wished to use a specific <code>TaskExecutor</code>, you had to declare a container bean and provide it to the adapter by setting the <code>container</code> attribute.
We added the <code>task-executor</code>, letting it be set directly on the adapter.
This is in addition to several other container attributes that were already available.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-rmi-ec"><a class="anchor" href="#x3.0-rmi-ec"></a>RMI Inbound Gateway</h5>
<div class="paragraph">
<p>The RMI Inbound Gateway now supports an <code>error-channel</code> attribute.
See <a href="#rmi-inbound">Inbound RMI</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x3.0-xslt-transformer"><a class="anchor" href="#x3.0-xslt-transformer"></a><code>XsltPayloadTransformer</code></h5>
<div class="paragraph">
<p>You can now specify the transformer factory class name by setting the <code>transformer-factory-class</code> attribute.
See <code><a href="#xml-xslt-payload-transformers">XsltPayloadTransformer</a></code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-2.1-2.2"><a class="anchor" href="#migration-2.1-2.2"></a>I.13. Changes between 2.1 and 2.2</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.1-to-2.2-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.
You can find migration guides for all versions back to 2.1 on the <a href="https://github.com/spring-projects/spring-integration/wiki">wiki</a>.</p>
</div>
<div class="sect3">
<h4 id="x2.2-new-components"><a class="anchor" href="#x2.2-new-components"></a>I.13.1. New Components</h4>
<div class="paragraph">
<p>Version 2.2 added a number of new components.</p>
</div>
<div class="sect4">
<h5 id="x2.2-redis-store-adapters"><a class="anchor" href="#x2.2-redis-store-adapters"></a><code>RedisStore</code> Inbound and Outbound Channel Adapters</h5>
<div class="paragraph">
<p>Spring Integration now has <code>RedisStore</code> Inbound and Outbound Channel Adapters, letting you write and read <code>Message</code> payloads to and from Redis collections.
For more information, see <a href="#redis-store-outbound-channel-adapter">RedisStore Outbound Channel Adapter</a> and <a href="#redis-store-inbound-channel-adapter">Redis Store Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-mongo-adapters"><a class="anchor" href="#x2.2-mongo-adapters"></a>MongoDB Inbound and Outbound Channel Adapters</h5>
<div class="paragraph">
<p>Spring Integration now has MongoDB inbound and outbound channel adapters, letting you write and read <code>Message</code> payloads to and from a MongoDB document store.
For more information, see <a href="#mongodb-outbound-channel-adapter">MongoDB Outbound Channel Adapter</a> and <a href="#mongodb-inbound-channel-adapter">MongoDB Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-jpa"><a class="anchor" href="#x2.2-jpa"></a>JPA Endpoints</h5>
<div class="paragraph">
<p>Spring Integration now includes components for the Java Persistence API (JPA) for retrieving and persisting JPA entity objects.
The JPA Adapter includes the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jpa-inbound-channel-adapter">Inbound channel adapter</a></p>
</li>
<li>
<p><a href="#jpa-outbound-channel-adapter">Outbound channel adapter</a></p>
</li>
<li>
<p><a href="#jpa-updating-outbound-gateway">Updating outbound gateway</a></p>
</li>
<li>
<p><a href="#jpa-retrieving-outbound-gateway">Retrieving outbound gateway</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="#jpa">JPA Support</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x2.2-general"><a class="anchor" href="#x2.2-general"></a>I.13.2. General Changes</h4>
<div class="paragraph">
<p>This section describes general changes from version 2.1 to version 2.2.</p>
</div>
<div class="sect4">
<h5 id="x2.2-spring-31"><a class="anchor" href="#x2.2-spring-31"></a>Spring 3.1 Used by Default</h5>
<div class="paragraph">
<p>Spring Integration now uses Spring 3.1.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-handler-advice"><a class="anchor" href="#x2.2-handler-advice"></a>Adding Behavior to Endpoints</h5>
<div class="paragraph">
<p>The ability to add an <code>&lt;advice-chain/&gt;</code> to a poller has been available for some time.
However, the behavior added by this affects the entire integration flow.
It did not address the ability to add (for example) retry to an individual endpoint.
The 2.2 release introduced the <code>&lt;request-handler-advice-chain/&gt;</code> to many endpoints.</p>
</div>
<div class="paragraph">
<p>In addition, we added three standard advice classes for this purpose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MessageHandlerRetryAdvice</code></p>
</li>
<li>
<p><code>MessageHandlerCircuitBreakerAdvice</code></p>
</li>
<li>
<p><code>ExpressionEvaluatingMessageHandlerAdvice</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="#message-handler-advice-chain">Adding Behavior to Endpoints</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-transaction-sync"><a class="anchor" href="#x2.2-transaction-sync"></a>Transaction Synchronization and Pseudo Transactions</h5>
<div class="paragraph">
<p>Pollers can now participate in Spring&#8217;s Transaction Synchronization feature.
This allows for synchronizing such operations as renaming files by an inbound channel adapter, depending on whether the transaction commits or rolls back.</p>
</div>
<div class="paragraph">
<p>In addition, you can enable these features when no &#8220;real&#8221; transaction is present, by means of a <code>PseudoTransactionManager</code>.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#transaction-synchronization">Transaction Synchronization</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-file-adapter"><a class="anchor" href="#x2.2-file-adapter"></a>File Adapter: Improved File Overwrite and Append Handling</h5>
<div class="paragraph">
<p>When using the file outbound channel adapter or the file outbound gateway, you can use a new <code>mode</code> property.
Prior to Spring Integration 2.2, target files were replaced when they existed.
Now you can specify the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REPLACE</code> (default)</p>
</li>
<li>
<p><code>APPEND</code></p>
</li>
<li>
<p><code>FAIL</code></p>
</li>
<li>
<p><code>IGNORE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="#file-writing-destination-exists">Dealing with Existing Destination Files</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-outbound-gateways"><a class="anchor" href="#x2.2-outbound-gateways"></a>Reply-Timeout Added to More Outbound Gateways</h5>
<div class="paragraph">
<p>The XML Namespace support adds the reply-timeout attribute to the following outbound gateways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AMQP Outbound Gateway</p>
</li>
<li>
<p>File Outbound Gateway</p>
</li>
<li>
<p>FTP Outbound Gateway</p>
</li>
<li>
<p>SFTP Outbound Gateway</p>
</li>
<li>
<p>WS Outbound Gateway</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-amqp-11"><a class="anchor" href="#x2.2-amqp-11"></a>Spring-AMQP 1.1</h5>
<div class="paragraph">
<p>Spring Integration now uses Spring AMQP 1.1.
This enables several features to be used within a Spring Integration application, including the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A fixed reply queue for the outbound gateway</p>
</li>
<li>
<p>HA (mirrored) queues</p>
</li>
<li>
<p>Publisher confirmations</p>
</li>
<li>
<p>Returned messages</p>
</li>
<li>
<p>Support for dead letter exchanges and dead letter queues</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-jdbc-11"><a class="anchor" href="#x2.2-jdbc-11"></a>JDBC Support - Stored Procedures Components</h5>
<div class="sect5">
<h6 id="spel-support-2"><a class="anchor" href="#spel-support-2"></a>SpEL Support</h6>
<div class="paragraph">
<p>When using the stored procedure components of the Spring Integration JDBC Adapter, you can now provide stored procedure names or stored function names by using the Spring Expression Language (SpEL).</p>
</div>
<div class="paragraph">
<p>Doing so lets you specify the stored procedures to be invoked at runtime.
For example, you can provide stored procedure names that you would like to execute through message headers.
For more information, see <a href="#stored-procedures">Stored Procedures</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="jmx-support"><a class="anchor" href="#jmx-support"></a>JMX Support</h6>
<div class="paragraph">
<p>The stored procedure components now provide basic JMX support, exposing some of their properties as MBeans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stored procedure name</p>
</li>
<li>
<p>Stored procedure name expression</p>
</li>
<li>
<p><code>JdbcCallOperations</code> cache statistics</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-jdbc-gateway-update-optional"><a class="anchor" href="#x2.2-jdbc-gateway-update-optional"></a>JDBC Support: Outbound Gateway</h5>
<div class="paragraph">
<p>When you use the JDBC outbound gateway, the update query is no longer mandatory.
You can now provide only a select query by using the request message as a source of parameters.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-jdbc-message-store-channels"><a class="anchor" href="#x2.2-jdbc-message-store-channels"></a>JDBC Support: Channel-specific Message Store Implementation</h5>
<div class="paragraph">
<p>We added a new message channel-specific message store implementation, providing a more scalable solution using database-specific SQL queries.
For more information, see <a href="#jdbc-message-store-channels">Backing Message Channels</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-shutdown"><a class="anchor" href="#x2.2-shutdown"></a>Orderly Shutdown</h5>
<div class="paragraph">
<p>We added a method called <code>stopActiveComponents()</code> to the <code>IntegrationMBeanExporter</code>.
It allows a Spring Integration application to be shut down in an orderly manner, disallowing new inbound messages to certain adapters and waiting for some time to allow in-flight messages to complete.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-jms-og"><a class="anchor" href="#x2.2-jms-og"></a>JMS Outbound Gateway Improvements</h5>
<div class="paragraph">
<p>You can now configure the JMS outbound gateway to use a <code>MessageListener</code> container to receive replies.
Doing so can improve performance of the gateway.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.2-o-t-j-t"><a class="anchor" href="#x2.2-o-t-j-t"></a><code>ObjectToJsonTransformer</code></h5>
<div class="paragraph">
<p>By default, the <code>ObjectToJsonTransformer</code> now sets the <code>content-type</code> header to <code>application/json</code>.
For more information, see <a href="#transformer">Transformer</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="httpChanges"><a class="anchor" href="#httpChanges"></a>HTTP Support</h5>
<div class="paragraph">
<p>Java serialization over HTTP is no longer enabled by default.
Previously, when setting an <code>expected-response-type</code> on a <code>Serializable</code> object, the <code>Accept</code> header was not properly set up.
We updated the <code>SerializingHttpMessageConverter</code> to set the <code>Accept</code> header to <code>application/x-java-serialized-object</code>.
However, because this could cause incompatibility with existing applications, we decided to no longer automatically add this converter to the HTTP endpoints.</p>
</div>
<div class="paragraph">
<p>If you wish to use Java serialization, you need to add the <code>SerializingHttpMessageConverter</code> to the appropriate endpoints by using the <code>message-converters</code> attribute (when you use XML configuration) or by using the <code>setMessageConverters()</code> method (in Java).</p>
</div>
<div class="paragraph">
<p>Alternatively, you may wish to consider using JSON instead.
It is enabled by having <code>Jackson</code> on the classpath.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-2.0-2.1"><a class="anchor" href="#migration-2.0-2.1"></a>I.14. Changes between 2.0 and 2.1</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.0-to-2.1-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.</p>
</div>
<div class="sect3">
<h4 id="x2.1-new-components"><a class="anchor" href="#x2.1-new-components"></a>I.14.1. New Components</h4>
<div class="paragraph">
<p>Version 2.1 added a number of new components.</p>
</div>
<div class="sect4">
<h5 id="x2.1-new-scripting-support"><a class="anchor" href="#x2.1-new-scripting-support"></a>JSR-223 Scripting Support</h5>
<div class="paragraph">
<p>In Spring Integration 2.0, we added support for <a href="https://groovy.codehaus.org/">Groovy</a>.
With Spring Integration 2.1, we expanded support for additional languages substantially by implementing support for <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> (&#8220;Scripting for the Java Platform&#8221;).
Now you have the ability to use any scripting language that supports JSR-223 including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Javascript</p>
</li>
<li>
<p>Ruby and JRuby</p>
</li>
<li>
<p>Python and Jython</p>
</li>
<li>
<p>Groovy</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For further details, see <a href="#scripting">Scripting Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-gemfire-support"><a class="anchor" href="#x2.1-new-gemfire-support"></a>GemFire Support</h5>
<div class="paragraph">
<p>Spring Integration provides support for <a href="https://www.vmware.com/products/application-platform/vfabric-gemfire/overview.html">GemFire</a> by providing inbound adapters for entry and continuous query events, an outbound adapter to write entries to the cache, and <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageStore.html"><code>MessageStore</code></a> and <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageGroupStore.html"><code>MessageGroupStore</code></a> implementations.
Spring integration leverages the <a href="https://www.springsource.org/spring-gemfire">Spring Gemfire</a> project, providing a thin wrapper over its components.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#gemfire">Pivotal GemFire and Apache Geode Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-amqp-support"><a class="anchor" href="#x2.1-new-amqp-support"></a>AMQP Support</h5>
<div class="paragraph">
<p>Spring Integration 2.1 added several channel adapters for receiving and sending messages by using the <a href="https://www.amqp.org/">Advanced Message Queuing Protocol</a> (AMQP).
Furthermore, Spring Integration also provides a point-to-point message channel and a publish-subscribe message channel, both of which are backed by AMQP Exchanges and Queues.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#amqp">AMQP Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-mongodb-support"><a class="anchor" href="#x2.1-new-mongodb-support"></a>MongoDB Support</h5>
<div class="paragraph">
<p>As of version 2.1, Spring Integration provides support for <a href="https://www.mongodb.org/">MongoDB</a> by providing a MongoDB-based <code>MessageStore</code>.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#mongodb">MongoDb Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-redis-support"><a class="anchor" href="#x2.1-new-redis-support"></a>Redis Support</h5>
<div class="paragraph">
<p>As of version 2.1, Spring Integration supports <a href="https://redis.io/">Redis</a>, an advanced key-value store, by providing a Redis-based <code>MessageStore</code> as well as publish-subscribe messaging adapters.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#redis">Redis Support</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-resource-support"><a class="anchor" href="#x2.1-new-resource-support"></a>Support for Spring&#8217;s Resource abstraction</h5>
<div class="paragraph">
<p>In version 2.1, we introduced a new resource inbound channel adapter that builds upon Spring&#8217;s resource abstraction to support greater flexibility across a variety of actual types of underlying resources, such as a file, a URL, or a classpath resource.
Therefore, it is similar to but more generic than the file inbound channel adapter.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#resource-inbound-channel-adapter">Resource Inbound Channel Adapter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-stored-proc-support"><a class="anchor" href="#x2.1-new-stored-proc-support"></a>Stored Procedure Components</h5>
<div class="paragraph">
<p>With Spring Integration 2.1, the <code>JDBC</code> Module also provides stored procedure support by adding several new components, including inbound and outbound channel adapters and an outbound gateway.
The stored procedure support leverages  Spring&#8217;s <a href="https://docs.spring.io/spring/docs/3.0.x/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html"><code>SimpleJdbcCall</code></a> class and consequently supports stored procedures for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Derby</p>
</li>
<li>
<p>DB2</p>
</li>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>Sybase</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The stored procedure components also support SQL functions for the following databases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MySQL</p>
</li>
<li>
<p>Microsoft SQL Server</p>
</li>
<li>
<p>Oracle</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For further details, see <a href="#stored-procedures">Stored Procedures</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-xpath-filter-support"><a class="anchor" href="#x2.1-new-xpath-filter-support"></a>XPath and XML Validating Filter</h5>
<div class="paragraph">
<p>Spring Integration 2.1 provides a new XPath-based message filter.
It is part of the <code>XML</code> module.
The XPath filter lets you filter messages by using XPath Expressions.
We also added documentation for the XML validating filter.</p>
</div>
<div class="paragraph">
<p>For more details, see <a href="#xml-xpath-filter">Using the XPath Filter</a> and <a href="#xml-validating-filter">XML Validating Filter</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-payload-enricher-support"><a class="anchor" href="#x2.1-new-payload-enricher-support"></a>Payload Enricher</h5>
<div class="paragraph">
<p>Since Spring Integration 2.1, we added the payload enricher.
A payload enricher defines an endpoint that typically passes a <a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/Message.html"><code>Message</code></a> to the exposed request channel and then expects a reply message.
The reply message then becomes the root object for evaluation of expressions to enrich the target payload.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#payload-enricher">Payload Enricher</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-ftp-outbound-gateway"><a class="anchor" href="#x2.1-new-ftp-outbound-gateway"></a>FTP and SFTP Outbound Gateways</h5>
<div class="paragraph">
<p>Spring Integration 2.1 provides two new outbound gateways to interact with remote File Transfer Protocol (FTP) or Secure File Transfer Protocol (SFT) servers.
These two gateways let you directly execute a limited set of remote commands.</p>
</div>
<div class="paragraph">
<p>For instance, you can use these outbound gateways to list, retrieve, and delete remote files and have the Spring Integration message flow continue with the remote server&#8217;s response.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#ftp-outbound-gateway">FTP Outbound Gateway</a> and <a href="#sftp-outbound-gateway">SFTP Outbound Gateway</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-new-ftp-session-caching"><a class="anchor" href="#x2.1-new-ftp-session-caching"></a>FTP Session Caching</h5>
<div class="paragraph">
<p>As of version 2.1, we have exposed more flexibility with regards to session management for remote file adapters (for example, FTP, SFTP, and others).</p>
</div>
<div class="paragraph">
<p>Specifically, we deprecated the <code>cache-sessions</code> attribute (which is available via the XML namespace support).
As an alternative, we added the <code>sessionCacheSize</code> and <code>sessionWaitTimeout</code> attributes on the <code>CachingSessionFactory</code>.</p>
</div>
<div class="paragraph">
<p>For further details, see <a href="#ftp-session-caching">FTP Session Caching</a> and <a href="#sftp-session-caching">SFTP Session Caching</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x2.1-framework-refactorings"><a class="anchor" href="#x2.1-framework-refactorings"></a>I.14.2. Framework Refactoring</h4>
<div class="paragraph">
<p>We refactored the Spring Integration framework in a number of ways, all described in this section.</p>
</div>
<div class="sect4">
<h5 id="x2.1-router-standardization"><a class="anchor" href="#x2.1-router-standardization"></a>Standardizing Router Configuration</h5>
<div class="paragraph">
<p>We standardized router parameters across all router implementations with Spring Integration 2.1 to provide a more consistent user experience.</p>
</div>
<div class="paragraph">
<p>In Spring Integration 2.1, we removed the <code>ignore-channel-name-resolution-failures</code> attribute in favor of consolidating its behavior with the <code>resolution-required</code> attribute.
Also, the <code>resolution-required</code> attribute now defaults to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Starting with Spring Integration 2.1, routers no longer silently drop any messages if no default output channel was defined.
This means that, by default, routers now require at least one resolved channel (if no <code>default-output-channel</code> was set) and, by default, throw a <code>MessageDeliveryException</code> if no channel was determined (or an attempt to send was not successful).</p>
</div>
<div class="paragraph">
<p>If, however, you do want to drop messages silently, you can set <code>default-output-channel="nullChannel"</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
With the standardization of router parameters and the consolidation of the parameters described earlier, older Spring Integration based applications may break.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For further details, see <code><a href="#router">Routers</a></code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-schema-updated"><a class="anchor" href="#x2.1-schema-updated"></a>XML Schemas updated to 2.1</h5>
<div class="paragraph">
<p>Spring Integration 2.1 ships with an updated XML Schema (version 2.1).
It provides many improvements, such as the Router standardizations <a href="#x2.1-router-standardization">discussed earlier</a>.</p>
</div>
<div class="paragraph">
<p>From now on, developers must always declare the latest XML schema (currently version 2.1).
Alternatively, they can use the version-less schema.
Generally, the best option is to use version-less namespaces, as these automatically use the latest available version of Spring Integration.</p>
</div>
<div class="paragraph">
<p>The following example declares a version-less Spring Integration namespace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int="http://www.springframework.org/schema/integration"
   xsi:schemaLocation="http://www.springframework.org/schema/integration
           https://www.springframework.org/schema/integration/spring-integration.xsd
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example declares a Spring Integration namespace with an explicit version:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:int="http://www.springframework.org/schema/integration"
   xsi:schemaLocation="http://www.springframework.org/schema/integration
           https://www.springframework.org/schema/integration/spring-integration-2.2.xsd
           http://www.springframework.org/schema/beans
           https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
...
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The old 1.0 and 2.0 schemas are still there.
However, if an application context still references one of those deprecated schemas, the validator fails on initialization.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x2.1-source-control-infrastructure"><a class="anchor" href="#x2.1-source-control-infrastructure"></a>I.14.3. Source Control Management and Build Infrastructure</h4>
<div class="paragraph">
<p>Version 2.1 introduced a number of changes to source control management and build infrastructure.
This section covers those changes.</p>
</div>
<div class="sect4">
<h5 id="x2.1-move-to-github"><a class="anchor" href="#x2.1-move-to-github"></a>Source Code Now Hosted on Github</h5>
<div class="paragraph">
<p>Since version 2.0, the Spring Integration project uses <a href="https://git-scm.com/">Git</a> for version control.
To increase community visibility even further, the project was moved from SpringSource hosted Git repositories to <a href="https://www.github.com/">Github</a>.
The Spring Integration Git repository is located at: <a href="https://github.com/spring-projects/spring-integration">spring-integration</a>.</p>
</div>
<div class="paragraph">
<p>For the project, we also improved the process of providing code contributions.
Further, we ensure that every commit is peer-reviewed.
In fact, core committers now follow the same process as contributors.
For more details, see <a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.adoc">Contributing</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="x2.1-sonar"><a class="anchor" href="#x2.1-sonar"></a>Improved Source Code Visibility with Sonar</h5>
<div class="paragraph">
<p>In an effort to provide better source code visibility and consequently to monitor the quality of Spring Integration&#8217;s source code, we set up an instance of <a href="https://www.sonarqube.org/">Sonar</a>.
We gather metrics nightly and make them available at <a href="https://sonar.spring.io/dashboard?id=org.springframework.integration%3Aspring-integration%3Amaster">sonar.spring.io</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x2.1-new-samples"><a class="anchor" href="#x2.1-new-samples"></a>I.14.4. New Samples</h4>
<div class="paragraph">
<p>For the 2.1 release of Spring Integration, we also expanded the Spring Integration Samples project and added many new samples, such as samples that cover AMQP support, a sample that showcases the new payload enricher, a sample illustrating techniques for testing Spring Integration flow fragments, and a sample for executing stored procedures against Oracle databases.
For details, visit <a href="https://github.com/spring-projects/spring-integration-samples">spring-integration-samples</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="migration-1.0-2.0"><a class="anchor" href="#migration-1.0-2.0"></a>I.15. Changes between Versions 1.0 and 2.0</h3>
<div class="paragraph">
<p>See the <a href="https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-1.0-to-2.0-Migration-Guide">Migration Guide</a> for important changes that might affect your applications.</p>
</div>
<div class="sect3">
<h4 id="migration-spring-30-support"><a class="anchor" href="#migration-spring-30-support"></a>I.15.1. Spring 3 support</h4>
<div class="paragraph">
<p>Spring Integration 2.0 is built on top of Spring 3.0.5 and makes many of its features available to our users.</p>
</div>
<div class="paragraph">
<p>[[2.0-spel-support]]
===== Support for the Spring Expression Language (SpEL)</p>
</div>
<div class="paragraph">
<p>You can now use SpEL expressions within the transformer, router, filter, splitter, aggregator, service-activator, header-enricher, and many more elements of the Spring Integration core namespace as well as within various adapters.
This guide includes many samples.</p>
</div>
<div class="sect4">
<h5 id="conversion-support"><a class="anchor" href="#conversion-support"></a>Conversion Service and Converter</h5>
<div class="paragraph">
<p>You can now benefit from the conversion service support provided with Spring while configuring many Spring Integration components, such as a <a href="https://www.enterpriseintegrationpatterns.com/DatatypeChannel.html">Datatype channel</a>.
See <a href="#channel-implementations">Message Channel Implementations</a> and <a href="#service-activator-introduction">[service-activator-introduction]</a>.
Also, the SpEL support mentioned in the previous point also relies upon the conversion service.
Therefore, you can register converters once and take advantage of them anywhere you use SpEL expressions.</p>
</div>
</div>
<div class="sect4">
<h5 id="task-scheduler-poller-support"><a class="anchor" href="#task-scheduler-poller-support"></a><code>TaskScheduler</code> and <code>Trigger</code></h5>
<div class="paragraph">
<p>Spring 3.0 defines two new strategies related to scheduling: <code>TaskScheduler</code> and <code>Trigger</code>.
Spring Integration (which uses a lot of scheduling) now builds upon these.
In fact, Spring Integration 1.0 had originally defined some of the components (such as <code>CronTrigger</code>) that have now been migrated into Spring 3.0&#8217;s core API.
Now you can benefit from reusing the same components within the entire application context (not just Spring Integration configuration).
We also greatly simplified configuration of Spring Integration pollers by providing attributes for directly configuring rates, delays, cron expressions, and trigger references.
See <a href="#channel-adapter">Channel Adapter</a> for sample configurations.</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-support"><a class="anchor" href="#rest-support"></a><code>RestTemplate</code> and <code>HttpMessageConverter</code></h5>
<div class="paragraph">
<p>Our outbound HTTP adapters now delegate to Spring&#8217;s <code>RestTemplate</code> for executing the HTTP request and handling its response.
This also means that you can reuse any custom <code>HttpMessageConverter</code> implementations.
See <a href="#http-outbound">HTTP Outbound Components</a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="new-eip"><a class="anchor" href="#new-eip"></a>I.15.2. Enterprise Integration Pattern Additions</h4>
<div class="paragraph">
<p>Also in 2.0, we have added support for even more of the patterns described in Hohpe and Woolf&#8217;s <a href="https://www.enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a> book.</p>
</div>
<div class="sect4">
<h5 id="new-message-history"><a class="anchor" href="#new-message-history"></a>Message History</h5>
<div class="paragraph">
<p>We now provide support for the <a href="https://www.enterpriseintegrationpatterns.com/MessageHistory.html">message history</a> pattern, letting you keep track of all traversed components, including the name of each channel and endpoint as well as the timestamp of that traversal.
See <a href="#message-history">Message History</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-message-store"><a class="anchor" href="#new-message-store"></a>Message Store</h5>
<div class="paragraph">
<p>We now provide support for the <a href="https://www.enterpriseintegrationpatterns.com/MessageStore.html">message store</a> pattern.
The message store provides a strategy for persisting messages on behalf of any process whose scope extends beyond a single transaction, such as the aggregator and the resequencer.
Many sections of this guide include samples of how to use a message store, as it affects several areas of Spring Integration.
See <a href="#message-store">Message Store</a>, <a href="#claim-check">Claim Check</a>, <a href="#channel">Message Channels</a>, <a href="#aggregator">Aggregator</a>, <a href="#jdbc">JDBC Support</a>`", and <a href="#resequencer">Resequencer</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-claim-check"><a class="anchor" href="#new-claim-check"></a>Claim Check</h5>
<div class="paragraph">
<p>We have added an implementation of the <a href="https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">claim check</a> pattern.
The idea behind the claim check pattern is that you can exchange a message payload for a &#8220;claim ticket&#8221;.
This lets you reduce bandwidth and avoid potential security issues when sending messages across channels.
See <a href="#claim-check">Claim Check</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-control-bus"><a class="anchor" href="#new-control-bus"></a>Control Bus</h5>
<div class="paragraph">
<p>We have provided implementations of the <a href="https://www.enterpriseintegrationpatterns.com/ControlBus.html">control bus</a> pattern, which lets you use messaging to manage and monitor endpoints and channels.
The implementations include both a SpEL-based approach and one that runs Groovy scripts.
See <a href="#control-bus">Control Bus</a> and <a href="#groovy-control-bus">Control Bus</a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="new-adapters"><a class="anchor" href="#new-adapters"></a>I.15.3. New Channel Adapters and Gateways</h4>
<div class="paragraph">
<p>We have added several new channel adapters and messaging gateways in Spring Integration 2.0.</p>
</div>
<div class="sect4">
<h5 id="new-ip"><a class="anchor" href="#new-ip"></a>TCP and UDP Adapters</h5>
<div class="paragraph">
<p>We have added channel adapters for receiving and sending messages over the TCP and UDP internet protocols.
See <a href="#ip">TCP and UDP Support</a> for more details.
See also the following blog: <a href="https://spring.io/blog/2010/03/29/using-udp-and-tcp-adapters-in-spring-integration-2-0-m3/">&#8220;Using UDP and TCP Adapters in Spring Integration 2.0 M3&#8221;</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-twitter"><a class="anchor" href="#new-twitter"></a>Twitter Adapters</h5>
<div class="paragraph">
<p>Twitter adapters provides support for sending and receiving Twitter status updates as well as direct messages.
You can also perform Twitter Searches with an inbound channel adapter.
See <a href="https://github.com/spring-projects/spring-integration-extensions/tree/master/spring-integration-social-twitter">Spring Integration Social Twitter</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-xmpp"><a class="anchor" href="#new-xmpp"></a>XMPP Adapters</h5>
<div class="paragraph">
<p>The new XMPP adapters support both chat messages and presence events.
See <a href="#xmpp">XMPP Support</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-ftp"><a class="anchor" href="#new-ftp"></a>FTP and FTPS Adapters</h5>
<div class="paragraph">
<p>Inbound and outbound file transfer support over FTP and FTPS is now available.
See <a href="#ftp">FTP/FTPS Adapters</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-sftp"><a class="anchor" href="#new-sftp"></a>SFTP Adapters</h5>
<div class="paragraph">
<p>Inbound and outbound file transfer support over SFTP is now available.
See <a href="#sftp">SFTP Adapters</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-feed"><a class="anchor" href="#new-feed"></a>Feed Adapters</h5>
<div class="paragraph">
<p>We have also added channel adapters for receiving news feeds (ATOM and RSS).
See <a href="#feed">Feed Adapter</a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="new-other"><a class="anchor" href="#new-other"></a>I.15.4. Other Additions</h4>
<div class="paragraph">
<p>Spring Integration adds a number of other features.
This section describes them.</p>
</div>
<div class="sect4">
<h5 id="new-groovy"><a class="anchor" href="#new-groovy"></a>Groovy Support</h5>
<div class="paragraph">
<p>Spring Integration 2.0 added Groovy support, letting you use the Groovy scripting language to provide integration and business logic.
See <a href="#groovy">Groovy support</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-map-transformer"><a class="anchor" href="#new-map-transformer"></a>Map Transformers</h5>
<div class="paragraph">
<p>These symmetrical transformers convert payload objects to and from <code>Map</code> objects.
See <a href="#transformer">Transformer</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-json-transformer"><a class="anchor" href="#new-json-transformer"></a>JSON Transformers</h5>
<div class="paragraph">
<p>These symmetrical transformers convert payload objects to and from JSON.
See <a href="#transformer">Transformer</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="new-serialize-transformer"><a class="anchor" href="#new-serialize-transformer"></a>Serialization Transformers</h5>
<div class="paragraph">
<p>These symmetrical transformers convert payload objects to and from byte arrays.
They also support the serializer and deserializer strategy interfaces that Spring 3.0.5 added.
See <a href="#transformer">Transformer</a> for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="new-refactoring"><a class="anchor" href="#new-refactoring"></a>I.15.5. Framework Refactoring</h4>
<div class="paragraph">
<p>The core API went through some significant refactoring to make it simpler and more usable.
Although we anticipate that the impact to developers should be minimal, you should read through this document to find what was changed.
Specifically, you should read <a href="#dynamic-routers">Dynamic Routers</a>, <a href="#gateway">Messaging Gateways</a>, <a href="#http-outbound">HTTP Outbound Components</a>, <a href="#message">Message</a>, and <a href="#aggregator">Aggregator</a>.
If you directly depend on some of the core components (<code>Message</code>, <code>MessageHeaders</code>, <code>MessageChannel</code>, <code>MessageBuilder</code>, and others), you need to update any import statements.
We restructured some packaging to provide the flexibility we needed for extending the domain model while avoiding any cyclical dependencies (it is a policy of the framework to avoid such &#8220;tangles&#8221;).</p>
</div>
</div>
<div class="sect3">
<h4 id="new-infrastructure"><a class="anchor" href="#new-infrastructure"></a>I.15.6. New Source Control Management and Build Infrastructure</h4>
<div class="paragraph">
<p>With Spring Integration 2.0, we switched our build environment to use Git for source control.
To access our repository, visit <a href="https://git.springsource.org/spring-integration" class="bare">git.springsource.org/spring-integration</a>.
We have also switched our build system to <a href="https://gradle.org/">Gradle</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="new-samples"><a class="anchor" href="#new-samples"></a>I.15.7. New Spring Integration Samples</h4>
<div class="paragraph">
<p>With Spring Integration 2.0, we have decoupled the samples from our main release distribution.
Please read the following blog to get more information: <a href="https://spring.io/blog/2010/09/29/new-spring-integration-samples/">New Spring Integration Samples</a>.
We have also created many new samples, including samples for every new adapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="new-sts"><a class="anchor" href="#new-sts"></a>I.15.8. Spring Tool Suite Visual Editor for Spring Integration</h4>
<div class="paragraph">
<p>There is an amazing new visual editor for Spring Integration included within the latest version of SpringSource Tool Suite.
If you are not already using STS, you can download it athttps://spring.io/tools/sts[Spring Tool Suite].</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-05-13 16:21:11 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>