<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>15.&nbsp;Integration Testing</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Spring Framework Reference Documentation"><link rel="up" href="testing.html" title="Part&nbsp;IV.&nbsp;Testing"><link rel="prev" href="unit-testing.html" title="14.&nbsp;Unit Testing"><link rel="next" href="testing-resources.html" title="16.&nbsp;Further Resources"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">15.&nbsp;Integration Testing</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="unit-testing.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Testing</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="testing-resources.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="integration-testing" href="#integration-testing"></a>15.&nbsp;Integration Testing</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing-overview" href="#integration-testing-overview"></a>15.1&nbsp;Overview</h2></div></div></div>

<p>It is important to be able to perform some integration testing without requiring
deployment to your application server or connecting to other enterprise infrastructure.
This will enable you to test things such as:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The correct wiring of your Spring IoC container contexts.
</li><li class="listitem">
Data access using JDBC or an ORM tool. This would include such things as the
correctness of SQL statements, Hibernate queries, JPA entity mappings, etc.
</li></ul></div>
<p>The Spring Framework provides first-class support for integration testing in the
<code class="literal">spring-test</code> module. The name of the actual JAR file might include the release version
and might also be in the long <code class="literal">org.springframework.test</code> form, depending on where you
get it from (see the <a class="link" href="overview.html#dependency-management" title="2.3.1&nbsp;Dependency Management and Naming Conventions">section on Dependency Management</a> for an
explanation). This library includes the <code class="literal">org.springframework.test</code> package, which
contains valuable classes for integration testing with a Spring container. This testing
does not rely on an application server or other deployment environment. Such tests are
slower to run than unit tests but much faster than the equivalent Selenium tests or remote
tests that rely on deployment to an application server.</p>
<p>In Spring 2.5 and later, unit and integration testing support is provided in the form of
the annotation-driven <a class="link" href="integration-testing.html#testcontext-framework" title="15.5&nbsp;Spring TestContext Framework">Spring TestContext Framework</a>. The
TestContext framework is agnostic of the actual testing framework in use, thus allowing
instrumentation of tests in various environments including JUnit, TestNG, and so on.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing-goals" href="#integration-testing-goals"></a>15.2&nbsp;Goals of Integration Testing</h2></div></div></div>

<p>Spring&#8217;s integration testing support has the following primary goals:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
To manage <a class="link" href="integration-testing.html#testing-ctx-management" title="15.2.1&nbsp;Context management and caching">Spring IoC container caching</a> between test
execution.
</li><li class="listitem">
To provide <a class="link" href="integration-testing.html#testing-fixture-di" title="15.2.2&nbsp;Dependency Injection of test fixtures">Dependency Injection of test fixture instances</a>.
</li><li class="listitem">
To provide <a class="link" href="integration-testing.html#testing-tx" title="15.2.3&nbsp;Transaction management">transaction management</a> appropriate to integration testing.
</li><li class="listitem">
To supply <a class="link" href="integration-testing.html#testing-support-classes" title="15.2.4&nbsp;Support classes for integration testing">Spring-specific base classes</a> that assist
developers in writing integration tests.
</li></ul></div>
<p>The next few sections describe each goal and provide links to implementation and
configuration details.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testing-ctx-management" href="#testing-ctx-management"></a>15.2.1&nbsp;Context management and caching</h3></div></div></div>

<p>The Spring TestContext Framework provides consistent loading of Spring
<code class="literal">ApplicationContext</code>s and <code class="literal">WebApplicationContext</code>s as well as caching of those
contexts. Support for the caching of loaded contexts is important, because startup time
can become an issue&#8201;&#8212;&#8201;not because of the overhead of Spring itself, but because the
objects instantiated by the Spring container take time to instantiate. For example, a
project with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to load the
mapping files, and incurring that cost before running every test in every test fixture
leads to slower overall test runs that reduce developer productivity.</p>
<p>Test classes typically declare either an array of <span class="emphasis"><em>resource locations</em></span> for XML or Groovy
configuration metadata&#8201;&#8212;&#8201;often in the classpath&#8201;&#8212;&#8201;or an array of <span class="emphasis"><em>annotated classes</em></span>
that is used to configure the application. These locations or classes are the same as or
similar to those specified in <code class="literal">web.xml</code> or other configuration files for production
deployments.</p>
<p>By default, once loaded, the configured <code class="literal">ApplicationContext</code> is reused for each test.
Thus the setup cost is incurred only once per test suite, and subsequent test execution
is much faster. In this context, the term <span class="emphasis"><em>test suite</em></span> means all tests run in the same
JVM&#8201;&#8212;&#8201;for example, all tests run from an Ant, Maven, or Gradle build for a given
project or module. In the unlikely case that a test corrupts the application context and
requires reloading&#8201;&#8212;&#8201;for example, by modifying a bean definition or the state of an
application object&#8201;&#8212;&#8201;the TestContext framework can be configured to reload the
configuration and rebuild the application context before executing the next test.</p>
<p>See <a class="xref" href="integration-testing.html#testcontext-ctx-management" title="15.5.4&nbsp;Context management">Section&nbsp;15.5.4, &#8220;Context management&#8221;</a> and <a class="xref" href="integration-testing.html#testcontext-ctx-management-caching" title="Context caching">the section called &#8220;Context caching&#8221;</a> with the
TestContext framework.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testing-fixture-di" href="#testing-fixture-di"></a>15.2.2&nbsp;Dependency Injection of test fixtures</h3></div></div></div>

<p>When the TestContext framework loads your application context, it can optionally
configure instances of your test classes via Dependency Injection. This provides a
convenient mechanism for setting up test fixtures using preconfigured beans from your
application context. A strong benefit here is that you can reuse application contexts
across various testing scenarios (e.g., for configuring Spring-managed object graphs,
transactional proxies, <code class="literal">DataSource</code>s, etc.), thus avoiding the need to duplicate
complex test fixture setup for individual test cases.</p>
<p>As an example, consider the scenario where we have a class, <code class="literal">HibernateTitleRepository</code>,
that implements data access logic for a <code class="literal">Title</code> domain entity. We want to write
integration tests that test the following areas:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The Spring configuration: basically, is everything related to the configuration of the
<code class="literal">HibernateTitleRepository</code> bean correct and present?
</li><li class="listitem">
The Hibernate mapping file configuration: is everything mapped correctly, and are the
correct lazy-loading settings in place?
</li><li class="listitem">
The logic of the <code class="literal">HibernateTitleRepository</code>: does the configured instance of this
class perform as anticipated?
</li></ul></div>
<p>See dependency injection of test fixtures with the <a class="link" href="integration-testing.html#testcontext-fixture-di" title="15.5.5&nbsp;Dependency injection of test fixtures">TestContext
framework</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testing-tx" href="#testing-tx"></a>15.2.3&nbsp;Transaction management</h3></div></div></div>

<p>One common issue in tests that access a real database is their effect on the state of
the persistence store. Even when you&#8217;re using a development database, changes to the
state may affect future tests. Also, many operations&#8201;&#8212;&#8201;such as inserting or modifying
persistent data&#8201;&#8212;&#8201;cannot be performed (or verified) outside a transaction.</p>
<p>The TestContext framework addresses this issue. By default, the framework will create
and roll back a transaction for each test. You simply write code that can assume the
existence of a transaction. If you call transactionally proxied objects in your tests,
they will behave correctly, according to their configured transactional semantics. In
addition, if a test method deletes the contents of selected tables while running within
the transaction managed for the test, the transaction will roll back by default, and the
database will return to its state prior to execution of the test. Transactional support
is provided to a test via a <code class="literal">PlatformTransactionManager</code> bean defined in the test&#8217;s
application context.</p>
<p>If you want a transaction to commit&#8201;&#8212;&#8201;unusual, but occasionally useful when you want a
particular test to populate or modify the database&#8201;&#8212;&#8201;the TestContext framework can be
instructed to cause the transaction to commit instead of roll back via the
<a class="link" href="integration-testing.html#integration-testing-annotations" title="15.4&nbsp;Annotations"><code class="literal">@Commit</code></a> annotation.</p>
<p>See transaction management with the <a class="link" href="integration-testing.html#testcontext-tx" title="15.5.7&nbsp;Transaction management">TestContext framework</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testing-support-classes" href="#testing-support-classes"></a>15.2.4&nbsp;Support classes for integration testing</h3></div></div></div>

<p>The Spring TestContext Framework provides several <code class="literal">abstract</code> support classes that
simplify the writing of integration tests. These base test classes provide well-defined
hooks into the testing framework as well as convenient instance variables and methods,
which enable you to access:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The <code class="literal">ApplicationContext</code>, for performing explicit bean lookups or testing the state of
the context as a whole.
</li><li class="listitem">
A <code class="literal">JdbcTemplate</code>, for executing SQL statements to query the database. Such queries can
be used to confirm database state both <span class="emphasis"><em>prior to</em></span> and <span class="emphasis"><em>after</em></span> execution of
database-related application code, and Spring ensures that such queries run in the
scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <a class="link" href="integration-testing.html#testcontext-tx-false-positives" title="Avoid false positives when testing ORM code">false positives</a>.
</li></ul></div>
<p>In addition, you may want to create your own custom, application-wide superclass with
instance variables and methods specific to your project.</p>
<p>See support classes for the <a class="link" href="integration-testing.html#testcontext-support-classes" title="15.5.9&nbsp;TestContext Framework support classes">TestContext framework</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing-support-jdbc" href="#integration-testing-support-jdbc"></a>15.3&nbsp;JDBC Testing Support</h2></div></div></div>

<p>The <code class="literal">org.springframework.test.jdbc</code> package contains <code class="literal">JdbcTestUtils</code>, which is a
collection of JDBC related utility functions intended to simplify standard database
testing scenarios. Specifically, <code class="literal">JdbcTestUtils</code> provides the following static utility
methods.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">countRowsInTable(..)</code>: counts the number of rows in the given table
</li><li class="listitem">
<code class="literal">countRowsInTableWhere(..)</code>: counts the number of rows in the given table, using
the provided <code class="literal">WHERE</code> clause
</li><li class="listitem">
<code class="literal">deleteFromTables(..)</code>: deletes all rows from the specified tables
</li><li class="listitem">
<code class="literal">deleteFromTableWhere(..)</code>: deletes rows from the given table, using the provided
<code class="literal">WHERE</code> clause
</li><li class="listitem">
<code class="literal">dropTables(..)</code>: drops the specified tables
</li></ul></div>
<p><span class="emphasis"><em>Note that <a class="link" href="integration-testing.html#testcontext-support-classes-junit4" title="JUnit 4 support classes"><code class="literal">AbstractTransactionalJUnit4SpringContextTests</code></a> and
<a class="link" href="integration-testing.html#testcontext-support-classes-testng" title="TestNG support classes"><code class="literal">AbstractTransactionalTestNGSpringContextTests</code></a>
provide convenience methods which delegate to the aforementioned methods in
<code class="literal">JdbcTestUtils</code>.</em></span></p>
<p>The <code class="literal">spring-jdbc</code> module provides support for configuring and launching an embedded
database which can be used in integration tests that interact with a database. For
details, see <a class="xref" href="jdbc.html#jdbc-embedded-database-support" title="19.8&nbsp;Embedded database support">Section&nbsp;19.8, &#8220;Embedded database support&#8221;</a> and
<a class="xref" href="jdbc.html#jdbc-embedded-database-dao-testing" title="19.8.5&nbsp;Testing data access logic with an embedded database">Section&nbsp;19.8.5, &#8220;Testing data access logic with an embedded database&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing-annotations" href="#integration-testing-annotations"></a>15.4&nbsp;Annotations</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-annotations-spring" href="#integration-testing-annotations-spring"></a>15.4.1&nbsp;Spring Testing Annotations</h3></div></div></div>

<p>The Spring Framework provides the following set of <span class="emphasis"><em>Spring-specific</em></span> annotations that
you can use in your unit and integration tests in conjunction with the TestContext
framework. Refer to the corresponding javadocs for further information, including
default attribute values, attribute aliases, and so on.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__bootstrapwith" href="#__bootstrapwith"></a>@BootstrapWith</h4></div></div></div>

<p><code class="literal">@BootstrapWith</code> is a class-level annotation that is used to configure how the <span class="emphasis"><em>Spring
TestContext Framework</em></span> is bootstrapped. Specifically, <code class="literal">@BootstrapWith</code> is used to specify
a custom <code class="literal">TestContextBootstrapper</code>. Consult the <a class="link" href="integration-testing.html#testcontext-bootstrapping" title="15.5.2&nbsp;Bootstrapping the TestContext framework">Bootstrapping
the TestContext framework</a> section for further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__contextconfiguration" href="#__contextconfiguration"></a>@ContextConfiguration</h4></div></div></div>

<p><code class="literal">@ContextConfiguration</code> defines class-level metadata that is used to determine how to
load and configure an <code class="literal">ApplicationContext</code> for integration tests. Specifically,
<code class="literal">@ContextConfiguration</code> declares the application context resource <code class="literal">locations</code> or the
annotated <code class="literal">classes</code> that will be used to load the context.</p>
<p>Resource locations are typically XML configuration files or Groovy scripts located in
the classpath; whereas, annotated classes are typically <code class="literal">@Configuration</code> classes. However,
resource locations can also refer to files and scripts in the file system, and annotated
classes can be component classes, etc.</p>
<pre class="programlisting"><span class="strong"><strong>@ContextConfiguration</strong></span>(<span class="hl-string">"/test-config.xml"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> XmlApplicationContextTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<pre class="programlisting"><span class="strong"><strong>@ContextConfiguration</strong></span>(<span class="strong"><strong>classes</strong></span> = TestConfig.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ConfigClassApplicationContextTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>As an alternative or in addition to declaring resource locations or annotated classes,
<code class="literal">@ContextConfiguration</code> may be used to declare <code class="literal">ApplicationContextInitializer</code> classes.</p>
<pre class="programlisting"><span class="strong"><strong>@ContextConfiguration</strong></span>(<span class="strong"><strong>initializers</strong></span> = CustomContextIntializer.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextInitializerTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><code class="literal">@ContextConfiguration</code> may optionally be used to declare the <code class="literal">ContextLoader</code> strategy
as well. Note, however, that you typically do not need to explicitly configure the
loader since the default loader supports either resource <code class="literal">locations</code> or annotated
<code class="literal">classes</code> as well as <code class="literal">initializers</code>.</p>
<pre class="programlisting"><span class="strong"><strong>@ContextConfiguration</strong></span>(<span class="strong"><strong>locations</strong></span> = <span class="hl-string">"/test-context.xml"</span>, <span class="strong"><strong>loader</strong></span> = CustomContextLoader.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomLoaderXmlApplicationContextTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">@ContextConfiguration</code> provides support for <span class="emphasis"><em>inheriting</em></span> resource locations or
configuration classes as well as context initializers declared by superclasses by
default.</p>
</td></tr></table></div>
<p>See <a class="xref" href="integration-testing.html#testcontext-ctx-management" title="15.5.4&nbsp;Context management">Section&nbsp;15.5.4, &#8220;Context management&#8221;</a> and the <code class="literal">@ContextConfiguration</code> javadocs for
further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__webappconfiguration" href="#__webappconfiguration"></a>@WebAppConfiguration</h4></div></div></div>

<p><code class="literal">@WebAppConfiguration</code> is a class-level annotation that is used to declare that the
<code class="literal">ApplicationContext</code> loaded for an integration test should be a <code class="literal">WebApplicationContext</code>.
The mere presence of <code class="literal">@WebAppConfiguration</code> on a test class ensures that a
<code class="literal">WebApplicationContext</code> will be loaded for the test, using the default value of
<code class="literal">"file:src/main/webapp"</code> for the path to the root of the web application (i.e., the
<span class="emphasis"><em>resource base path</em></span>). The resource base path is used behind the scenes to create a
<code class="literal">MockServletContext</code> which serves as the <code class="literal">ServletContext</code> for the test&#8217;s
<code class="literal">WebApplicationContext</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@WebAppConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebAppTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>To override the default, specify a different base resource path via the <span class="emphasis"><em>implicit</em></span>
<code class="literal">value</code> attribute. Both <code class="literal">classpath:</code> and <code class="literal">file:</code> resource prefixes are supported. If no
resource prefix is supplied the path is assumed to be a file system resource.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@WebAppConfiguration("classpath:test-web-resources")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebAppTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>Note that <code class="literal">@WebAppConfiguration</code> must be used in conjunction with
<code class="literal">@ContextConfiguration</code>, either within a single test class or within a test class
hierarchy. See the <code class="literal">@WebAppConfiguration</code> javadocs for further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__contexthierarchy" href="#__contexthierarchy"></a>@ContextHierarchy</h4></div></div></div>

<p><code class="literal">@ContextHierarchy</code> is a class-level annotation that is used to define a hierarchy of
<code class="literal">ApplicationContext</code>s for integration tests. <code class="literal">@ContextHierarchy</code> should be declared
with a list of one or more <code class="literal">@ContextConfiguration</code> instances, each of which defines a
level in the context hierarchy. The following examples demonstrate the use of
<code class="literal">@ContextHierarchy</code> within a single test class; however, <code class="literal">@ContextHierarchy</code> can also be
used within a test class hierarchy.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextHierarchyTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WebIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>If you need to merge or override the configuration for a given level of the context
hierarchy within a test class hierarchy, you must explicitly name that level by
supplying the same value to the <code class="literal">name</code> attribute in <code class="literal">@ContextConfiguration</code> at each
corresponding level in the class hierarchy. See
<a class="xref" href="integration-testing.html#testcontext-ctx-management-ctx-hierarchies" title="Context hierarchies">the section called &#8220;Context hierarchies&#8221;</a> and the <code class="literal">@ContextHierarchy</code> javadocs
for further examples.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__activeprofiles" href="#__activeprofiles"></a>@ActiveProfiles</h4></div></div></div>

<p><code class="literal">@ActiveProfiles</code> is a class-level annotation that is used to declare which <span class="emphasis"><em>bean
definition profiles</em></span> should be active when loading an <code class="literal">ApplicationContext</code> for an
integration test.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@ActiveProfiles</strong></span>(<span class="hl-string">"dev"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DeveloperTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@ActiveProfiles</strong></span>({<span class="hl-string">"dev"</span>, <span class="hl-string">"integration"</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DeveloperIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">@ActiveProfiles</code> provides support for <span class="emphasis"><em>inheriting</em></span> active bean definition profiles
declared by superclasses by default. It is also possible to resolve active bean
definition profiles programmatically by implementing a custom
<a class="link" href="integration-testing.html#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code class="literal">ActiveProfilesResolver</code></a>
and registering it via the <code class="literal">resolver</code> attribute of <code class="literal">@ActiveProfiles</code>.</p>
</td></tr></table></div>
<p>See <a class="xref" href="integration-testing.html#testcontext-ctx-management-env-profiles" title="Context configuration with environment profiles">the section called &#8220;Context configuration with environment profiles&#8221;</a> and the <code class="literal">@ActiveProfiles</code> javadocs
for examples and further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__testpropertysource" href="#__testpropertysource"></a>@TestPropertySource</h4></div></div></div>

<p><code class="literal">@TestPropertySource</code> is a class-level annotation that is used to configure the locations
of properties files and inlined properties to be added to the set of <code class="literal">PropertySources</code> in
the <code class="literal">Environment</code> for an <code class="literal">ApplicationContext</code> loaded for an integration test.</p>
<p>Test property sources have higher precedence than those loaded from the operating
system&#8217;s environment or Java system properties as well as property sources added by the
application declaratively via <code class="literal">@PropertySource</code> or programmatically. Thus, test property
sources can be used to selectively override properties defined in system and application
property sources. Furthermore, inlined properties have higher precedence than properties
loaded from resource locations.</p>
<p>The following example demonstrates how to declare a properties file from the classpath.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@TestPropertySource</strong></span>(<span class="hl-string">"/test.properties"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>The following example demonstrates how to declare <span class="emphasis"><em>inlined</em></span> properties.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@TestPropertySource</strong></span>(properties = { <span class="hl-string">"timezone = GMT"</span>, <span class="hl-string">"port: 4242"</span> })
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__dirtiescontext" href="#__dirtiescontext"></a>@DirtiesContext</h4></div></div></div>

<p><code class="literal">@DirtiesContext</code> indicates that the underlying Spring <code class="literal">ApplicationContext</code> has been
<span class="emphasis"><em>dirtied</em></span> during the execution of a test (i.e., modified or corrupted in some manner&#8201;&#8212;&#8201;for example, by changing the state of a singleton bean) and should be closed. When an
application context is marked <span class="emphasis"><em>dirty</em></span>, it is removed from the testing framework&#8217;s cache
and closed. As a consequence, the underlying Spring container will be rebuilt for any
subsequent test that requires a context with the same configuration metadata.</p>
<p><code class="literal">@DirtiesContext</code> can be used as both a class-level and method-level annotation within
the same class or class hierarchy. In such scenarios, the <code class="literal">ApplicationContext</code> is marked
as <span class="emphasis"><em>dirty</em></span> before or after any such annotated method as well as before or after the
current test class, depending on the configured <code class="literal">methodMode</code> and <code class="literal">classMode</code>.</p>
<p>The following examples explain when the context would be dirtied for various
configuration scenarios:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<p class="simpara">Before the current test class, when declared on a class with class mode set to
<code class="literal">BEFORE_CLASS</code>.</p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext(classMode = BEFORE_CLASS)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FreshContextTests {
    <span class="hl-comment">// some tests that require a new Spring container</span>
}</pre>
</li><li class="listitem">
<p class="simpara">After the current test class, when declared on a class with class mode set to
<code class="literal">AFTER_CLASS</code> (i.e., the default class mode).</p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextDirtyingTests {
    <span class="hl-comment">// some tests that result in the Spring container being dirtied</span>
}</pre>
</li><li class="listitem">
<p class="simpara">Before each test method in the current test class, when declared on a class with class
mode set to <code class="literal">BEFORE_EACH_TEST_METHOD.</code></p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FreshContextTests {
    <span class="hl-comment">// some tests that require a new Spring container</span>
}</pre>
</li><li class="listitem">
<p class="simpara">After each test method in the current test class, when declared on a class with class
mode set to <code class="literal">AFTER_EACH_TEST_METHOD.</code></p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ContextDirtyingTests {
    <span class="hl-comment">// some tests that result in the Spring container being dirtied</span>
}</pre>
</li><li class="listitem">
<p class="simpara">Before the current test, when declared on a method with the method mode set to
<code class="literal">BEFORE_METHOD</code>.</p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext(methodMode = BEFORE_METHOD)</strong></span>
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichRequiresFreshAppCtx() {
    <span class="hl-comment">// some logic that requires a new Spring container</span>
}</pre>
</li><li class="listitem">
<p class="simpara">After the current test, when declared on a method with the method mode set to
<code class="literal">AFTER_METHOD</code> (i.e., the default method mode).</p>
<pre class="programlisting"><span class="strong"><strong>@DirtiesContext</strong></span>
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichDirtiesAppCtx() {
    <span class="hl-comment">// some logic that results in the Spring container being dirtied</span>
}</pre>
</li></ul></div>
<p>If <code class="literal">@DirtiesContext</code> is used in a test whose context is configured as part of a context
hierarchy via <code class="literal">@ContextHierarchy</code>, the <code class="literal">hierarchyMode</code> flag can be used to control how
the context cache is cleared. By default an <span class="emphasis"><em>exhaustive</em></span> algorithm will be used that
clears the context cache including not only the current level but also all other context
hierarchies that share an ancestor context common to the current test; all
<code class="literal">ApplicationContext</code>s that reside in a sub-hierarchy of the common ancestor context
will be removed from the context cache and closed. If the <span class="emphasis"><em>exhaustive</em></span> algorithm is
overkill for a particular use case, the simpler <span class="emphasis"><em>current level</em></span> algorithm can be
specified instead, as seen below.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTests {
    <span class="hl-comment">// class body...</span>
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTests <span class="hl-keyword">extends</span> BaseTests {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    @DirtiesContext(<span class="strong"><strong>hierarchyMode = CURRENT_LEVEL</strong></span>)
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> test() {
        <span class="hl-comment">// some logic that results in the child context being dirtied</span>
    }
}</pre>
<p>For further details regarding the <code class="literal">EXHAUSTIVE</code> and <code class="literal">CURRENT_LEVEL</code> algorithms see the
<code class="literal">DirtiesContext.HierarchyMode</code> javadocs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__testexecutionlisteners" href="#__testexecutionlisteners"></a>@TestExecutionListeners</h4></div></div></div>

<p><code class="literal">@TestExecutionListeners</code> defines class-level metadata for configuring the
<code class="literal">TestExecutionListener</code> implementations that should be registered with the
<code class="literal">TestContextManager</code>. Typically, <code class="literal">@TestExecutionListeners</code> is used in conjunction with
<code class="literal">@ContextConfiguration</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@TestExecutionListeners</strong></span>({CustomTestExecutionListener.<span class="hl-keyword">class</span>, AnotherTestExecutionListener.<span class="hl-keyword">class</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomTestExecutionListenerTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><code class="literal">@TestExecutionListeners</code> supports <span class="emphasis"><em>inherited</em></span> listeners by default. See the javadocs
for an example and further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__commit" href="#__commit"></a>@Commit</h4></div></div></div>

<p><code class="literal">@Commit</code> indicates that the transaction for a transactional test method should be
<span class="emphasis"><em>committed</em></span> after the test method has completed. <code class="literal">@Commit</code> can be used as a direct
replacement for <code class="literal">@Rollback(false)</code> in order to more explicitly convey the intent of the
code. Analogous to <code class="literal">@Rollback</code>, <code class="literal">@Commit</code> may also be declared as a class-level or
method-level annotation.</p>
<pre class="programlisting"><span class="strong"><strong>@Commit</strong></span>
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithoutRollback() {
    <span class="hl-comment">// ...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__rollback" href="#__rollback"></a>@Rollback</h4></div></div></div>

<p><code class="literal">@Rollback</code> indicates whether the transaction for a transactional test method should be
<span class="emphasis"><em>rolled back</em></span> after the test method has completed. If <code class="literal">true</code>, the transaction is rolled
back; otherwise, the transaction is committed (see also <code class="literal">@Commit</code>). Rollback semantics
for integration tests in the Spring TestContext Framework default to <code class="literal">true</code> even if
<code class="literal">@Rollback</code> is not explicitly declared.</p>
<p>When declared as a class-level annotation, <code class="literal">@Rollback</code> defines the default rollback
semantics for all test methods within the test class hierarchy. When declared as a
method-level annotation, <code class="literal">@Rollback</code> defines rollback semantics for the specific test
method, potentially overriding class-level <code class="literal">@Rollback</code> or <code class="literal">@Commit</code> semantics.</p>
<pre class="programlisting"><span class="strong"><strong>@Rollback</strong></span>(false)
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithoutRollback() {
    <span class="hl-comment">// ...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__beforetransaction" href="#__beforetransaction"></a>@BeforeTransaction</h4></div></div></div>

<p><code class="literal">@BeforeTransaction</code> indicates that the annotated <code class="literal">void</code> method should be executed
<span class="emphasis"><em>before</em></span> a transaction is started for test methods configured to run within a
transaction via Spring&#8217;s <code class="literal">@Transactional</code> annotation. As of Spring Framework 4.3,
<code class="literal">@BeforeTransaction</code> methods are not required to be <code class="literal">public</code> and may be declared on Java
8 based interface default methods.</p>
<pre class="programlisting"><span class="strong"><strong>@BeforeTransaction</strong></span>
<span class="hl-keyword">void</span> beforeTransaction() {
    <span class="hl-comment">// logic to be executed before a transaction is started</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__aftertransaction" href="#__aftertransaction"></a>@AfterTransaction</h4></div></div></div>

<p><code class="literal">@AfterTransaction</code> indicates that the annotated <code class="literal">void</code> method should be executed
<span class="emphasis"><em>after</em></span> a transaction is ended for test methods configured to run within a transaction
via Spring&#8217;s <code class="literal">@Transactional</code> annotation. As of Spring Framework 4.3, <code class="literal">@AfterTransaction</code>
methods are not required to be <code class="literal">public</code> and may be declared on Java 8 based interface
default methods.</p>
<pre class="programlisting"><span class="strong"><strong>@AfterTransaction</strong></span>
<span class="hl-keyword">void</span> afterTransaction() {
    <span class="hl-comment">// logic to be executed after a transaction has ended</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__sql" href="#__sql"></a>@Sql</h4></div></div></div>

<p><code class="literal">@Sql</code> is used to annotate a test class or test method to configure SQL scripts to be
executed against a given database during integration tests.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="strong"><strong>@Sql</strong></span>({<span class="hl-string">"/test-schema.sql"</span>, <span class="hl-string">"/test-user-data.sql"</span>})
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that relies on the test schema and test data</span>
}</pre>
<p>See <a class="xref" href="integration-testing.html#testcontext-executing-sql-declaratively" title="Executing SQL scripts declaratively with @Sql">the section called &#8220;Executing SQL scripts declaratively with @Sql&#8221;</a> for further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__sqlconfig" href="#__sqlconfig"></a>@SqlConfig</h4></div></div></div>

<p><code class="literal">@SqlConfig</code> defines metadata that is used to determine how to parse and execute SQL
scripts configured via the <code class="literal">@Sql</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
@Sql(
    scripts = <span class="hl-string">"/test-user-data.sql"</span>,
    config = <span class="strong"><strong>@SqlConfig</strong></span>(commentPrefix = <span class="hl-string">"`"</span>, separator = <span class="hl-string">"@@"</span>)
)
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that relies on the test data</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__sqlgroup" href="#__sqlgroup"></a>@SqlGroup</h4></div></div></div>

<p><code class="literal">@SqlGroup</code> is a container annotation that aggregates several <code class="literal">@Sql</code> annotations.
<code class="literal">@SqlGroup</code> can be used natively, declaring several nested <code class="literal">@Sql</code> annotations, or it can
be used in conjunction with Java 8&#8217;s support for repeatable annotations, where <code class="literal">@Sql</code> can
simply be declared several times on the same class or method, implicitly generating this
container annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="strong"><strong>@SqlGroup</strong></span>({
    <em><span class="hl-annotation" style="color: gray">@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),</span></em>
    <em><span class="hl-annotation" style="color: gray">@Sql("/test-user-data.sql")</span></em>
)}
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that uses the test schema and test data</span>
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-annotations-standard" href="#integration-testing-annotations-standard"></a>15.4.2&nbsp;Standard Annotation Support</h3></div></div></div>

<p>The following annotations are supported with standard semantics for all configurations
of the Spring TestContext Framework. Note that these annotations are not specific to
tests and can be used anywhere in the Spring Framework.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">@Autowired</code>
</li><li class="listitem">
<code class="literal">@Qualifier</code>
</li><li class="listitem">
<code class="literal">@Resource</code> (javax.annotation) <span class="emphasis"><em>if JSR-250 is present</em></span>
</li><li class="listitem">
<code class="literal">@ManagedBean</code> (javax.annotation) <span class="emphasis"><em>if JSR-250 is present</em></span>
</li><li class="listitem">
<code class="literal">@Inject</code> (javax.inject) <span class="emphasis"><em>if JSR-330 is present</em></span>
</li><li class="listitem">
<code class="literal">@Named</code> (javax.inject) <span class="emphasis"><em>if JSR-330 is present</em></span>
</li><li class="listitem">
<code class="literal">@PersistenceContext</code> (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span>
</li><li class="listitem">
<code class="literal">@PersistenceUnit</code> (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span>
</li><li class="listitem">
<code class="literal">@Required</code>
</li><li class="listitem">
<code class="literal">@Transactional</code>
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: JSR-250 Lifecycle Annotations"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">JSR-250 Lifecycle Annotations</th></tr><tr><td align="left" valign="top">

<p>In the Spring TestContext Framework <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> may be used with
standard semantics on any application components configured in the <code class="literal">ApplicationContext</code>;
however, these lifecycle annotations have limited usage within an actual test class.</p>
<p>If a method within a test class is annotated with <code class="literal">@PostConstruct</code>, that method will be
executed before any <span class="emphasis"><em>before</em></span> methods of the underlying test framework (e.g., methods
annotated with JUnit 4&#8217;s <code class="literal">@Before</code>), and that will apply for every test method in the test
class. On the other hand, if a method within a test class is annotated with
<code class="literal">@PreDestroy</code>, that method will <span class="emphasis"><em>never</em></span> be executed. Within a test class it is
therefore recommended to use test lifecycle callbacks from the underlying test framework
instead of <code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-annotations-junit" href="#integration-testing-annotations-junit"></a>15.4.3&nbsp;Spring JUnit 4 Testing Annotations</h3></div></div></div>

<p>The following annotations are <span class="emphasis"><em>only</em></span> supported when used in conjunction with the
<a class="link" href="integration-testing.html#testcontext-junit4-runner" title="Spring JUnit 4 Runner">SpringRunner</a>, <a class="link" href="integration-testing.html#testcontext-junit4-rules" title="Spring JUnit 4 Rules">Spring&#8217;s JUnit
rules</a>, or <a class="link" href="integration-testing.html#testcontext-support-classes-junit4" title="JUnit 4 support classes">Spring&#8217;s JUnit 4 support classes</a>.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__ifprofilevalue" href="#__ifprofilevalue"></a>@IfProfileValue</h4></div></div></div>

<p><code class="literal">@IfProfileValue</code> indicates that the annotated test is enabled for a specific testing
environment. If the configured <code class="literal">ProfileValueSource</code> returns a matching <code class="literal">value</code> for the
provided <code class="literal">name</code>, the test is enabled. Otherwise, the test will be disabled and
effectively <span class="emphasis"><em>ignored</em></span>.</p>
<p><code class="literal">@IfProfileValue</code> can be applied at the class level, the method level, or both.
Class-level usage of <code class="literal">@IfProfileValue</code> takes precedence over method-level usage for any
methods within that class or its subclasses. Specifically, a test is enabled if it is
enabled both at the class level <span class="emphasis"><em>and</em></span> at the method level; the absence of
<code class="literal">@IfProfileValue</code> means the test is implicitly enabled. This is analogous to the
semantics of JUnit 4&#8217;s <code class="literal">@Ignore</code> annotation, except that the presence of <code class="literal">@Ignore</code> always
disables a test.</p>
<pre class="programlisting"><span class="strong"><strong>@IfProfileValue</strong></span>(<span class="strong"><strong>name</strong></span>=<span class="hl-string">"java.vendor"</span>, <span class="strong"><strong>value</strong></span>=<span class="hl-string">"Oracle Corporation"</span>)
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichRunsOnlyOnOracleJvm() {
    <span class="hl-comment">// some logic that should run only on Java VMs from Oracle Corporation</span>
}</pre>
<p>Alternatively, you can configure <code class="literal">@IfProfileValue</code> with a list of <code class="literal">values</code> (with <span class="emphasis"><em>OR</em></span>
semantics) to achieve TestNG-like support for <span class="emphasis"><em>test groups</em></span> in a JUnit 4 environment.
Consider the following example:</p>
<pre class="programlisting"><span class="strong"><strong>@IfProfileValue</strong></span>(<span class="strong"><strong>name</strong></span>=<span class="hl-string">"test-groups"</span>, <span class="strong"><strong>values</strong></span>={<span class="hl-string">"unit-tests"</span>, <span class="hl-string">"integration-tests"</span>})
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    <span class="hl-comment">// some logic that should run only for unit and integration test groups</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__profilevaluesourceconfiguration" href="#__profilevaluesourceconfiguration"></a>@ProfileValueSourceConfiguration</h4></div></div></div>

<p><code class="literal">@ProfileValueSourceConfiguration</code> is a class-level annotation that specifies what type
of <code class="literal">ProfileValueSource</code> to use when retrieving <span class="emphasis"><em>profile values</em></span> configured through the
<code class="literal">@IfProfileValue</code> annotation. If <code class="literal">@ProfileValueSourceConfiguration</code> is not declared for a
test, <code class="literal">SystemProfileValueSource</code> is used by default.</p>
<pre class="programlisting"><span class="strong"><strong>@ProfileValueSourceConfiguration</strong></span>(CustomProfileValueSource.<span class="hl-keyword">class</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomProfileValueSourceTests {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__timed" href="#__timed"></a>@Timed</h4></div></div></div>

<p><code class="literal">@Timed</code> indicates that the annotated test method must finish execution in a specified
time period (in milliseconds). If the text execution time exceeds the specified time
period, the test fails.</p>
<p>The time period includes execution of the test method itself, any repetitions of the
test (see <code class="literal">@Repeat</code>), as well as any <span class="emphasis"><em>set up</em></span> or <span class="emphasis"><em>tear down</em></span> of the test fixture.</p>
<pre class="programlisting"><span class="strong"><strong>@Timed</strong></span>(millis=<span class="hl-number">1000</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessWithOneSecondTimeout() {
    <span class="hl-comment">// some logic that should not take longer than 1 second to execute</span>
}</pre>
<p>Spring&#8217;s <code class="literal">@Timed</code> annotation has different semantics than JUnit 4&#8217;s <code class="literal">@Test(timeout=&#8230;&#8203;)</code>
support. Specifically, due to the manner in which JUnit 4 handles test execution timeouts
(that is, by executing the test method in a separate <code class="literal">Thread</code>), <code class="literal">@Test(timeout=&#8230;&#8203;)</code>
preemptively fails the test if the test takes too long. Spring&#8217;s <code class="literal">@Timed</code>, on the other
hand, does not preemptively fail the test but rather waits for the test to complete
before failing.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__repeat" href="#__repeat"></a>@Repeat</h4></div></div></div>

<p><code class="literal">@Repeat</code> indicates that the annotated test method must be executed repeatedly. The
number of times that the test method is to be executed is specified in the annotation.</p>
<p>The scope of execution to be repeated includes execution of the test method itself as
well as any <span class="emphasis"><em>set up</em></span> or <span class="emphasis"><em>tear down</em></span> of the test fixture.</p>
<pre class="programlisting"><span class="strong"><strong>@Repeat</strong></span>(<span class="hl-number">10</span>)
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testProcessRepeatedly() {
    <span class="hl-comment">// ...</span>
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-annotations-meta" href="#integration-testing-annotations-meta"></a>15.4.4&nbsp;Meta-Annotation Support for Testing</h3></div></div></div>

<p>It is possible to use most test-related annotations as
<a class="link" href="beans.html#beans-meta-annotations" title="7.10.2&nbsp;Meta-annotations">meta-annotations</a> in order to create custom <span class="emphasis"><em>composed
annotations</em></span> and reduce configuration duplication across a test suite.</p>
<p>Each of the following may be used as meta-annotations in conjunction with the
<a class="link" href="integration-testing.html#testcontext-framework" title="15.5&nbsp;Spring TestContext Framework">TestContext framework</a>.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">@BootstrapWith</code>
</li><li class="listitem">
<code class="literal">@ContextConfiguration</code>
</li><li class="listitem">
<code class="literal">@ContextHierarchy</code>
</li><li class="listitem">
<code class="literal">@ActiveProfiles</code>
</li><li class="listitem">
<code class="literal">@TestPropertySource</code>
</li><li class="listitem">
<code class="literal">@DirtiesContext</code>
</li><li class="listitem">
<code class="literal">@WebAppConfiguration</code>
</li><li class="listitem">
<code class="literal">@TestExecutionListeners</code>
</li><li class="listitem">
<code class="literal">@Transactional</code>
</li><li class="listitem">
<code class="literal">@BeforeTransaction</code>
</li><li class="listitem">
<code class="literal">@AfterTransaction</code>
</li><li class="listitem">
<code class="literal">@Commit</code>
</li><li class="listitem">
<code class="literal">@Rollback</code>
</li><li class="listitem">
<code class="literal">@Sql</code>
</li><li class="listitem">
<code class="literal">@SqlConfig</code>
</li><li class="listitem">
<code class="literal">@SqlGroup</code>
</li><li class="listitem">
<code class="literal">@Repeat</code>
</li><li class="listitem">
<code class="literal">@Timed</code>
</li><li class="listitem">
<code class="literal">@IfProfileValue</code>
</li><li class="listitem">
<code class="literal">@ProfileValueSourceConfiguration</code>
</li></ul></div>
<p>For example, if we discover that we are repeating the following configuration
across our JUnit 4 based test suite&#8230;&#8203;</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderRepositoryTests { }

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UserRepositoryTests { }</pre>
<p>We can reduce the above duplication by introducing a custom <span class="emphasis"><em>composed annotation</em></span>
that centralizes the common test configuration like this:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Target(ElementType.TYPE)</span></em>
<em><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <em><span class="hl-annotation" style="color: gray">@interface</span></em> TransactionalDevTest { }</pre>
<p>Then we can use our custom <code class="literal">@TransactionalDevTest</code> annotation to simplify the
configuration of individual test classes as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@TransactionalDevTest</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderRepositoryTests { }

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@TransactionalDevTest</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UserRepositoryTests { }</pre>
<p>For further details, consult the <a class="link" href="annotation-programming-model.html" title="38.&nbsp;Spring Annotation Programming Model">Spring Annotation Programming Model</a>.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testcontext-framework" href="#testcontext-framework"></a>15.5&nbsp;Spring TestContext Framework</h2></div></div></div>

<p>The <span class="emphasis"><em>Spring TestContext Framework</em></span> (located in the
<code class="literal">org.springframework.test.context</code> package) provides generic, annotation-driven unit and
integration testing support that is agnostic of the testing framework in use. The
TestContext framework also places a great deal of importance on <span class="emphasis"><em>convention over
configuration</em></span> with reasonable defaults that can be overridden through annotation-based
configuration.</p>
<p>In addition to generic testing infrastructure, the TestContext framework provides
explicit support for JUnit 4 and TestNG in the form of <code class="literal">abstract</code> support classes. For
JUnit 4, Spring also provides a custom JUnit <code class="literal">Runner</code> and custom JUnit <code class="literal">Rules</code> that allow
one to write so-called <span class="emphasis"><em>POJO test classes</em></span>. POJO test classes are not required to
extend a particular class hierarchy.</p>
<p>The following section provides an overview of the internals of the TestContext
framework. If you are only interested in <span class="emphasis"><em>using</em></span> the framework and not necessarily
interested in <span class="emphasis"><em>extending</em></span> it with your own custom listeners or custom loaders, feel free
to go directly to the configuration (<a class="link" href="integration-testing.html#testcontext-ctx-management" title="15.5.4&nbsp;Context management">context management</a>,
<a class="link" href="integration-testing.html#testcontext-fixture-di" title="15.5.5&nbsp;Dependency injection of test fixtures">dependency injection</a>, <a class="link" href="integration-testing.html#testcontext-tx" title="15.5.7&nbsp;Transaction management">transaction
management</a>), <a class="link" href="integration-testing.html#testcontext-support-classes" title="15.5.9&nbsp;TestContext Framework support classes">support classes</a>, and
<a class="link" href="integration-testing.html#integration-testing-annotations" title="15.4&nbsp;Annotations">annotation support</a> sections.</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-key-abstractions" href="#testcontext-key-abstractions"></a>15.5.1&nbsp;Key abstractions</h3></div></div></div>

<p>The core of the framework consists of the <code class="literal">TestContextManager</code> class and the
<code class="literal">TestContext</code>, <code class="literal">TestExecutionListener</code>, and <code class="literal">SmartContextLoader</code> interfaces. A
<code class="literal">TestContextManager</code> is created per test class (e.g., for the execution of all test
methods within a single test class in JUnit 4). The <code class="literal">TestContextManager</code> in turn manages a
<code class="literal">TestContext</code> that holds the context of the current test. The <code class="literal">TestContextManager</code> also
updates the state of the <code class="literal">TestContext</code> as the test progresses and delegates to
<code class="literal">TestExecutionListener</code> implementations, which instrument the actual test execution by
providing dependency injection, managing transactions, and so on. A <code class="literal">SmartContextLoader</code>
is responsible for loading an <code class="literal">ApplicationContext</code> for a given test class. Consult the
javadocs and the Spring test suite for further information and examples of various
implementations.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_testcontext" href="#_testcontext"></a>TestContext</h4></div></div></div>

<p><code class="literal">TestContext</code> encapsulates the context in which a test is executed, agnostic of the
actual testing framework in use, and provides context management and caching support for
the test instance for which it is responsible. The <code class="literal">TestContext</code> also delegates to a
<code class="literal">SmartContextLoader</code> to load an <code class="literal">ApplicationContext</code> if requested.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_testcontextmanager" href="#_testcontextmanager"></a>TestContextManager</h4></div></div></div>

<p><code class="literal">TestContextManager</code> is the main entry point into the <span class="emphasis"><em>Spring TestContext Framework</em></span>,
which manages a single <code class="literal">TestContext</code> and signals events to each registered
<code class="literal">TestExecutionListener</code> at well-defined test execution points:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
prior to any <span class="emphasis"><em>before class</em></span> or <span class="emphasis"><em>before all</em></span> methods of a particular testing framework
</li><li class="listitem">
test instance post-processing
</li><li class="listitem">
prior to any <span class="emphasis"><em>before</em></span> or <span class="emphasis"><em>before each</em></span> methods of a particular testing framework
</li><li class="listitem">
after any <span class="emphasis"><em>after</em></span> or <span class="emphasis"><em>after each</em></span> methods of a particular testing framework
</li><li class="listitem">
after any <span class="emphasis"><em>after class</em></span> or <span class="emphasis"><em>after all</em></span> methods of a particular testing framework
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_testexecutionlistener" href="#_testexecutionlistener"></a>TestExecutionListener</h4></div></div></div>

<p><code class="literal">TestExecutionListener</code> defines the API for reacting to test execution events published
by the <code class="literal">TestContextManager</code> with which the listener is registered. See
<a class="xref" href="integration-testing.html#testcontext-tel-config" title="15.5.3&nbsp;TestExecutionListener configuration">Section&nbsp;15.5.3, &#8220;TestExecutionListener configuration&#8221;</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_context_loaders" href="#_context_loaders"></a>Context Loaders</h4></div></div></div>

<p><code class="literal">ContextLoader</code> is a strategy interface that was introduced in Spring 2.5 for loading an
<code class="literal">ApplicationContext</code> for an integration test managed by the Spring TestContext Framework.
Implement <code class="literal">SmartContextLoader</code> instead of this interface in order to provide support for
annotated classes, active bean definition profiles, test property sources, context
hierarchies, and <code class="literal">WebApplicationContext</code> support.</p>
<p><code class="literal">SmartContextLoader</code> is an extension of the <code class="literal">ContextLoader</code> interface introduced in
Spring 3.1. The <code class="literal">SmartContextLoader</code> SPI supersedes the <code class="literal">ContextLoader</code> SPI that was
introduced in Spring 2.5. Specifically, a <code class="literal">SmartContextLoader</code> can choose to process
resource <code class="literal">locations</code>, annotated <code class="literal">classes</code>, or context <code class="literal">initializers</code>. Furthermore, a
<code class="literal">SmartContextLoader</code> can set active bean definition profiles and test property sources in
the context that it loads.</p>
<p>Spring provides the following implementations:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">DelegatingSmartContextLoader</code>: one of two default loaders which delegates internally
to an <code class="literal">AnnotationConfigContextLoader</code>, a <code class="literal">GenericXmlContextLoader</code>, or a
<code class="literal">GenericGroovyXmlContextLoader</code> depending either on the configuration declared for the
test class or on the presence of default locations or default configuration classes.
Groovy support is only enabled if Groovy is on the classpath.
</li><li class="listitem">
<code class="literal">WebDelegatingSmartContextLoader</code>: one of two default loaders which delegates
internally to an <code class="literal">AnnotationConfigWebContextLoader</code>, a <code class="literal">GenericXmlWebContextLoader</code>, or a
<code class="literal">GenericGroovyXmlWebContextLoader</code> depending either on the configuration declared for the
test class or on the presence of default locations or default configuration classes. A
web <code class="literal">ContextLoader</code> will only be used if <code class="literal">@WebAppConfiguration</code> is present on the test
class. Groovy support is only enabled if Groovy is on the classpath.
</li><li class="listitem">
<code class="literal">AnnotationConfigContextLoader</code>: loads a standard <code class="literal">ApplicationContext</code> from
<span class="emphasis"><em>annotated classes</em></span>.
</li><li class="listitem">
<code class="literal">AnnotationConfigWebContextLoader</code>: loads a <code class="literal">WebApplicationContext</code> from <span class="emphasis"><em>annotated
classes</em></span>.
</li><li class="listitem">
<code class="literal">GenericGroovyXmlContextLoader</code>: loads a standard <code class="literal">ApplicationContext</code> from <span class="emphasis"><em>resource
locations</em></span> that are either Groovy scripts or XML configuration files.
</li><li class="listitem">
<code class="literal">GenericGroovyXmlWebContextLoader</code>: loads a <code class="literal">WebApplicationContext</code> from <span class="emphasis"><em>resource
locations</em></span> that are either Groovy scripts or XML configuration files.
</li><li class="listitem">
<code class="literal">GenericXmlContextLoader</code>: loads a standard <code class="literal">ApplicationContext</code> from XML <span class="emphasis"><em>resource
locations</em></span>.
</li><li class="listitem">
<code class="literal">GenericXmlWebContextLoader</code>: loads a <code class="literal">WebApplicationContext</code> from XML <span class="emphasis"><em>resource
locations</em></span>.
</li><li class="listitem">
<code class="literal">GenericPropertiesContextLoader</code>: loads a standard <code class="literal">ApplicationContext</code> from Java
Properties files.
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-bootstrapping" href="#testcontext-bootstrapping"></a>15.5.2&nbsp;Bootstrapping the TestContext framework</h3></div></div></div>

<p>The default configuration for the internals of the Spring TestContext Framework is
sufficient for all common use cases. However, there are times when a development team or
third party framework would like to change the default <code class="literal">ContextLoader</code>, implement a
custom <code class="literal">TestContext</code> or <code class="literal">ContextCache</code>, augment the default sets of
<code class="literal">ContextCustomizerFactory</code> and <code class="literal">TestExecutionListener</code> implementations, etc. For such low
level control over how the TestContext framework operates, Spring provides a
bootstrapping strategy.</p>
<p><code class="literal">TestContextBootstrapper</code> defines the SPI for <span class="emphasis"><em>bootstrapping</em></span> the TestContext framework.
A <code class="literal">TestContextBootstrapper</code> is used by the <code class="literal">TestContextManager</code> to load the
<code class="literal">TestExecutionListener</code> implementations for the current test and to build the
<code class="literal">TestContext</code> that it manages. A custom bootstrapping strategy can be configured for a
test class (or test class hierarchy) via <code class="literal">@BootstrapWith</code>, either directly or as a
meta-annotation. If a bootstrapper is not explicitly configured via <code class="literal">@BootstrapWith</code>,
either the <code class="literal">DefaultTestContextBootstrapper</code> or the <code class="literal">WebTestContextBootstrapper</code> will be
used, depending on the presence of <code class="literal">@WebAppConfiguration</code>.</p>
<p>Since the <code class="literal">TestContextBootstrapper</code> SPI is likely to change in the future in order to
accommodate new requirements, implementers are strongly encouraged not to implement this
interface directly but rather to extend <code class="literal">AbstractTestContextBootstrapper</code> or one of its
concrete subclasses instead.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-tel-config" href="#testcontext-tel-config"></a>15.5.3&nbsp;TestExecutionListener configuration</h3></div></div></div>

<p>Spring provides the following <code class="literal">TestExecutionListener</code> implementations that are registered
by default, exactly in this order.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">ServletTestExecutionListener</code>: configures Servlet API mocks for a
<code class="literal">WebApplicationContext</code>
</li><li class="listitem">
<code class="literal">DirtiesContextBeforeModesTestExecutionListener</code>: handles the <code class="literal">@DirtiesContext</code> annotation for
<span class="emphasis"><em>before</em></span> modes
</li><li class="listitem">
<code class="literal">DependencyInjectionTestExecutionListener</code>: provides dependency injection for the test
instance
</li><li class="listitem">
<code class="literal">DirtiesContextTestExecutionListener</code>: handles the <code class="literal">@DirtiesContext</code> annotation for
<span class="emphasis"><em>after</em></span> modes
</li><li class="listitem">
<code class="literal">TransactionalTestExecutionListener</code>: provides transactional test execution with
default rollback semantics
</li><li class="listitem">
<code class="literal">SqlScriptsTestExecutionListener</code>: executes SQL scripts configured via the <code class="literal">@Sql</code>
annotation
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tel-config-registering-tels" href="#testcontext-tel-config-registering-tels"></a>Registering custom TestExecutionListeners</h4></div></div></div>

<p>Custom <code class="literal">TestExecutionListener</code>s can be registered for a test class and its subclasses
via the <code class="literal">@TestExecutionListeners</code> annotation. See
<a class="link" href="integration-testing.html#integration-testing-annotations" title="15.4&nbsp;Annotations">annotation support</a> and the javadocs for
<code class="literal">@TestExecutionListeners</code> for details and examples.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tel-config-automatic-discovery" href="#testcontext-tel-config-automatic-discovery"></a>Automatic discovery of default TestExecutionListeners</h4></div></div></div>

<p>Registering custom <code class="literal">TestExecutionListener</code>s via <code class="literal">@TestExecutionListeners</code> is suitable
for custom listeners that are used in limited testing scenarios; however, it can become
cumbersome if a custom listener needs to be used across a test suite. Since Spring
Framework 4.1, this issue is addressed via support for automatic discovery of <span class="emphasis"><em>default</em></span>
<code class="literal">TestExecutionListener</code> implementations via the <code class="literal">SpringFactoriesLoader</code> mechanism.</p>
<p>Specifically, the <code class="literal">spring-test</code> module declares all core default
<code class="literal">TestExecutionListener</code>s under the
<code class="literal">org.springframework.test.context.TestExecutionListener</code> key in its
<code class="literal">META-INF/spring.factories</code> properties file. Third-party frameworks and developers can
contribute their own <code class="literal">TestExecutionListener</code>s to the list of default listeners in the
same manner via their own <code class="literal">META-INF/spring.factories</code> properties file.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tel-config-ordering" href="#testcontext-tel-config-ordering"></a>Ordering TestExecutionListeners</h4></div></div></div>

<p>When the TestContext framework discovers default <code class="literal">TestExecutionListener</code>s via the
aforementioned <code class="literal">SpringFactoriesLoader</code> mechanism, the instantiated listeners are sorted
using Spring&#8217;s <code class="literal">AnnotationAwareOrderComparator</code> which honors Spring&#8217;s <code class="literal">Ordered</code> interface
and <code class="literal">@Order</code> annotation for ordering. <code class="literal">AbstractTestExecutionListener</code> and all default
<code class="literal">TestExecutionListener</code>s provided by Spring implement <code class="literal">Ordered</code> with appropriate
values. Third-party frameworks and developers should therefore make sure that their
<span class="emphasis"><em>default</em></span> <code class="literal">TestExecutionListener</code>s are registered in the proper order by implementing
<code class="literal">Ordered</code> or declaring <code class="literal">@Order</code>. Consult the javadocs for the <code class="literal">getOrder()</code> methods of the
core default <code class="literal">TestExecutionListener</code>s for details on what values are assigned to each
core listener.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tel-config-merging" href="#testcontext-tel-config-merging"></a>Merging TestExecutionListeners</h4></div></div></div>

<p>If a custom <code class="literal">TestExecutionListener</code> is registered via <code class="literal">@TestExecutionListeners</code>, the
<span class="emphasis"><em>default</em></span> listeners will not be registered. In most common testing scenarios, this
effectively forces the developer to manually declare all default listeners in addition to
any custom listeners. The following listing demonstrates this style of configuration.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>The challenge with this approach is that it requires that the developer know exactly
which listeners are registered by default. Moreover, the set of default listeners can
change from release to release&#8201;&#8212;&#8201;for example, <code class="literal">SqlScriptsTestExecutionListener</code> was
introduced in Spring Framework 4.1, and <code class="literal">DirtiesContextBeforeModesTestExecutionListener</code>
was introduced in Spring Framework 4.2. Furthermore, third-party frameworks like Spring
Security register their own default <code class="literal">TestExecutionListener</code>s via the aforementioned
<a class="link" href="integration-testing.html#testcontext-tel-config-automatic-discovery" title="Automatic discovery of default TestExecutionListeners">automatic discovery mechanism</a>.</p>
<p>To avoid having to be aware of and re-declare <span class="strong"><strong>all</strong></span> <span class="emphasis"><em>default</em></span> listeners, the
<code class="literal">mergeMode</code> attribute of <code class="literal">@TestExecutionListeners</code> can be set to
<code class="literal">MergeMode.MERGE_WITH_DEFAULTS</code>. <code class="literal">MERGE_WITH_DEFAULTS</code> indicates that locally declared
listeners should be merged with the default listeners. The merging algorithm ensures that
duplicates are removed from the list and that the resulting set of merged listeners is
sorted according to the semantics of <code class="literal">AnnotationAwareOrderComparator</code> as described in
<a class="xref" href="integration-testing.html#testcontext-tel-config-ordering" title="Ordering TestExecutionListeners">the section called &#8220;Ordering TestExecutionListeners&#8221;</a>. If a listener implements <code class="literal">Ordered</code> or is annotated
with <code class="literal">@Order</code> it can influence the position in which it is merged with the defaults;
otherwise, locally declared listeners will simply be appended to the list of default
listeners when merged.</p>
<p>For example, if the <code class="literal">MyCustomTestExecutionListener</code> class in the previous example
configures its <code class="literal">order</code> value (for example, <code class="literal">500</code>) to be less than the order of the
<code class="literal">ServletTestExecutionListener</code> (which happens to be <code class="literal">1000</code>), the
<code class="literal">MyCustomTestExecutionListener</code> can then be automatically merged with the list of
defaults <span class="emphasis"><em>in front of</em></span> the <code class="literal">ServletTestExecutionListener</code>, and the previous example could
be replaced with the following.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-ctx-management" href="#testcontext-ctx-management"></a>15.5.4&nbsp;Context management</h3></div></div></div>

<p>Each <code class="literal">TestContext</code> provides context management and caching support for the test instance
it is responsible for. Test instances do not automatically receive access to the
configured <code class="literal">ApplicationContext</code>. However, if a test class implements the
<code class="literal">ApplicationContextAware</code> interface, a reference to the <code class="literal">ApplicationContext</code> is supplied
to the test instance. Note that <code class="literal">AbstractJUnit4SpringContextTests</code> and
<code class="literal">AbstractTestNGSpringContextTests</code> implement <code class="literal">ApplicationContextAware</code> and therefore
provide access to the <code class="literal">ApplicationContext</code> automatically.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: @Autowired ApplicationContext"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">@Autowired ApplicationContext</th></tr><tr><td align="left" valign="top">

<p>As an alternative to implementing the <code class="literal">ApplicationContextAware</code> interface, you can
inject the application context for your test class through the <code class="literal">@Autowired</code> annotation
on either a field or setter method. For example:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {

    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> ApplicationContext applicationContext;

    <span class="hl-comment">// class body...</span>
}</pre>
<p>Similarly, if your test is configured to load a <code class="literal">WebApplicationContext</code>, you can inject
the web application context into your test as follows:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="strong"><strong>@WebAppConfiguration</strong></span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebAppTest {
    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-comment">// class body...</span>
}</pre>
<p>Dependency injection via <code class="literal">@Autowired</code> is provided by the
<code class="literal">DependencyInjectionTestExecutionListener</code> which is configured by default (see
<a class="xref" href="integration-testing.html#testcontext-fixture-di" title="15.5.5&nbsp;Dependency injection of test fixtures">Section&nbsp;15.5.5, &#8220;Dependency injection of test fixtures&#8221;</a>).</p>
</td></tr></table></div>
<p>Test classes that use the TestContext framework do not need to extend any particular
class or implement a specific interface to configure their application context. Instead,
configuration is achieved simply by declaring the <code class="literal">@ContextConfiguration</code> annotation at
the class level. If your test class does not explicitly declare application context
resource <code class="literal">locations</code> or annotated <code class="literal">classes</code>, the configured <code class="literal">ContextLoader</code> determines
how to load a context from a default location or default configuration classes. In
addition to context resource <code class="literal">locations</code> and annotated <code class="literal">classes</code>, an application context
can also be configured via application context <code class="literal">initializers</code>.</p>
<p>The following sections explain how to configure an <code class="literal">ApplicationContext</code> via XML
configuration files, Groovy scripts, annotated classes (typically <code class="literal">@Configuration</code>
classes), or context initializers using Spring&#8217;s <code class="literal">@ContextConfiguration</code> annotation.
Alternatively, you can implement and configure your own custom <code class="literal">SmartContextLoader</code> for
advanced use cases.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-xml" href="#testcontext-ctx-management-xml"></a>Context configuration with XML resources</h4></div></div></div>

<p>To load an <code class="literal">ApplicationContext</code> for your tests using XML configuration files, annotate
your test class with <code class="literal">@ContextConfiguration</code> and configure the <code class="literal">locations</code> attribute with
an array that contains the resource locations of XML configuration metadata. A plain or
relative path&#8201;&#8212;&#8201;for example <code class="literal">"context.xml"</code>&#8201;&#8212;&#8201;will be treated as a classpath resource
that is relative to the package in which the test class is defined. A path starting with
a slash is treated as an absolute classpath location, for example
<code class="literal">"/org/example/config.xml"</code>. A path which represents a resource URL (i.e., a path
prefixed with <code class="literal">classpath:</code>, <code class="literal">file:</code>, <code class="literal">http:</code>, etc.) will be used <span class="emphasis"><em>as is</em></span>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from "/app-config.xml" and</span>
<span class="hl-comment">// "/test-config.xml" in the root of the classpath</span>
<span class="strong"><strong>@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><code class="literal">@ContextConfiguration</code> supports an alias for the <code class="literal">locations</code> attribute through the
standard Java <code class="literal">value</code> attribute. Thus, if you do not need to declare additional
attributes in <code class="literal">@ContextConfiguration</code>, you can omit the declaration of the <code class="literal">locations</code>
attribute name and declare the resource locations by using the shorthand format
demonstrated in the following example.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="strong"><strong>@ContextConfiguration({"/app-config.xml", "/test-config.xml"})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>If you omit both the <code class="literal">locations</code> and <code class="literal">value</code> attributes from the <code class="literal">@ContextConfiguration</code>
annotation, the TestContext framework will attempt to detect a default XML resource
location. Specifically, <code class="literal">GenericXmlContextLoader</code> and <code class="literal">GenericXmlWebContextLoader</code> detect
a default location based on the name of the test class. If your class is named
<code class="literal">com.example.MyTest</code>, <code class="literal">GenericXmlContextLoader</code> loads your application context from
<code class="literal">"classpath:com/example/MyTest-context.xml"</code>.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.example;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from</span>
<span class="hl-comment">// "classpath:com/example/MyTest-context.xml"</span>
<span class="strong"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-groovy" href="#testcontext-ctx-management-groovy"></a>Context configuration with Groovy scripts</h4></div></div></div>

<p>To load an <code class="literal">ApplicationContext</code> for your tests using Groovy scripts that utilize the
<a class="link" href="beans.html#groovy-bean-definition-dsl" title="The Groovy Bean Definition DSL">Groovy Bean Definition DSL</a>, annotate your test class with
<code class="literal">@ContextConfiguration</code> and configure the <code class="literal">locations</code> or <code class="literal">value</code> attribute with an array
that contains the resource locations of Groovy scripts. Resource lookup semantics for
Groovy scripts are the same as those described for <a class="link" href="integration-testing.html#testcontext-ctx-management-xml" title="Context configuration with XML resources">XML
configuration files</a>.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Enabling Groovy script support"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Enabling Groovy script support</th></tr><tr><td align="left" valign="top">

<p>Support for using Groovy scripts to load an <code class="literal">ApplicationContext</code> in the Spring
TestContext Framework is enabled automatically if Groovy is on the classpath.</p>
</td></tr></table></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from "/AppConfig.groovy" and</span>
<span class="hl-comment">// "/TestConfig.groovy" in the root of the classpath</span>
<span class="strong"><strong>@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>If you omit both the <code class="literal">locations</code> and <code class="literal">value</code> attributes from the <code class="literal">@ContextConfiguration</code>
annotation, the TestContext framework will attempt to detect a default Groovy script.
Specifically, <code class="literal">GenericGroovyXmlContextLoader</code> and <code class="literal">GenericGroovyXmlWebContextLoader</code>
detect a default location based on the name of the test class. If your class is named
<code class="literal">com.example.MyTest</code>, the Groovy context loader will load your application context from
<code class="literal">"classpath:com/example/MyTestContext.groovy"</code>.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.example;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from</span>
<span class="hl-comment">// "classpath:com/example/MyTestContext.groovy"</span>
<span class="strong"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Declaring XML config and Groovy scripts simultaneously"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Declaring XML config and Groovy scripts simultaneously</th></tr><tr><td align="left" valign="top">

<p>Both XML configuration files and Groovy scripts can be declared simultaneously via the
<code class="literal">locations</code> or <code class="literal">value</code> attribute of <code class="literal">@ContextConfiguration</code>. If the path to a configured
resource location ends with <code class="literal">.xml</code> it will be loaded using an <code class="literal">XmlBeanDefinitionReader</code>;
otherwise it will be loaded using a <code class="literal">GroovyBeanDefinitionReader</code>.</p>
<p>The following listing demonstrates how to combine both in an integration test.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from</span>
<span class="hl-comment">// "/app-config.xml" and "/TestConfig.groovy"</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-javaconfig" href="#testcontext-ctx-management-javaconfig"></a>Context configuration with annotated classes</h4></div></div></div>

<p>To load an <code class="literal">ApplicationContext</code> for your tests using <span class="emphasis"><em>annotated classes</em></span> (see
<a class="xref" href="beans.html#beans-java" title="7.12&nbsp;Java-based container configuration">Section&nbsp;7.12, &#8220;Java-based container configuration&#8221;</a>), annotate your test class with <code class="literal">@ContextConfiguration</code> and configure the
<code class="literal">classes</code> attribute with an array that contains references to annotated classes.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from AppConfig and TestConfig</span>
<span class="strong"><strong>@ContextConfiguration(classes = {AppConfig.class, TestConfig.class})</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Annotated Classes"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Annotated Classes</th></tr><tr><td align="left" valign="top">

<p>The term <span class="emphasis"><em>annotated class</em></span> can refer to any of the following.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
A class annotated with <code class="literal">@Configuration</code>
</li><li class="listitem">
A component (i.e., a class annotated with <code class="literal">@Component</code>, <code class="literal">@Service</code>, <code class="literal">@Repository</code>, etc.)
</li><li class="listitem">
A JSR-330 compliant class that is annotated with <code class="literal">javax.inject</code> annotations
</li><li class="listitem">
Any other class that contains <code class="literal">@Bean</code>-methods
</li></ul></div>
<p>Consult the javadocs of <code class="literal">@Configuration</code> and <code class="literal">@Bean</code> for further information regarding
the configuration and semantics of <span class="emphasis"><em>annotated classes</em></span>, paying special attention to
the discussion of <span class="emphasis"><em>`@Bean` Lite Mode</em></span>.</p>
</td></tr></table></div>
<p>If you omit the <code class="literal">classes</code> attribute from the <code class="literal">@ContextConfiguration</code> annotation, the
TestContext framework will attempt to detect the presence of default configuration
classes. Specifically, <code class="literal">AnnotationConfigContextLoader</code> and
<code class="literal">AnnotationConfigWebContextLoader</code> will detect all <code class="literal">static</code> nested classes of the test class
that meet the requirements for configuration class implementations as specified in the
<code class="literal">@Configuration</code> javadocs. In the following example, the <code class="literal">OrderServiceTest</code> class
declares a <code class="literal">static</code> nested configuration class named <code class="literal">Config</code> that will be automatically
used to load the <code class="literal">ApplicationContext</code> for the test class. Note that the name of the
configuration class is arbitrary. In addition, a test class can contain more than one
<code class="literal">static</code> nested configuration class if desired.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from the</span>
<span class="hl-comment">// static nested Config class</span>
<span class="strong"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderServiceTest {

    <em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
    <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> Config {

        <span class="hl-comment">// this bean will be injected into the OrderServiceTest class</span>
        <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
        <span class="hl-keyword">public</span> OrderService orderService() {
            OrderService orderService = <span class="hl-keyword">new</span> OrderServiceImpl();
            <span class="hl-comment">// set properties, etc.</span>
            <span class="hl-keyword">return</span> orderService;
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> OrderService orderService;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testOrderService() {
        <span class="hl-comment">// test the orderService</span>
    }

}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-mixed-config" href="#testcontext-ctx-management-mixed-config"></a>Mixing XML, Groovy scripts, and annotated classes</h4></div></div></div>

<p>It may sometimes be desirable to mix XML configuration files, Groovy scripts, and
annotated classes (i.e., typically <code class="literal">@Configuration</code> classes) to configure an
<code class="literal">ApplicationContext</code> for your tests. For example, if you use XML configuration in
production, you may decide that you want to use <code class="literal">@Configuration</code> classes to configure
specific Spring-managed components for your tests, or vice versa.</p>
<p>Furthermore, some third-party frameworks (like Spring Boot) provide first-class support
for loading an <code class="literal">ApplicationContext</code> from different types of resources simultaneously
(e.g., XML configuration files, Groovy scripts, and <code class="literal">@Configuration</code> classes). The Spring
Framework historically has not supported this for standard deployments. Consequently,
most of the <code class="literal">SmartContextLoader</code> implementations that the Spring Framework delivers in
the <code class="literal">spring-test</code> module support only one resource type per test context; however, this
does not mean that you cannot use both. One exception to the general rule is that the
<code class="literal">GenericGroovyXmlContextLoader</code> and <code class="literal">GenericGroovyXmlWebContextLoader</code> support both XML
configuration files and Groovy scripts simultaneously. Furthermore, third-party
frameworks may choose to support the declaration of both <code class="literal">locations</code> and <code class="literal">classes</code> via
<code class="literal">@ContextConfiguration</code>, and with the standard testing support in the TestContext
framework, you have the following options.</p>
<p>If you want to use resource locations (e.g., XML or Groovy) <span class="emphasis"><em>and</em></span> <code class="literal">@Configuration</code>
classes to configure your tests, you will have to pick one as the <span class="emphasis"><em>entry point</em></span>, and
that one will have to include or import the other. For example, in XML or Groovy scripts
you can include <code class="literal">@Configuration</code> classes via component scanning or define them as normal
Spring beans; whereas, in a <code class="literal">@Configuration</code> class you can use <code class="literal">@ImportResource</code> to
import XML configuration files or Groovy scripts. Note that this behavior is semantically
equivalent to how you configure your application in production: in production
configuration you will define either a set of XML or Groovy resource locations or a set
of <code class="literal">@Configuration</code> classes that your production <code class="literal">ApplicationContext</code> will be loaded
from, but you still have the freedom to include or import the other type of configuration.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-initializers" href="#testcontext-ctx-management-initializers"></a>Context configuration with context initializers</h4></div></div></div>

<p>To configure an <code class="literal">ApplicationContext</code> for your tests using context initializers, annotate
your test class with <code class="literal">@ContextConfiguration</code> and configure the <code class="literal">initializers</code> attribute
with an array that contains references to classes that implement
<code class="literal">ApplicationContextInitializer</code>. The declared context initializers will then be used to
initialize the <code class="literal">ConfigurableApplicationContext</code> that is loaded for your tests. Note that
the concrete <code class="literal">ConfigurableApplicationContext</code> type supported by each declared
initializer must be compatible with the type of <code class="literal">ApplicationContext</code> created by the
<code class="literal">SmartContextLoader</code> in use (i.e., typically a <code class="literal">GenericApplicationContext</code>).
Furthermore, the order in which the initializers are invoked depends on whether they
implement Spring&#8217;s <code class="literal">Ordered</code> interface or are annotated with Spring&#8217;s <code class="literal">@Order</code> annotation
or the standard <code class="literal">@Priority</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from TestConfig</span>
<span class="hl-comment">// and initialized by TestAppCtxInitializer</span>
<span class="strong"><strong>@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>It is also possible to omit the declaration of XML configuration files, Groovy scripts,
or annotated classes in <code class="literal">@ContextConfiguration</code> entirely and instead declare only
<code class="literal">ApplicationContextInitializer</code> classes which are then responsible for registering beans
in the context&#8201;&#8212;&#8201;for example, by programmatically loading bean definitions from XML
files or configuration classes.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be initialized by EntireAppInitializer</span>
<span class="hl-comment">// which presumably registers beans in the context</span>
<span class="strong"><strong>@ContextConfiguration(initializers = EntireAppInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-inheritance" href="#testcontext-ctx-management-inheritance"></a>Context configuration inheritance</h4></div></div></div>

<p><code class="literal">@ContextConfiguration</code> supports boolean <code class="literal">inheritLocations</code> and <code class="literal">inheritInitializers</code>
attributes that denote whether resource locations or annotated classes and context
initializers declared by superclasses should be <span class="emphasis"><em>inherited</em></span>. The default value for
both flags is <code class="literal">true</code>. This means that a test class inherits the resource locations or
annotated classes as well as the context initializers declared by any superclasses.
Specifically, the resource locations or annotated classes for a test class are appended
to the list of resource locations or annotated classes declared by superclasses.
Similarly, the initializers for a given test class will be added to the set of
initializers defined by test superclasses. Thus, subclasses have the option
of <span class="emphasis"><em>extending</em></span> the resource locations, annotated classes, or context initializers.</p>
<p>If the <code class="literal">inheritLocations</code> or <code class="literal">inheritInitializers</code> attribute in <code class="literal">@ContextConfiguration</code>
is set to <code class="literal">false</code>, the resource locations or annotated classes and the context
initializers, respectively, for the test class <span class="emphasis"><em>shadow</em></span> and effectively replace the
configuration defined by superclasses.</p>
<p>In the following example that uses XML resource locations, the <code class="literal">ApplicationContext</code> for
<code class="literal">ExtendedTest</code> will be loaded from <span class="emphasis"><em>"base-config.xml"</em></span> <span class="emphasis"><em>and</em></span>
<span class="emphasis"><em>"extended-config.xml"</em></span>, in that order. Beans defined in <span class="emphasis"><em>"extended-config.xml"</em></span> may
therefore <span class="emphasis"><em>override</em></span> (i.e., replace) those defined in <span class="emphasis"><em>"base-config.xml"</em></span>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from "/base-config.xml"</span>
<span class="hl-comment">// in the root of the classpath</span>
<span class="strong"><strong>@ContextConfiguration("/base-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}

<span class="hl-comment">// ApplicationContext will be loaded from "/base-config.xml" and</span>
<span class="hl-comment">// "/extended-config.xml" in the root of the classpath</span>
<span class="strong"><strong>@ContextConfiguration("/extended-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>Similarly, in the following example that uses annotated classes, the
<code class="literal">ApplicationContext</code> for <code class="literal">ExtendedTest</code> will be loaded from the <code class="literal">BaseConfig</code> <span class="emphasis"><em>and</em></span>
<code class="literal">ExtendedConfig</code> classes, in that order. Beans defined in <code class="literal">ExtendedConfig</code> may therefore
override (i.e., replace) those defined in <code class="literal">BaseConfig</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from BaseConfig</span>
<span class="strong"><strong>@ContextConfiguration(classes = BaseConfig.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}

<span class="hl-comment">// ApplicationContext will be loaded from BaseConfig and ExtendedConfig</span>
<span class="strong"><strong>@ContextConfiguration(classes = ExtendedConfig.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}</pre>
<p>In the following example that uses context initializers, the <code class="literal">ApplicationContext</code> for
<code class="literal">ExtendedTest</code> will be initialized using <code class="literal">BaseInitializer</code> <span class="emphasis"><em>and</em></span>
<code class="literal">ExtendedInitializer</code>. Note, however, that the order in which the initializers are
invoked depends on whether they implement Spring&#8217;s <code class="literal">Ordered</code> interface or are annotated
with Spring&#8217;s <code class="literal">@Order</code> annotation or the standard <code class="literal">@Priority</code> annotation.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be initialized by BaseInitializer</span>
<span class="strong"><strong>@ContextConfiguration(initializers = BaseInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}

<span class="hl-comment">// ApplicationContext will be initialized by BaseInitializer</span>
<span class="hl-comment">// and ExtendedInitializer</span>
<span class="strong"><strong>@ContextConfiguration(initializers = ExtendedInitializer.class)</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <span class="hl-comment">// class body...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-env-profiles" href="#testcontext-ctx-management-env-profiles"></a>Context configuration with environment profiles</h4></div></div></div>

<p>Spring 3.1 introduced first-class support in the framework for the notion of
environments and profiles (a.k.a., <span class="emphasis"><em>bean definition profiles</em></span>), and integration tests
can be configured to activate particular bean definition profiles for various testing
scenarios. This is achieved by annotating a test class with the <code class="literal">@ActiveProfiles</code>
annotation and supplying a list of profiles that should be activated when loading the
<code class="literal">ApplicationContext</code> for the test.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">@ActiveProfiles</code> may be used with any implementation of the new <code class="literal">SmartContextLoader</code>
SPI, but <code class="literal">@ActiveProfiles</code> is not supported with implementations of the older
<code class="literal">ContextLoader</code> SPI.</p>
</td></tr></table></div>
<p>Let&#8217;s take a look at some examples with XML configuration and <code class="literal">@Configuration</code> classes.</p>
<pre class="programlisting"><span class="hl-comment">&lt;!-- app-config.xml --&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xmlns:jdbc</span>=<span class="hl-value">"http://www.springframework.org/schema/jdbc"</span>
    <span class="hl-attribute">xmlns:jee</span>=<span class="hl-value">"http://www.springframework.org/schema/jee"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"..."</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transferService"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.service.internal.DefaultTransferService"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"accountRepository"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"feePolicy"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountRepository"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.repository.internal.JdbcAccountRepository"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"feePolicy"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"com.bank.service.internal.ZeroFeePolicy"</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;beans</span> <span class="hl-attribute">profile</span>=<span class="hl-value">"dev"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;jdbc:embedded-database</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;jdbc:script</span>
                <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:com/bank/config/sql/schema.sql"</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;jdbc:script</span>
                <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:com/bank/config/sql/test-data.sql"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/jdbc:embedded-database&gt;</span>
    <span class="hl-tag">&lt;/beans&gt;</span>

    <span class="hl-tag">&lt;beans</span> <span class="hl-attribute">profile</span>=<span class="hl-value">"production"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">"java:comp/env/jdbc/datasource"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/beans&gt;</span>

    <span class="hl-tag">&lt;beans</span> <span class="hl-attribute">profile</span>=<span class="hl-value">"default"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;jdbc:embedded-database</span> <span class="hl-attribute">id</span>=<span class="hl-value">"dataSource"</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;jdbc:script</span>
                <span class="hl-attribute">location</span>=<span class="hl-value">"classpath:com/bank/config/sql/schema.sql"</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/jdbc:embedded-database&gt;</span>
    <span class="hl-tag">&lt;/beans&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// ApplicationContext will be loaded from "classpath:/app-config.xml"</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("/app-config.xml")</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> TransferService transferService;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTransferService() {
        <span class="hl-comment">// test the transferService</span>
    }
}</pre>
<p>When <code class="literal">TransferServiceTest</code> is run, its <code class="literal">ApplicationContext</code> will be loaded from the
<code class="literal">app-config.xml</code> configuration file in the root of the classpath. If you inspect
<code class="literal">app-config.xml</code> you&#8217;ll notice that the <code class="literal">accountRepository</code> bean has a dependency on a
<code class="literal">dataSource</code> bean; however, <code class="literal">dataSource</code> is not defined as a top-level bean. Instead,
<code class="literal">dataSource</code> is defined three times: in the <span class="emphasis"><em>production</em></span> profile, the
<span class="emphasis"><em>dev</em></span> profile, and the <span class="emphasis"><em>default</em></span> profile.</p>
<p>By annotating <code class="literal">TransferServiceTest</code> with <code class="literal">@ActiveProfiles("dev")</code> we instruct the Spring
TestContext Framework to load the <code class="literal">ApplicationContext</code> with the active profiles set to
<code class="literal">{"dev"}</code>. As a result, an embedded database will be created and populated with test data,
and the <code class="literal">accountRepository</code> bean will be wired with a reference to the development
<code class="literal">DataSource</code>. And that&#8217;s likely what we want in an integration test.</p>
<p>It is sometimes useful to assign beans to a <code class="literal">default</code> profile. Beans within the default profile
are only included when no other profile is specifically activated. This can be used to define
<span class="emphasis"><em>fallback</em></span> beans to be used in the application&#8217;s default state. For example, you may
explicitly provide a data source for <code class="literal">dev</code> and <code class="literal">production</code> profiles, but define an in-memory
data source as a default when neither of these is active.</p>
<p>The following code listings demonstrate how to implement the same configuration and
integration test but using <code class="literal">@Configuration</code> classes instead of XML.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@Profile("dev")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> StandaloneDataConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DataSource dataSource() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hl-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .addScript(<span class="hl-string">"classpath:com/bank/config/sql/test-data.sql"</span>)
            .build();
    }
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@Profile("production")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JndiDataConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean(destroyMethod="")</span></em>
    <span class="hl-keyword">public</span> DataSource dataSource() <span class="hl-keyword">throws</span> Exception {
        Context ctx = <span class="hl-keyword">new</span> InitialContext();
        <span class="hl-keyword">return</span> (DataSource) ctx.lookup(<span class="hl-string">"java:comp/env/jdbc/datasource"</span>);
    }
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@Profile("default")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultDataConfig {

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> DataSource dataSource() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(<span class="hl-string">"classpath:com/bank/config/sql/schema.sql"</span>)
            .build();
    }
}</pre>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceConfig {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em> DataSource dataSource;

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> TransferService transferService() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DefaultTransferService(accountRepository(), feePolicy());
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> AccountRepository accountRepository() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> JdbcAccountRepository(dataSource);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span class="hl-keyword">public</span> FeePolicy feePolicy() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> ZeroFeePolicy();
    }

}</pre>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = {
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> TransferService transferService;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTransferService() {
        <span class="hl-comment">// test the transferService</span>
    }
}</pre>
<p>In this variation, we have split the XML configuration into four independent
<code class="literal">@Configuration</code> classes:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">TransferServiceConfig</code>: acquires a <code class="literal">dataSource</code> via dependency injection using
<code class="literal">@Autowired</code>
</li><li class="listitem">
<code class="literal">StandaloneDataConfig</code>: defines a <code class="literal">dataSource</code> for an embedded database suitable for
developer tests
</li><li class="listitem">
<code class="literal">JndiDataConfig</code>: defines a <code class="literal">dataSource</code> that is retrieved from JNDI in a production
environment
</li><li class="listitem">
<code class="literal">DefaultDataConfig</code>: defines a <code class="literal">dataSource</code> for a default embedded database in case
no profile is active
</li></ul></div>
<p>As with the XML-based configuration example, we still annotate <code class="literal">TransferServiceTest</code>
with <code class="literal">@ActiveProfiles("dev")</code>, but this time we specify all four configuration classes
via the <code class="literal">@ContextConfiguration</code> annotation. The body of the test class itself remains
completely unchanged.</p>
<p>It is often the case that a single set of profiles is used across multiple test classes
within a given project. Thus, to avoid duplicate declarations of the <code class="literal">@ActiveProfiles</code>
annotation it is possible to declare <code class="literal">@ActiveProfiles</code> once on a base class, and
subclasses will automatically inherit the <code class="literal">@ActiveProfiles</code> configuration from the base
class. In the following example, the declaration of <code class="literal">@ActiveProfiles</code> (as well as other
annotations) has been moved to an abstract superclass, <code class="literal">AbstractIntegrationTest</code>.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = {
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("dev")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractIntegrationTest {
}</pre>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<span class="hl-comment">// "dev" profile inherited from superclass</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest <span class="hl-keyword">extends</span> AbstractIntegrationTest {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> TransferService transferService;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testTransferService() {
        <span class="hl-comment">// test the transferService</span>
    }
}</pre>
<p><code class="literal">@ActiveProfiles</code> also supports an <code class="literal">inheritProfiles</code> attribute that can be used to
disable the inheritance of active profiles.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<span class="hl-comment">// "dev" profile overridden with "production"</span>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles(profiles = "production", inheritProfiles = false)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductionTransferServiceTest <span class="hl-keyword">extends</span> AbstractIntegrationTest {
    <span class="hl-comment">// test body</span>
}</pre>
<p><a name="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"></a>Furthermore, it is sometimes necessary to resolve active profiles for tests
<span class="emphasis"><em>programmatically</em></span> instead of declaratively&#8201;&#8212;&#8201;for example, based on:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the current operating system
</li><li class="listitem">
whether tests are being executed on a continuous integration build server
</li><li class="listitem">
the presence of certain environment variables
</li><li class="listitem">
the presence of custom class-level annotations
</li><li class="listitem">
etc.
</li></ul></div>
<p>To resolve active bean definition profiles programmatically, simply implement a custom
<code class="literal">ActiveProfilesResolver</code> and register it via the <code class="literal">resolver</code> attribute of
<code class="literal">@ActiveProfiles</code>. The following example demonstrates how to implement and register a
custom <code class="literal">OperatingSystemActiveProfilesResolver</code>. For further information, refer to the
corresponding javadocs.</p>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service;

<span class="hl-comment">// "dev" profile overridden programmatically via a custom resolver</span>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles(
    resolver = OperatingSystemActiveProfilesResolver.class,
    inheritProfiles = false)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransferServiceTest <span class="hl-keyword">extends</span> AbstractIntegrationTest {
    <span class="hl-comment">// test body</span>
}</pre>
<pre class="programlisting"><span class="hl-keyword">package</span> com.bank.service.test;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OperatingSystemActiveProfilesResolver <span class="hl-keyword">implements</span> ActiveProfilesResolver {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        <span class="hl-comment">// determine the value of profile based on the operating system</span>
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> String[] {profile};
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-property-sources" href="#testcontext-ctx-management-property-sources"></a>Context configuration with test property sources</h4></div></div></div>

<p>Spring 3.1 introduced first-class support in the framework for the notion of an
environment with a hierarchy of <span class="emphasis"><em>property sources</em></span>, and since Spring 4.1 integration
tests can be configured with test-specific property sources. In contrast to the
<code class="literal">@PropertySource</code> annotation used on <code class="literal">@Configuration</code> classes, the <code class="literal">@TestPropertySource</code>
annotation can be declared on a test class to declare resource locations for test
properties files or <span class="emphasis"><em>inlined</em></span> properties. These test property sources will be added to
the set of <code class="literal">PropertySources</code> in the <code class="literal">Environment</code> for the <code class="literal">ApplicationContext</code> loaded
for the annotated integration test.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">@TestPropertySource</code> may be used with any implementation of the <code class="literal">SmartContextLoader</code>
SPI, but <code class="literal">@TestPropertySource</code> is not supported with implementations of the older
<code class="literal">ContextLoader</code> SPI.</p>
<p>Implementations of <code class="literal">SmartContextLoader</code> gain access to merged test property source values
via the <code class="literal">getPropertySourceLocations()</code> and <code class="literal">getPropertySourceProperties()</code> methods in
<code class="literal">MergedContextConfiguration</code>.</p>
</td></tr></table></div>
<p><span class="strong"><strong>Declaring test property sources</strong></span></p>
<p>Test properties files can be configured via the <code class="literal">locations</code> or <code class="literal">value</code> attribute of
<code class="literal">@TestPropertySource</code> as shown in the following example.</p>
<p>Both traditional and XML-based properties file formats are supported&#8201;&#8212;&#8201;for example,
<code class="literal">"classpath:/com/example/test.properties"</code> or <code class="literal">"file:///path/to/file.xml"</code>.</p>
<p>Each path will be interpreted as a Spring <code class="literal">Resource</code>. A plain path&#8201;&#8212;&#8201;for example,
<code class="literal">"test.properties"</code>&#8201;&#8212;&#8201;will be treated as a classpath resource that is <span class="emphasis"><em>relative</em></span> to the
package in which the test class is defined. A path starting with a slash will be treated
as an <span class="emphasis"><em>absolute</em></span> classpath resource, for example: <code class="literal">"/org/example/test.xml"</code>. A path which
references a URL (e.g., a path prefixed with <code class="literal">classpath:</code>, <code class="literal">file:</code>, <code class="literal">http:</code>, etc.) will
be loaded using the specified resource protocol. Resource location wildcards (e.g.
<code class="literal"><span class="strong"><strong>*/</strong></span>.properties</code>) are not permitted: each location must evaluate to exactly one
<code class="literal">.properties</code> or <code class="literal">.xml</code> resource.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@TestPropertySource("/test.properties")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><span class="emphasis"><em>Inlined</em></span> properties in the form of key-value pairs can be configured via the
<code class="literal">properties</code> attribute of <code class="literal">@TestPropertySource</code> as shown in the following example. All
key-value pairs will be added to the enclosing <code class="literal">Environment</code> as a single test
<code class="literal">PropertySource</code> with the highest precedence.</p>
<p>The supported syntax for key-value pairs is the same as the syntax defined for entries in
a Java properties file:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">"key=value"</code>
</li><li class="listitem">
<code class="literal">"key:value"</code>
</li><li class="listitem">
<code class="literal">"key value"</code>
</li></ul></div>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@TestPropertySource(properties = {"timezone = GMT", "port: 4242"})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><span class="strong"><strong>Default properties file detection</strong></span></p>
<p>If <code class="literal">@TestPropertySource</code> is declared as an empty annotation (i.e., without explicit
values for the <code class="literal">locations</code> or <code class="literal">properties</code> attributes), an attempt will be made to detect
a <span class="emphasis"><em>default</em></span> properties file relative to the class that declared the annotation. For
example, if the annotated test class is <code class="literal">com.example.MyTest</code>, the corresponding default
properties file is <code class="literal">"classpath:com/example/MyTest.properties"</code>. If the default cannot be
detected, an <code class="literal">IllegalStateException</code> will be thrown.</p>
<p><span class="strong"><strong>Precedence</strong></span></p>
<p>Test property sources have higher precedence than those loaded from the operating
system&#8217;s environment or Java system properties as well as property sources added by the
application declaratively via <code class="literal">@PropertySource</code> or programmatically. Thus, test property
sources can be used to selectively override properties defined in system and application
property sources. Furthermore, inlined properties have higher precedence than properties
loaded from resource locations.</p>
<p>In the following example, the <code class="literal">timezone</code> and <code class="literal">port</code> properties as well as any properties
defined in <code class="literal">"/test.properties"</code> will override any properties of the same name that are
defined in system and application property sources. Furthermore, if the
<code class="literal">"/test.properties"</code> file defines entries for the <code class="literal">timezone</code> and <code class="literal">port</code> properties those
will be overridden by the <span class="emphasis"><em>inlined</em></span> properties declared via the <code class="literal">properties</code> attribute.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyIntegrationTests {
    <span class="hl-comment">// class body...</span>
}</pre>
<p><span class="strong"><strong>Inheriting and overriding test property sources</strong></span></p>
<p><code class="literal">@TestPropertySource</code> supports boolean <code class="literal">inheritLocations</code> and <code class="literal">inheritProperties</code>
attributes that denote whether resource locations for properties files and inlined
properties declared by superclasses should be <span class="emphasis"><em>inherited</em></span>. The default value for both
flags is <code class="literal">true</code>. This means that a test class inherits the locations and inlined
properties declared by any superclasses. Specifically, the locations and inlined
properties for a test class are appended to the locations and inlined properties declared
by superclasses. Thus, subclasses have the option of <span class="emphasis"><em>extending</em></span> the locations and
inlined properties. Note that properties that appear later will <span class="emphasis"><em>shadow</em></span> (i.e..,
override) properties of the same name that appear earlier. In addition, the
aforementioned precedence rules apply for inherited test property sources as well.</p>
<p>If the <code class="literal">inheritLocations</code> or <code class="literal">inheritProperties</code> attribute in <code class="literal">@TestPropertySource</code> is set
to <code class="literal">false</code>, the locations or inlined properties, respectively, for the test class <span class="emphasis"><em>shadow</em></span>
and effectively replace the configuration defined by superclasses.</p>
<p>In the following example, the <code class="literal">ApplicationContext</code> for <code class="literal">BaseTest</code> will be loaded using
only the <code class="literal">"base.properties"</code> file as a test property source. In contrast, the
<code class="literal">ApplicationContext</code> for <code class="literal">ExtendedTest</code> will be loaded using the <code class="literal">"base.properties"</code>
<span class="strong"><strong>and</strong></span> <code class="literal">"extended.properties"</code> files as test property source locations.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@TestPropertySource("base.properties")</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <span class="hl-comment">// ...</span>
}

<em><span class="hl-annotation" style="color: gray">@TestPropertySource("extended.properties")</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <span class="hl-comment">// ...</span>
}</pre>
<p>In the following example, the <code class="literal">ApplicationContext</code> for <code class="literal">BaseTest</code> will be loaded using only
the <span class="emphasis"><em>inlined</em></span> <code class="literal">key1</code> property. In contrast, the <code class="literal">ApplicationContext</code> for <code class="literal">ExtendedTest</code> will be
loaded using the <span class="emphasis"><em>inlined</em></span> <code class="literal">key1</code> and <code class="literal">key2</code> properties.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@TestPropertySource(properties = "key1 = value1")</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTest {
    <span class="hl-comment">// ...</span>
}

<em><span class="hl-annotation" style="color: gray">@TestPropertySource(properties = "key2 = value2")</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTest <span class="hl-keyword">extends</span> BaseTest {
    <span class="hl-comment">// ...</span>
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-web" href="#testcontext-ctx-management-web"></a>Loading a WebApplicationContext</h4></div></div></div>

<p>Spring 3.2 introduced support for loading a <code class="literal">WebApplicationContext</code> in integration
tests. To instruct the TestContext framework to load a <code class="literal">WebApplicationContext</code> instead
of a standard <code class="literal">ApplicationContext</code>, simply annotate the respective test class with
<code class="literal">@WebAppConfiguration</code>.</p>
<p>The presence of <code class="literal">@WebAppConfiguration</code> on your test class instructs the TestContext
framework (TCF) that a <code class="literal">WebApplicationContext</code> (WAC) should be loaded for your
integration tests. In the background the TCF makes sure that a <code class="literal">MockServletContext</code> is
created and supplied to your test&#8217;s WAC. By default the base resource path for your
<code class="literal">MockServletContext</code> will be set to <span class="emphasis"><em>"src/main/webapp"</em></span>. This is interpreted as a path
relative to the root of your JVM (i.e., normally the path to your project). If you&#8217;re
familiar with the directory structure of a web application in a Maven project, you&#8217;ll
know that <span class="emphasis"><em>"src/main/webapp"</em></span> is the default location for the root of your WAR. If you
need to override this default, simply provide an alternate path to the
<code class="literal">@WebAppConfiguration</code> annotation (e.g., <code class="literal">@WebAppConfiguration("src/test/webapp")</code>). If
you wish to reference a base resource path from the classpath instead of the file
system, just use Spring&#8217;s <span class="emphasis"><em>classpath:</em></span> prefix.</p>
<p>Please note that Spring&#8217;s testing support for <code class="literal">WebApplicationContexts</code> is on par with its
support for standard <code class="literal">ApplicationContexts</code>. When testing with a <code class="literal">WebApplicationContext</code>
you are free to declare XML configuration files, Groovy scripts, or <code class="literal">@Configuration</code>
classes via <code class="literal">@ContextConfiguration</code>. You are of course also free to use any other test
annotations such as <code class="literal">@ActiveProfiles</code>, <code class="literal">@TestExecutionListeners</code>, <code class="literal">@Sql</code>, <code class="literal">@Rollback</code>,
etc.</p>
<p>The following examples demonstrate some of the various configuration options for loading
a <code class="literal">WebApplicationContext</code>.</p>
<p>
<b>Conventions.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>

<span class="hl-comment">// defaults to "file:src/main/webapp"</span>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>

<span class="hl-comment">// detects "WacTests-context.xml" in same package</span>
<span class="hl-comment">// or static nested @Configuration class</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre><p>

</p>
<p>The above example demonstrates the TestContext framework&#8217;s support for <span class="emphasis"><em>convention over
configuration</em></span>. If you annotate a test class with <code class="literal">@WebAppConfiguration</code> without
specifying a resource base path, the resource path will effectively default
to <span class="emphasis"><em>"file:src/main/webapp"</em></span>. Similarly, if you declare <code class="literal">@ContextConfiguration</code> without
specifying resource <code class="literal">locations</code>, annotated <code class="literal">classes</code>, or context <code class="literal">initializers</code>, Spring
will attempt to detect the presence of your configuration using conventions
(i.e., <span class="emphasis"><em>"WacTests-context.xml"</em></span> in the same package as the <code class="literal">WacTests</code> class or static
nested <code class="literal">@Configuration</code> classes).</p>
<p>
<b>Default resource semantics.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>

<span class="hl-comment">// file system resource</span>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration("webapp")</span></em>

<span class="hl-comment">// classpath resource</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("/spring/test-servlet-config.xml")</span></em>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre><p>

</p>
<p>This example demonstrates how to explicitly declare a resource base path with
<code class="literal">@WebAppConfiguration</code> and an XML resource location with <code class="literal">@ContextConfiguration</code>. The
important thing to note here is the different semantics for paths with these two
annotations. By default, <code class="literal">@WebAppConfiguration</code> resource paths are file system based;
whereas, <code class="literal">@ContextConfiguration</code> resource locations are classpath based.</p>
<p>
<b>Explicit resource semantics.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>

<span class="hl-comment">// classpath resource</span>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration("classpath:test-web-resources")</span></em>

<span class="hl-comment">// file system resource</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")</span></em>

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {
    <span class="hl-comment">//...</span>
}</pre><p>

</p>
<p>In this third example, we see that we can override the default resource semantics for
both annotations by specifying a Spring resource prefix. Contrast the comments in this
example with the previous example.</p>
<p>To provide comprehensive web testing support, Spring 3.2 introduced a
<code class="literal">ServletTestExecutionListener</code> that is enabled by default. When testing against a
<code class="literal">WebApplicationContext</code> this <a class="link" href="integration-testing.html#testcontext-key-abstractions" title="15.5.1&nbsp;Key abstractions">TestExecutionListener</a> sets
up default thread-local state via Spring Web&#8217;s <code class="literal">RequestContextHolder</code> before each test
method and creates a <code class="literal">MockHttpServletRequest</code>, <code class="literal">MockHttpServletResponse</code>, and
<code class="literal">ServletWebRequest</code> based on the base resource path configured via
<code class="literal">@WebAppConfiguration</code>. <code class="literal">ServletTestExecutionListener</code> also ensures that the
<code class="literal">MockHttpServletResponse</code> and <code class="literal">ServletWebRequest</code> can be injected into the test
instance, and once the test is complete it cleans up thread-local state.</p>
<p>Once you have a <code class="literal">WebApplicationContext</code> loaded for your test you might find that you
need to interact with the web mocks&#8201;&#8212;&#8201;for example, to set up your test fixture or to
perform assertions after invoking your web component. The following example demonstrates
which mocks can be autowired into your test instance. Note that the
<code class="literal">WebApplicationContext</code> and <code class="literal">MockServletContext</code> are both cached across the test suite;
whereas, the other mocks are managed per test method by the
<code class="literal">ServletTestExecutionListener</code>.</p>
<p>
<b>Injecting mocks.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> WacTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    WebApplicationContext wac; <span class="hl-comment">// cached</span>

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    MockServletContext servletContext; <span class="hl-comment">// cached</span>

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    MockHttpSession session;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    MockHttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    MockHttpServletResponse response;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    ServletWebRequest webRequest;

    <span class="hl-comment">//...</span>
}</pre><p>

</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-caching" href="#testcontext-ctx-management-caching"></a>Context caching</h4></div></div></div>

<p>Once the TestContext framework loads an <code class="literal">ApplicationContext</code> (or <code class="literal">WebApplicationContext</code>)
for a test, that context will be cached and reused for <span class="emphasis"><em>all</em></span> subsequent tests that
declare the same unique context configuration within the same test suite. To understand
how caching works, it is important to understand what is meant by <span class="emphasis"><em>unique</em></span> and <span class="emphasis"><em>test
suite</em></span>.</p>
<p>An <code class="literal">ApplicationContext</code> can be <span class="emphasis"><em>uniquely</em></span> identified by the combination of
configuration parameters that are used to load it. Consequently, the unique combination
of configuration parameters are used to generate a <span class="emphasis"><em>key</em></span> under which the context is
cached. The TestContext framework uses the following configuration parameters to build
the context cache key:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">locations</code> <span class="emphasis"><em>(from @ContextConfiguration)</em></span>
</li><li class="listitem">
<code class="literal">classes</code> <span class="emphasis"><em>(from @ContextConfiguration)</em></span>
</li><li class="listitem">
<code class="literal">contextInitializerClasses</code> <span class="emphasis"><em>(from @ContextConfiguration)</em></span>
</li><li class="listitem">
<code class="literal">contextCustomizers</code> <span class="emphasis"><em>(from ContextCustomizerFactory)</em></span>
</li><li class="listitem">
<code class="literal">contextLoader</code> <span class="emphasis"><em>(from @ContextConfiguration)</em></span>
</li><li class="listitem">
<code class="literal">parent</code> <span class="emphasis"><em>(from @ContextHierarchy)</em></span>
</li><li class="listitem">
<code class="literal">activeProfiles</code> <span class="emphasis"><em>(from @ActiveProfiles)</em></span>
</li><li class="listitem">
<code class="literal">propertySourceLocations</code> <span class="emphasis"><em>(from @TestPropertySource)</em></span>
</li><li class="listitem">
<code class="literal">propertySourceProperties</code> <span class="emphasis"><em>(from @TestPropertySource)</em></span>
</li><li class="listitem">
<code class="literal">resourceBasePath</code> <span class="emphasis"><em>(from @WebAppConfiguration)</em></span>
</li></ul></div>
<p>For example, if <code class="literal">TestClassA</code> specifies <code class="literal">{"app-config.xml", "test-config.xml"}</code> for the
<code class="literal">locations</code> (or <code class="literal">value</code>) attribute of <code class="literal">@ContextConfiguration</code>, the TestContext framework
will load the corresponding <code class="literal">ApplicationContext</code> and store it in a <code class="literal">static</code> context cache
under a key that is based solely on those locations. So if <code class="literal">TestClassB</code> also defines
<code class="literal">{"app-config.xml", "test-config.xml"}</code> for its locations (either explicitly or
implicitly through inheritance) but does not define <code class="literal">@WebAppConfiguration</code>, a different
<code class="literal">ContextLoader</code>, different active profiles, different context initializers, different
test property sources, or a different parent context, then the same <code class="literal">ApplicationContext</code>
will be shared by both test classes. This means that the setup cost for loading an
application context is incurred only once (per test suite), and subsequent test execution
is much faster.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Test suites and forked processes"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Test suites and forked processes</th></tr><tr><td align="left" valign="top">

<p>The Spring TestContext framework stores application contexts in a <span class="emphasis"><em>static</em></span> cache. This
means that the context is literally stored in a <code class="literal">static</code> variable. In other words, if
tests execute in separate processes the static cache will be cleared between each test
execution, and this will effectively disable the caching mechanism.</p>
<p>To benefit from the caching mechanism, all tests must run within the same process or
test suite. This can be achieved by executing all tests as a group within an IDE.
Similarly, when executing tests with a build framework such as Ant, Maven, or Gradle it
is important to make sure that the build framework does not <span class="emphasis"><em>fork</em></span> between tests. For
example, if the
<a class="ulink" href="http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode" target="_top">forkMode</a>
for the Maven Surefire plug-in is set to <code class="literal">always</code> or <code class="literal">pertest</code>, the TestContext
framework will not be able to cache application contexts between test classes and the
build process will run significantly slower as a result.</p>
</td></tr></table></div>
<p>Since Spring Framework 4.3, the size of the context cache is bounded with a default
maximum size of 32. Whenever the maximum size is reached, a <span class="emphasis"><em>least recently used</em></span> (LRU)
eviction policy is used to evict and close stale contexts. The maximum size can be
configured from the command line or a build script by setting a JVM system property named
<code class="literal">spring.test.context.cache.maxSize</code>. As an alternative, the same property can be set
programmatically via the <code class="literal">SpringProperties</code> API.</p>
<p>Since having a large number of application contexts loaded within a given test suite can
cause the suite to take an unnecessarily long time to execute, it is often beneficial to
know exactly how many contexts have been loaded and cached. To view the statistics for
the underlying context cache, simply set the log level for the
<code class="literal">org.springframework.test.context.cache</code> logging category to <code class="literal">DEBUG</code>.</p>
<p>In the unlikely case that a test corrupts the application context and requires reloading&#8201;&#8212;&#8201;for example, by modifying a bean definition or the state of an application object&#8201;&#8212;&#8201;you can annotate your test class or test method with <code class="literal">@DirtiesContext</code> (see the
discussion of <code class="literal">@DirtiesContext</code> in <a class="xref" href="integration-testing.html#integration-testing-annotations-spring" title="15.4.1&nbsp;Spring Testing Annotations">Section&nbsp;15.4.1, &#8220;Spring Testing Annotations&#8221;</a>). This
instructs Spring to remove the context from the cache and rebuild the application
context before executing the next test. Note that support for the <code class="literal">@DirtiesContext</code>
annotation is provided by the <code class="literal">DirtiesContextBeforeModesTestExecutionListener</code> and the
<code class="literal">DirtiesContextTestExecutionListener</code> which are enabled by default.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management-ctx-hierarchies" href="#testcontext-ctx-management-ctx-hierarchies"></a>Context hierarchies</h4></div></div></div>

<p>When writing integration tests that rely on a loaded Spring <code class="literal">ApplicationContext</code>, it is
often sufficient to test against a single context; however, there are times when it is
beneficial or even necessary to test against a hierarchy of <code class="literal">ApplicationContext</code>s. For
example, if you are developing a Spring MVC web application you will typically have a
root <code class="literal">WebApplicationContext</code> loaded via Spring&#8217;s <code class="literal">ContextLoaderListener</code> and a child
<code class="literal">WebApplicationContext</code> loaded via Spring&#8217;s <code class="literal">DispatcherServlet</code>. This results in a
parent-child context hierarchy where shared components and infrastructure configuration
are declared in the root context and consumed in the child context by web-specific
components. Another use case can be found in Spring Batch applications where you often
have a parent context that provides configuration for shared batch infrastructure and a
child context for the configuration of a specific batch job.</p>
<p>Since Spring Framework 3.2.2, it is possible to write integration tests that use context
hierarchies by declaring context configuration via the <code class="literal">@ContextHierarchy</code> annotation,
either on an individual test class or within a test class hierarchy. If a context
hierarchy is declared on multiple classes within a test class hierarchy it is also
possible to merge or override the context configuration for a specific, named level in
the context hierarchy. When merging configuration for a given level in the hierarchy the
configuration resource type (i.e., XML configuration files or annotated classes) must be
consistent; otherwise, it is perfectly acceptable to have different levels in a context
hierarchy configured using different resource types.</p>
<p>The following JUnit 4 based examples demonstrate common configuration scenarios for
integration tests that require the use of context hierarchies.</p>
<p><code class="literal">ControllerIntegrationTests</code> represents a typical integration testing scenario for a
Spring MVC web application by declaring a context hierarchy consisting of two levels,
one for the <span class="emphasis"><em>root</em></span> WebApplicationContext (loaded using the <code class="literal">TestAppConfig</code>
<code class="literal">@Configuration</code> class) and one for the <span class="emphasis"><em>dispatcher servlet</em></span> <code class="literal">WebApplicationContext</code>
(loaded using the <code class="literal">WebConfig</code> <code class="literal">@Configuration</code> class). The <code class="literal">WebApplicationContext</code> that
is <span class="emphasis"><em>autowired</em></span> into the test instance is the one for the child context (i.e., the
lowest context in the hierarchy).</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ControllerIntegrationTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-comment">// ...</span>
}</pre>
<p>The following test classes define a context hierarchy within a test class hierarchy.
<code class="literal">AbstractWebTests</code> declares the configuration for a root <code class="literal">WebApplicationContext</code> in a
Spring-powered web application. Note, however, that <code class="literal">AbstractWebTests</code> does not declare
<code class="literal">@ContextHierarchy</code>; consequently, subclasses of <code class="literal">AbstractWebTests</code> can optionally
participate in a context hierarchy or simply follow the standard semantics for
<code class="literal">@ContextConfiguration</code>. <code class="literal">SoapWebServiceTests</code> and <code class="literal">RestWebServiceTests</code> both extend
<code class="literal">AbstractWebTests</code> and define a context hierarchy via <code class="literal">@ContextHierarchy</code>. The result is
that three application contexts will be loaded (one for each declaration of
<code class="literal">@ContextConfiguration</code>), and the application context loaded based on the configuration
in <code class="literal">AbstractWebTests</code> will be set as the parent context for each of the contexts loaded
for the concrete subclasses.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractWebTests {}

@ContextHierarchy(<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("/spring/soap-ws-config.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SoapWebServiceTests <span class="hl-keyword">extends</span> AbstractWebTests {}

@ContextHierarchy(<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("/spring/rest-ws-config.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RestWebServiceTests <span class="hl-keyword">extends</span> AbstractWebTests {}</pre>
<p>The following classes demonstrate the use of <span class="emphasis"><em>named</em></span> hierarchy levels in order to
<span class="emphasis"><em>merge</em></span> the configuration for specific levels in a context hierarchy. <code class="literal">BaseTests</code>
defines two levels in the hierarchy, <code class="literal">parent</code> and <code class="literal">child</code>. <code class="literal">ExtendedTests</code> extends
<code class="literal">BaseTests</code> and instructs the Spring TestContext Framework to merge the context
configuration for the <code class="literal">child</code> hierarchy level, simply by ensuring that the names
declared via the <code class="literal">name</code> attribute in <code class="literal">@ContextConfiguration</code> are both <code class="literal">"child"</code>. The
result is that three application contexts will be loaded: one for <code class="literal">"/app-config.xml"</code>,
one for <code class="literal">"/user-config.xml"</code>, and one for <code class="literal">{"/user-config.xml", "/order-config.xml"}</code>.
As with the previous example, the application context loaded from <code class="literal">"/app-config.xml"</code>
will be set as the parent context for the contexts loaded from <code class="literal">"/user-config.xml"</code>
and <code class="literal">{"/user-config.xml", "/order-config.xml"}</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTests {}

<em><span class="hl-annotation" style="color: gray">@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTests <span class="hl-keyword">extends</span> BaseTests {}</pre>
<p>In contrast to the previous example, this example demonstrates how to <span class="emphasis"><em>override</em></span> the
configuration for a given named level in a context hierarchy by setting the
<code class="literal">inheritLocations</code> flag in <code class="literal">@ContextConfiguration</code> to <code class="literal">false</code>. Consequently, the
application context for <code class="literal">ExtendedTests</code> will be loaded only from
<code class="literal">"/test-user-config.xml"</code> and will have its parent set to the context loaded from
<code class="literal">"/app-config.xml"</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BaseTests {}

<em><span class="hl-annotation" style="color: gray">@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExtendedTests <span class="hl-keyword">extends</span> BaseTests {}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Dirtying a context within a context hierarchy"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Dirtying a context within a context hierarchy</th></tr><tr><td align="left" valign="top">

<p>If <code class="literal">@DirtiesContext</code> is used in a test whose context is configured as part of a context
hierarchy, the <code class="literal">hierarchyMode</code> flag can be used to control how the context cache is
cleared. For further details consult the discussion of <code class="literal">@DirtiesContext</code> in
<a class="link" href="integration-testing.html#integration-testing-annotations-spring" title="15.4.1&nbsp;Spring Testing Annotations">Spring Testing Annotations</a> and the
<code class="literal">@DirtiesContext</code> javadocs.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-fixture-di" href="#testcontext-fixture-di"></a>15.5.5&nbsp;Dependency injection of test fixtures</h3></div></div></div>

<p>When you use the <code class="literal">DependencyInjectionTestExecutionListener</code>&#8201;&#8212;&#8201;which is configured by
default&#8201;&#8212;&#8201;the dependencies of your test instances are <span class="emphasis"><em>injected</em></span> from beans in the
application context that you configured with <code class="literal">@ContextConfiguration</code>. You may use setter
injection, field injection, or both, depending on which annotations you choose and
whether you place them on setter methods or fields. For consistency with the annotation
support introduced in Spring 2.5 and 3.0, you can use Spring&#8217;s <code class="literal">@Autowired</code> annotation
or the <code class="literal">@Inject</code> annotation from JSR 330.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>The TestContext framework does not instrument the manner in which a test instance is
instantiated. Thus the use of <code class="literal">@Autowired</code> or <code class="literal">@Inject</code> for constructors has no effect
for test classes.</p>
</td></tr></table></div>
<p>Because <code class="literal">@Autowired</code> is used to perform <a class="link" href="beans.html#beans-factory-autowire" title="7.4.5&nbsp;Autowiring collaborators"><span class="emphasis"><em>autowiring by type</em></span></a>, if you have multiple bean definitions of the same type, you cannot rely on this
approach for those particular beans. In that case, you can use <code class="literal">@Autowired</code> in
conjunction with <code class="literal">@Qualifier</code>. As of Spring 3.0 you may also choose to use <code class="literal">@Inject</code> in
conjunction with <code class="literal">@Named</code>. Alternatively, if your test class has access to its
<code class="literal">ApplicationContext</code>, you can perform an explicit lookup by using (for example) a call
to <code class="literal">applicationContext.getBean("titleRepository")</code>.</p>
<p>If you do not want dependency injection applied to your test instances, simply do not
annotate fields or setter methods with <code class="literal">@Autowired</code> or <code class="literal">@Inject</code>. Alternatively, you can
disable dependency injection altogether by explicitly configuring your class with
<code class="literal">@TestExecutionListeners</code> and omitting <code class="literal">DependencyInjectionTestExecutionListener.class</code>
from the list of listeners.</p>
<p>Consider the scenario of testing a <code class="literal">HibernateTitleRepository</code> class, as outlined in the
<a class="link" href="integration-testing.html#integration-testing-goals" title="15.2&nbsp;Goals of Integration Testing">Goals</a> section. The next two code listings demonstrate the
use of <code class="literal">@Autowired</code> on fields and setter methods. The application context configuration
is presented after all sample code listings.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The dependency injection behavior in the following code listings is not specific to
JUnit 4. The same DI techniques can be used in conjunction with any testing framework.</p>
<p>The following examples make calls to static assertion methods such as <code class="literal">assertNotNull()</code>
but without prepending the call with <code class="literal">Assert</code>. In such cases, assume that the method was
properly imported through an <code class="literal">import static</code> declaration that is not shown in the
example.</p>
</td></tr></table></div>
<p>The first code listing shows a JUnit 4 based implementation of the test class that uses
<code class="literal">@Autowired</code> for field injection.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// specifies the Spring configuration to load for this test fixture</span>
<span class="strong"><strong>@ContextConfiguration("repository-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateTitleRepositoryTests {

    <span class="hl-comment">// this instance will be dependency injected by type</span>
    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">private</span> HibernateTitleRepository titleRepository;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> findById() {
        Title title = titleRepository.findById(<span class="hl-keyword">new</span> Long(<span class="hl-number">10</span>));
        assertNotNull(title);
    }
}</pre>
<p>Alternatively, you can configure the class to use <code class="literal">@Autowired</code> for setter injection as
seen below.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<span class="hl-comment">// specifies the Spring configuration to load for this test fixture</span>
<span class="strong"><strong>@ContextConfiguration("repository-config.xml")</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateTitleRepositoryTests {

    <span class="hl-comment">// this instance will be dependency injected by type</span>
    <span class="hl-keyword">private</span> HibernateTitleRepository titleRepository;

    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTitleRepository(HibernateTitleRepository titleRepository) {
        <span class="hl-keyword">this</span>.titleRepository = titleRepository;
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> findById() {
        Title title = titleRepository.findById(<span class="hl-keyword">new</span> Long(<span class="hl-number">10</span>));
        assertNotNull(title);
    }
}</pre>
<p>The preceding code listings use the same XML context file referenced by the
<code class="literal">@ContextConfiguration</code> annotation (that is, <code class="literal">repository-config.xml</code>), which looks like
this:</p>
<pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"</span><span class="strong"><strong>titleRepository</strong></span>" class="<span class="strong"><strong>com.foo.repository.hibernate.HibernateTitleRepository</strong></span>"&gt;
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"sessionFactory"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"sessionFactory"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.orm.hibernate5.LocalSessionFactoryBean"</span><span class="hl-tag">&gt;</span>
        <span class="hl-comment">&lt;!-- configuration elided for brevity --&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>If you are extending from a Spring-provided test base class that happens to use
<code class="literal">@Autowired</code> on one of its setter methods, you might have multiple beans of the affected
type defined in your application context: for example, multiple <code class="literal">DataSource</code> beans. In
such a case, you can override the setter method and use the <code class="literal">@Qualifier</code> annotation to
indicate a specific target bean as follows, but make sure to delegate to the overridden
method in the superclass as well.</p>
<pre class="programlisting"><span class="hl-comment">// ...</span>

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(<span class="strong"><strong>@Qualifier("myDataSource")</strong></span> DataSource dataSource) {
        <span class="strong"><strong>super</strong></span>.setDataSource(dataSource);
    }

<span class="hl-comment">// ...</span></pre>
<p>The specified qualifier value indicates the specific <code class="literal">DataSource</code> bean to inject,
narrowing the set of type matches to a specific bean. Its value is matched against
<code class="literal">&lt;qualifier&gt;</code> declarations within the corresponding <code class="literal">&lt;bean&gt;</code> definitions. The bean name
is used as a fallback qualifier value, so you may effectively also point to a specific
bean by name there (as shown above, assuming that "myDataSource" is the bean id).</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-web-scoped-beans" href="#testcontext-web-scoped-beans"></a>15.5.6&nbsp;Testing request and session scoped beans</h3></div></div></div>

<p><a class="link" href="beans.html#beans-factory-scopes-other" title="7.5.4&nbsp;Request, session, global session, application, and WebSocket scopes">Request and session scoped beans</a> have been supported by
Spring since the early years, and since Spring 3.2 it&#8217;s a breeze to test your
request-scoped and session-scoped beans by following these steps.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Ensure that a <code class="literal">WebApplicationContext</code> is loaded for your test by annotating your test
class with <code class="literal">@WebAppConfiguration</code>.
</li><li class="listitem">
Inject the mock request or session into your test instance and prepare your test
fixture as appropriate.
</li><li class="listitem">
Invoke your web component that you retrieved from the configured
<code class="literal">WebApplicationContext</code> (i.e., via dependency injection).
</li><li class="listitem">
Perform assertions against the mocks.
</li></ul></div>
<p>The following code snippet displays the XML configuration for a login use case. Note
that the <code class="literal">userService</code> bean has a dependency on a request-scoped <code class="literal">loginAction</code> bean.
Also, the <code class="literal">LoginAction</code> is instantiated using <a class="link" href="expressions.html" title="10.&nbsp;Spring Expression Language (SpEL)">SpEL expressions</a> that
retrieve the username and password from the current HTTP request. In our test, we will
want to configure these request parameters via the mock managed by the TestContext
framework.</p>
<p>
<b>Request-scoped bean configuration.&nbsp;</b>

</p><pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userService"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.SimpleUserService"</span>
            <span class="hl-attribute">c:loginAction-ref</span>=<span class="hl-value">"loginAction"</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"loginAction"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.LoginAction"</span>
            <span class="hl-attribute">c:username</span>=<span class="hl-value">"</span><span class="marked">{request.getParameter('user')}"
            c:password="</span>{request.getParameter('pswd')}"
            scope="request"&gt;
        <span class="hl-tag">&lt;aop:scoped-proxy /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><p>

</p>
<p>In <code class="literal">RequestScopedBeanTests</code> we inject both the <code class="literal">UserService</code> (i.e., the subject under
test) and the <code class="literal">MockHttpServletRequest</code> into our test instance. Within our
<code class="literal">requestScope()</code> test method we set up our test fixture by setting request parameters in
the provided <code class="literal">MockHttpServletRequest</code>. When the <code class="literal">loginUser()</code> method is invoked on our
<code class="literal">userService</code> we are assured that the user service has access to the request-scoped
<code class="literal">loginAction</code> for the current <code class="literal">MockHttpServletRequest</code> (i.e., the one we just set
parameters in). We can then perform assertions against the results based on the known
inputs for the username and password.</p>
<p>
<b>Request-scoped bean test.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RequestScopedBeanTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em> UserService userService;
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em> MockHttpServletRequest request;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> requestScope() {

        request.setParameter(<span class="hl-string">"user"</span>, <span class="hl-string">"enigma"</span>);
        request.setParameter(<span class="hl-string">"pswd"</span>, <span class="hl-string">"$pr!ng"</span>);

        LoginResults results = userService.loginUser();

        <span class="hl-comment">// assert results</span>
    }
}</pre><p>

</p>
<p>The following code snippet is similar to the one we saw above for a request-scoped bean;
however, this time the <code class="literal">userService</code> bean has a dependency on a session-scoped
<code class="literal">userPreferences</code> bean. Note that the <code class="literal">UserPreferences</code> bean is instantiated using a
SpEL expression that retrieves the <span class="emphasis"><em>theme</em></span> from the current HTTP session. In our test,
we will need to configure a theme in the mock session managed by the TestContext
framework.</p>
<p>
<b>Session-scoped bean configuration.&nbsp;</b>

</p><pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userService"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.SimpleUserService"</span>
            <span class="hl-attribute">c:userPreferences-ref</span>=<span class="hl-value">"userPreferences"</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"userPreferences"</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">"com.example.UserPreferences"</span>
            <span class="hl-attribute">c:theme</span>=<span class="hl-value">"#{session.getAttribute('theme')}"</span>
            <span class="hl-attribute">scope</span>=<span class="hl-value">"session"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;aop:scoped-proxy /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre><p>

</p>
<p>In <code class="literal">SessionScopedBeanTests</code> we inject the <code class="literal">UserService</code> and the <code class="literal">MockHttpSession</code> into
our test instance. Within our <code class="literal">sessionScope()</code> test method we set up our test fixture by
setting the expected "theme" attribute in the provided <code class="literal">MockHttpSession</code>. When the
<code class="literal">processUserPreferences()</code> method is invoked on our <code class="literal">userService</code> we are assured that
the user service has access to the session-scoped <code class="literal">userPreferences</code> for the current
<code class="literal">MockHttpSession</code>, and we can perform assertions against the results based on the
configured theme.</p>
<p>
<b>Session-scoped bean test.&nbsp;</b>

</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SessionScopedBeanTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em> UserService userService;
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em> MockHttpSession session;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sessionScope() <span class="hl-keyword">throws</span> Exception {

        session.setAttribute(<span class="hl-string">"theme"</span>, <span class="hl-string">"blue"</span>);

        Results results = userService.processUserPreferences();

        <span class="hl-comment">// assert results</span>
    }
}</pre><p>

</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-tx" href="#testcontext-tx"></a>15.5.7&nbsp;Transaction management</h3></div></div></div>

<p>In the TestContext framework, transactions are managed by the
<code class="literal">TransactionalTestExecutionListener</code> which is configured by default, even if you do not
explicitly declare <code class="literal">@TestExecutionListeners</code> on your test class. To enable support for
transactions, however, you must configure a <code class="literal">PlatformTransactionManager</code> bean in the
<code class="literal">ApplicationContext</code> that is loaded via <code class="literal">@ContextConfiguration</code> semantics (further
details are provided below). In addition, you must declare Spring&#8217;s <code class="literal">@Transactional</code>
annotation either at the class or method level for your tests.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-test-managed-transactions" href="#testcontext-tx-test-managed-transactions"></a>Test-managed transactions</h4></div></div></div>

<p><span class="emphasis"><em>Test-managed transactions</em></span> are transactions that are managed <span class="emphasis"><em>declaratively</em></span> via the
<code class="literal">TransactionalTestExecutionListener</code> or <span class="emphasis"><em>programmatically</em></span> via <code class="literal">TestTransaction</code> (see
below). Such transactions should not be confused with <span class="emphasis"><em>Spring-managed transactions</em></span>
(i.e., those managed directly by Spring within the <code class="literal">ApplicationContext</code> loaded for tests)
or <span class="emphasis"><em>application-managed transactions</em></span> (i.e., those managed programmatically within
application code that is invoked via tests). Spring-managed and application-managed
transactions will typically participate in test-managed transactions; however, caution
should be taken if Spring-managed or application-managed transactions are configured with
any <span class="emphasis"><em>propagation</em></span> type other than <code class="literal">REQUIRED</code> or <code class="literal">SUPPORTS</code> (see the discussion on
<a class="link" href="transaction.html#tx-propagation" title="17.5.7&nbsp;Transaction propagation">transaction propagation</a> for details).</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-enabling-transactions" href="#testcontext-tx-enabling-transactions"></a>Enabling and disabling transactions</h4></div></div></div>

<p>Annotating a test method with <code class="literal">@Transactional</code> causes the test to be run within a
transaction that will, by default, be automatically rolled back after completion of the
test. If a test class is annotated with <code class="literal">@Transactional</code>, each test method within that
class hierarchy will be run within a transaction. Test methods that are not annotated
with <code class="literal">@Transactional</code> (at the class or method level) will not be run within a
transaction. Furthermore, tests that are annotated with <code class="literal">@Transactional</code> but have the
<code class="literal">propagation</code> type set to <code class="literal">NOT_SUPPORTED</code> will not be run within a transaction.</p>
<p><span class="emphasis"><em>Note that <a class="link" href="integration-testing.html#testcontext-support-classes-junit4" title="JUnit 4 support classes"><code class="literal">AbstractTransactionalJUnit4SpringContextTests</code></a> and
<a class="link" href="integration-testing.html#testcontext-support-classes-testng" title="TestNG support classes"><code class="literal">AbstractTransactionalTestNGSpringContextTests</code></a>
are preconfigured for transactional support at the class level.</em></span></p>
<p>The following example demonstrates a common scenario for writing an integration test for
a Hibernate-based <code class="literal">UserRepository</code>. As explained in
<a class="xref" href="integration-testing.html#testcontext-tx-rollback-and-commit-behavior" title="Transaction rollback and commit behavior">the section called &#8220;Transaction rollback and commit behavior&#8221;</a>, there is no need to clean up the
database after the <code class="literal">createUser()</code> method is executed since any changes made to the
database will be automatically rolled back by the <code class="literal">TransactionalTestExecutionListener</code>.
See <a class="xref" href="integration-testing.html#testing-examples-petclinic" title="15.7&nbsp;PetClinic Example">Section&nbsp;15.7, &#8220;PetClinic Example&#8221;</a> for an additional example.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = TestConfig.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateUserRepositoryTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    HibernateUserRepository repository;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> createUser() {
        <span class="hl-comment">// track initial state in test database:</span>
        <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> count = countRowsInTable(<span class="hl-string">"user"</span>);

        User user = <span class="hl-keyword">new</span> User(...);
        repository.save(user);

        <span class="hl-comment">// Manual flush is required to avoid false positive in test</span>
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + <span class="hl-number">1</span>);
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">int</span> countRowsInTable(String tableName) {
        <span class="hl-keyword">return</span> JdbcTestUtils.countRowsInTable(<span class="hl-keyword">this</span>.jdbcTemplate, tableName);
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> assertNumUsers(<span class="hl-keyword">int</span> expected) {
        assertEquals(<span class="hl-string">"Number of rows in the [user] table."</span>, expected, countRowsInTable(<span class="hl-string">"user"</span>));
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-rollback-and-commit-behavior" href="#testcontext-tx-rollback-and-commit-behavior"></a>Transaction rollback and commit behavior</h4></div></div></div>

<p>By default, test transactions will be automatically rolled back after completion of the
test; however, transactional commit and rollback behavior can be configured declaratively
via the <code class="literal">@Commit</code> and <code class="literal">@Rollback</code> annotations. See the corresponding entries in the
<a class="link" href="integration-testing.html#integration-testing-annotations" title="15.4&nbsp;Annotations">annotation support</a> section for further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-programmatic-tx-mgt" href="#testcontext-tx-programmatic-tx-mgt"></a>Programmatic transaction management</h4></div></div></div>

<p>Since Spring Framework 4.1, it is possible to interact with test-managed transactions
<span class="emphasis"><em>programmatically</em></span> via the static methods in <code class="literal">TestTransaction</code>. For example,
<code class="literal">TestTransaction</code> may be used within <span class="emphasis"><em>test</em></span> methods, <span class="emphasis"><em>before</em></span> methods, and <span class="emphasis"><em>after</em></span>
methods to start or end the current test-managed transaction or to configure the current
test-managed transaction for rollback or commit. Support for <code class="literal">TestTransaction</code> is
automatically available whenever the <code class="literal">TransactionalTestExecutionListener</code> is enabled.</p>
<p>The following example demonstrates some of the features of <code class="literal">TestTransaction</code>. Consult the
javadocs for <code class="literal">TestTransaction</code> for further details.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = TestConfig.class)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProgrammaticTransactionManagementTests <span class="hl-keyword">extends</span>
        AbstractTransactionalJUnit4SpringContextTests {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> transactionalTest() {
        <span class="hl-comment">// assert initial state in test database:</span>
        assertNumUsers(<span class="hl-number">2</span>);

        deleteFromTables(<span class="hl-string">"user"</span>);

        <span class="hl-comment">// changes to the database will be committed!</span>
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(<span class="hl-number">0</span>);

        TestTransaction.start();
        <span class="hl-comment">// perform other actions against the database that will</span>
        <span class="hl-comment">// be automatically rolled back after the test completes...</span>
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> assertNumUsers(<span class="hl-keyword">int</span> expected) {
        assertEquals(<span class="hl-string">"Number of rows in the [user] table."</span>, expected, countRowsInTable(<span class="hl-string">"user"</span>));
    }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-before-and-after-tx" href="#testcontext-tx-before-and-after-tx"></a>Executing code outside of a transaction</h4></div></div></div>

<p>Occasionally you need to execute certain code before or after a transactional test method
but outside the transactional context&#8201;&#8212;&#8201;for example, to verify the initial database state
prior to execution of your test or to verify expected transactional commit behavior after
test execution (if the test was configured to commit the transaction).
<code class="literal">TransactionalTestExecutionListener</code> supports the <code class="literal">@BeforeTransaction</code> and
<code class="literal">@AfterTransaction</code> annotations exactly for such scenarios. Simply annotate any <code class="literal">void</code>
method in a test class or any <code class="literal">void</code> default method in a test interface with one of these
annotations, and the <code class="literal">TransactionalTestExecutionListener</code> ensures that your <span class="emphasis"><em>before
transaction method</em></span> or <span class="emphasis"><em>after transaction method</em></span> is executed at the appropriate time.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Any <span class="emphasis"><em>before methods</em></span> (such as methods annotated with JUnit 4&#8217;s <code class="literal">@Before</code>) and any <span class="emphasis"><em>after
methods</em></span> (such as methods annotated with JUnit 4&#8217;s <code class="literal">@After</code>) are executed <span class="emphasis"><em>within</em></span> a
transaction. In addition, methods annotated with <code class="literal">@BeforeTransaction</code> or
<code class="literal">@AfterTransaction</code> are naturally not executed for test methods that are not configured
to run within a transaction.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-mgr-config" href="#testcontext-tx-mgr-config"></a>Configuring a transaction manager</h4></div></div></div>

<p><code class="literal">TransactionalTestExecutionListener</code> expects a <code class="literal">PlatformTransactionManager</code> bean to be
defined in the Spring <code class="literal">ApplicationContext</code> for the test. In case there are multiple
instances of <code class="literal">PlatformTransactionManager</code> within the test&#8217;s <code class="literal">ApplicationContext</code>, a
<span class="emphasis"><em>qualifier</em></span> may be declared via <code class="literal">@Transactional("myTxMgr")</code> or
<code class="literal">@Transactional(transactionManager = "myTxMgr")</code>, or <code class="literal">TransactionManagementConfigurer</code>
can be implemented by an <code class="literal">@Configuration</code> class. Consult the javadocs for
<code class="literal">TestContextTransactionUtils.retrieveTransactionManager()</code> for details on the algorithm
used to look up a transaction manager in the test&#8217;s <code class="literal">ApplicationContext</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx-annotation-demo" href="#testcontext-tx-annotation-demo"></a>Demonstration of all transaction-related annotations</h4></div></div></div>

<p>The following JUnit 4 based example displays a fictitious integration testing scenario
highlighting all transaction-related annotations. The example is <span class="strong"><strong>not</strong></span> intended to
demonstrate best practices but rather to demonstrate how these annotations can be used.
Consult the <a class="link" href="integration-testing.html#integration-testing-annotations" title="15.4&nbsp;Annotations">annotation support</a> section for further
information and configuration examples. <a class="link" href="integration-testing.html#testcontext-executing-sql-declaratively-tx">Transaction management for <code class="literal">@Sql</code></a> contains an additional example using <code class="literal">@Sql</code> for
declarative SQL script execution with default transaction rollback semantics.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="strong"><strong>@Transactional(transactionManager = "txMgr")</strong></span>
<span class="strong"><strong>@Commit</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FictitiousTransactionalTest {

    <span class="strong"><strong>@BeforeTransaction</strong></span>
    <span class="hl-keyword">void</span> verifyInitialDatabaseState() {
        <span class="hl-comment">// logic to verify the initial state before a transaction is started</span>
    }

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setUpTestDataWithinTransaction() {
        <span class="hl-comment">// set up test data within the transaction</span>
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-comment">// overrides the class-level @Commit setting</span>
    <span class="strong"><strong>@Rollback</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> modifyDatabaseWithinTransaction() {
        <span class="hl-comment">// logic which uses the test data and modifies database state</span>
    }

    <em><span class="hl-annotation" style="color: gray">@After</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> tearDownWithinTransaction() {
        <span class="hl-comment">// execute "tear down" logic within the transaction</span>
    }

    <span class="strong"><strong>@AfterTransaction</strong></span>
    <span class="hl-keyword">void</span> verifyFinalDatabaseState() {
        <span class="hl-comment">// logic to verify the final state after transaction has rolled back</span>
    }

}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Avoid false positives when testing ORM code"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"><a name="testcontext-tx-false-positives" href="#testcontext-tx-false-positives"></a>Avoid false positives when testing ORM code</th></tr><tr><td align="left" valign="top">

<p>When you test application code that manipulates the state of a Hibernate session or JPA
persistence context, make sure to <span class="emphasis"><em>flush</em></span> the underlying unit of work within test
methods that execute that code. Failing to flush the underlying unit of work can produce
<span class="emphasis"><em>false positives</em></span>: your test may pass, but the same code throws an exception in a live,
production environment. In the following Hibernate-based example test case, one method
demonstrates a false positive, and the other method correctly exposes the results of
flushing the session. Note that this applies to any ORM frameworks that maintain an
in-memory <span class="emphasis"><em>unit of work</em></span>.</p>
<pre class="programlisting"><span class="hl-comment">// ...</span>

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SessionFactory sessionFactory;

<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<em><span class="hl-annotation" style="color: gray">@Test</span></em> <span class="hl-comment">// no expected exception!</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> falsePositive() {
    updateEntityInHibernateSession();
    <span class="hl-comment">// False positive: an exception will be thrown once the Hibernate</span>
    <span class="hl-comment">// Session is finally flushed (i.e., in production code)</span>
}

<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<em><span class="hl-annotation" style="color: gray">@Test(expected = ...)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateWithSessionFlush() {
    updateEntityInHibernateSession();
    <span class="hl-comment">// Manual flush is required to avoid false positive in test</span>
    sessionFactory.getCurrentSession().flush();
}

<span class="hl-comment">// ...</span></pre>
<p>Or for JPA:</p>
<pre class="programlisting"><span class="hl-comment">// ...</span>

<em><span class="hl-annotation" style="color: gray">@PersistenceContext</span></em>
EntityManager entityManager;

<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<em><span class="hl-annotation" style="color: gray">@Test</span></em> <span class="hl-comment">// no expected exception!</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> falsePositive() {
    updateEntityInJpaPersistenceContext();
    <span class="hl-comment">// False positive: an exception will be thrown once the JPA</span>
    <span class="hl-comment">// EntityManager is finally flushed (i.e., in production code)</span>
}

<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<em><span class="hl-annotation" style="color: gray">@Test(expected = ...)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    <span class="hl-comment">// Manual flush is required to avoid false positive in test</span>
    entityManager.flush();
}

<span class="hl-comment">// ...</span></pre>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-executing-sql" href="#testcontext-executing-sql"></a>15.5.8&nbsp;Executing SQL scripts</h3></div></div></div>

<p>When writing integration tests against a relational database, it is often beneficial
to execute SQL scripts to modify the database schema or insert test data into tables.
The <code class="literal">spring-jdbc</code> module provides support for <span class="emphasis"><em>initializing</em></span> an embedded or existing
database by executing SQL scripts when the Spring <code class="literal">ApplicationContext</code> is loaded. See
<a class="xref" href="jdbc.html#jdbc-embedded-database-support" title="19.8&nbsp;Embedded database support">Section&nbsp;19.8, &#8220;Embedded database support&#8221;</a> and <a class="xref" href="jdbc.html#jdbc-embedded-database-dao-testing" title="19.8.5&nbsp;Testing data access logic with an embedded database">Section&nbsp;19.8.5, &#8220;Testing data access logic with an embedded database&#8221;</a> for
details.</p>
<p>Although it is very useful to initialize a database for testing <span class="emphasis"><em>once</em></span> when the
<code class="literal">ApplicationContext</code> is loaded, sometimes it is essential to be able to modify the
database <span class="emphasis"><em>during</em></span> integration tests. The following sections explain how to execute SQL
scripts programmatically and declaratively during integration tests.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-executing-sql-programmatically" href="#testcontext-executing-sql-programmatically"></a>Executing SQL scripts programmatically</h4></div></div></div>

<p>Spring provides the following options for executing SQL scripts programmatically within
integration test methods.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">org.springframework.jdbc.datasource.init.ScriptUtils</code>
</li><li class="listitem">
<code class="literal">org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code>
</li><li class="listitem">
<code class="literal">org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code>
</li><li class="listitem">
<code class="literal">org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code>
</li></ul></div>
<p><code class="literal">ScriptUtils</code> provides a collection of static utility methods for working with SQL scripts
and is mainly intended for internal use within the framework. However, if you require
full control over how SQL scripts are parsed and executed, <code class="literal">ScriptUtils</code> may suit your
needs better than some of the other alternatives described below. Consult the javadocs for
individual methods in <code class="literal">ScriptUtils</code> for further details.</p>
<p><code class="literal">ResourceDatabasePopulator</code> provides a simple object-based API for programmatically
populating, initializing, or cleaning up a database using SQL scripts defined in
external resources. <code class="literal">ResourceDatabasePopulator</code> provides options for configuring the
character encoding, statement separator, comment delimiters, and error handling flags
used when parsing and executing the scripts, and each of the configuration options has
a reasonable default value. Consult the javadocs for details on default values. To
execute the scripts configured in a <code class="literal">ResourceDatabasePopulator</code>, you can invoke either
the <code class="literal">populate(Connection)</code> method to execute the populator against a
<code class="literal">java.sql.Connection</code> or the <code class="literal">execute(DataSource)</code> method to execute the populator
against a <code class="literal">javax.sql.DataSource</code>. The following example specifies SQL scripts for a test
schema and test data, sets the statement separator to <code class="literal">"@@"</code>, and then executes the
scripts against a <code class="literal">DataSource</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> databaseTest {
    ResourceDatabasePopulator populator = <span class="hl-keyword">new</span> ResourceDatabasePopulator();
    populator.addScripts(
        <span class="hl-keyword">new</span> ClassPathResource(<span class="hl-string">"test-schema.sql"</span>),
        <span class="hl-keyword">new</span> ClassPathResource(<span class="hl-string">"test-data.sql"</span>));
    populator.setSeparator(<span class="hl-string">"@@"</span>);
    populator.execute(<span class="hl-keyword">this</span>.dataSource);
    <span class="hl-comment">// execute code that uses the test schema and data</span>
}</pre>
<p>Note that <code class="literal">ResourceDatabasePopulator</code> internally delegates to <code class="literal">ScriptUtils</code> for parsing
and executing SQL scripts. Similarly, the <code class="literal">executeSqlScript(..)</code> methods in
<a class="link" href="integration-testing.html#testcontext-support-classes-junit4" title="JUnit 4 support classes"><code class="literal">AbstractTransactionalJUnit4SpringContextTests</code></a> and
<a class="link" href="integration-testing.html#testcontext-support-classes-testng" title="TestNG support classes"><code class="literal">AbstractTransactionalTestNGSpringContextTests</code></a>
internally use a <code class="literal">ResourceDatabasePopulator</code> for executing SQL scripts. Consult the javadocs
for the various <code class="literal">executeSqlScript(..)</code> methods for further details.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-executing-sql-declaratively" href="#testcontext-executing-sql-declaratively"></a>Executing SQL scripts declaratively with @Sql</h4></div></div></div>

<p>In addition to the aforementioned mechanisms for executing SQL scripts
<span class="emphasis"><em>programmatically</em></span>, SQL scripts can also be configured <span class="emphasis"><em>declaratively</em></span> in the Spring
TestContext Framework. Specifically, the <code class="literal">@Sql</code> annotation can be declared on a test
class or test method to configure the resource paths to SQL scripts that should be
executed against a given database either before or after an integration test method. Note
that method-level declarations override class-level declarations and that support for
<code class="literal">@Sql</code> is provided by the <code class="literal">SqlScriptsTestExecutionListener</code> which is enabled by default.</p>
<p><span class="strong"><strong>Path resource semantics</strong></span></p>
<p>Each path will be interpreted as a Spring <code class="literal">Resource</code>. A plain path&#8201;&#8212;&#8201;for example,
<code class="literal">"schema.sql"</code>&#8201;&#8212;&#8201;will be treated as a classpath resource that is <span class="emphasis"><em>relative</em></span> to the
package in which the test class is defined. A path starting with a slash will be treated
as an <span class="emphasis"><em>absolute</em></span> classpath resource, for example: <code class="literal">"/org/example/schema.sql"</code>. A path
which references a URL (e.g., a path prefixed with <code class="literal">classpath:</code>, <code class="literal">file:</code>, <code class="literal">http:</code>, etc.)
will be loaded using the specified resource protocol.</p>
<p>The following example demonstrates how to use <code class="literal">@Sql</code> at the class level and at the method
level within a JUnit 4 based integration test class.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@Sql("/test-schema.sql")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DatabaseTests {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> emptySchemaTest {
        <span class="hl-comment">// execute code that uses the test schema without any test data</span>
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <em><span class="hl-annotation" style="color: gray">@Sql({"/test-schema.sql", "/test-user-data.sql"})</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
        <span class="hl-comment">// execute code that uses the test schema and test data</span>
    }
}</pre>
<p><span class="strong"><strong>Default script detection</strong></span></p>
<p>If no SQL scripts are specified, an attempt will be made to detect a <code class="literal">default</code> script
depending on where <code class="literal">@Sql</code> is declared. If a default cannot be detected, an
<code class="literal">IllegalStateException</code> will be thrown.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>class-level declaration</em></span>: if the annotated test class is <code class="literal">com.example.MyTest</code>, the
corresponding default script is <code class="literal">"classpath:com/example/MyTest.sql"</code>.
</li><li class="listitem">
<span class="emphasis"><em>method-level declaration</em></span>: if the annotated test method is named <code class="literal">testMethod()</code> and is
defined in the class <code class="literal">com.example.MyTest</code>, the corresponding default script is
<code class="literal">"classpath:com/example/MyTest.testMethod.sql"</code>.
</li></ul></div>
<p><span class="strong"><strong>Declaring multiple <code class="literal">@Sql</code> sets</strong></span></p>
<p>If multiple sets of SQL scripts need to be configured for a given test class or test
method but with different syntax configuration, different error handling rules, or
different execution phases per set, it is possible to declare multiple instances of
<code class="literal">@Sql</code>. With Java 8, <code class="literal">@Sql</code> can be used as a <span class="emphasis"><em>repeatable</em></span> annotation. Otherwise, the
<code class="literal">@SqlGroup</code> annotation can be used as an explicit container for declaring multiple
instances of <code class="literal">@Sql</code>.</p>
<p>The following example demonstrates the use of <code class="literal">@Sql</code> as a repeatable annotation using
Java 8. In this scenario the <code class="literal">test-schema.sql</code> script uses a different syntax for
single-line comments.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))</span></em>
<em><span class="hl-annotation" style="color: gray">@Sql("/test-user-data.sql")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that uses the test schema and test data</span>
}</pre>
<p>The following example is identical to the above except that the <code class="literal">@Sql</code> declarations are
grouped together within <code class="literal">@SqlGroup</code> for compatibility with Java 6 and Java 7.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that uses the test schema and test data</span>
}</pre>
<p><span class="strong"><strong>Script execution phases</strong></span></p>
<p>By default, SQL scripts will be executed <span class="emphasis"><em>before</em></span> the corresponding test method. However,
if a particular set of scripts needs to be executed <span class="emphasis"><em>after</em></span> the test method&#8201;&#8212;&#8201;for
example, to clean up database state&#8201;&#8212;&#8201;the <code class="literal">executionPhase</code> attribute in <code class="literal">@Sql</code> can be
used as seen in the following example. Note that <code class="literal">ISOLATED</code> and <code class="literal">AFTER_TEST_METHOD</code> are
statically imported from <code class="literal">Sql.TransactionMode</code> and <code class="literal">Sql.ExecutionPhase</code> respectively.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<em><span class="hl-annotation" style="color: gray">@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)</span></em>
<em><span class="hl-annotation" style="color: gray">@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> userTest {
    <span class="hl-comment">// execute code that needs the test data to be committed</span>
    <span class="hl-comment">// to the database outside of the test's transaction</span>
}</pre>
<p><span class="strong"><strong>Script configuration with <code class="literal">@SqlConfig</code></strong></span></p>
<p>Configuration for script parsing and error handling can be configured via the
<code class="literal">@SqlConfig</code> annotation. When declared as a class-level annotation on an integration test
class, <code class="literal">@SqlConfig</code> serves as <span class="emphasis"><em>global</em></span> configuration for all SQL scripts within the test
class hierarchy. When declared directly via the <code class="literal">config</code> attribute of the <code class="literal">@Sql</code>
annotation, <code class="literal">@SqlConfig</code> serves as <span class="emphasis"><em>local</em></span> configuration for the SQL scripts declared
within the enclosing <code class="literal">@Sql</code> annotation. Every attribute in <code class="literal">@SqlConfig</code> has an implicit
default value which is documented in the javadocs of the corresponding attribute. Due to
the rules defined for annotation attributes in the Java Language Specification, it is
unfortunately not possible to assign a value of <code class="literal">null</code> to an annotation attribute. Thus,
in order to support overrides of inherited global configuration, <code class="literal">@SqlConfig</code> attributes
have an explicit default value of either <code class="literal">""</code> for Strings or <code class="literal">DEFAULT</code> for Enums. This
approach allows local declarations of <code class="literal">@SqlConfig</code> to selectively override individual
attributes from global declarations of <code class="literal">@SqlConfig</code> by providing a value other than <code class="literal">""</code>
or <code class="literal">DEFAULT</code>. Global <code class="literal">@SqlConfig</code> attributes are inherited whenever local <code class="literal">@SqlConfig</code>
attributes do not supply an explicit value other than <code class="literal">""</code> or <code class="literal">DEFAULT</code>. Explicit <span class="emphasis"><em>local</em></span>
configuration therefore overrides <span class="emphasis"><em>global</em></span> configuration.</p>
<p>The configuration options provided by <code class="literal">@Sql</code> and <code class="literal">@SqlConfig</code> are equivalent to those
supported by <code class="literal">ScriptUtils</code> and <code class="literal">ResourceDatabasePopulator</code> but are a superset of those
provided by the <code class="literal">&lt;jdbc:initialize-database/&gt;</code> XML namespace element. Consult the javadocs
of individual attributes in <code class="literal">@Sql</code> and <code class="literal">@SqlConfig</code> for details.</p>
<p><a name="testcontext-executing-sql-declaratively-tx" href="#testcontext-executing-sql-declaratively-tx"></a><span class="strong"><strong>Transaction management for <code class="literal">@Sql</code></strong></span></p>
<p>By default, the <code class="literal">SqlScriptsTestExecutionListener</code> will infer the desired transaction
semantics for scripts configured via <code class="literal">@Sql</code>. Specifically, SQL scripts will be executed
without a transaction, within an existing Spring-managed transaction&#8201;&#8212;&#8201;for example, a
transaction managed by the <code class="literal">TransactionalTestExecutionListener</code> for a test annotated with
<code class="literal">@Transactional</code>&#8201;&#8212;&#8201;or within an isolated transaction, depending on the configured value
of the <code class="literal">transactionMode</code> attribute in <code class="literal">@SqlConfig</code> and the presence of a
<code class="literal">PlatformTransactionManager</code> in the test&#8217;s <code class="literal">ApplicationContext</code>. As a bare minimum
however, a <code class="literal">javax.sql.DataSource</code> must be present in the test&#8217;s <code class="literal">ApplicationContext</code>.</p>
<p>If the algorithms used by <code class="literal">SqlScriptsTestExecutionListener</code> to detect a <code class="literal">DataSource</code> and
<code class="literal">PlatformTransactionManager</code> and infer the transaction semantics do not suit your needs,
you may specify explicit names via the <code class="literal">dataSource</code> and <code class="literal">transactionManager</code> attributes
of <code class="literal">@SqlConfig</code>. Furthermore, the transaction propagation behavior can be controlled via
the <code class="literal">transactionMode</code> attribute of <code class="literal">@SqlConfig</code>&#8201;&#8212;&#8201;for example, if scripts should be
executed in an isolated transaction. Although a thorough discussion of all supported
options for transaction management with <code class="literal">@Sql</code> is beyond the scope of this reference
manual, the javadocs for <code class="literal">@SqlConfig</code> and <code class="literal">SqlScriptsTestExecutionListener</code> provide
detailed information, and the following example demonstrates a typical testing scenario
using JUnit 4 and transactional tests with <code class="literal">@Sql</code>. Note that there is no need to clean up
the database after the <code class="literal">usersTest()</code> method is executed since any changes made to the
database (either within the test method or within the <code class="literal">/test-data.sql</code> script) will
be automatically rolled back by the <code class="literal">TransactionalTestExecutionListener</code> (see
<a class="link" href="integration-testing.html#testcontext-tx" title="15.5.7&nbsp;Transaction management">transaction management</a> for details).</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = TestDatabaseConfig.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@Transactional</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransactionalSqlScriptsTests {

    <span class="hl-keyword">protected</span> JdbcTemplate jdbcTemplate;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <em><span class="hl-annotation" style="color: gray">@Sql("/test-data.sql")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> usersTest() {
        <span class="hl-comment">// verify state in test database:</span>
        assertNumUsers(<span class="hl-number">2</span>);
        <span class="hl-comment">// execute code that uses the test data...</span>
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">int</span> countRowsInTable(String tableName) {
        <span class="hl-keyword">return</span> JdbcTestUtils.countRowsInTable(<span class="hl-keyword">this</span>.jdbcTemplate, tableName);
    }

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> assertNumUsers(<span class="hl-keyword">int</span> expected) {
        assertEquals(<span class="hl-string">"Number of rows in the [user] table."</span>, expected, countRowsInTable(<span class="hl-string">"user"</span>));
    }
}</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-support-classes" href="#testcontext-support-classes"></a>15.5.9&nbsp;TestContext Framework support classes</h3></div></div></div>

<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-junit4-runner" href="#testcontext-junit4-runner"></a>Spring JUnit 4 Runner</h4></div></div></div>

<p>The <span class="emphasis"><em>Spring TestContext Framework</em></span> offers full integration with JUnit 4 through a
custom runner (supported on JUnit 4.12 or higher). By annotating test classes with
<code class="literal">@RunWith(SpringJUnit4ClassRunner.class)</code> or the shorter <code class="literal">@RunWith(SpringRunner.class)</code>
variant, developers can implement standard JUnit 4 based unit and integration tests and
simultaneously reap the benefits of the TestContext framework such as support for loading
application contexts, dependency injection of test instances, transactional test method
execution, and so on. If you would like to use the Spring TestContext Framework with an
alternative runner such as JUnit 4&#8217;s <code class="literal">Parameterized</code> or third-party runners such as the
<code class="literal">MockitoJUnitRunner</code>, you may optionally use <a class="link" href="integration-testing.html#testcontext-junit4-rules" title="Spring JUnit 4 Rules">Spring&#8217;s support
for JUnit rules</a> instead.</p>
<p>The following code listing displays the minimal requirements for configuring a test class
to run with the custom Spring <code class="literal">Runner</code>. <code class="literal">@TestExecutionListeners</code> is configured with an
empty list in order to disable the default listeners, which otherwise would require an
<code class="literal">ApplicationContext</code> to be configured through <code class="literal">@ContextConfiguration</code>.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@TestExecutionListeners({})</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleTest {

   <em><span class="hl-annotation" style="color: gray">@Test</span></em>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testMethod() {
      <span class="hl-comment">// execute test logic...</span>
   }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-junit4-rules" href="#testcontext-junit4-rules"></a>Spring JUnit 4 Rules</h4></div></div></div>

<p>The <code class="literal">org.springframework.test.context.junit4.rules</code> package provides the following JUnit
4 rules (supported on JUnit 4.12 or higher).</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">SpringClassRule</code>
</li><li class="listitem">
<code class="literal">SpringMethodRule</code>
</li></ul></div>
<p><code class="literal">SpringClassRule</code> is a JUnit <code class="literal">TestRule</code> that supports <span class="emphasis"><em>class-level</em></span> features of the
<span class="emphasis"><em>Spring TestContext Framework</em></span>; whereas, <code class="literal">SpringMethodRule</code> is a JUnit <code class="literal">MethodRule</code> that
supports instance-level and method-level features of the <span class="emphasis"><em>Spring TestContext Framework</em></span>.</p>
<p>In contrast to the <code class="literal">SpringRunner</code>, Spring&#8217;s rule-based JUnit support has the advantage
that it is independent of any <code class="literal">org.junit.runner.Runner</code> implementation and can therefore
be combined with existing alternative runners like JUnit 4&#8217;s <code class="literal">Parameterized</code> or third-party
runners such as the <code class="literal">MockitoJUnitRunner</code>.</p>
<p>In order to support the full functionality of the TestContext framework, a
<code class="literal">SpringClassRule</code> must be combined with a <code class="literal">SpringMethodRule</code>. The following example
demonstrates the proper way to declare these rules in an integration test.</p>
<pre class="programlisting"><span class="hl-comment">// Optionally specify a non-Spring Runner via @RunWith(...)</span>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> IntegrationTest {

   <em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> SpringClassRule SPRING_CLASS_RULE = <span class="hl-keyword">new</span> SpringClassRule();

   <em><span class="hl-annotation" style="color: gray">@Rule</span></em>
   <span class="hl-keyword">public</span> <span class="hl-keyword">final</span> SpringMethodRule springMethodRule = <span class="hl-keyword">new</span> SpringMethodRule();

   <em><span class="hl-annotation" style="color: gray">@Test</span></em>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testMethod() {
      <span class="hl-comment">// execute test logic...</span>
   }
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-support-classes-junit4" href="#testcontext-support-classes-junit4"></a>JUnit 4 support classes</h4></div></div></div>

<p>The <code class="literal">org.springframework.test.context.junit4</code> package provides the following support
classes for JUnit 4 based test cases (supported on JUnit 4.12 or higher).</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">AbstractJUnit4SpringContextTests</code>
</li><li class="listitem">
<code class="literal">AbstractTransactionalJUnit4SpringContextTests</code>
</li></ul></div>
<p><code class="literal">AbstractJUnit4SpringContextTests</code> is an abstract base test class that integrates the
<span class="emphasis"><em>Spring TestContext Framework</em></span> with explicit <code class="literal">ApplicationContext</code> testing support in
a JUnit 4 environment. When you extend <code class="literal">AbstractJUnit4SpringContextTests</code>, you can
access a <code class="literal">protected</code> <code class="literal">applicationContext</code> instance variable that can be used to perform
explicit bean lookups or to test the state of the context as a whole.</p>
<p><code class="literal">AbstractTransactionalJUnit4SpringContextTests</code> is an abstract <span class="emphasis"><em>transactional</em></span> extension
of <code class="literal">AbstractJUnit4SpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code class="literal">javax.sql.DataSource</code> bean and a <code class="literal">PlatformTransactionManager</code>
bean to be defined in the <code class="literal">ApplicationContext</code>. When you extend
<code class="literal">AbstractTransactionalJUnit4SpringContextTests</code> you can access a <code class="literal">protected</code> <code class="literal">jdbcTemplate</code>
instance variable that can be used to execute SQL statements to query the database. Such
queries can be used to confirm database state both <span class="emphasis"><em>prior to</em></span> and <span class="emphasis"><em>after</em></span> execution of
database-related application code, and Spring ensures that such queries run in the scope of
the same transaction as the application code. When used in conjunction with an ORM tool,
be sure to avoid <a class="link" href="integration-testing.html#testcontext-tx-false-positives" title="Avoid false positives when testing ORM code">false positives</a>. As mentioned in
<a class="xref" href="integration-testing.html#integration-testing-support-jdbc" title="15.3&nbsp;JDBC Testing Support">Section&nbsp;15.3, &#8220;JDBC Testing Support&#8221;</a>, <code class="literal">AbstractTransactionalJUnit4SpringContextTests</code>
also provides convenience methods which delegate to methods in <code class="literal">JdbcTestUtils</code> using the
aforementioned <code class="literal">jdbcTemplate</code>. Furthermore, <code class="literal">AbstractTransactionalJUnit4SpringContextTests</code>
provides an <code class="literal">executeSqlScript(..)</code> method for executing SQL scripts against the configured
<code class="literal">DataSource</code>.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>These classes are a convenience for extension. If you do not want your test classes to be
tied to a Spring-specific class hierarchy, you can configure your own custom test classes
by using <code class="literal">@RunWith(SpringRunner.class)</code> or <a class="link" href="integration-testing.html#testcontext-junit4-rules" title="Spring JUnit 4 Rules">Spring&#8217;s
JUnit rules</a>.</p>
</td></tr></table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-support-classes-testng" href="#testcontext-support-classes-testng"></a>TestNG support classes</h4></div></div></div>

<p>The <code class="literal">org.springframework.test.context.testng</code> package provides the following support
classes for TestNG based test cases.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">AbstractTestNGSpringContextTests</code>
</li><li class="listitem">
<code class="literal">AbstractTransactionalTestNGSpringContextTests</code>
</li></ul></div>
<p><code class="literal">AbstractTestNGSpringContextTests</code> is an abstract base test class that integrates the
<span class="emphasis"><em>Spring TestContext Framework</em></span> with explicit <code class="literal">ApplicationContext</code> testing support in
a TestNG environment. When you extend <code class="literal">AbstractTestNGSpringContextTests</code>, you can
access a <code class="literal">protected</code> <code class="literal">applicationContext</code> instance variable that can be used to perform
explicit bean lookups or to test the state of the context as a whole.</p>
<p><code class="literal">AbstractTransactionalTestNGSpringContextTests</code> is an abstract <span class="emphasis"><em>transactional</em></span> extension
of <code class="literal">AbstractTestNGSpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code class="literal">javax.sql.DataSource</code> bean and a <code class="literal">PlatformTransactionManager</code>
bean to be defined in the <code class="literal">ApplicationContext</code>. When you extend
<code class="literal">AbstractTransactionalTestNGSpringContextTests</code> you can access a <code class="literal">protected</code> <code class="literal">jdbcTemplate</code>
instance variable that can be used to execute SQL statements to query the database. Such
queries can be used to confirm database state both <span class="emphasis"><em>prior to</em></span> and <span class="emphasis"><em>after</em></span> execution of
database-related application code, and Spring ensures that such queries run in the scope of
the same transaction as the application code. When used in conjunction with an ORM tool,
be sure to avoid <a class="link" href="integration-testing.html#testcontext-tx-false-positives" title="Avoid false positives when testing ORM code">false positives</a>. As mentioned in
<a class="xref" href="integration-testing.html#integration-testing-support-jdbc" title="15.3&nbsp;JDBC Testing Support">Section&nbsp;15.3, &#8220;JDBC Testing Support&#8221;</a>, <code class="literal">AbstractTransactionalTestNGSpringContextTests</code>
also provides convenience methods which delegate to methods in <code class="literal">JdbcTestUtils</code> using the
aforementioned <code class="literal">jdbcTemplate</code>. Furthermore, <code class="literal">AbstractTransactionalTestNGSpringContextTests</code>
provides an <code class="literal">executeSqlScript(..)</code> method for executing SQL scripts against the configured
<code class="literal">DataSource</code>.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>These classes are a convenience for extension. If you do not want your test classes to be
tied to a Spring-specific class hierarchy, you can configure your own custom test classes
by using <code class="literal">@ContextConfiguration</code>, <code class="literal">@TestExecutionListeners</code>, and so on, and by manually
instrumenting your test class with a <code class="literal">TestContextManager</code>. See the source code of
<code class="literal">AbstractTestNGSpringContextTests</code> for an example of how to instrument your test class.</p>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-mvc-test-framework" href="#spring-mvc-test-framework"></a>15.6&nbsp;Spring MVC Test Framework</h2></div></div></div>

<p>The <span class="emphasis"><em>Spring MVC Test framework</em></span> provides first class support for testing Spring MVC
code using a fluent API that can be used with JUnit, TestNG, or any other testing
framework. It&#8217;s built on the
<a class="ulink" href="http://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html" target="_top">Servlet API mock objects</a>
from the <code class="literal">spring-test</code> module and hence does <span class="emphasis"><em>not</em></span> use a running Servlet container. It
uses the <code class="literal">DispatcherServlet</code> to provide full Spring MVC runtime behavior and provides support
for loading actual Spring configuration with the <span class="emphasis"><em>TestContext framework</em></span> in addition to a
standalone mode in which controllers may be instantiated manually and tested one at a time.</p>
<p><span class="emphasis"><em>Spring MVC Test</em></span> also provides client-side support for testing code that uses
the <code class="literal">RestTemplate</code>. Client-side tests mock the server responses and also do <span class="emphasis"><em>not</em></span>
use a running server.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Spring Boot provides an option to write full, end-to-end integration tests that include
a running server. If this is your goal please have a look at the
<a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications" target="_top">Spring Boot reference page</a>.
For more information on the differences between out-of-container and end-to-end
integration tests, see <a class="xref" href="integration-testing.html#spring-mvc-test-vs-end-to-end-integration-tests" title="Differences between Out-of-Container and End-to-End Integration Tests">the section called &#8220;Differences between Out-of-Container and End-to-End Integration Tests&#8221;</a>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-mvc-test-server" href="#spring-mvc-test-server"></a>15.6.1&nbsp;Server-Side Tests</h3></div></div></div>

<p>It&#8217;s easy to write a plain unit test for a Spring MVC controller using JUnit or TestNG:
simply instantiate the controller, inject it with mocked or stubbed dependencies, and call
its methods passing <code class="literal">MockHttpServletRequest</code>, <code class="literal">MockHttpServletResponse</code>, etc., as necessary.
However, when writing such a unit test, much remains untested: for example, request
mappings, data binding, type conversion, validation, and much more. Furthermore, other
controller methods such as <code class="literal">@InitBinder</code>, <code class="literal">@ModelAttribute</code>, and <code class="literal">@ExceptionHandler</code> may
also be invoked as part of the request processing lifecycle.</p>
<p>The goal of <span class="emphasis"><em>Spring MVC Test</em></span> is to provide an effective way for testing controllers
by performing requests and generating responses through the actual <code class="literal">DispatcherServlet</code>.</p>
<p><span class="emphasis"><em>Spring MVC Test</em></span> builds on the familiar <a class="link" href="unit-testing.html#mock-objects-servlet" title="14.1.3&nbsp;Servlet API">"mock" implementations
of the Servlet API</a> available in the <code class="literal">spring-test</code> module. This allows performing
requests and generating responses without the need for running in a Servlet container.
For the most part everything should work as it does at runtime with a few notable
exceptions as explained in <a class="xref" href="integration-testing.html#spring-mvc-test-vs-end-to-end-integration-tests" title="Differences between Out-of-Container and End-to-End Integration Tests">the section called &#8220;Differences between Out-of-Container and End-to-End Integration Tests&#8221;</a>. Here is a
JUnit 4 based example of using Spring MVC Test:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("test-servlet-context.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExampleTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="hl-keyword">this</span>.wac).build();
    }

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getAccount() <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">this</span>.mockMvc.perform(get(<span class="hl-string">"/accounts/1"</span>).accept(MediaType.parseMediaType(<span class="hl-string">"application/json;charset=UTF-8"</span>)))
            .andExpect(status().isOk())
            .andExpect(content().contentType(<span class="hl-string">"application/json"</span>))
            .andExpect(jsonPath(<span class="hl-string">"$.name"</span>).value(<span class="hl-string">"Lee"</span>));
    }

}</pre>
<p>The above test relies on the <code class="literal">WebApplicationContext</code> support of the <span class="emphasis"><em>TestContext framework</em></span>
for loading Spring configuration from an XML configuration file located in the same package
as the test class, but Java-based and Groovy-based configuration are also supported. See these
<a class="ulink" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context" target="_top">sample tests</a>.</p>
<p>The <code class="literal">MockMvc</code> instance is used to perform a <code class="literal">GET</code> request to <code class="literal">"/accounts/1"</code> and verify
that the resulting response has status 200, the content type is <code class="literal">"application/json"</code>, and the
response body has a JSON property called "name" with the value "Lee". The <code class="literal">jsonPath</code>
syntax is supported through the Jayway <a class="ulink" href="https://github.com/jayway/JsonPath" target="_top">JsonPath
project</a>. There are lots of other options for verifying the result of the performed
request that will be discussed below.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-static-imports" href="#spring-mvc-test-server-static-imports"></a>Static Imports</h4></div></div></div>

<p>The fluent API in the example above requires a few static imports such as
<code class="literal">MockMvcRequestBuilders.*</code>, <code class="literal">MockMvcResultMatchers.*</code>,
and <code class="literal">MockMvcBuilders.*</code>. An easy way to find these classes is to search for
types matching <span class="emphasis"><em>"MockMvc*"</em></span>. If using Eclipse, be sure to add them as
"favorite static members" in the Eclipse preferences under
<span class="emphasis"><em>Java &#8594; Editor &#8594; Content Assist &#8594; Favorites</em></span>. That will allow use of content
assist after typing the first character of the static method name. Other IDEs (e.g.
IntelliJ) may not require any additional configuration. Just check the support for code
completion on static members.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-setup-options" href="#spring-mvc-test-server-setup-options"></a>Setup Options</h4></div></div></div>

<p>There are two main options for creating an instance of <code class="literal">MockMvc</code>.
The first is to load Spring MVC configuration through the <span class="emphasis"><em>TestContext
framework</em></span>, which loads the Spring configuration and injects a <code class="literal">WebApplicationContext</code>
into the test to use to build a <code class="literal">MockMvc</code> instance:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("my-servlet-context.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="hl-keyword">this</span>.wac).build();
    }

    <span class="hl-comment">// ...</span>

}</pre>
<p>The second is to simply create a controller instance manually without loading Spring
configuration. Instead basic default configuration, roughly comparable to that of
the MVC JavaConfig or the MVC namespace, is automatically created and can be customized
to a degree:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        <span class="hl-keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(<span class="hl-keyword">new</span> AccountController()).build();
    }

    <span class="hl-comment">// ...</span>

}</pre>
<p>Which setup option should you use?</p>
<p>The <span class="emphasis"><em>"webAppContextSetup"</em></span> loads your actual Spring MVC configuration resulting in a
more complete integration test. Since the <span class="emphasis"><em>TestContext framework</em></span> caches the loaded
Spring configuration, it helps keep tests running fast, even as you introduce more tests
in your test suite. Furthermore, you can inject mock services into controllers through
Spring configuration in order to remain focused on testing the web layer. Here is an
example of declaring a mock service with Mockito:</p>
<pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"accountService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.mockito.Mockito"</span> <span class="hl-attribute">factory-method</span>=<span class="hl-value">"mock"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.example.AccountService"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre>
<p>You can then inject the mock service into the test in order set up and verify
expectations:</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@ContextConfiguration("test-servlet-context.xml")</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> AccountTests {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> WebApplicationContext wac;

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span class="hl-keyword">private</span> AccountService accountService;

    <span class="hl-comment">// ...</span>

}</pre>
<p>The <span class="emphasis"><em>"standaloneSetup"</em></span> on the other hand is a little closer to a unit test. It tests
one controller at a time: the controller can be injected with mock dependencies manually,
and it doesn&#8217;t involve loading Spring configuration. Such tests are more focused on style
and make it easier to see which controller is being tested, whether any specific Spring
MVC configuration is required to work, and so on. The "standaloneSetup" is also a very
convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.</p>
<p>Just like with any "integration vs. unit testing" debate, there is no right or wrong
answer. However, using the "standaloneSetup" does imply the need for additional
"webAppContextSetup" tests in order to verify your Spring MVC configuration.
Alternatively, you may choose to write all tests with "webAppContextSetup" in order to
always test against your actual Spring MVC configuration.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-performing-requests" href="#spring-mvc-test-server-performing-requests"></a>Performing Requests</h4></div></div></div>

<p>It&#8217;s easy to perform requests using any HTTP method:</p>
<pre class="programlisting">mockMvc.perform(post(<span class="hl-string">"/hotels/{id}"</span>, <span class="hl-number">42</span>).accept(MediaType.APPLICATION_JSON));</pre>
<p>You can also perform file upload requests that internally use
<code class="literal">MockMultipartHttpServletRequest</code> so that there is no actual parsing of a multipart
request but rather you have to set it up:</p>
<pre class="programlisting">mockMvc.perform(fileUpload(<span class="hl-string">"/doc"</span>).file(<span class="hl-string">"a1"</span>, <span class="hl-string">"ABC"</span>.getBytes(<span class="hl-string">"UTF-8"</span>)));</pre>
<p>You can specify query parameters in URI template style:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/hotels?foo={foo}"</span>, <span class="hl-string">"bar"</span>));</pre>
<p>Or you can add Servlet request parameters representing either query of form parameters:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/hotels"</span>).param(<span class="hl-string">"foo"</span>, <span class="hl-string">"bar"</span>));</pre>
<p>If application code relies on Servlet request parameters and doesn&#8217;t check the query
string explicitly (as is most often the case) then it doesn&#8217;t matter which option you use.
Keep in mind however that query params provided with the URI template will be decoded while
request parameters provided through the <code class="literal">param(&#8230;&#8203;)</code> method are expected to already be decoded.</p>
<p>In most cases it&#8217;s preferable to leave out the context path and the Servlet path from
the request URI. If you must test with the full request URI, be sure to set the
<code class="literal">contextPath</code> and <code class="literal">servletPath</code> accordingly so that request mappings will work:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/app/main/hotels/{id}"</span>).contextPath(<span class="hl-string">"/app"</span>).servletPath(<span class="hl-string">"/main"</span>))</pre>
<p>Looking at the above example, it would be cumbersome to set the contextPath and
servletPath with every performed request. Instead you can set up default request
properties:</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyWebTests {

    <span class="hl-keyword">private</span> MockMvc mockMvc;

    <em><span class="hl-annotation" style="color: gray">@Before</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
        mockMvc = standaloneSetup(<span class="hl-keyword">new</span> AccountController())
            .defaultRequest(get(<span class="hl-string">"/"</span>)
            .contextPath(<span class="hl-string">"/app"</span>).servletPath(<span class="hl-string">"/main"</span>)
            .accept(MediaType.APPLICATION_JSON).build();
    }</pre>
<p>The above properties will affect every request performed through the <code class="literal">MockMvc</code> instance.
If the same property is also specified on a given request, it overrides the default value.
That is why the HTTP method and URI in the default request don&#8217;t matter since they must be
specified on every request.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-defining-expectations" href="#spring-mvc-test-server-defining-expectations"></a>Defining Expectations</h4></div></div></div>

<p>Expectations can be defined by appending one or more <code class="literal">.andExpect(..)</code> calls after
performing a request:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/accounts/1"</span>)).andExpect(status().isOk());</pre>
<p><code class="literal">MockMvcResultMatchers.*</code> provides a number of expectations, some of which are further
nested with more detailed expectations.</p>
<p>Expectations fall in two general categories. The first category of assertions verifies
properties of the response: for example, the response status, headers, and content. These
are the most important results to assert.</p>
<p>The second category of assertions goes beyond the response. These assertions allow
one to inspect Spring MVC specific aspects such as which controller method processed
the request, whether an exception was raised and handled, what the content of the model
is, what view was selected, what flash attributes were added, and so on. They also allow
one to inspect Servlet specific aspects such as request and session attributes.</p>
<p>The following test asserts that binding or validation failed:</p>
<pre class="programlisting">mockMvc.perform(post(<span class="hl-string">"/persons"</span>))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors(<span class="hl-string">"person"</span>));</pre>
<p>Many times when writing tests, it&#8217;s useful to <span class="emphasis"><em>dump</em></span> the results of the performed request.
This can be done as follows, where <code class="literal">print()</code> is a static import from
<code class="literal">MockMvcResultHandlers</code>:</p>
<pre class="programlisting">mockMvc.perform(post(<span class="hl-string">"/persons"</span>))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors(<span class="hl-string">"person"</span>));</pre>
<p>As long as request processing does not cause an unhandled exception, the <code class="literal">print()</code> method
will print all the available result data to <code class="literal">System.out</code>. Spring Framework 4.2 introduced
a <code class="literal">log()</code> method and two additional variants of the <code class="literal">print()</code> method, one that accepts
an <code class="literal">OutputStream</code> and one that accepts a <code class="literal">Writer</code>. For example, invoking
<code class="literal">print(System.err)</code> will print the result data to <code class="literal">System.err</code>; while invoking
<code class="literal">print(myWriter)</code> will print the result data to a custom writer. If you would like to
have the result data <span class="emphasis"><em>logged</em></span> instead of printed, simply invoke the <code class="literal">log()</code> method which
will log the result data as a single <code class="literal">DEBUG</code> message under the
<code class="literal">org.springframework.test.web.servlet.result</code> logging category.</p>
<p>In some cases, you may want to get direct access to the result and verify something that
cannot be verified otherwise. This can be achieved by appending <code class="literal">.andReturn()</code> after all
other expectations:</p>
<pre class="programlisting">MvcResult mvcResult = mockMvc.perform(post(<span class="hl-string">"/persons"</span>)).andExpect(status().isOk()).andReturn();
<span class="hl-comment">// ...</span></pre>
<p>If all tests repeat the same expectations you can set up common expectations once
when building the <code class="literal">MockMvc</code> instance:</p>
<pre class="programlisting">standaloneSetup(<span class="hl-keyword">new</span> SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType(<span class="hl-string">"application/json;charset=UTF-8"</span>))
    .build()</pre>
<p>Note that common expectations are <span class="emphasis"><em>always</em></span> applied and cannot be overridden without
creating a separate <code class="literal">MockMvc</code> instance.</p>
<p>When JSON response content contains hypermedia links created with
<a class="ulink" href="https://github.com/spring-projects/spring-hateoas" target="_top">Spring HATEOAS</a>, the resulting links can
be verified using JsonPath expressions:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/people"</span>).accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath(<span class="hl-string">"$.links[?(@.rel == 'self')].href"</span>).value(<span class="hl-string">"http://localhost:8080/people"</span>));</pre>
<p>When XML response content contains hypermedia links created with
<a class="ulink" href="https://github.com/spring-projects/spring-hateoas" target="_top">Spring HATEOAS</a>, the resulting links can
be verified using XPath expressions:</p>
<pre class="programlisting">Map&lt;String, String&gt; ns = Collections.singletonMap(<span class="hl-string">"ns"</span>, <span class="hl-string">"http://www.w3.org/2005/Atom"</span>);
mockMvc.perform(get(<span class="hl-string">"/handle"</span>).accept(MediaType.APPLICATION_XML))
    .andExpect(xpath(<span class="hl-string">"/person/ns:link[@rel='self']/@href"</span>, ns).string(<span class="hl-string">"http://localhost:8080/people"</span>));</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-filters" href="#spring-mvc-test-server-filters"></a>Filter Registrations</h4></div></div></div>

<p>When setting up a <code class="literal">MockMvc</code> instance, you can register one or more Servlet <code class="literal">Filter</code> instances:</p>
<pre class="programlisting">mockMvc = standaloneSetup(<span class="hl-keyword">new</span> PersonController()).addFilters(<span class="hl-keyword">new</span> CharacterEncodingFilter()).build();</pre>
<p>Registered filters will be invoked through via the <code class="literal">MockFilterChain</code> from <code class="literal">spring-test</code>, and the
last filter will delegate to the <code class="literal">DispatcherServlet</code>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-vs-end-to-end-integration-tests" href="#spring-mvc-test-vs-end-to-end-integration-tests"></a>Differences between Out-of-Container and End-to-End Integration Tests</h4></div></div></div>

<p>As mentioned earlier <span class="emphasis"><em>Spring MVC Test</em></span> is built on the Servlet API mock objects from
the <code class="literal">spring-test</code> module and does not use a running Servlet container. Therefore
there are some important differences compared to full end-to-end integration tests
with an actual client and server running.</p>
<p>The easiest way to think about this is starting with a blank <code class="literal">MockHttpServletRequest</code>.
Whatever you add to it is what the request will be. Things that may catch you by surprise
are that there is no context path by default, no <code class="literal">jsessionid</code> cookie, no forwarding, error,
or async dispatches, and therefore no actual JSP rendering. Instead, "forwarded" and
"redirected" URLs are saved in the <code class="literal">MockHttpServletResponse</code> and can be asserted with
expectations.</p>
<p>This means if you are using JSPs you can verify the JSP page to which the request was
forwarded, but there won&#8217;t be any HTML rendered. In other words, the JSP will not be
<span class="emphasis"><em>invoked</em></span>. Note however that all other rendering technologies which don&#8217;t rely on
forwarding such as Thymeleaf, Freemarker, and Velocity will render HTML to the response
body as expected. The same is true for rendering JSON, XML, and other formats via
<code class="literal">@ResponseBody</code> methods.</p>
<p>Alternatively you may consider the full end-to-end integration testing support from
Spring Boot via <code class="literal">@WebIntegrationTest</code>. See the
<a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications" target="_top">Spring Boot reference</a>.</p>
<p>There are pros and cons for each approach. The options provided in <span class="emphasis"><em>Spring MVC Test</em></span>
are different stops on the scale from classic unit testing to full integration testing.
To be certain, none of the options in Spring MVC Test fall under the category of classic
unit testing, but they <span class="emphasis"><em>are</em></span> a little closer to it. For example, you can isolate the web
layer by injecting mocked services into controllers, in which case you&#8217;re testing the web
layer only through the <code class="literal">DispatcherServlet</code> but with actual Spring configuration, just
like you might test the data access layer in isolation from the layers above. Or you
can use the standalone setup focusing on one controller at a time and manually providing
the configuration required to make it work.</p>
<p>Another important distinction when using <span class="emphasis"><em>Spring MVC Test</em></span> is that conceptually such
tests are on the <span class="emphasis"><em>inside</em></span> of the server-side so you can check what handler was used,
if an exception was handled with a HandlerExceptionResolver, what the content of the
model is, what binding errors there were, etc. That means it&#8217;s easier to write
expectations since the server is not a black box as it is when testing it through
an actual HTTP client. This is generally an advantage of classic unit testing, that it&#8217;s
easier to write, reason about, and debug but does not replace the need for full
integration tests. At the same time it&#8217;s important not to lose sight of the fact that
the response is the most important thing to check. In short, there is room here for
multiple styles and strategies of testing even within the same project.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-resources" href="#spring-mvc-test-server-resources"></a>Further Server-Side Test Examples</h4></div></div></div>

<p>The framework&#8217;s own tests include
<a class="ulink" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples" target="_top">many
sample tests</a> intended to demonstrate how to use Spring MVC Test. Browse these examples
for further ideas. Also the
<a class="ulink" href="https://github.com/spring-projects/spring-mvc-showcase" target="_top">spring-mvc-showcase</a> has full test
coverage based on Spring MVC Test.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-mvc-test-server-htmlunit" href="#spring-mvc-test-server-htmlunit"></a>15.6.2&nbsp;HtmlUnit Integration</h3></div></div></div>

<p>Spring provides integration between <a class="link" href="integration-testing.html#spring-mvc-test-server" title="15.6.1&nbsp;Server-Side Tests">MockMvc</a> and
<a class="ulink" href="http://htmlunit.sourceforge.net/" target="_top">HtmlUnit</a>. This simplifies performing end-to-end testing
when using HTML based views. This integration enables developers to:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Easily test HTML pages using tools such as <a class="ulink" href="http://htmlunit.sourceforge.net/" target="_top">HtmlUnit</a>,
<a class="ulink" href="http://seleniumhq.org/projects/webdriver/" target="_top">WebDriver</a>, &amp;
<a class="ulink" href="http://www.gebish.org/manual/current/testing.html#spock_junit__testng" target="_top">Geb</a> without the
need to deploy to a Servlet container
</li><li class="listitem">
Test JavaScript within pages
</li><li class="listitem">
Optionally test using mock services to speed up testing
</li><li class="listitem">
Share logic between in-container end-to-end tests and out-of-container integration tests
</li></ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p><code class="literal">MockMvc</code> works with templating technologies that do not rely on a Servlet Container (e.g.,
Thymeleaf, Freemarker, Velocity, etc.), but it does not work with JSPs since they rely on
the Servlet Container.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-htmlunit-why" href="#spring-mvc-test-server-htmlunit-why"></a>Why HtmlUnit Integration?</h4></div></div></div>

<p>The most obvious question that comes to mind is, "Why do I need this?". The answer is best
found by exploring a very basic sample application. Assume you have a Spring MVC web
application that supports CRUD operations on a <code class="literal">Message</code> object. The application also supports
paging through all messages. How would you go about testing it?</p>
<p>With Spring MVC Test, we can easily test if we are able to create a <code class="literal">Message</code>.</p>
<pre class="programlisting">MockHttpServletRequestBuilder createMessage = post(<span class="hl-string">"/messages/"</span>)
	.param(<span class="hl-string">"summary"</span>, <span class="hl-string">"Spring Rocks"</span>)
	.param(<span class="hl-string">"text"</span>, <span class="hl-string">"In case you didn't know, Spring Rocks!"</span>);

mockMvc.perform(createMessage)
	.andExpect(status().is3xxRedirection())
	.andExpect(redirectedUrl(<span class="hl-string">"/messages/123"</span>));</pre>
<p>What if we want to test our form view that allows us to create the message? For example,
assume our form looks like the following snippet:</p>
<pre class="programlisting"><span class="hl-tag">&lt;form</span> <span class="hl-attribute">id</span>=<span class="hl-value">"messageForm"</span> <span class="hl-attribute">action</span>=<span class="hl-value">"/messages/"</span> <span class="hl-attribute">method</span>=<span class="hl-value">"post"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;div</span> <span class="hl-attribute">class</span>=<span class="hl-value">"pull-right"</span><span class="hl-tag">&gt;</span><span class="hl-tag">&lt;a</span> <span class="hl-attribute">href</span>=<span class="hl-value">"/messages/"</span><span class="hl-tag">&gt;</span>Messages<span class="hl-tag">&lt;/a&gt;</span><span class="hl-tag">&lt;/div&gt;</span>

  <span class="hl-tag">&lt;label</span> <span class="hl-attribute">for</span>=<span class="hl-value">"summary"</span><span class="hl-tag">&gt;</span>Summary<span class="hl-tag">&lt;/label&gt;</span>
  <span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"required"</span> <span class="hl-attribute">id</span>=<span class="hl-value">"summary"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"summary"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span><span class="hl-tag"> /&gt;</span>

  <span class="hl-tag">&lt;label</span> <span class="hl-attribute">for</span>=<span class="hl-value">"text"</span><span class="hl-tag">&gt;</span>Message<span class="hl-tag">&lt;/label&gt;</span>
  <span class="hl-tag">&lt;textarea</span> <span class="hl-attribute">id</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"text"</span><span class="hl-tag">&gt;</span><span class="hl-tag">&lt;/textarea&gt;</span>

  <span class="hl-tag">&lt;div</span> <span class="hl-attribute">class</span>=<span class="hl-value">"form-actions"</span><span class="hl-tag">&gt;</span>
	<span class="hl-tag">&lt;input</span> <span class="hl-attribute">type</span>=<span class="hl-value">"submit"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"Create"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/div&gt;</span>
<span class="hl-tag">&lt;/form&gt;</span></pre>
<p>How do we ensure that our form will produce the correct request to create a new message? A
naive attempt would look like this:</p>
<pre class="programlisting">mockMvc.perform(get(<span class="hl-string">"/messages/form"</span>))
	.andExpect(xpath(<span class="hl-string">"//input[@name='summary']"</span>).exists())
	.andExpect(xpath(<span class="hl-string">"//textarea[@name='text']"</span>).exists());</pre>
<p>This test has some obvious drawbacks. If we update our controller to use the parameter
<code class="literal">message</code> instead of <code class="literal">text</code>, our form test would continue to pass even though the HTML
form is out of synch with the controller. To resolve this we can combine our two tests.</p>
<a name="spring-mvc-test-server-htmlunit-mock-mvc-test" href="#spring-mvc-test-server-htmlunit-mock-mvc-test"></a><pre class="programlisting">String summaryParamName = <span class="hl-string">"summary"</span>;
String textParamName = <span class="hl-string">"text"</span>;
mockMvc.perform(get(<span class="hl-string">"/messages/form"</span>))
		.andExpect(xpath(<span class="hl-string">"//input[@name='"</span> + summaryParamName + <span class="hl-string">"']"</span>).exists())
		.andExpect(xpath(<span class="hl-string">"//textarea[@name='"</span> + textParamName + <span class="hl-string">"']"</span>).exists());

MockHttpServletRequestBuilder createMessage = post(<span class="hl-string">"/messages/"</span>)
		.param(summaryParamName, <span class="hl-string">"Spring Rocks"</span>)
		.param(textParamName, <span class="hl-string">"In case you didn't know, Spring Rocks!"</span>);

mockMvc.perform(createMessage)
		.andExpect(status().is3xxRedirection())
		.andExpect(redirectedUrl(<span class="hl-string">"/messages/123"</span>));</pre>
<p>This would reduce the risk of our test incorrectly passing, but there are still some
problems.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
What if we have multiple forms on our page? Admittedly we could update our xpath
expressions, but they get more complicated the more factors we take into account (Are the
fields the correct type? Are the fields enabled? etc.).
</li><li class="listitem">
Another issue is that we are doing double the work we would expect.
We must first verify the view, and then we submit the view with the same parameters we just
verified. Ideally this could be done all at once.
</li><li class="listitem">
Finally, there are some things that we still cannot account for. For example, what if the
form has JavaScript validation that we wish to test as well?
</li></ul></div>
<p>The overall problem is that testing a web page does not involve a single interaction.
Instead, it is a combination of how the user interacts with a web page and how that web
page interacts with other resources. For example, the result of a form view is used as
the input to a user for creating a message. In addition, our form view may potentially
utilize additional resources which impact the behavior of the page, such as JavaScript
validation.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-why-integration" href="#spring-mvc-test-server-htmlunit-why-integration"></a>Integration testing to the rescue?</h5></div></div></div>

<p>To resolve the issues above we could perform end-to-end integration testing, but this has
some obvious drawbacks. Consider testing the view that allows us to page through the messages.
We might need the following tests.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Does our page display a notification to the user indicating that no results are available
when the messages are empty?
</li><li class="listitem">
Does our page properly display a single message?
</li><li class="listitem">
Does our page properly support paging?
</li></ul></div>
<p>To set up these tests, we would need to ensure our database contained the proper messages
in it. This leads to a number of additional challenges.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Ensuring the proper messages are in the database can be tedious; consider foreign key
constraints.
</li><li class="listitem">
Testing can become slow since each test would need to ensure that the database is in the
correct state.
</li><li class="listitem">
Since our database needs to be in a specific state, we cannot run tests in parallel.
</li><li class="listitem">
Performing assertions on things like auto-generated ids, timestamps, etc. can be difficult.
</li></ul></div>
<p>These challenges do not mean that we should abandon end-to-end integration testing
altogether. Instead, we can reduce the number of end-to-end integration tests by
refactoring our detailed tests to use mock services which will execute much faster, more
reliably, and without side effects. We can then implement a small number of <span class="emphasis"><em>true</em></span>
end-to-end integration tests that validate simple workflows to ensure that everything
works together properly.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-why-mockmvc" href="#spring-mvc-test-server-htmlunit-why-mockmvc"></a>Enter HtmlUnit Integration</h5></div></div></div>

<p>So how can we achieve a balance between testing the interactions of our pages and still
retain good performance within our test suite? The answer is: "By integrating MockMvc
with HtmlUnit."</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-options" href="#spring-mvc-test-server-htmlunit-options"></a>HtmlUnit Integration Options</h5></div></div></div>

<p>There are a number of ways to integrate <code class="literal">MockMvc</code> with HtmlUnit.</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-mah" title="MockMvc and HtmlUnit">MockMvc and HtmlUnit</a>: Use this option if you
want to use the raw HtmlUnit libraries.
</li><li class="listitem">
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-webdriver" title="MockMvc and WebDriver">MockMvc and WebDriver</a>: Use this option to
ease development and reuse code between integration and end-to-end testing.
</li><li class="listitem">
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-geb" title="MockMvc and Geb">MockMvc and Geb</a>: Use this option if you would
like to use Groovy for testing, ease development, and reuse code between integration and
end-to-end testing.
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-htmlunit-mah" href="#spring-mvc-test-server-htmlunit-mah"></a>MockMvc and HtmlUnit</h4></div></div></div>

<p>This section describes how to integrate <code class="literal">MockMvc</code> and HtmlUnit. Use this option if you
want to use the raw HtmlUnit libraries.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-mah-setup" href="#spring-mvc-test-server-htmlunit-mah-setup"></a>MockMvc and HtmlUnit Setup</h5></div></div></div>

<p>First, make sure that you have included a test dependency on <code class="literal">net.sourceforge.htmlunit:htmlunit</code>.
In order to use HtmlUnit with Apache HttpComponents 4.5+, you will need to use HtmlUnit
2.18 or higher.</p>
<p>We can easily create an HtmlUnit <code class="literal">WebClient</code> that integrates with <code class="literal">MockMvc</code> using the
<code class="literal">MockMvcWebClientBuilder</code> as follows.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
WebApplicationContext context;

WebClient webClient;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	webClient = MockMvcWebClientBuilder
		.webAppContextSetup(context)
		.build();
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This is a simple example of using <code class="literal">MockMvcWebClientBuilder</code>. For advanced usage see
<a class="xref" href="integration-testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder" title="Advanced MockMvcWebClientBuilder">the section called &#8220;Advanced MockMvcWebClientBuilder&#8221;</a></p>
</td></tr></table></div>
<p>This will ensure that any URL referencing <code class="literal">localhost</code> as the server will be directed to
our <code class="literal">MockMvc</code> instance without the need for a real HTTP connection. Any other URL will be
requested using a network connection as normal. This allows us to easily test the use of
CDNs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-mah-usage" href="#spring-mvc-test-server-htmlunit-mah-usage"></a>MockMvc and HtmlUnit Usage</h5></div></div></div>

<p>Now we can use HtmlUnit as we normally would, but without the need to deploy our
application to a Servlet container. For example, we can request the view to create
a message with the following.</p>
<pre class="programlisting">HtmlPage createMsgFormPage = webClient.getPage(<span class="hl-string">"http://localhost/messages/form"</span>);</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The default context path is <code class="literal">""</code>. Alternatively, we can specify the context path as
illustrated in <a class="xref" href="integration-testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder" title="Advanced MockMvcWebClientBuilder">the section called &#8220;Advanced MockMvcWebClientBuilder&#8221;</a>.</p>
</td></tr></table></div>
<p>Once we have a reference to the <code class="literal">HtmlPage</code>, we can then fill out the form and submit
it to create a message.</p>
<pre class="programlisting">HtmlForm form = createMsgFormPage.getHtmlElementById(<span class="hl-string">"messageForm"</span>);
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById(<span class="hl-string">"summary"</span>);
summaryInput.setValueAttribute(<span class="hl-string">"Spring Rocks"</span>);
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById(<span class="hl-string">"text"</span>);
textInput.setText(<span class="hl-string">"In case you didn't know, Spring Rocks!"</span>);
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute(<span class="hl-string">"input"</span>, <span class="hl-string">"type"</span>, <span class="hl-string">"submit"</span>);
HtmlPage newMessagePage = submit.click();</pre>
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a class="ulink" href="http://joel-costigliola.github.io/assertj/" target="_top">AssertJ</a> library.</p>
<pre class="programlisting">assertThat(newMessagePage.getUrl().toString()).endsWith(<span class="hl-string">"/messages/123"</span>);
String id = newMessagePage.getHtmlElementById(<span class="hl-string">"id"</span>).getTextContent();
assertThat(id).isEqualTo(<span class="hl-string">"123"</span>);
String summary = newMessagePage.getHtmlElementById(<span class="hl-string">"summary"</span>).getTextContent();
assertThat(summary).isEqualTo(<span class="hl-string">"Spring Rocks"</span>);
String text = newMessagePage.getHtmlElementById(<span class="hl-string">"text"</span>).getTextContent();
assertThat(text).isEqualTo(<span class="hl-string">"In case you didn't know, Spring Rocks!"</span>);</pre>
<p>This improves on our <a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc test</a> in a
number of ways. First we no longer have to explicitly verify our form and then create a
request that looks like the form. Instead, we request the form, fill it out, and submit
it, thereby significantly reducing the overhead.</p>
<p>Another important factor is that <a class="ulink" href="http://htmlunit.sourceforge.net/javascript.html" target="_top">HtmlUnit
uses the Mozilla Rhino engine</a> to evaluate JavaScript. This means that we can test the
behavior of JavaScript within our pages as well!</p>
<p>Refer to the <a class="ulink" href="http://htmlunit.sourceforge.net/gettingStarted.html" target="_top">HtmlUnit documentation</a>
for additional information about using HtmlUnit.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-mah-advanced-builder" href="#spring-mvc-test-server-htmlunit-mah-advanced-builder"></a>Advanced MockMvcWebClientBuilder</h5></div></div></div>

<p>In the examples so far, we have used <code class="literal">MockMvcWebClientBuilder</code> in the simplest way possible,
by building a <code class="literal">WebClient</code> based on the <code class="literal">WebApplicationContext</code> loaded for us by the Spring
TestContext Framework. This approach is repeated here.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
WebApplicationContext context;

WebClient webClient;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	webClient = MockMvcWebClientBuilder
		.webAppContextSetup(context)
		.build();
}</pre>
<p>We can also specify additional configuration options.</p>
<pre class="programlisting">WebClient webClient;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	webClient = MockMvcWebClientBuilder
		<span class="hl-comment">// demonstrates applying a MockMvcConfigurer (Spring Security)</span>
		.webAppContextSetup(context, springSecurity())
		<span class="hl-comment">// for illustration only - defaults to ""</span>
		.contextPath(<span class="hl-string">""</span>)
		<span class="hl-comment">// By default MockMvc is used for localhost only;</span>
		<span class="hl-comment">// the following will use MockMvc for example.com and example.org as well</span>
		.useMockMvcForHosts(<span class="hl-string">"example.com"</span>,<span class="hl-string">"example.org"</span>)
		.build();
}</pre>
<p>As an alternative, we can perform the exact same setup by configuring the <code class="literal">MockMvc</code>
instance separately and supplying it to the <code class="literal">MockMvcWebClientBuilder</code> as follows.</p>
<pre class="programlisting">MockMvc mockMvc = MockMvcBuilders
		.webAppContextSetup(context)
		.apply(springSecurity())
		.build();

webClient = MockMvcWebClientBuilder
		.mockMvcSetup(mockMvc)
		<span class="hl-comment">// for illustration only - defaults to ""</span>
		.contextPath(<span class="hl-string">""</span>)
		<span class="hl-comment">// By default MockMvc is used for localhost only;</span>
		<span class="hl-comment">// the following will use MockMvc for example.com and example.org as well</span>
		.useMockMvcForHosts(<span class="hl-string">"example.com"</span>,<span class="hl-string">"example.org"</span>)
		.build();</pre>
<p>This is more verbose, but by building the <code class="literal">WebClient</code> with a <code class="literal">MockMvc</code> instance we have
the full power of <code class="literal">MockMvc</code> at our fingertips.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>For additional information on creating a <code class="literal">MockMvc</code> instance refer to
<a class="xref" href="integration-testing.html#spring-mvc-test-server-setup-options" title="Setup Options">the section called &#8220;Setup Options&#8221;</a>.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-htmlunit-webdriver" href="#spring-mvc-test-server-htmlunit-webdriver"></a>MockMvc and WebDriver</h4></div></div></div>

<p>In the previous sections, we have seen how to use <code class="literal">MockMvc</code> in conjunction with the raw
HtmlUnit APIs. In this section, we will leverage additional abstractions within the Selenium
<a class="ulink" href="http://docs.seleniumhq.org/projects/webdriver/" target="_top">WebDriver</a> to make things even easier.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-webdriver-why" href="#spring-mvc-test-server-htmlunit-webdriver-why"></a>Why WebDriver and MockMvc?</h5></div></div></div>

<p>We can already use HtmlUnit and <code class="literal">MockMvc</code>, so why would we want to use <code class="literal">WebDriver</code>? The
Selenium <code class="literal">WebDriver</code> provides a very elegant API that allows us to easily organize our code.
To better understand, let&#8217;s explore an example.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>Despite being a part of <a class="ulink" href="http://docs.seleniumhq.org/" target="_top">Selenium</a>, WebDriver does not require
a Selenium Server to run your tests.</p>
</td></tr></table></div>
<p>Suppose we need to ensure that a message is created properly. The tests involve finding
the HTML form input elements, filling them out, and making various assertions.</p>
<p>This approach results in numerous, separate tests because we want to test error
conditions as well. For example, we want to ensure that we get an error if we fill out
only part of the form. If we fill out the entire form, the newly created message should
be displayed afterwards.</p>
<p>If one of the fields were named "summary", then we might have something like the
following repeated in multiple places within our tests.</p>
<pre class="programlisting">HtmlTextInput summaryInput = currentPage.getHtmlElementById(<span class="hl-string">"summary"</span>);
summaryInput.setValueAttribute(summary);</pre>
<p>So what happens if we change the <code class="literal">id</code> to "smmry"? Doing so would force us to update all
of our tests to incorporate this change! Of course, this violates the <span class="emphasis"><em>DRY Principle</em></span>; so
we should ideally extract this code into its own method as follows.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
	setSummary(currentPage, summary);
	<span class="hl-comment">// ...</span>
}

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSummary(HtmlPage currentPage, String summary) {
	HtmlTextInput summaryInput = currentPage.getHtmlElementById(<span class="hl-string">"summary"</span>);
	summaryInput.setValueAttribute(summary);
}</pre>
<p>This ensures that we do not have to update all of our tests if we change the UI.</p>
<p>We might even take this a step further and place this logic within an Object that
represents the <code class="literal">HtmlPage</code> we are currently on.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CreateMessagePage {

	<span class="hl-keyword">final</span> HtmlPage currentPage;

	<span class="hl-keyword">final</span> HtmlTextInput summaryInput;

	<span class="hl-keyword">final</span> HtmlSubmitInput submit;

	<span class="hl-keyword">public</span> CreateMessagePage(HtmlPage currentPage) {
		<span class="hl-keyword">this</span>.currentPage = currentPage;
		<span class="hl-keyword">this</span>.summaryInput = currentPage.getHtmlElementById(<span class="hl-string">"summary"</span>);
		<span class="hl-keyword">this</span>.submit = currentPage.getHtmlElementById(<span class="hl-string">"submit"</span>);
	}

	<span class="hl-keyword">public</span> &lt;T&gt; T createMessage(String summary, String text) <span class="hl-keyword">throws</span> Exception {
		setSummary(summary);

		HtmlPage result = submit.click();
		<span class="hl-keyword">boolean</span> error = CreateMessagePage.at(result);

		<span class="hl-keyword">return</span> (T) (error ? <span class="hl-keyword">new</span> CreateMessagePage(result) : <span class="hl-keyword">new</span> ViewMessagePage(result));
	}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSummary(String summary) <span class="hl-keyword">throws</span> Exception {
		summaryInput.setValueAttribute(summary);
	}

	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">boolean</span> at(HtmlPage page) {
		<span class="hl-keyword">return</span> <span class="hl-string">"Create Message"</span>.equals(page.getTitleText());
	}
}</pre>
<p>Formerly, this pattern is known as the
<a class="ulink" href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects" target="_top">Page Object Pattern</a>. While we can
certainly do this with HtmlUnit, WebDriver provides some tools that we will explore in the
following sections to make this pattern much easier to implement.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-webdriver-setup" href="#spring-mvc-test-server-htmlunit-webdriver-setup"></a>MockMvc and WebDriver Setup</h5></div></div></div>

<p>To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project
includes a test dependency on <code class="literal">org.seleniumhq.selenium:selenium-htmlunit-driver</code>.</p>
<p>We can easily create a Selenium <code class="literal">WebDriver</code> that integrates with <code class="literal">MockMvc</code> using the
<code class="literal">MockMvcHtmlUnitDriverBuilder</code> as follows.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
WebApplicationContext context;

WebDriver driver;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	driver = MockMvcHtmlUnitDriverBuilder
		.webAppContextSetup(context)
		.build();
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This is a simple example of using <code class="literal">MockMvcHtmlUnitDriverBuilder</code>.
For more advanced usage, refer to <a class="xref" href="integration-testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder" title="Advanced MockMvcHtmlUnitDriverBuilder">the section called &#8220;Advanced MockMvcHtmlUnitDriverBuilder&#8221;</a></p>
</td></tr></table></div>
<p>This will ensure that any URL referencing <code class="literal">localhost</code> as the server will be directed to
our <code class="literal">MockMvc</code> instance without the need for a real HTTP connection. Any other URL will be
requested using a network connection as normal. This allows us to easily test the use of
CDNs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-webdriver-usage" href="#spring-mvc-test-server-htmlunit-webdriver-usage"></a>MockMvc and WebDriver Usage</h5></div></div></div>

<p>Now we can use WebDriver as we normally would, but without the need to deploy our
application to a Servlet container. For example, we can request the view to create
a message with the following.</p>
<pre class="programlisting">CreateMessagePage page = CreateMessagePage.to(driver);</pre>
<p>We can then fill out the form and submit it to create a message.</p>
<pre class="programlisting">ViewMessagePage viewMessagePage =
	page.createMessage(ViewMessagePage.<span class="hl-keyword">class</span>, expectedSummary, expectedText);</pre>
<p>This improves on the design of our
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-mah-usage" title="MockMvc and HtmlUnit Usage">HtmlUnit test</a> by leveraging the <span class="emphasis"><em>Page Object
Pattern</em></span>. As we mentioned in <a class="xref" href="integration-testing.html#spring-mvc-test-server-htmlunit-webdriver-why" title="Why WebDriver and MockMvc?">the section called &#8220;Why WebDriver and MockMvc?&#8221;</a>, we can
use the Page Object Pattern with HtmlUnit, but it is much easier with WebDriver. Let&#8217;s
take a look at our new <code class="literal">CreateMessagePage</code> implementation.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CreateMessagePage
		<span class="hl-keyword">extends</span> AbstractPage { <a name="CO1-1" href="#CO1-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

	<a name="CO1-2" href="#CO1-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
	<span class="hl-keyword">private</span> WebElement summary;
	<span class="hl-keyword">private</span> WebElement text;

	<a name="CO1-3" href="#CO1-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
	<em><span class="hl-annotation" style="color: gray">@FindBy(css = "input[type=submit]")</span></em>
	<span class="hl-keyword">private</span> WebElement submit;

	<span class="hl-keyword">public</span> CreateMessagePage(WebDriver driver) {
		<span class="hl-keyword">super</span>(driver);
	}

	<span class="hl-keyword">public</span> &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) {
		<span class="hl-keyword">this</span>.summary.sendKeys(summary);
		<span class="hl-keyword">this</span>.text.sendKeys(details);
		<span class="hl-keyword">this</span>.submit.click();
		<span class="hl-keyword">return</span> PageFactory.initElements(driver, resultPage);
	}

	<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> CreateMessagePage to(WebDriver driver) {
		driver.get(<span class="hl-string">"http://localhost:9990/mail/messages/form"</span>);
		<span class="hl-keyword">return</span> PageFactory.initElements(driver, CreateMessagePage.<span class="hl-keyword">class</span>);
	}
}</pre>
<div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The first thing you will notice is that <code class="literal">CreateMessagePage</code> extends the
<code class="literal">AbstractPage</code>. We won&#8217;t go over the details of <code class="literal">AbstractPage</code>, but in summary it
contains common functionality for all of our pages. For example, if our application has
a navigational bar, global error messages, etc., this logic can be placed in a shared
location.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left">
<p>The next thing you will notice is that we have a member variable for each of the
parts of the HTML page that we are interested in. These are of type <code class="literal">WebElement</code>.
<code class="literal">WebDriver</code>'s <a class="ulink" href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory" target="_top">PageFactory</a> allows
us to remove a lot of code from the HtmlUnit version of <code class="literal">CreateMessagePage</code> by
automatically resolving each <code class="literal">WebElement</code>. The
<a class="ulink" href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-" target="_top">PageFactory#initElements(WebDriver,Class&lt;T&gt;)</a>
method will automatically resolve each <code class="literal">WebElement</code> by using the field name and looking it
up by the <code class="literal">id</code> or <code class="literal">name</code> of the element within the HTML page.</p>
</td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left">
<p>We can use the
<a class="ulink" href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations" target="_top">@FindBy annotation</a>
to override the default lookup behavior. Our example demonstrates how to use the <code class="literal">@FindBy</code>
annotation to look up our submit button using a css selector, <span class="strong"><strong>input[type=submit]</strong></span>.</p>
</td></tr></table></div>
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a class="ulink" href="https://code.google.com/p/fest/" target="_top">FEST assertion library</a>.</p>
<pre class="programlisting">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo(<span class="hl-string">"Successfully created a new message"</span>);</pre>
<p>We can see that our <code class="literal">ViewMessagePage</code> allows us to interact with our custom domain
model. For example, it exposes a method that returns a <code class="literal">Message</code> object.</p>
<pre class="programlisting"><span class="hl-keyword">public</span> Message getMessage() <span class="hl-keyword">throws</span> ParseException {
	Message message = <span class="hl-keyword">new</span> Message();
	message.setId(getId());
	message.setCreated(getCreated());
	message.setSummary(getSummary());
	message.setText(getText());
	<span class="hl-keyword">return</span> message;
}</pre>
<p>We can then leverage the rich domain objects in our assertions.</p>
<p>Lastly, don&#8217;t forget to <span class="emphasis"><em>close</em></span> the <code class="literal">WebDriver</code> instance when the test is complete.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@After</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> destroy() {
	<span class="hl-keyword">if</span> (driver != null) {
		driver.close();
	}
}</pre>
<p>For additional information on using WebDriver, refer to the Selenium
<a class="ulink" href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started" target="_top">WebDriver documentation</a>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-webdriver-advanced-builder" href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder"></a>Advanced MockMvcHtmlUnitDriverBuilder</h5></div></div></div>

<p>In the examples so far, we have used <code class="literal">MockMvcHtmlUnitDriverBuilder</code> in the simplest way
possible, by building a <code class="literal">WebDriver</code> based on the <code class="literal">WebApplicationContext</code> loaded for us by
the Spring TestContext Framework. This approach is repeated here.</p>
<pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
WebApplicationContext context;

WebDriver driver;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	driver = MockMvcHtmlUnitDriverBuilder
		.webAppContextSetup(context)
		.build();
}</pre>
<p>We can also specify additional configuration options.</p>
<pre class="programlisting">WebDriver driver;

<em><span class="hl-annotation" style="color: gray">@Before</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() {
	driver = MockMvcHtmlUnitDriverBuilder
		<span class="hl-comment">// demonstrates applying a MockMvcConfigurer (Spring Security)</span>
		.webAppContextSetup(context, springSecurity())
		<span class="hl-comment">// for illustration only - defaults to ""</span>
		.contextPath(<span class="hl-string">""</span>)
		<span class="hl-comment">// By default MockMvc is used for localhost only;</span>
		<span class="hl-comment">// the following will use MockMvc for example.com and example.org as well</span>
		.useMockMvcForHosts(<span class="hl-string">"example.com"</span>,<span class="hl-string">"example.org"</span>)
		.build();
}</pre>
<p>As an alternative, we can perform the exact same setup by configuring the <code class="literal">MockMvc</code>
instance separately and supplying it to the <code class="literal">MockMvcHtmlUnitDriverBuilder</code> as follows.</p>
<pre class="programlisting">MockMvc mockMvc = MockMvcBuilders
		.webAppContextSetup(context)
		.apply(springSecurity())
		.build();

driver = MockMvcHtmlUnitDriverBuilder
		.mockMvcSetup(mockMvc)
		<span class="hl-comment">// for illustration only - defaults to ""</span>
		.contextPath(<span class="hl-string">""</span>)
		<span class="hl-comment">// By default MockMvc is used for localhost only;</span>
		<span class="hl-comment">// the following will use MockMvc for example.com and example.org as well</span>
		.useMockMvcForHosts(<span class="hl-string">"example.com"</span>,<span class="hl-string">"example.org"</span>)
		.build();</pre>
<p>This is more verbose, but by building the <code class="literal">WebDriver</code> with a <code class="literal">MockMvc</code> instance we have
the full power of <code class="literal">MockMvc</code> at our fingertips.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>For additional information on creating a <code class="literal">MockMvc</code> instance refer to
<a class="xref" href="integration-testing.html#spring-mvc-test-server-setup-options" title="Setup Options">the section called &#8220;Setup Options&#8221;</a>.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-server-htmlunit-geb" href="#spring-mvc-test-server-htmlunit-geb"></a>MockMvc and Geb</h4></div></div></div>

<p>In the previous section, we saw how to use <code class="literal">MockMvc</code> with <code class="literal">WebDriver</code>. In this section,
we will use <a class="ulink" href="http://www.gebish.org/" target="_top">Geb</a> to make our tests even Groovy-er.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-geb-why" href="#spring-mvc-test-server-htmlunit-geb-why"></a>Why Geb and MockMvc?</h5></div></div></div>

<p>Geb is backed by WebDriver, so it offers many of the
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-webdriver-why" title="Why WebDriver and MockMvc?">same benefits</a> that we get from
WebDriver. However, Geb makes things even easier by taking care of some of the
boilerplate code for us.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-geb-setup" href="#spring-mvc-test-server-htmlunit-geb-setup"></a>MockMvc and Geb Setup</h5></div></div></div>

<p>We can easily initialize a Geb <code class="literal">Browser</code> with a Selenium <code class="literal">WebDriver</code> that uses <code class="literal">MockMvc</code>
as follows.</p>
<pre class="programlisting">def setup() {
	browser.driver = MockMvcHtmlUnitDriverBuilder
		.webAppContextSetup(context)
		.build()
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>This is a simple example of using <code class="literal">MockMvcHtmlUnitDriverBuilder</code>.
For more advanced usage, refer to <a class="xref" href="integration-testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder" title="Advanced MockMvcHtmlUnitDriverBuilder">the section called &#8220;Advanced MockMvcHtmlUnitDriverBuilder&#8221;</a></p>
</td></tr></table></div>
<p>This will ensure that any URL referencing <code class="literal">localhost</code> as the server will be directed to
our <code class="literal">MockMvc</code> instance without the need for a real HTTP connection. Any other URL will be
requested using a network connection as normal. This allows us to easily test the use of
CDNs.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="spring-mvc-test-server-htmlunit-geb-usage" href="#spring-mvc-test-server-htmlunit-geb-usage"></a>MockMvc and Geb Usage</h5></div></div></div>

<p>Now we can use Geb as we normally would, but without the need to deploy our
application to a Servlet container. For example, we can request the view to create
a message with the following:</p>
<pre class="programlisting">to CreateMessagePage</pre>
<p>We can then fill out the form and submit it to create a message.</p>
<pre class="programlisting">when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)</pre>
<p>Any unrecognized method calls or property accesses/references that are not found will be
forwarded to the current page object. This removes a lot of the boilerplate code we needed
when using WebDriver directly.</p>
<p>As with direct WebDriver usage, this improves on the design of our
<a class="link" href="integration-testing.html#spring-mvc-test-server-htmlunit-mah-usage" title="MockMvc and HtmlUnit Usage">HtmlUnit test</a> by leveraging the <span class="emphasis"><em>Page Object
Pattern</em></span>. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and
WebDriver, but it is even easier with Geb. Let&#8217;s take a look at our new Groovy-based
<code class="literal">CreateMessagePage</code> implementation.</p>
<pre class="programlisting"><span class="hl-keyword">class</span> CreateMessagePage <span class="hl-keyword">extends</span> Page {
	<span class="hl-keyword">static</span> url = <span class="hl-string">'messages/form'</span>
	<span class="hl-keyword">static</span> at = { assert title == <span class="hl-string">'Messages : Create'</span>; true }
	<span class="hl-keyword">static</span> content =  {
		submit { $(<span class="hl-string">'input[type=submit]'</span>) }
		form { $(<span class="hl-string">'form'</span>) }
		errors(required:false) { $(<span class="hl-string">'label.error, .alert-error'</span>)?.text() }
	}
}</pre>
<p>The first thing you will notice is that our <code class="literal">CreateMessagePage</code> extends <code class="literal">Page</code>. We won&#8217;t
go over the details of <code class="literal">Page</code>, but in summary it contains common functionality for all of
our pages. The next thing you will notice is that we define a URL in which this page can
be found. This allows us to navigate to the page as follows.</p>
<pre class="programlisting">to CreateMessagePage</pre>
<p>We also have an <code class="literal">at</code> closure that determines if we are at the specified page. It should return
<code class="literal">true</code> if we are on the correct page. This is why we can assert that we are on the correct
page as follows.</p>
<pre class="programlisting">then:
at CreateMessagePage
errors.contains(<span class="hl-string">'This field is required.'</span>)</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>We use an assertion in the closure, so that we can determine where things went wrong if
we were at the wrong page.</p>
</td></tr></table></div>
<p>Next we create a <code class="literal">content</code> closure that specifies all the areas of interest within the page.
We can use a
<a class="ulink" href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api" target="_top">jQuery-ish Navigator API</a>
to select the content we are interested in.</p>
<p>Finally, we can verify that a new message was created successfully.</p>
<pre class="programlisting">then:
at ViewMessagePage
success == <span class="hl-string">'Successfully created a new message'</span>
id
date
summary == expectedSummary
message == expectedMessage</pre>
<p>For further details on how to get the most out of Geb, consult
<a class="ulink" href="http://www.gebish.org/manual/current/" target="_top">The Book of Geb</a> user&#8217;s manual.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-mvc-test-client" href="#spring-mvc-test-client"></a>15.6.3&nbsp;Client-Side REST Tests</h3></div></div></div>

<p>Client-side tests can be used to test code that internally uses the <code class="literal">RestTemplate</code>.
The idea is to declare expected requests and to provide "stub" responses so that
you can focus on testing the code in isolation, i.e. without running a server.
Here is an example:</p>
<pre class="programlisting">RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo(<span class="hl-string">"/greeting"</span>)).andRespond(withSuccess());

<span class="hl-comment">// Test code that uses the above RestTemplate ...</span>

mockServer.verify();</pre>
<p>In the above example, <code class="literal">MockRestServiceServer</code>, the central class for client-side REST
tests, configures the <code class="literal">RestTemplate</code> with a custom <code class="literal">ClientHttpRequestFactory</code> that
asserts actual requests against expectations and returns "stub" responses. In this case
we expect a request to "/greeting" and want to return a 200 response with
"text/plain" content. We could define as additional expected requests and stub responses as
needed. When expected requests and stub responses are defined, the <code class="literal">RestTemplate</code> can be
used in client-side code as usual. At the end of testing <code class="literal">mockServer.verify()</code> can be
used to verify that all expectations have been satisfied.</p>
<p>By default requests are expected in the order in which expectations were declared.
You can set the <code class="literal">ignoreExpectOrder</code> option when building the server in which case
all expectations are checked (in order) to find a match for a given request. That
means requests are allowed to come in any order. Here is an example:</p>
<pre class="programlisting">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();</pre>
<p>Even with unordered requests by default each request is allowed to execute once only.
The <code class="literal">expect</code> method provides an overloaded variant that accepts an <code class="literal">ExpectedCount</code>
argument that specifies a count range, e.g. <code class="literal">once</code>, <code class="literal">manyTimes</code>, <code class="literal">max</code>, <code class="literal">min</code>,
<code class="literal">between</code>, and so on. Here is an example:</p>
<pre class="programlisting">RestTemplate restTemplate = <span class="hl-keyword">new</span> RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(<span class="hl-number">2</span>), requestTo(<span class="hl-string">"/foo"</span>)).andRespond(withSuccess());
mockServer.expect(times(<span class="hl-number">3</span>), requestTo(<span class="hl-string">"/bar"</span>)).andRespond(withSuccess());

<span class="hl-comment">// ...</span>

mockServer.verify();</pre>
<p>Note that when <code class="literal">ignoreExpectOrder</code> is not set (the default), and therefore requests
are expected in order of declaration, then that order only applies to the first of
any expected request. For example if "/foo" is expected 2 times followed by "/bar"
3 times, then there should be a request to "/foo" before there is a request to "/bar"
but aside from that subsequent "/foo" and "/bar" requests can come at any time.</p>
<p>As an alternative to all of the above the client-side test support also provides a
<code class="literal">ClientHttpRequestFactory</code> implementation that can be configured into a <code class="literal">RestTemplate</code>
to bind it to a <code class="literal">MockMvc</code> instance. That allows processing requests using actual
server-side logic but without running a server. Here is an example:</p>
<pre class="programlisting">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(<span class="hl-keyword">this</span>.wac).build();
<span class="hl-keyword">this</span>.restTemplate = <span class="hl-keyword">new</span> RestTemplate(<span class="hl-keyword">new</span> MockMvcClientHttpRequestFactory(mockMvc));

<span class="hl-comment">// Test code that uses the above RestTemplate ...</span>

mockServer.verify();</pre>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-client-static-imports" href="#spring-mvc-test-client-static-imports"></a>Static Imports</h4></div></div></div>

<p>Just like with server-side tests, the fluent API for client-side tests requires a few
static imports. Those are easy to find by searching <span class="emphasis"><em>"MockRest*"</em></span>. Eclipse users
should add <code class="literal">"MockRestRequestMatchers.*"</code> and <code class="literal">"MockRestResponseCreators.*"</code>
as "favorite static members" in the Eclipse preferences under
<span class="emphasis"><em>Java &#8594; Editor &#8594; Content Assist &#8594; Favorites</em></span>.
That allows using content assist after typing the first character of the
static method name. Other IDEs (e.g. IntelliJ) may not require any additional
configuration. Just check the support for code completion on static members.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-mvc-test-client-resources" href="#spring-mvc-test-client-resources"></a>Further Examples of Client-side REST Tests</h4></div></div></div>

<p>Spring MVC Test&#8217;s own tests include
<a class="ulink" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples" target="_top">example
tests</a> of client-side REST tests.</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing-examples-petclinic" href="#testing-examples-petclinic"></a>15.7&nbsp;PetClinic Example</h2></div></div></div>

<p>The PetClinic application, available on
<a class="ulink" href="https://github.com/spring-projects/spring-petclinic" target="_top">GitHub</a>, illustrates several features
of the <span class="emphasis"><em>Spring TestContext Framework</em></span> in a JUnit 4 environment. Most test functionality
is included in the <code class="literal">AbstractClinicTests</code>, for which a partial listing is shown below:</p>
<pre class="programlisting"><span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertEquals;
<span class="hl-comment">// import ...</span>

<span class="strong"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> AbstractClinicTests <span class="strong"><strong>extends AbstractTransactionalJUnit4SpringContextTests</strong></span> {

    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">protected</span> Clinic clinic;

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getVets() {
        Collection&lt;Vet&gt; vets = <span class="hl-keyword">this</span>.clinic.getVets();
        assertEquals(<span class="hl-string">"JDBC query must show the same number of vets"</span>,
            <span class="strong"><strong>super.countRowsInTable("VETS")</strong></span>, vets.size());
        Vet v1 = EntityUtils.getById(vets, Vet.<span class="hl-keyword">class</span>, <span class="hl-number">2</span>);
        assertEquals(<span class="hl-string">"Leary"</span>, v1.getLastName());
        assertEquals(<span class="hl-number">1</span>, v1.getNrOfSpecialties());
        assertEquals(<span class="hl-string">"radiology"</span>, (v1.getSpecialties().get(<span class="hl-number">0</span>)).getName());
        <span class="hl-comment">// ...</span>
    }

    <span class="hl-comment">// ...</span>
}</pre>
<p>Notes:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
This test case extends the <code class="literal">AbstractTransactionalJUnit4SpringContextTests</code> class, from
which it inherits configuration for Dependency Injection (through the
<code class="literal">DependencyInjectionTestExecutionListener</code>) and transactional behavior (through the
<code class="literal">TransactionalTestExecutionListener</code>).
</li><li class="listitem">
The <code class="literal">clinic</code> instance variable&#8201;&#8212;&#8201;the application object being tested&#8201;&#8212;&#8201;is set by
Dependency Injection through <code class="literal">@Autowired</code> semantics.
</li><li class="listitem">
The <code class="literal">getVets()</code> method illustrates how you can use the inherited <code class="literal">countRowsInTable()</code>
method to easily verify the number of rows in a given table, thus verifying correct
behavior of the application code being tested. This allows for stronger tests and
lessens dependency on the exact test data. For example, you can add additional rows in
the database without breaking tests.
</li><li class="listitem">
Like many integration tests that use a database, most of the tests in
<code class="literal">AbstractClinicTests</code> depend on a minimum amount of data already in the database before
the test cases run. Alternatively, you might choose to populate the database within the
test fixture set up of your test cases&#8201;&#8212;&#8201;again, within the same transaction as the
tests.
</li></ul></div>
<p>The PetClinic application supports three data access technologies: JDBC, Hibernate, and
JPA. By declaring <code class="literal">@ContextConfiguration</code> without any specific resource locations, the
<code class="literal">AbstractClinicTests</code> class will have its application context loaded from the default
location, <code class="literal">AbstractClinicTests-context.xml</code>, which declares a common <code class="literal">DataSource</code>.
Subclasses specify additional context locations that must declare a
<code class="literal">PlatformTransactionManager</code> and a concrete implementation of <code class="literal">Clinic</code>.</p>
<p>For example, the Hibernate implementation of the PetClinic tests contains the following
implementation. For this example, <code class="literal">HibernateClinicTests</code> does not contain a single line
of code: we only need to declare <code class="literal">@ContextConfiguration</code>, and the tests are inherited
from <code class="literal">AbstractClinicTests</code>. Because <code class="literal">@ContextConfiguration</code> is declared without any
specific resource locations, the <span class="emphasis"><em>Spring TestContext Framework</em></span> loads an application
context from all the beans defined in <code class="literal">AbstractClinicTests-context.xml</code> (i.e., the
inherited locations) and <code class="literal">HibernateClinicTests-context.xml</code>, with
<code class="literal">HibernateClinicTests-context.xml</code> possibly overriding beans defined in
<code class="literal">AbstractClinicTests-context.xml</code>.</p>
<pre class="programlisting"><span class="strong"><strong>@ContextConfiguration</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateClinicTests <span class="hl-keyword">extends</span> AbstractClinicTests { }</pre>
<p>In a large-scale application, the Spring configuration is often split across multiple
files. Consequently, configuration locations are typically specified in a common base
class for all application-specific integration tests. Such a base class may also add
useful instance variables&#8201;&#8212;&#8201;populated by Dependency Injection, naturally&#8201;&#8212;&#8201;such as a
<code class="literal">SessionFactory</code> in the case of an application using Hibernate.</p>
<p>As far as possible, you should have exactly the same Spring configuration files in your
integration tests as in the deployed environment. One likely point of difference
concerns database connection pooling and transaction infrastructure. If you are
deploying to a full-blown application server, you will probably use its connection pool
(available through JNDI) and JTA implementation. Thus in production you will use a
<code class="literal">JndiObjectFactoryBean</code> or <code class="literal">&lt;jee:jndi-lookup&gt;</code> for the <code class="literal">DataSource</code> and
<code class="literal">JtaTransactionManager</code>. JNDI and JTA will not be available in out-of-container
integration tests, so you should use a combination like the Commons DBCP
<code class="literal">BasicDataSource</code> and <code class="literal">DataSourceTransactionManager</code> or <code class="literal">HibernateTransactionManager</code>
for them. You can factor out this variant behavior into a single XML file, having the
choice between application server and a 'local' configuration separated from all other
configuration, which will not vary between the test and production environments. In
addition, it is advisable to use properties files for connection settings. See the
PetClinic application for an example.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="unit-testing.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="testing.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="testing-resources.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.&nbsp;Unit Testing&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;16.&nbsp;Further Resources</td></tr></table></div></body></html>