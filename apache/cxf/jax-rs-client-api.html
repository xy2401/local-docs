
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Client API">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- JAX-RS Client API
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="restful-services.html">RESTful Services</a>&nbsp;&gt;&nbsp;<a href="jax-rs.html">JAX-RS</a>&nbsp;&gt;&nbsp;<a href="jax-rs-client-api.html">JAX-RS Client API</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p>&#160;<span style="font-size:2em;font-weight:bold">JAX-RS : Client API</span>


&#160;</p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1552503433924 {padding: 0px;}
div.rbtoc1552503433924 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1552503433924 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1552503433924">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-MavenDependency">Maven Dependency</a></li><li><a shape="rect" href="#JAX-RSClientAPI-JAX-RS2.0ClientAPI">JAX-RS 2.0 Client API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-JAX-RS2.0andCXFspecificAPI">JAX-RS 2.0 and CXF specific API</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-Proxy-basedAPI">Proxy-based API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-Customizingproxies">Customizing proxies</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConvertingproxiestoWebClientsandviceversa">Converting proxies to Web Clients and vice versa</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Handlingexceptions">Handling exceptions</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringproxiesinSpring">Configuring proxies in Spring</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Injectingproxies">Injecting proxies</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Asynchronousproxyinvocations">Asynchronous proxy invocations</a></li><li><a shape="rect" href="#JAX-RSClientAPI-BufferingResponses">Buffering Responses</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Limitations">Limitations</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Workingwithusermodels">Working with user models</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-CXFWebClientAPI">CXF WebClient API</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSClientAPI-Asynchronousinvocations">Asynchronous invocations</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Workingwithexplicitcollections">Working with explicit collections</a></li><li><a shape="rect" href="#JAX-RSClientAPI-Handlingexceptions.1">Handling exceptions</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringHTTPclientsinSpring">Configuring HTTP clients in Spring</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSClientAPI-XML-centricclients">XML-centric clients</a></li><li><a shape="rect" href="#JAX-RSClientAPI-SupportforarbitraryHTTPmethodsforsyncinvocations.">Support for arbitrary HTTP methods for sync invocations.</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ThreadSafety">Thread Safety</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringClientsatRuntime">Configuring Clients at Runtime</a></li><li><a shape="rect" href="#JAX-RSClientAPI-CreatingclientsprogrammaticallywithnoSpringdependencies">Creating clients programmatically with no Spring dependencies</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ConfiguringanHTTPConduitfromSpring">Configuring an HTTP Conduit from Spring</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ClientsandAuthentication">Clients and Authentication</a></li><li><a shape="rect" href="#JAX-RSClientAPI-ClientsinSpringBoot">Clients in Spring Boot</a></li></ul>
</div><h1 id="JAX-RSClientAPI-MavenDependency">Maven Dependency</h1><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;
  &lt;version&gt;3.0.15&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><p>In CXF 2.7.x no JAX-RS 2.0 Client API is supported and CXF specific Client API is located in the cxf-rt-frontend-jaxrs module.</p><p>CXF Apache HttpClient based transport is required to get the asynchronous invocations working correctly:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
  &lt;artifactId&gt;cxf-rt-transports-http-hc&lt;/artifactId&gt;
  &lt;!-- 2.7.8 or 3.0.15 --&gt; 
  &lt;version&gt;${cxf.version}&lt;/version&gt;
&lt;/dependency&gt;
</pre>
</div></div><h1 id="JAX-RSClientAPI-JAX-RS2.0ClientAPI">JAX-RS 2.0 Client API</h1><p>CXF 3.0.0 implements JAX-RS 2.0 Client API. Internally it is implemented in terms of CXF specific WebClient.</p><p>The <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/index.html" rel="nofollow">javax.ws.rs.client</a> provides a short overview of how JAX-RS 2.0 Client API works.</p><p>Typically, one starts from <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/ClientBuilder.html" rel="nofollow">ClientBuilder</a> in order to create a <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Client.html" rel="nofollow">Client</a>. <br clear="none"> Next <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/WebTarget.html" rel="nofollow">WebTarget</a> is created and further customized as needed.</p><p>Next, <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.Builder.html" rel="nofollow">Invocation.Builder</a> is initialized and the request can be made immediately using one of the <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/SyncInvoker.html" rel="nofollow">SyncInvoker</a> methods, with the builder directly implementing SyncInvoker.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Client client = ClientBuilder.newBuilder().newClient();
WebTarget target = client.target("http://localhost:8080/rs");
target = target.path("service").queryParam("a", "avalue");

Invocation.Builder builder = target.request();
Response response = builder.get();
Book book = builder.get(Book.class);

</pre>
</div></div><p>The above sequence can be easily collapsed into a single code sequence if preferred.<br clear="none"> Note that SyncInvoker (and AsyncInvoker) expects <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Entity.html" rel="nofollow">Entity</a> to represent the request body.</p><p>Invocation.Builder has a shortcut to <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.html" rel="nofollow">Invocation</a> via its build(...) methods to further customize the invocation.</p><p>Invocation.Builder.async() links to AsyncInvoker.</p><p>Client and WebTarget are all can be individually configured, the implement <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/Configurable.html" rel="nofollow">Configurable</a> interface which can accept the providers and properties and return <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/core/Configuration.html" rel="nofollow">Configuration</a>. Configuring the Client directly or indirectly via ClientBuilder.withConfig method affects all the WebClients spawned by a given Client.</p><h2 id="JAX-RSClientAPI-JAX-RS2.0andCXFspecificAPI">JAX-RS 2.0 and CXF specific API</h2><p>CXF proxy and WebClient client code has been retrofitted to support JAX-RS 2.0 client filters, reader and writer interceptors, new exception classes and Response API.</p><p>WebClient offers shortcuts to JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/AsyncInvoker.html" rel="nofollow">AsyncInvoker</a> and <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/SyncInvoker.html" rel="nofollow">SyncInvoker</a> interfaces.</p><p>WebClient.getConfig(Object client) supports JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/WebTarget.html" rel="nofollow">WebTarget</a> and <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0-rev-a/apidocs/javax/ws/rs/client/Invocation.Builder.html" rel="nofollow">Invocation.Builder</a> for 2.0 clients to be able to get to the lower-level CXF configuration and set up the properties such as 'receiveTimeout', etc.</p><h1 id="JAX-RSClientAPI-Proxy-basedAPI">Proxy-based API</h1><p>With the proxy-based API, one can reuse on the client side the interfaces or even the resource classes which have already been designed for processing the HTTP requests on the server side (note that a <a shape="rect" class="external-link" href="http://cglib.sourceforge.net/" rel="nofollow">cglib</a>-nodeps dependency will need to be available on the classpath for proxies created from concrete classes). When reused on the client side, they simply act as remote proxies.</p><p><a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactory.java">JAXRSClientFactory</a> is a utility class which wraps <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java">JAXRSClientFactoryBean</a>. JAXRSClientFactory offers a number of utility methods but JAXRSClientFactoryBean can also be used directly if desired.</p><p>For example, given these class definitions:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Path("/bookstore")
public interface BookStore {
   @GET
   Books getAllBooks();
   
   @Path("{id}")
   BookResource getBookSubresource(@PathParam("id") long id) throws NoBookFoundException;
}

public class BookStoreImpl implements BookStore {
   public Books getAllBooks() {}
   
   public BookResource getBookSubresource(long id) throws NoBookFoundException {}
}

public interface BookResource {
   @GET
   Book getBook();
}

public class BookResourceImpl implements BookResource {
   Book getBook() {}
}

</pre>
</div></div><p>the following client code retrieves a Book with id '1' and a collection of books:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore store = JAXRSClientFactory.create("http://bookstore.com", BookStore.class);
// (1) remote GET call to http://bookstore.com/bookstore
Books books = store.getAllBooks();
// (2) no remote call
BookResource subresource = store.getBookSubresource(1);
// {3} remote GET call to http://bookstore.com/bookstore/1
Book b = subresource.getBook();
</pre>
</div></div><p>When proxies are created, initially or when subresource methods are invoked, the current URI is updated with corresponding @Path, @PathParam, @QueryParam or @MatrixParam values, while @HttpHeader and @CookieParam values contribute to the current set of HTTP headers. Same happens before the remote invocation is done.</p><p>It is important to understand that strictly speaking there is no direct relationship between a given method on the client side and the same one on the server side. The job of the proxy is to construct a correct URI according to given class and method specifications - it may or may not be the same method on the corresponding server class that will be invoked (provided of course that it is a JAX-RS annotated server resource class - but that may not be the case!) More often than not, you will see a method foo() invoked on a server resource class whenever the same method is invoked on the corresponding remote proxy - but in the presence of @Path annotations with arbitrary regular expressions this is not guaranteed, however this doesn't matter, as the most important thing is that a proxy will produce a correct URI and it will be matched as <strong>expected</strong> by a server class.</p><p>Client-side MessageBodyReaders and MessageBodyWriters are used to process request or response bodies just as they do on the server side. More specifically, method body writers are invoked whenever a remote method parameter is assumed to be a request body (that is, it has no JAX-RS annotations attached) or when a form submission is emulated with the help of either @FormParams or the JAX-RS MultivaluedMap.</p><p>You can make multiple remote invocations on the same proxy (initial or subresource), the current URI and headers will be updated properly for each call.</p><p>If you would like to proxify concrete classes such as BookStoreImpl for example (say you can not extract interfaces), then drop the cglib-nodeps.jar on a classpath. Such classes must have a default constructor. All methods which have nothing to do with JAX-RS will simply be ignored on the client side and marked as unsupported.</p><h2 id="JAX-RSClientAPI-Customizingproxies">Customizing proxies</h2><p>Proxies end up implementing not only the interface requested at proxy creation time but also a <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/Client.java">Client</a> interface. In many cases one does not need to explicitly specify commonly used HTTP headers such as Content-Type or Accept as this information will likely be available from @Consumes or @Produces annotations. At the same time you may explicitly set either of these headers, or indeed some other header. You can use a simple <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java">WebClient</a> utility method for converting a proxy to a base client:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
WebClient.client(proxy).accept("text/xml");
// continue using the proxy    
</pre>
</div></div><p>You can also check a current set of headers, current and base URIs and a client Response.</p><h2 id="JAX-RSClientAPI-ConvertingproxiestoWebClientsandviceversa">Converting proxies to Web Clients and vice versa</h2><p>Using proxies is just one way to consume a service. Proxies hide away the details of how URIs are being composed while HTTP-centric WebClients provide for an explicit URI creation. Both proxies and http clients rely on the same base information such as headers and the current URI so at any moment of time you can create a WebClient instance out of the existing proxy:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
Client client = WebClient.client(proxy);
WebClient httpClient = WebClient.fromClient(client);
// continue using the http client    
</pre>
</div></div><p>At any moment of time you can convert an http client into a proxy too:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy1 = JAXRSClientFactory.create("http://books", BookStore.class);
Client client = WebClient.client(proxy1);
BookStore proxy2 = JAXRSClientFactory.fromClient(client, BookStore.class);
</pre>
</div></div><h2 id="JAX-RSClientAPI-Handlingexceptions">Handling exceptions</h2><p>There are a couple of ways you can handle remote exceptions with proxies.<br clear="none"> One approach is to register a <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/ResponseExceptionMapper.java">ResponseExceptionMapper</a> as a provider either from Spring using a jaxrs:client or using a corresponding JAXRSClientFactory utility method. This way you can map remote error codes to expected checked exceptions or runtime exceptions if needed.</p><p>If no ResponseExceptionMapper is available when a remote invocation failed then an instance of javax.ws.rs.WebApplicationException will be thrown (Note org.apache.cxf.jaxrs.client.ServerWebApplicationException is used to represent the server exceptions before CXF 2.7.0.). At this point of time you can check the actual Response and proceed from there:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
try {
    proxy.getBook();
} catch(WebApplicationException ex) {
  Response r = ex.getResponse();
  String message = ex.getMessage();
}
</pre>
</div></div><p>javax.ws.rs.ProcessingException will be thrown if the exception has occurred for one of two reasons:</p><ul class="alternate"><li>the remote invocation succeeded but no proper MessageBodyReader has been found on the client side; in this case the Response object representing the result of the invocation will still be available</li><li>the remote invocation has failed for whatever reasons on the client side, example, no MessageBodyWriter is available.</li></ul><p>Note org.apache.cxf.jaxrs.client.ClientWebApplicationException is used to represent the client processing exceptions before CXF 2.7.0.</p><h2 id="JAX-RSClientAPI-ConfiguringproxiesinSpring">Configuring proxies in Spring</h2><p>When creating a proxy with JAXRSClientFactory, you can pass a Spring configuration location as one of the arguments. Or you can create a default bus using Spring configuration and all proxies will pick it up:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">SpringBusFactory bf = new SpringBusFactory();
Bus bus = bf.createBus("org/apache/cxf/systest/jaxrs/security/jaxrs-https.xml");
BusFactory.setDefaultBus(bus);
// BookStore proxy will get the configuration from Spring
BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);
</pre>
</div></div><h2 id="JAX-RSClientAPI-Injectingproxies">Injecting proxies</h2><p>For injecting proxies via a spring context, use the jaxrs:client element like:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:client id="restClient"
    address="http://localhost:${testutil.ports.BookServerRestSoap}/test/services/rest"
    serviceClass="org.apache.cxf.systest.jaxrs.BookStoreJaxrsJaxws"
    inheritHeaders="true"&gt;
    &lt;jaxrs:headers&gt;
        &lt;entry key="Accept" value="text/xml"/&gt;
    &lt;/jaxrs:headers&gt;
&lt;/jaxrs:client&gt;  
</pre>
</div></div><p>See this <a shape="rect" class="external-link" href="https://github.com/apache/cxf/blob/master/systests/jaxrs/src/test/resources/jaxrs_soap_rest/WEB-INF/beans.xml" rel="nofollow">bean</a> for a full example of how jaxrs:client can be used to inject a proxy. Note that WebClient can also be injected as a jaxrs:client.</p><p>&#160;</p><h2 id="JAX-RSClientAPI-Asynchronousproxyinvocations">Asynchronous proxy invocations</h2><p>Starting from CXF 3.1.7 it is possible to do the asynchronous proxy invocations. One needs to register&#160;JAX-RS 2.0&#160;<a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html" rel="nofollow">InvocationCallback</a>&#160;as a proxy request context property:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);

Book book = null;
final InvocationCallback&lt;Book&gt; callback = new InvocationCallback&lt;Book&gt;() {
  public void completed(Book response) {
     book = response;
  }
  public void failed(Throwable error) {
  }
};


WebClient.getConfig(proxy).getRequestContext().put(InvocationCallback.class.getName(), callback);
assertNull(proxy.getBook());
Thread.sleep(3);
assertNotNull(book);</pre>
</div></div><p>If you have a proxy with different methods returning different response types then either register an Object bound InvocationCallback or register a collection of type-specific callbacks:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class);

// Book
Book book = null;
final InvocationCallback&lt;Book&gt; bookCallback = new InvocationCallback&lt;Book&gt;() {
  public void completed(Book response) {
     book = response;
  }
  public void failed(Throwable error) {
  }
};
// Chapter
Chapter chapter = null;
final InvocationCallback&lt;Chapter&gt; chapterCallback = new InvocationCallback&lt;Chapter&gt;() {
  public void completed(Chapter response) {
     chapter = response;
  }
  public void failed(Throwable error) {
  }
};
&#160;
WebClient.getConfig(proxy).getRequestContext().put(InvocationCallback.class.getName(),&#160;
                                                   Arrays.asList(bookCallback, chapterCallback));
// Get Book
assertNull(proxy.getBook(123L));
Thread.sleep(3);
assertNotNull(book);
&#160;
// Get Book Chapter
assertNull(proxy.getBookChapter(123L));
Thread.sleep(3);
assertNotNull(chapter);</pre>
</div></div><p>Make sure a proxy is created in a thread safe mode if it is being accessed by multiple threads for every new request thread to have its own callback.</p><h2 id="JAX-RSClientAPI-BufferingResponses">Buffering Responses</h2><p>One way to buffer proxy responses is to have a proxy method return JAX-RS Response, use its bufferEntity()&#160; method (available in JAX-RS 2.0) and use Response.readEntity which can return typed responses if preferred.</p><p>The other option is to have a "buffer.proxy.response" property enabled on a given proxy instance.</p><h2 id="JAX-RSClientAPI-Limitations">Limitations</h2><p>Proxy sub-resource methods returning Objects can not be invoked. Prefer to have sub-resource methods returning typed classes: interfaces, abstract classes or concrete implementations.</p><p>&#160;</p><h2 id="JAX-RSClientAPI-Workingwithusermodels">Working with user models</h2><p>Proxies can be created with the external user model being applied to a proxy class, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactory.createFromModel("http://books", BookNoAnnotations.class, "classpath:/resources/model.xml", null);
</pre>
</div></div><p>BookNoAnnotations is either an interface or concrete class with no JAX-RS annotations. Both client proxies and server endpoints can 'turn' it into a RESTful resource by applying an external user model.</p><h1 id="JAX-RSClientAPI-CXFWebClientAPI">CXF WebClient API</h1><p>HTTP centric clients are <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/WebClient.java">WebClient</a> instances which also implement the <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/Client.java">Client</a> interface. In addition to setting various Client request properties, you can also make an explicit HTTP invocation with an HTTP verb being the name of a given operation :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
Book book = client.path("bookstore/books").accept("text/xml").get(Book.class);
</pre>
</div></div><p>You can choose to get an explicit JAX-RS Response instead and check the response code, headers or entity body if any:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
client.path("bookstore/books");
client.type("text/xml").accept("text/xml")
Response r = client.post(new Book());
Book b = r.readEntity(Book.class);
</pre>
</div></div><p>WebClient lets you get back to a base URI or to a previous path segment and move forward, it can be handy for getting a number of individual entries from a service with ids embedded in path segments :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient client = WebClient.create("http://books");
List&lt;Book&gt; books = getBooks(client, 1L, 2L, 3L)

private List&lt;Book&gt; getBooks(WebClient client, Long ...ids) {
   List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); 
   for (Long id : ids) {
       books.add(client.path(id).get(Book.class));
       client.back(); 
   } 
   return books;
}
</pre>
</div></div><p>The above code will send requests like "GET <span class="nolink">http://books/1</span>", "GET <span class="nolink">http://books/2</span>", etc.</p><p>If the request URI can be parameterized then you may want to use the following code:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Book book = WebClient.create("http://books").path("{year}/{id}", 2010, 123).get(Book.class);
// as opposed to
// WebClient.create("http://books").path(2010).path(123).get(Book.class);
</pre>
</div></div><p>When reusing the same WebClient instance for multiple invocations, one may want to reset its state with the help of the reset() method, for example, when the Accept header value needs to be changed and the current URI needs to be reset to the baseURI (as an alternative to a back(true) call). The resetQuery() method may be used to reset the query values only. Both options are available for proxies too.</p><p><span class="confluence-anchor-link" id="JAX-RSClientAPI-asynchronousinvocations"></span></p><h2 id="JAX-RSClientAPI-Asynchronousinvocations">Asynchronous invocations</h2><p>WebClient has several methods accepting JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html" rel="nofollow">InvocationCallback</a> and returning Future. Alternatively, users can also use WebClient.async() shortcut to work with a standard <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/AsyncInvoker.html" rel="nofollow">AsyncInvoker</a>.</p><h2 id="JAX-RSClientAPI-Workingwithexplicitcollections">Working with explicit collections</h2><p>WebClient supports <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/GenericEntity.html" rel="nofollow">GenericEntity</a> and JAX-RS 2.0 <a shape="rect" class="external-link" href="https://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/GenericType.html" rel="nofollow">GenericType</a> directly and via JAX-RS 2.0 SyncInvoker and AsyncInvoker to make it easier to work with the explicit collections.</p><p>WebClient also has few collection-aware methods, example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Collection&lt;? extends Book&gt; books = WebClient.getCollection(Book.class);
Collection&lt;? extends Book&gt; books = WebClient.postAndGetCollection(new ArrayList&lt;Book&gt;(), Book.class);

</pre>
</div></div><h2 id="JAX-RSClientAPI-Handlingexceptions.1">Handling exceptions</h2><p>You can handle remote exceptions by either explicitly getting a Response object as shown above and handling error statuses as needed or you can catch either javax.ws.rs.WebApplicationException or javax.ws.rs.ProcessingException exceptions, the same way it can be done with proxies.</p><h2 id="JAX-RSClientAPI-ConfiguringHTTPclientsinSpring">Configuring HTTP clients in Spring</h2><p>Like proxies, HTTP clients can be created using a number of WebClient static utility methods: you can pass a location to a Spring configuration bean if needed or you can set up a default bus as shown above. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;bean id="myJsonProvider" class="org.apache.cxf.jaxrs.provider.JSONProvider" &gt; 
    &lt;property name="supportUnwrapped" value="true" /&gt; 
    &lt;property name="wrapperName" value="nodeName" /&gt; 
&lt;/bean&gt; 

&lt;util:list id="webClientProviders"&gt; 
    &lt;ref bean="myJsonProvider"/&gt; 
&lt;/util:list&gt; 

&lt;bean id="myWebClient" class="org.apache.cxf.jaxrs.client.WebClient" factory-method="create"&gt; 
    &lt;constructor-arg type="java.lang.String" value="http://some.base.url.that.responds/" /&gt; 
    &lt;constructor-arg ref="webClientProviders" /&gt; 
&lt;/bean&gt; 
</pre>
</div></div><p>Note, starting from CXF 2.7.5 it is possible to set-up WebClient instances the same way as proxies, using jaxrs:client:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;jaxrs:client id="webClient"
    address="https://localhost:${port}/services/rest"
    serviceClass="org.apache.cxf.jaxrs.client.WebClient"&gt;
    &lt;jaxrs:headers&gt;
        &lt;entry key="Accept" value="text/xml"/&gt;
    &lt;/jaxrs:headers&gt;
&lt;/jaxrs:client&gt;
</pre>
</div></div><p>The only limitation of using this option is that some of jaxrs:client attributes ("inheritHeaders", "modelRef") and elements ("model") are not really applicable to WebClient.</p><h1 id="JAX-RSClientAPI-XML-centricclients">XML-centric clients</h1><p>XML-centric clients are WebClients using an <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLSource.java">XMLSource</a> utility class. XMLSource has a number of methods facilitating the retrieval of JAXB beans, individual properties or links with the help of XPath expressions. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">WebClient wc = WebClient.create("http://aggregated/data");
XMLSource source = wc.get(XMLSource.class);
source.setBuffering(true);
Book b1 = source.getNode("/books/book[position() = 1]", Book.class);
Book b2 = source.getNode("/books/book[position() = 2]", Book.class);
</pre>
</div></div><p>Note that an XMLSource instance can be set to buffer the input stream thus allowing for executing multiple XPath queries.<br clear="none"> XMlSource can also help with getting the URIs representing the links or XML instances as Strings.</p><h1 id="JAX-RSClientAPI-SupportforarbitraryHTTPmethodsforsyncinvocations.">Support for arbitrary HTTP methods for sync invocations.</h1><p>To get the arbitrary HTTP methods supported with the synchronous client calls or bypass some known Java HTTPUrlConnection issues (example it will block empty DELETE requests) add the HttpClient-based transport dependency and set a "use.async.http.conduit" contextual property.</p><p>This will work as is for asynchronous calls given that the HttpClient-based transport is required.</p><h1 id="JAX-RSClientAPI-ThreadSafety">Thread Safety</h1><p>Proxies and web clients (clients) are not thread safe by default. In some cases this can be a limitation, especially when clients are injected; synchronizing on them can cause performance side effects.</p><p>One way to 'make' clients thread-safe is to use WebClient.fromClient(Client) for web clients or JAXRSClientFactoryBean.fromClient() factory methods which copy all the original configuration properties and can be used to create new client instances per every request.</p><p>A single client doing multiple invocations without changing the current URI or headers is thread-safe (while creating a Invocation.Builder instances concurrently is not&#160;thread-safe since the shared instance of non-thread-safe class ClientProviderFactory is used under the hood). The only limitation in this case applies to proxies, in that they can not get "out of band" headers without synchronizing, ex :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// get some response headers passed to us 'out of band', which is not thread-safe for a plain proxy: 
String bookHeader = WebClient.client(injectedBookStoreProxy).getHeaders().getFirst("BookHeader"); 
</pre>
</div></div><p>Final option is to use a 'threadSafe' boolean property when creating proxies or web clients (either from Spring or programmatically), see this <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/JAXRSMultithreadedClientTest.java">test</a> for more details. Thread-safe clients created this way keep their state in a thread-local storage.</p><p>If a number of incoming threads is limited then one option is just do nothing, while the other option is to reset the thread local state :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">try { 
   webClient.path("bar") 
   webClient.header("bar", baz); 
   webClient.invoke(...); 
} finally { 
   // if using a proxy: WebClient.client(proxy).reset(); 
   webClient.reset(); 
} 
</pre>
</div></div><p>Yet another option is to use JAXRSClientFactoryBean and a 'secondsToKeepState' property for creating thread-safe clients - this will instruct clients to clean-up the thread-local state periodically.</p><h1 id="JAX-RSClientAPI-ConfiguringClientsatRuntime">Configuring Clients at Runtime</h1><p>Proxy and http-centric clients are typically created by JAXRSClientFactory or WebClient factory methods but <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/client/JAXRSClientFactoryBean.java">JAXRSClientFactoryBean</a> can also be used for pre-configuring clients before they are created.</p><p>Sometimes, you may want to configure a client instance after it is been created. For example, one may want to configure HTTPConduit programmatically, as opposed to setting its properties using Spring. ClientConfiguration represents a client-specific configuration state and can be accessed like this :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">Book proxy = JAXRSClientFactory.create("http://books", Book.class);
ClientConfiguration config = WebClient.getConfig(proxy);
HTTPConduit conduit1 = (HTTPConduit)config.getConduit();

WebClient webclient = WebClient.create("http://books");
HTTPConduit conduit2 = (HTTPConduit)WebClient.getConfig(webclient).getConduit();
</pre>
</div></div><p>When working with JAX-RS 2.0 Client API one can set some low-level HTTP properties via Configurable interface:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">//http.connection.timeout
//http.receive.timeout
//http.proxy.server.uri
//http.proxy.server.port
Client client = ClientBuilder.newClient();
client.property("http.receive.timeout", 1000000);&#160;</pre>
</div></div><h1 id="JAX-RSClientAPI-CreatingclientsprogrammaticallywithnoSpringdependencies">Creating clients programmatically with no Spring dependencies</h1><p>Example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">JAXRSClientFactoryBean sf = new JAXRSClientFactoryBean();
sf.setResourceClass(CustomerService.class);
sf.setAddress("http://localhost:9000/");
BindingFactoryManager manager = sf.getBus().getExtension(BindingFactoryManager.class);
JAXRSBindingFactory factory = new JAXRSBindingFactory();
factory.setBus(sf.getBus());
manager.registerBindingFactory(JAXRSBindingFactory.JAXRS_BINDING_ID, factory);
CustomerService service = sf.create(CustomerService.class);
WebClient wc = sf.createWebClient();
</pre>
</div></div><h1 id="JAX-RSClientAPI-ConfiguringanHTTPConduitfromSpring">Configuring an HTTP Conduit from Spring</h1><p>There's a number of ways to configure HTTPConduits for proxies and WebClients.</p><p>It is possible to have an HTTPConduit configuration which will apply to all clients using different request URIs or only to those with using a specific URI. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="http://books:9095/bookstore.*"/&gt; 
</pre>
</div></div><p>This configuration will affect all proxies and WebClients which have requestURIs starting from 'http://books:9095/bookstore'. Note the trailing '.*' suffix in the name of the http:conduit element.</p><p>Please see <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-url.xml">this configuration file</a> for more examples.</p><p>Alternatively you can just do:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="*.http-conduit"/&gt; 
</pre>
</div></div><p>This configuration will affect all the clients, irrespective of the URIs being dealt with.</p><p>If you work with proxies then you can have the proxy-specific configuration using the expanded QName notation:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="{http://foo.bar}BookService.http-conduit"/&gt; 
</pre>
</div></div><p>In this example, 'foo.bar' is a reverse package name of the BookService proxy class.</p><p>Similarly, for WebClients you can do:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;http:conduit name="{http://localhost:8080}WebClient.http-conduit"/&gt; 
</pre>
</div></div><p>In this example, 'http://localhost:8080' is the base service URI.</p><p>Please see <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-client1.xml">jaxrs-https-client1.xml</a> and <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/systests/jaxrs/src/test/java/org/apache/cxf/systest/jaxrs/security/jaxrs-https-client2.xml">jaxrs-https-client2.xml</a> configuration files for more examples.</p><p>Also see <a shape="rect" href="client-http-transport-including-ssl-support.html">this wiki page</a> on how to configure HTTPConduits.</p><h1 id="JAX-RSClientAPI-ClientsandAuthentication">Clients and Authentication</h1><p>Proxies and HTTP-centric clients can have the HTTP Authorization header set up explicitly:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">// Replace 'user' and 'password' by the actual values
String authorizationHeader = "Basic " 
    + org.apache.cxf.common.util.Base64Utility.encode("user:password".getBytes());

// proxies
WebClient.client(proxy).header("Authorization", authorizationHeader);

// web clients
webClient.header("Authorization", authorizationHeader);

</pre>
</div></div><p>or by providing a username and password pair at client creation time, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">BookStore proxy = JAXRSClientFactory.create("http://books", BookStore.class, "username", "password", "classpath:/config/https.xml");

WebClient client = WebClient.create("http://books", "username", "password", "classpath:/config/https.xml");
</pre>
</div></div><p>When injecting clients from Spring, one can add 'username' and 'password' values as attributes to jaxrs:client elements or add them to WebClient factory create methods.</p><h1 id="JAX-RSClientAPI-ClientsinSpringBoot">Clients in Spring Boot</h1><p>Please see&#160;<a shape="rect" href="jaxrsclientspringboot.html">JAXRSClientSpringBoot</a> documentation on how CXF <span class="confluence-link">JAX-RS Clients</span> can be used in a SpringBoot Application.</p><p>&#160;</p><p>&#160;</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190809">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190809&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

