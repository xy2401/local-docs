
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - JAX-RS Advanced XML">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- JAX-RS Advanced XML
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="restful-services.html">RESTful Services</a>&nbsp;&gt;&nbsp;<a href="jax-rs.html">JAX-RS</a>&nbsp;&gt;&nbsp;<a href="jax-rs-advanced-xml.html">JAX-RS Advanced XML</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p>&#160;</p><p>&#160;</p><p>&#160;</p><p></p><p><span style="font-size:2em;font-weight:bold"> JAX-RS : Advanced XML </span>


</p><p></p><p>&#160;</p><p>&#160;</p><p>&#160;</p><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1524513385073 {padding: 0px;}
div.rbtoc1524513385073 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1524513385073 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1524513385073">
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSAdvancedXML-XPathsupport">XPath support</a>
<ul class="toc-indentation"><li><a shape="rect" href="#JAX-RSAdvancedXML-Introduction">Introduction</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-UsingXMLSourceandXPathProviderintheapplicationcode">Using XMLSource and XPathProvider in the application code</a></li></ul>
</li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSLTsupport">XSLT support</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XMLProcessingInstructions">XML Processing Instructions</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSLTTransform">XSLTTransform</a></li><li><a shape="rect" href="#JAX-RSAdvancedXML-XSISchemaLocation">XSI Schema Location</a></li></ul>
</div><h1 id="JAX-RSAdvancedXML-XPathsupport">XPath support</h1><p>XPath is supported on the server and client sides with the help of <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLSource.java">XMLSource</a> utility and <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/XPathProvider.java">XPathProvider</a> provider classes. The difference between the two is that XPathProvider allows for specifying the XPath expressions in the external configuration.</p><h2 id="JAX-RSAdvancedXML-Introduction">Introduction</h2><p>XMLSource allows for converting matched XML DOM element, attribute and text nodes into typed complex and primitive classes. DOM Node and Element classes as well as JAXP Source and DOMSource can also be used. A single XMLSource instance can be used to query the same input source multiple times if the buffering mode is enabled.</p><p>Here are some examples:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);
// query 1
String value = xp.getValue("/foo/bar/@attr");
assertEquals("3", value);

// query 2
Integer intValue = xp.getNode("/foo/bar/@attr", Integer.class);
assertEquals(3, intValue);

// query 3
Node node = xp.getNode("/foo/bar/@attr", Node.class);
assertEquals("3", node.getTextValue());
</pre>
</div></div><p>In the above example a primitive attribute node is accessed in a number of ways, using the same XMLSource instance. <br clear="none"> Matched XML complex (element) nodes can be converted in a similar way:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">public class Bar {
    @XmlAttribute
    private String attr;  
    public String getAttribute() {
        return attr;
    } 
}

InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

// query 1
Bar bean = xp.getNode("/foo/bar", Bar.class);
assertEquals("3", bean.getAttribute());
 
// query 2
String value = xp.getValue("/foo/bar");
assertEquals("&lt;bar attr=\"3\"&gt;barValue&lt;/bar&gt;", value);
</pre>
</div></div><p>Note that JAXB is used internally to convert the matched XML element into a class like Bar which does not have to have an @XmlRootElement annotation. The 2nd query in the above example how a String representation of the matched complex node can be captured.</p><p>XMLSource also provides methods for capturing multiple nodes, example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo&gt;&lt;bar attr=\"3\"&gt;value1&lt;/bar&gt;&lt;bar attr=\"4\"&gt;value2&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);
// query 1
String[] values = xp.getValue("/foo/bar/text()");
assertEquals("value1", values[0]);
assertEquals("value2", values[1]);

// query 2
Integer[] intValues = xp.getNodes("/foo/bar/@attr", Integer.class);
assertEquals(3, intValues[0]);
assertEquals(4, intValues[1]);

// query 3
Bar[] nodes = xp.getNodes("/foo/bar", Bar.class);
</pre>
</div></div><p>All the above examples have been simplified in that no namespaces have been used. Most real XML instances will have plenty of them and XMLSource has methods accepting optional maps containing prefixes as keys and namespaces as values:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">InputStream is = new ByteArrayInputStream("&lt;foo xmlns=\"http://foo\"&gt;&lt;ns1:bar xmlns:ns1=\"http://bar\" attr=\"3\"&gt;barValue&lt;/bar&gt;&lt;/foo&gt;".getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

Foo foo = xp.getNode("/ps1:foo", Collections.singletonMap("ps1", "http://foo"), Foo.class);
assertNotNull(foo);

Bar foo = xp.getNode("/ps2:bar", Collections.singletonMap("ps2", "http://bar"), Bar.class);
assertNotNull(foo);
</pre>
</div></div><p>In the above example, a default "http://foo" namespace qualifies the root "foo" element while its 'bar' children are qualified with the <br clear="none"> "http://bar" namespace. Note that XMLSource is configured to make sure these namespaces are checked but the prefixes used do not have to match the ones in the actual XML instance which may not even have them at all, for example, when default namespaces are used.</p><p>XMLSource also provides few methods for capturing attribute or text values representing the HTTP links:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">String xmlString = "&lt;customers xmlns=\"http://customers\"&gt;
                    + "&lt;customer id="1" homepage=\"http://customers/1\"/&gt;"
                    + "&lt;/customers&gt;";
InputStream is = new ByteArrayInputStream(xmlString.getBytes());
XMLSource xp = new XMLSource(is);

URI homePage = xp.getLink("/ps1:customer[@id='1']/@homePage", 
                           Collections.singletonMap("ps1", "http://customers"));
WebClient client = WebClient.create(homePage);
// access the home page
</pre>
</div></div><p>In the above example the link to the home page of the customer with id equal to '1' is retrieved and is used to create a WebClient instance.</p><p>In some cases, the links are relative. In such cases the base URI is already either known to the application code or it may be specified as the value of the <a shape="rect" class="external-link" href="http://www.w3.org/TR/xmlbase/" rel="nofollow">xml:base</a> attribute. In the latter case XMLSource makes it easy to get this base URI:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">String xmlString = "&lt;customers xmlns=\"http://customers\" xml:base="http://customers"&gt;
                    + "&lt;customer id="1"/&gt;&lt;customer id="2"/&gt;"
                    + "&lt;/customers&gt;";
InputStream is = new ByteArrayInputStream(xmlString.getBytes());
XMLSource xp = new XMLSource(is);
xp.setBuffering(true);

URI baseURI = xp.getBaseURI();
URI[] relativeURIs = xp.getLinks("/ps1:customer/@id", Collections.singletonMap("ps1", "http://customers"));

WebClient client = WebClient.create(baseURI);
for (URI uri: relativeURIs) {
  client.path(uri);
  // access the home page
  
  // and get back to the base URI
  client.back(true); 
}
</pre>
</div></div><p>In the last example, a customer id also represents a relative URI, with xml:base attribute pointing to a base URI.<br clear="none"> XMLSource is used to get all the relative URIs, creates a WebClient with the base URI and then iterates using individual relative URIs.</p><h2 id="JAX-RSAdvancedXML-UsingXMLSourceandXPathProviderintheapplicationcode">Using XMLSource and XPathProvider in the application code</h2><p>Please see <a shape="rect" href="http://cxf.apache.org/docs/jax-rs-client-api.html#JAX-RSClientAPI-XMLcentricclients">this section</a> on how http-centric WebClients can use XPath, and here is an example for the server side:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("/root")
public class Root {
   @POST
   public void post(XMLSource source) {
       String value = source.getProperty("/books/book/@name");
   }    
}
</pre>
</div></div><p>Users have an option to hide XPath expressions, by registering an XPathProvider which is a JAX-RS MessageBodyReader, either on the client or server sides. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">XPathProvider provider = new XPathProvider();
provider.setGlobalExpression("/books/book[position() = 1]");
WebClient wc = WebClient.create("http://aggregated/data", Collections.singletonList(provider));
Book b = wc.get(Book.class);
</pre>
</div></div><h1 id="JAX-RSAdvancedXML-XSLTsupport">XSLT support</h1><p>XSLT is currently supported by <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/provider/XSLTJaxbProvider.java">XSLTJaxbProvider</a>. This provider works relies on JAXB to initiate the transformation process and can be used to produce pretty much any format, including non-XML ones. Likewise, it can be used to extract XML data out of incoming XML fragments. This provider can be used on the server and client sides.</p><p>Please see this <a shape="rect" class="external-link" href="http://sberyozkin.blogspot.com/2009/05/mvc-xml-way-with-cxf-jax-rs.html" rel="nofollow">blog entry</a> for an overview of how this provider can help with separating the presentation logic from the main application code.</p><p>XSLTJaxbProvider can be configured to handle input or output data, scoped by media types if needed. For example, one may configure it such that one template handles "application/xml" formats only while the other one handles "application/json" writes only.</p><p>XSLTJaxbProvider uses an injected JAX-RS UriInfo to inject all the usual JAX-RS information like template or query parameters into a given XSLT template. These parameters will be injected with the names equal to corresponding @PathParam, QueryParam, etc values. Additionally, an absolute, base and relative path URIs will be injected as "absolute.path", "base.path" and "relative.path" parameters. Finally, custom inParameters and outParameters map properties can also be injected and they will be added to all the XSLT template instances.</p><p>For example, given this resource method definition:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("/root")
public class Root {
   @GET
   @Path("{id}") 
   @Produces({"application/xml", "application/json", "text/html"} )
   public Book get(@PathParam("id") String id, @QueryParam("name") String name) {
       return getBook(id, name);
   }    
}
</pre>
</div></div><p>the XSLT templates will have parameters with name 'id' and 'name' injected. In this particular case it may make sense to have two templates, one for processing a Book XML stream (generated by JAXB) only, and the other one for adding HTML specific elements. The HTML-specific template will most likely import the template dealing with the Book stream.</p><p>Here are some examples of how XSLTJaxbTemplate can be configured:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">   &lt;map id="outTemplates"&gt;
      &lt;entry key="application/xml" value="classpath:/WEB-INF/templates/book-xml.xsl"/&gt;
      &lt;entry key="text/html" value="classpath:/WEB-INF/templates/book-html.xsl"/&gt;
      &lt;entry key="application/json" value="classpath:/WEB-INF/templates/book-json.xsl"/&gt;
  &lt;/map&gt;
  
  &lt;bean id="uriResolver" class="org.apache.cxf.systest.jaxrs.URIResolverImpl"/&gt;
  
  &lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;    
      &lt;property name="outMediaTemplates" ref="outTemplates"/&gt;
      &lt;property name="resolver" ref="uriResolver"/&gt;
  &lt;/bean&gt;
</pre>
</div></div><p>In this example, the provider is injected with three out templates, one for modifying the Book XML stream, the other one - for creating an HTML Book representation and the last one for writing a JSON sequence which the existing JSON providers may not be able to generate.</p><p>A 'uriResolver' property can be used to point to a custom javax.xml.transform.URIResolver implementation which can be used to resolve relative links in few XSLT instructions such as 'import'/etc. A 'systemId' property can also be set. Additionally, inProperties and outProperties map properties can be injected and they will be used when XSLT template instances will be created.</p><p>Here is a simpler configuration example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">   &lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;    
      &lt;property name="outTemplate" value="classpath:/WEB-INF/templates/book-xml.xsl"/&gt;
      &lt;property name="inTemplate" class="classpath:/WEB-INF/templates/fromNewBookToOldBook.xsl"/&gt;
  &lt;/bean&gt;
</pre>
</div></div><p>The provider is configured with one output template and one input template which will apply to all request and response data.</p><p>When XSLTJaxbProvider is used for processing the incoming requests, its main goal is to ensure the incoming XML can be adapted as needed for the JAXB unmarshalling to succeed. The in template can modify the incoming XML in a number of ways or it can extract the XML fragment out of the bigger XML instance which is similar to what XMLSource and XPathProvider can do as well. Please also check the new <a shape="rect" href="http://cxf.apache.org/docs/transformationfeature.html">Transformation</a> feature.</p><p>Note that XSLTJaxbProvider may be used with other XML-aware providers on the same endpoint if needed. In such cases one needs to restrict the set of classes it can handle, for it to not interfere with the other XML provider. This can be done using inClassNames and outClassNames list properties which enumerate supported class names. Alternatively, a new "supportJaxbOnly" property can be set, in which case XSLTJaxbProvider will simply delegate to JAXBElementProvider if no template is available for a given class.</p><p>Note that when XSLTJaxbProvider is used on the client side, it may not always be possible for template parameters be injected in cases when http-centric clients are used (as opposed to proxies). For example :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">WebClient client = WebClient.create("http://books");
client.path("/store/1").get();
</pre>
</div></div><p>it is not possible to deduce that '1' represents a template parameter in the "/store/1" expression. However, one can use the following code instead if '1' needs to be available to XSLT templates :</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">WebClient client = WebClient.create("http://books");
client.path("/store/{id}", 1).get();
</pre>
</div></div><h1 id="JAX-RSAdvancedXML-XMLProcessingInstructions">XML Processing Instructions</h1><p>One way to get outbound XML transformed to HTML or get an XHTML payload further decorated with CSS tags is to <a shape="rect" class="external-link" href="http://www.w3.org/TR/xml-stylesheet/" rel="nofollow">associate an xml-stylesheet processing instruction</a> with the XML payload, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;?xml-stylesheet type="text/xsl" href="http://localhost/myapp/stylesheets/toHTML.xsl"?&gt;
&lt;products xmlns="http://products"&gt;
   &lt;product id="1"/&gt;
&lt;/products&gt;
</pre>
</div></div><p>The browser will fetch a stylesheet from the server and will transform this XML on the client's machine.<br clear="none"> This option is alternative to using XSLTJaxbProvider to create HTML on the server side. It may become less easy to use if XSL stylesheets importing other documents or rely on additional parameters to produce the HTML but it can definitely be used to offload the cost of doing the transformations from the server in some cases.</p><p>You can also combine XSLTJaxbProvider to create complex HTML on the server and use xml-stylesheet instructions to get the browser to download and cache the CSS stylesheets, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;?xml-stylesheet type="text/css" href="http://localhost/myapp/stylesheets/HTMLDecorator.css"?&gt;
&lt;! 
   XSLTJaxbProvider transformed the XML products payload into well-formed XHTML.
   The browser will get HTMLDecorator.css at the next step and apply it to this HTML 
--&gt;
&lt;html&gt;
   &lt;title&gt;The products&lt;/title&gt;
   &lt;table&gt;
     &lt;!-- description of products --&gt;
   &lt;/table&gt;
&lt;/html&gt;
</pre>
</div></div><p>When working with JAXB, the way to add such xml processing instructions is to set a <br clear="none"> "com.sun.xml.bind.xmlHeaders" or "com.sun.xml.internal.bind.xmlHeaders" on the JAXB Marshaller.</p><p>Up until CXF 2.5.1 the way to do is to use a JAXBElementProvider 'marshallerProperties' map property, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;beans xmlns:util="http://www.springframework.org/schema/util"&gt;
&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
&lt;map&gt;
&lt;entry key="com.sun.xml.bind.xmlHeaders" 
       value="&lt;?xml-stylesheet type='text/xsl' href='/stylesheets/toHTML.xsl'?&gt;"/&gt;
&lt;/map&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>
</div></div><p>The problem here is how to correctly point to an absolute URI identifying the toHTML.xsl resource.<br clear="none"> Assuming that the browser will correctly resolve a relative URI such as "/stylesheets/toHTML.xsl", then all is set.<br clear="none"> Otherwise the best option is to extend JAXBElementProvider and set marshaller properties there by using JAX-RS UriInfo to get to the base request URI.</p><p>Starting from CXF 2.5.1 and 2.4.5 one can use an <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XMLInstruction.java">XMLInstruction</a> annotation:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XMLInstruction("&lt;?xml-stylesheet type='text/xsl' href='/stylesheets/toHTML.xsl'?&gt;")
   public Products getProducts() {}
}
</pre>
</div></div><p>Lets assume one runs a 'myapp' web application with CXFServlet listening on "/services/*", which can accept requests such as "GET <a shape="rect" class="external-link" href="http://localhost/myapp/services/products" rel="nofollow">http://localhost/myapp/services/products</a>".</p><p>The above relative href value will be converted to "http://localhost/myapp/stylesheets/toHTML.xsl" thus making it easy to resources not 'covered' by CXFServlet. What if you prefer not to even list 'stylesheets' in href='/stylesheets/toHTML.xsl' given that the name of the resource folder may change ?<br clear="none"> Use an 'xmlResourceOffset' property of JAXBElementProvider:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean id="jaxbProvider" class="org.apache.cxf.jaxrs.provider.JAXBElementProvider"&gt;
&lt;property name="xmlResourceOffset" value="stylesheets"/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</pre>
</div></div><p>and only have href='toHTML.xsl'. You can also use xmlResourceOffset to make sure the absolute URI will be covered by CXFServlet if preferred.</p><h1 id="JAX-RSAdvancedXML-XSLTTransform">XSLTTransform</h1><p>&#160;</p><p><a shape="rect" class="external-link" href="https://git-wip-us.apache.org/repos/asf?p=cxf.git;a=blob;f=rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XSLTTransform.java;h=245106caa903c4ec4612fb65ecc01061004fae67;hb=HEAD">XSLTTransform</a> is a new annotation introduced in CXF 3.0.0. It can support either server or client driven transformations.</p><p>Single XSLTTransform annotation can also support both client and server transformations.</p><p>Its 'mediaTypes' property, if enabled, is used to restrict the server-based transformations to the listed media types only and expected to be a subset of JAX-RS Produces value.</p><p>&#160;</p><p>XSLTTransform can be used in SERVER, CLIENT or BOTH modes.</p><p>For it to be effective for the server side transformations (SERVER, BOTH), it has to be used in conjunction with XSLTJaxbProvider.</p><p>Default JAXBElementProvider will support XSLTransform CLIENT mode independently.</p><p>When it is used either in CLIENT or BOTH modes to let the clients run the transformations it is processed by JAXBElementProvider and is converted into XML XSL instruction.</p><p>Using it in BOTH mode effectively supports a transformation 'negotiation': the clients which can do the transformation themselves will have an XML XSL instruction added to the response XML payloads,</p><p>and in other case the server will run the transformations.</p><p>Examples:</p><p>&#160;</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">// server based Products to XML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSLTTransform("template.xsl")
   public Products getProducts() {}
}

// server based Products to HTML transformation, 
// Product to XML is not affected
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", mediaTypes = {"text/html"})
   public Products getProducts() {}
}

// client based Products XML to XML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSLTTransform(value = "template.xsl", type = CLIENT)
   public Products getProducts() {}
}

// client based Products XML to HTML transformation, 
// Product to XML is not affected
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", type = CLIENT, mediaTypes = {"text/html"})
   public Products getProducts() {}
}

// clients with "Accept: application/xml" will do Products XML to HTML transformation 
// clients with "Accept: text/html" will have server-based Products to HTML transformation
@Path("products")
public class Resource {
   @GET
   @Produces("application/xml", "text/html")
   @XSLTTransform(value = "template.xsl", type = BOTH, mediaTypes = {"text/html"})
   public Products getProducts() {}
}&#160;





&#160;</pre>
</div></div><p>&#160;</p><p>Typically you do not need to configure either XSLT or JAXB providers with the additional properties for XSLTTransform be effective unless BOTH mode is used, in this case simply set XSLTJaxbProvider "supportJaxbOnly":</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;bean id="xsltProvider" class="org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"&gt;
&lt;property name="supportJaxbOnly" value="true"/&gt;
&lt;/bean&gt;
</pre>
</div></div><p>The above configuration is sufficient to have XSLTTransform BOTH mode supported.</p><h1 id="JAX-RSAdvancedXML-XSISchemaLocation">XSI Schema Location</h1><p>Some tools such as <a shape="rect" class="external-link" href="http://office.microsoft.com/en-us/excel-help/get-and-analyze-data-from-the-web-in-excel-HA001054848.aspx" rel="nofollow">Microsoft Excel</a> can do WEB queries and import the XML payload but this payload is expected to use an xsi:schemaLocation attribute pointing to the XML schema document describing this XML, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">&lt;products xmlns="http://products"
   xmlns:xsi=""http://www.w3.org/2000/10/XMLSchema-instance""
   xsi:schemaLocation="http://localhost/myapp/schemas/product.xsd"&gt;
   &lt;product id="1"/&gt;
&lt;/products&gt;
</pre>
</div></div><p>In order to get this attribute set with JAXB, one needs to use a "javax.xml.bind.Marshaller.JAXB_SCHEMA_LOCATION" property which can be set on JAXBElementProvider directly (similarly to the way XML Processing Instructions set, see the previous section) or, starting with CXF 2.5.1, with the help of a new <a shape="rect" class="external-link" href="http://svn.apache.org/repos/asf/cxf/trunk/rt/frontend/jaxrs/src/main/java/org/apache/cxf/jaxrs/ext/xml/XSISchemaLocation.java">XSISchemaLocation</a> annotation:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default" style="font-size:12px;">@Path("products")
public class Resource {
   @GET
   @Produces("application/xml")
   @XSISchemaLocation("schemas/products.xsd")
   public Products getProducts() {}
}
</pre>
</div></div><p>Please see the previous section on how to affect the absolute URI to a given schema with the help of JAXBElementProvider.<br clear="none"> Note that XSISchemaLocation may have a noNamespace attribute set to 'true' if a given schema has no target namespace.</p></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=24190965">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=24190965&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

