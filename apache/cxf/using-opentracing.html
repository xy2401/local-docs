
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--

    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<html>
  <head>

<link type="text/css" rel="stylesheet" href="/resources/site.css">
<script src='/resources/space.js'></script>

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="keywords" content="business integration, EAI, SOA, Service Oriented Architecture, web services, SOAP, JBI, JMS, WSDL, XML, EDI, Electronic Data Interchange, standards support, integration standards, application integration, middleware, software, solutions, services, CXF, open source">
<meta name="description" content="Apache CXF, Services Framework - Using OpenTracing">


<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shCoreCXF.css">
<link type="text/css" rel="stylesheet" href="/resources/highlighter/styles/shThemeCXF.css">

<script src='/resources/highlighter/scripts/shCore.js'></script>
<script src='/resources/highlighter/scripts/shBrushJava.js'></script>
<script src='/resources/highlighter/scripts/shBrushXml.js'></script>
<script src='/resources/highlighter/scripts/shBrushBash.js'></script>
<script>
  SyntaxHighlighter.defaults['toolbar'] = false;
  SyntaxHighlighter.all();
</script>


    <title>
Apache CXF -- Using OpenTracing
    </title>
  </head>
<body onload="init()">


<table width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td id="cell-0-0" colspan="2">&nbsp;</td>
    <td id="cell-0-1">&nbsp;</td>
    <td id="cell-0-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-1-0">&nbsp;</td>
    <td id="cell-1-1">&nbsp;</td>
    <td id="cell-1-2">
      <!-- Banner -->
<div class="banner" id="banner"><div><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td align="left" colspan="1" nowrap>
<a shape="rect" href="http://cxf.apache.org/" title="Apache CXF"><span style="font-weight: bold; font-size: 170%; color: white">Apache CXF</span></a>
</td><td align="right" colspan="1" nowrap>
<a shape="rect" href="http://www.apache.org/" title="The Apache Sofware Foundation"><img border="0" alt="ASF Logo" src="http://cxf.apache.org/images/asf-logo.png"></a>
</td></tr></table></div></div>
      <!-- Banner -->
      <div id="top-menu">
        <table border="0" cellpadding="1" cellspacing="0" width="100%">
          <tr>
            <td>
              <div align="left">
                <!-- Breadcrumbs -->
<a href="index.html">Index</a>&nbsp;&gt;&nbsp;<a href="distributed-tracing.html">Distributed Tracing</a>&nbsp;&gt;&nbsp;<a href="using-opentracing.html">Using OpenTracing</a>
                <!-- Breadcrumbs -->
              </div>
            </td>
            <td>
              <div align="right">
                <!-- Quicklinks -->
<div id="quicklinks"><p><a shape="rect" href="http://cxf.apache.org/download.html">Download</a> | <a shape="rect" href="http://cxf.apache.org/docs/index.html">Documentation</a></p></div>
                <!-- Quicklinks -->
              </div>
            </td>
          </tr>
        </table>
      </div>
    </td>
    <td id="cell-1-3">&nbsp;</td>
    <td id="cell-1-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-2-0" colspan="2">&nbsp;</td>
    <td id="cell-2-1">
      <table>
        <tr valign="top">
          <td height="100%">
            <div id="wrapper-menu-page-right">
              <div id="wrapper-menu-page-top">
                <div id="wrapper-menu-page-bottom">
                  <div id="menu-page">
                    <!-- NavigationBar -->
<div id="navigation"><ul class="alternate"><li><a shape="rect" href="overview.html">Overview</a></li><li><a shape="rect" href="how-tos.html">How-Tos</a></li><li><a shape="rect" href="frontends.html">Frontends</a></li><li><a shape="rect" href="databindings.html">DataBindings</a></li><li><a shape="rect" href="transports.html">Transports</a></li><li><a shape="rect" href="configuration.html">Configuration</a></li><li><a shape="rect" href="debugging-and-logging.html">Debugging and Logging</a></li><li><a shape="rect" href="tools.html">Tools</a></li><li><a shape="rect" href="restful-services.html">RESTful Services</a></li><li><a shape="rect" href="wsdl-bindings.html">WSDL Bindings</a></li><li><a shape="rect" href="service-routing.html">Service Routing</a></li><li><a shape="rect" href="dynamic-languages.html">Dynamic Languages</a></li><li><a shape="rect" href="ws-support.html">WS-* Support</a></li><li><a shape="rect" href="advanced-integration.html">Advanced Integration</a></li><li><a shape="rect" href="deployment.html">Deployment</a></li><li><a shape="rect" href="schemas-and-namespaces.html">Use of Schemas and Namespaces</a></li></ul><hr><ul class="alternate"><li><p>Search</p></li></ul><form enctype="application/x-www-form-urlencoded" method="get" id="cse-search-box" action="http://www.google.com/cse">
  <div>
    <input type="hidden" name="cx" value="002890367768291051730:o99qiwa09y4">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="21">
    <input type="submit" name="sa" value="Search">
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script><hr><ul class="alternate"><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest/">API 3.2.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/javadoc/latest-3.1.x/">API 3.1.x (Javadoc)</a></li><li><a shape="rect" href="http://cxf.apache.org/">CXF Website</a></li></ul><p>&#160;</p><p><a shape="rect" class="external-link" href="http://www.apache.org/events/current-event.html"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="http://www.apache.org/events/current-event-125x125.png" data-image-src="http://www.apache.org/events/current-event-125x125.png"></span></a></p></div>
                    <!-- NavigationBar -->
                  </div>
              </div>
            </div>
          </div>
         </td>
         <td height="100%">
           <!-- Content -->
           <div class="wiki-content">
<div id="ConfluenceContent"><p><style type="text/css">/*<![CDATA[*/
div.rbtoc1546725419019 {padding: 0px;}
div.rbtoc1546725419019 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1546725419019 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style></p><div class="toc-macro rbtoc1546725419019">
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Overview">Overview</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracinginApacheCXFusingOpenTracing">Distributed Tracing in Apache CXF using OpenTracing</a></li><li><a shape="rect" href="#UsingOpenTracing-ANoteonOpenTracingAPIs">A Note on OpenTracing APIs</a></li><li><a shape="rect" href="#UsingOpenTracing-OpenTracingAPIv0.30.0andApacheCXF3.2.x">OpenTracing API v0.30.0 and Apache CXF 3.2.x</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-ConfiguringClient">Configuring Client</a></li><li><a shape="rect" href="#UsingOpenTracing-ConfiguringServer">Configuring Server</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingInAction:UsageScenarios">Distributed Tracing In Action: Usage Scenarios</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured">Example #1: Client and Server with default distributed tracing configured</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#2:ClientandServerwithnestedtrace">Example #2: Client and Server with nested trace</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#3:ClientandServertracewithtimeline">Example #3: Client and Server trace with timeline</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#4:ClientandServerwithbinaryannotations(key/value)">Example #4: Client and Server with binary annotations (key/value)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools)">Example #5: Client and Server with parallel trace (involving thread pools)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side)">Example #6: Client and Server with asynchronous JAX-RS service (server-side)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side)">Example #7: Client and Server with asynchronous invocation (client-side)</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport">Distributed Tracing with OpenTracing and JAX-WS support</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi">Distributed Tracing with OpenTracing and OSGi</a></li><li><a shape="rect" href="#UsingOpenTracing-Samples">Samples</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-OpenTracingAPIv0.31.0andApacheCXF3.3.x">OpenTracing API v0.31.0 and Apache CXF 3.3.x</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-ConfiguringClient.1">Configuring Client</a></li><li><a shape="rect" href="#UsingOpenTracing-ConfiguringServer.1">Configuring Server</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingInAction:UsageScenarios.1">Distributed Tracing In Action: Usage Scenarios</a>
<ul class="toc-indentation"><li><a shape="rect" href="#UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured.1">Example #1: Client and Server with default distributed tracing configured</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#2:ClientandServerwithnestedtrace.1">Example #2: Client and Server with nested trace</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#3:ClientandServertracewithtimeline.1">Example #3: Client and Server trace with timeline</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#4:ClientandServerwithannotations(key/value)">Example #4: Client and Server with annotations (key/value)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools).1">Example #5: Client and Server with parallel trace (involving thread pools)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side).1">Example #6: Client and Server with asynchronous JAX-RS service (server-side)</a></li><li><a shape="rect" href="#UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side).1">Example #7: Client and Server with asynchronous invocation (client-side)</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport.1">Distributed Tracing with OpenTracing and JAX-WS support</a></li><li><a shape="rect" href="#UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi.1">Distributed Tracing with OpenTracing and OSGi</a></li><li><a shape="rect" href="#UsingOpenTracing-Samples.1">Samples</a></li></ul>
</li><li><a shape="rect" href="#UsingOpenTracing-AccessingOpenTracingAPIs">Accessing OpenTracing APIs</a></li></ul>
</div><h1 id="UsingOpenTracing-Overview">Overview</h1><p><a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> is a vendor-neutral open standard for distributed tracing. Essentially, for Java-based projects the specification exists as a set of <a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java APIs</a> which any distributed tracing solution is welcome to implement. There are<a shape="rect" class="external-link" href="http://opentracing.io/documentation/pages/supported-tracers" rel="nofollow"> quite a few distributed tracing frameworks</a> available which are compatible with <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>, notably <a shape="rect" class="external-link" href="http://zipkin.io/" rel="nofollow">Zipkin</a> (via community contributions like <a shape="rect" class="external-link" href="https://github.com/openzipkin/brave-opentracing" rel="nofollow">bridge from Brave to OpenTracing</a> ), <a shape="rect" class="external-link" href="http://lightstep.com/" rel="nofollow">Lightstep</a> and <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>. Starting from <strong>3.2.1</strong> release, Apache CXF fully supports integration (through <strong>cxf-integration-tracing-opentracing</strong> module) with any distributed tracer that provides <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> implementation.</p><p>The section <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+Apache+HTrace">dedicated to Apache HTrace </a>has pretty good introduction into distributed tracing basics however <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> specification abstracts a lot of things, outlining just a general APIs to denote the <strong>Span&#160;</strong>lifecycle and injection points to propagate the context across many distributed components. As such, the intrinsic details about HTTP headers f.e. becomes an integral part of the distributed tracer of your choice, out of reach for Apache CXF.</p><h1 id="UsingOpenTracing-DistributedTracinginApacheCXFusingOpenTracing">Distributed Tracing in Apache CXF using OpenTracing</h1><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is a very popular framework for building services and web APIs. No doubts, it is going to play even more important role in context of microservices architecture letting developers to quickly build and deploy individual JAX-RS/JAX-WS services. Distributed tracing is an essential technique to observe the application platform as a whole, breaking the request to individual service traces as it goes through and crosses the boundaries of threads, processes and machines.</p><p>The current integration of distributed tracing in <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> supports&#160;<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.30.0+</strong> and provides full-fledged support of JAX-RS 2.x / JAX-WS applications. From high-level prospective, the JAX-RS integration consists of three main parts:</p><ul><li><strong>TracerContext</strong> (injectable through <strong>@Context</strong> annotation)</li><li><strong>OpenTracingProvider</strong> (server-side JAX-RS provider) and <strong>OpenTracingClientProvider</strong> (client-side JAX-RS provider)</li><li class="external-link"><strong>OpenTracingFeature</strong> (server-side JAX-RS feature) to simplify the configuration and integration</li></ul><p>Similarly, from high-level perspective,&#160;JAX-WS integration includes:</p><ul><li><strong>OpenTracingStartInterceptor</strong> / <strong>OpenTracingStopInterceptor</strong> / <strong>OpenTracingFeature&#160;</strong><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> feature (server-side JAX-WS support)</li><li><strong>OpenTracingClientStartInterceptor</strong> / <strong>OpenTracingClientStopInterceptor</strong> / <strong>OpenTracingClientFeature&#160;</strong><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> feature (client-side JAX-WS support)</li></ul><p><a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> uses HTTP headers to hand off tracing context from the client to the service and from the service to service. Those headers are specific to distributing tracing framework you have picked and are not configurable at the moment (unless the framework itself has a way to do that).</p><p>By default, <strong>OpenTracingClientProvider</strong> will try to pass the currently active <strong>span</strong> through HTTP headers on each service invocation. If there is no active spans, the new span will be created and passed through HTTP headers on per-invocation basis. Essentially, for JAX-RS applications just registering <strong>OpenTracingClientProvider</strong> on the client and <strong>OpenTracingProvider</strong> on the server is enough to have tracing context to be properly passed everywhere. The only configuration part which is necessary are <strong>span reporters(s)</strong> and <strong>sampler(s)</strong> which are, not surprisingly, specific to distributing tracing framework you have chosen.</p><p>It is also worth to mention the way <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> attaches the description to <strong>spans</strong>. With regards to the client integration, the description becomes a full URL being invoked prefixed by HTTP method, for example: <strong>GET </strong><a shape="rect" class="external-link" href="http://localhost:8282/books" rel="nofollow"><strong>http://localhost:8282</strong>/books</a>. On the server side integration, the description becomes a relative JAX-RS resource path prefixed by HTTP method, f.e.: <strong>GET books, POST book/123</strong></p><h1 id="UsingOpenTracing-ANoteonOpenTracingAPIs">A Note on OpenTracing APIs</h1><p><a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> is evolving very fast and, sadly but not surprisingly, often the changes being made are not backward compatible. The <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> <strong>3.2.x</strong> release branch stays on <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.30.0&#160;</strong>as of now, while the <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> <strong>3.3.x</strong> is using <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> <strong class="external-link">0.31.0</strong>. There are<strong class="external-link"> </strong>quite many major differences between both APIs but <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is trying hard to smooth it over. It is worth to mention that&#160;<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>-compatible clients and servers may not depend on the same APIs version, the only issue you will run into is related to compatibility of the provided Java clients for the tracer of your choice.</p><h1 id="UsingOpenTracing-OpenTracingAPIv0.30.0andApacheCXF3.2.x">OpenTracing API v0.30.0 and Apache CXF 3.2.x</h1><h2 id="UsingOpenTracing-ConfiguringClient">Configuring Client</h2><p>In this section and below, all the code snippets are going to be based on <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> distributed tracing framework (<strong>release 0.20.6+</strong>), although everything we are going to discuss is equally applicable to any other existing alternatives. Essentially, the only dependency <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> integration relies on is the <strong>Tracer</strong> instance.</p><p>There are a couple of ways the JAX-RS client could be configured, depending on the client implementation. <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> provides its own <strong>WebClient</strong> which could be configured just like that (in future versions, there would be a simpler ways to do that using client specific features):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("web-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
                
Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(new OpenTracingClientProvider(tracer)))
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>The configuration based on using the standard JAX-RS <strong>Client</strong> is very similar:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
                
final OpenTracingClientProvider provider = new OpenTracingClientProvider(tracer);
final Client client = ClientBuilder.newClient().register(provider);
    
final Response response = client
  .target("http://localhost:9000/catalog")
  .request()
  .accept(MediaType.APPLICATION_JSON)
  .get();</pre>
</div></div><p>Alternatively, you may use <strong>GlobalTracer</strong> to pass the tracer around, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

// This method should only be called once during the application initialization phase.
GlobalTracer.register(tracer);

// No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
final OpenTracingClientProvider provider = new OpenTracingClientProvider();</pre>
</div></div><h2 id="UsingOpenTracing-ConfiguringServer">Configuring Server</h2><p>Server configuration is a bit simpler than the client one thanks to the feature class available, <strong>OpenTracingFeature</strong>. Depending on the way the&#160;<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is used to configure JAX-RS services, it could be part of JAX-RS application configuration, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        final Tracer tracer = new Configuration("tracer-server", 
                new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
                new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
            ).getTracer();

            
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    new OpenTracingFeature(tracer)
                )
            );
    } 
}</pre>
</div></div><p>Or it could be configured using <strong>JAXRSServerFactoryBean</strong> as well, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer-server", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

final JAXRSServerFactoryBean factory = RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setProvider(new OpenTracingFeature(tracer));
...
return factory.create();</pre>
</div></div><p>Alternatively, you may rely on <strong>GlobalTracer</strong> to pass the tracer around, so in this case the <strong>OpenTracingFeature</strong> will pick it up from there, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    // No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
                    new OpenTracingFeature()
                )
            );
    } 
}</pre>
</div></div><p>Once the <strong>span reporter</strong> and <strong>sampler</strong> are properly configured, all generated <strong>spans</strong> are going to be collected and available for analysis and/or visualization.</p><h2 id="UsingOpenTracing-DistributedTracingInAction:UsageScenarios">Distributed Tracing In Action: Usage Scenarios</h2><p class="confluence-link">In the following subsections we are going to walk through many different scenarios to illustrate the distributed tracing in action, starting from the simplest ones and finishing with asynchronous JAX-RS services. All examples assume that configuration <strong>has been done</strong> (see please <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient"><span class="confluence-link"><span class="confluence-link">Configuring Client</span></span></a><span class="confluence-link">&#160;</span> and<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-configuringserver"><span class="confluence-link">&#160;</span></a><a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringServer"><span class="confluence-link">Configuring Server</span></a> sections above).</p><h3 id="UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured">Example #1: Client and Server with default distributed tracing configured</h3><p>In the first example we are going to see the effect of using default configuration on the client and on the server, with only <strong>OpenTracingClientProvider</strong>&#160; and <strong><strong>OpenTracing</strong>Provider</strong> registered. The JAX-RS resource endpoint is pretty basic stubbed method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>The client is as simple as that:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-client</strong>) and consequent invocation of the service on the server side (service name<strong> tracer-server</strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2012:41:7.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2013:18:20.png"></span></p><h3 id="UsingOpenTracing-Example#2:ClientandServerwithnestedtrace">Example #2: Client and Server with nested trace</h3><p>In this example server-side implementation of the JAX-RS service is going to call an external system (simulated as a simple delay of 500ms) within its own span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final ActiveSpan scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
            
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered"><strong>tracer</strong>-client</span></strong>) and consequent invocation of the service on the server side (service name<strong><span class="label label-default service-filter-label"><strong> tracer-</strong>server</span></strong><span class="label label-default service-filter-label">)</span> is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:9:7.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:10:40.png"></span></p><h3 id="UsingOpenTracing-Example#3:ClientandServertracewithtimeline">Example #3: Client and Server trace with timeline</h3><p>In this example server-side implementation of the JAX-RS service is going to add timeline to the active span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
         
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered">tracer-client</span></strong>) and consequent invocation of the service on the server side (service name<strong> <span class="label label-default service-filter-label">traceser-server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="using-opentracing.data/image2017-9-10%2014:26:23.png"></span></p><p>&#160;</p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Please notice that timelines are treated as<strong> logs events</strong> in <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>.</p></div></div><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:19:1.png"></span></p><h3 id="UsingOpenTracing-Example#4:ClientandServerwithbinaryannotations(key/value)">Example #4: Client and Server with binary annotations (key/value)</h3><p>In this example server-side implementation of the JAX-RS service is going to add key/value annotations to the active span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
         
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered"><strong><span class="label label-default service-filter-label service-tag-filtered"><strong>tracer</strong></span></strong>-client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample server trace properties (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="400" src="using-opentracing.data/image2017-9-10%2014:40:20.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:46:4.png"></span></p><h3 id="UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools)">Example #5: Client and Server with parallel trace (involving thread pools)</h3><p>In this example server-side implementation of the JAX-RS service is going to offload some work into thread pool and then return the response to the client, simulating parallel execution. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                     
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
         
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                     
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
        
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (process name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:49:4.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:50:2.png"></span></p><h3 id="UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side)">Example #6: Client and Server with asynchronous JAX-RS service (server-side)</h3><p>In this example server-side implementation of the JAX-RS service is going to be executed asynchronously. It poses a challenge from the tracing prospective as request and response are processed in different threads (in general). At the moment, <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> does not support the transparent tracing spans management (except for default use case) but provides the simple ways to do that (by letting to transfer spans from thread to thread). The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                             
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                             
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:54:2.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:55:0.png"></span></p><h3 id="UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side)">Example #7: Client and Server with asynchronous invocation (client-side)</h3><p>In this example server-side implementation of the JAX-RS service is going to be the default one:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>While the JAX-RS client&#160;implementation is going to perform the asynchronous invocation:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>In this respect, there is no difference from the caller prospective however a bit more work is going under the hood to transfer the active tracing span from JAX-RS client request filter to client response filter as in general those are executed in different threads (similarly to server-side asynchronous JAX-RS resource invocation). The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2015:0:49.png"></span></p><p>The same trace will be looking pretty similar using traditional <a shape="rect" class="external-link" href="https://github.com/openzipkin/zipkin/tree/master/zipkin-ui" rel="nofollow">Zipkin UI</a> frontend:</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2017-9-10%2014:58:53.png"></span></p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport">Distributed Tracing with OpenTracing and JAX-WS support</h2><p>Distributed tracing in the <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is build primarily around JAX-RS 2.x implementation. However, JAX-WS is also supported but it requires to write some boiler-plate code and use&#160;<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> directly (the JAX-WS integration is going to be enhanced in the future). Essentially, from the server-side prospective the in/out interceptors, <strong>OpenTracingStartInterceptor</strong> and <strong><strong>OpenTracing</strong>StopInterceptor </strong>respectively, should be configured as part of interceptor chains, either manually or using <strong><strong>OpenTracing</strong>Feature</strong>. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();

final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getFeatures().add(new OpenTracingFeature(trace));
...
sf.create();</pre>
</div></div><p>Similarly to the server-side, client-side needs own set of out/in interceptors, <strong><strong>OpenTracing</strong>ClientStartInterceptor</strong> and <strong><strong>OpenTracing</strong>ClientStopInterceptor</strong> (or <strong><strong>OpenTracing</strong>ClientFeature</strong>). Please notice the difference from server-side:&#160; <strong><strong>OpenTracing</strong>ClientStartInterceptor</strong> becomes out-interceptor while <strong><strong>OpenTracing</strong>ClientStopInterceptor</strong> becomes in-interceptor. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer", 
        new Configuration.SamplerConfiguration(ConstSampler.TYPE, 1), /* or any other Sampler */
        new Configuration.ReporterConfiguration(new HttpSender("http://localhost:14268/api/traces")) /* or any other Sender */
    ).getTracer();
              
final JaxWsProxyFactoryBean sf = new JaxWsProxyFactoryBean();
...
sf.getFeatures().add(new OpenTracingClientFeature(tracer));
...
sf.create();

</pre>
</div></div><p>As it was mentioned before, you may use <strong>GlobalTracer</strong> utility class to pass the tracer around so, for example, any JAX-WS service will be able to retrieve the current tracer by invoking <strong>GlobalTracer.get()</strong> method.</p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi">Distributed Tracing with OpenTracing and OSGi</h2><p class="external-link">Most of the distributed tracers compatible with <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> API could be deployed into <strong>OSGi</strong> container and as such, the integration is fully available for <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> services running inside the container. For a complete example please take a look on <a shape="rect" class="external-link" href="https://github.com/apache/cxf/master/distribution/src/main/release/samples/jax_rs_tracing_opentracing_osgi/README.txt" rel="nofollow">jax_rs_tracing_opentracing_osgi</a> sample project, but here is the typical <strong>OSGi</strong>&#160; Blueprint snippet in case of <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>.</p><p class="external-link">&#160;</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: xml; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/blueprint/core"
       xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"

       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                           http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
                           http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;bean id="tracingFeature" class="org.apache.cxf.tracing.opentracing.jaxrs.OpenTracingFeature"&gt;
        &lt;argument index="0"&gt;
            &lt;bean factory-ref="builder" factory-method="build" /&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="metrics" class="com.uber.jaeger.metrics.Metrics"&gt;
        &lt;argument index="0"&gt;
            &lt;bean class="com.uber.jaeger.metrics.StatsFactoryImpl"&gt;
                &lt;argument index="0"&gt;
                    &lt;bean class="com.uber.jaeger.metrics.NullStatsReporter" /&gt;
                &lt;/argument&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="builder" class="com.uber.jaeger.Tracer.Builder"&gt;
        &lt;argument index="0" value="cxf-server" /&gt;
        &lt;argument index="1"&gt;
            &lt;bean class="com.uber.jaeger.reporters.RemoteReporter"&gt;
                &lt;argument index="0" ref="sender" /&gt;
                &lt;argument index="1" value="1000"/&gt;
                &lt;argument index="2" value="100"/&gt;
                &lt;argument index="3" ref="metrics"/&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
        &lt;argument index="2"&gt;
            &lt;bean class="com.uber.jaeger.samplers.ConstSampler"&gt;
                &lt;argument index="0" value="true" /&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sender" class="com.uber.jaeger.senders.HttpSender"&gt;
        &lt;argument index="0" value="http://localhost:14268/api/traces" /&gt;
    &lt;/bean&gt;
    
    &lt;cxf:bus&gt;
        &lt;cxf:features&gt;
            &lt;cxf:logging /&gt;
        &lt;/cxf:features&gt;
    &lt;/cxf:bus&gt;

    &lt;jaxrs:server id="catalogServer" address="/"&gt;
        &lt;jaxrs:serviceBeans&gt;
            ...
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref component-id="tracingFeature" /&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;
&lt;/blueprint&gt;</pre>
</div></div><h2 id="UsingOpenTracing-Samples">Samples</h2><ul style="list-style-type: square;"><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi" rel="nofollow">https://github.com/apache/cxf/tree/3.2.x-fixes/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi</a></li></ul><h1 id="UsingOpenTracing-OpenTracingAPIv0.31.0andApacheCXF3.3.x">OpenTracing API v0.31.0 and Apache CXF 3.3.x</h1><h2 id="UsingOpenTracing-ConfiguringClient.1">Configuring Client</h2><p>In this section and below, all the code snippets are going to be based on <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> distributed tracing framework (<strong>release 0.30.3+</strong>), although everything we are going to discuss is equally applicable to any other existing alternatives. Essentially, the only dependency <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> integration relies on is the <strong>Tracer</strong> instance. <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> uses service Java's <a shape="rect" class="external-link" href="https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html" rel="nofollow">ServiceLoader</a> mechanism to determine the instance of the tracer to use, so it is necessary to provide <strong>META-INF/services/io.jaegertracing.spi.SenderFactory</strong> binding, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">io.jaegertracing.thrift.internal.senders.ThriftSenderFactory</pre>
</div></div><p>Alternatively, you may just provide own implementation of the <strong>SenderConfiguration</strong> with the override <strong>getSender</strong> method, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final SenderConfiguration senderConfiguration = new SenderConfiguration() {
    @Override
    public Sender getSender() {
        return ...; /* the desired Sender implementation */
    }
}</pre>
</div></div><p>There are a couple of ways the JAX-RS client could be configured, depending on the client implementation. <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> provides its own <strong>WebClient</strong> which could be configured just like that (in future versions, there would be a simpler ways to do that using client specific features):</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("web-client")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();
                
Response response = WebClient
    .create("http://localhost:9000/catalog", Arrays.asList(new OpenTracingClientProvider(tracer)))
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>The configuration based on using the standard JAX-RS <strong>Client</strong> is very similar:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client") 
     .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
                
final OpenTracingClientProvider provider = new OpenTracingClientProvider(tracer);
final Client client = ClientBuilder.newClient().register(provider);
    
final Response response = client
  .target("http://localhost:9000/catalog")
  .request()
  .accept(MediaType.APPLICATION_JSON)
  .get();</pre>
</div></div><p>Alternatively, you may use <strong>GlobalTracer</strong> to pass the tracer around, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("jaxrs-client")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();

// This method should only be called once during the application initialization phase.
GlobalTracer.register(tracer);

// No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
final OpenTracingClientProvider provider = new OpenTracingClientProvider();</pre>
</div></div><h2 id="UsingOpenTracing-ConfiguringServer.1">Configuring Server</h2><p>Server configuration is a bit simpler than the client one thanks to the feature class available, <strong>OpenTracingFeature</strong>. Depending on the way the&#160;<a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is used to configure JAX-RS services, it could be part of JAX-RS application configuration, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        final Tracer tracer = new Configuration("tracer-server") 
            .withSampler(
                new SamplerConfiguration()
                    .withType(ConstSampler.TYPE) /* or any other Sampler */
                    .withParam(1)
            )
            .withReporter(
                new ReporterConfiguration()
                    .withSender(
                        new SenderConfiguration() /* or any other Sender configuration */
                            .withEndpoint("http://localhost:14268/api/traces")
                    )
            )
            .getTracer();
            
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    new OpenTracingFeature(tracer)
                )
            );
    } 
}</pre>
</div></div><p>Or it could be configured using <strong>JAXRSServerFactoryBean</strong> as well, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer-server") 
    .withSampler(
        new SamplerConfiguration()
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();

final JAXRSServerFactoryBean factory = RuntimeDelegate.getInstance().createEndpoint(/* application instance */, JAXRSServerFactoryBean.class);
factory.setProvider(new OpenTracingFeature(tracer));
...
return factory.create();</pre>
</div></div><p>Alternatively, you may rely on <strong>GlobalTracer</strong> to pass the tracer around, so in this case the <strong>OpenTracingFeature</strong> will pick it up from there, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@ApplicationPath( "/" )
public class CatalogApplication extends Application {
    @Override
    public Set&lt;Object&gt; getSingletons() {
        return new HashSet&lt;&gt;(
                Arrays.asList(
                    // No explicit Tracer instance is required, it will be picked off the GlobalTracer using get() method
                    new OpenTracingFeature()
                )
            );
    } 
}</pre>
</div></div><p>Once the <strong>span reporter</strong> and <strong>sampler</strong> are properly configured, all generated <strong>spans</strong> are going to be collected and available for analysis and/or visualization.</p><h2 id="UsingOpenTracing-DistributedTracingInAction:UsageScenarios.1">Distributed Tracing In Action: Usage Scenarios</h2><p class="confluence-link">In the following subsections we are going to walk through many different scenarios to illustrate the distributed tracing in action, starting from the simplest ones and finishing with asynchronous JAX-RS services. All examples assume that configuration <strong>has been done</strong> (see please <a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringClient.1"><span class="confluence-link"><span class="confluence-link">Configuring Client</span></span></a><span class="confluence-link">&#160;</span> and<a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-configuringserver"><span class="confluence-link">&#160;</span></a><a shape="rect" href="https://cwiki.apache.org/confluence/display/CXF20DOC/Using+OpenTracing#UsingOpenTracing-ConfiguringServer.1"><span class="confluence-link">Configuring Server</span></a> sections above).</p><h3 id="UsingOpenTracing-Example#1:ClientandServerwithdefaultdistributedtracingconfigured.1">Example #1: Client and Server with default distributed tracing configured</h3><p>In the first example we are going to see the effect of using default configuration on the client and on the server, with only <strong>OpenTracingClientProvider</strong>&#160; and <strong><strong>OpenTracing</strong>Provider</strong> registered. The JAX-RS resource endpoint is pretty basic stubbed method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>The client is as simple as that:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Response response = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .get();</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-client</strong>) and consequent invocation of the service on the server side (service name<strong> tracer-server</strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_14-59-19.png"></span></p><h3 id="UsingOpenTracing-Example#2:ClientandServerwithnestedtrace.1">Example #2: Client and Server with nested trace</h3><p>In this example server-side implementation of the JAX-RS service is going to call an external system (simulated as a simple delay of 500ms) within its own span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    try(final Scope scope = tracer.startSpan("Calling External System")) {
        // Simulating a delay of 500ms required to call external system
        Thread.sleep(500);
            
        return Arrays.asList(
            new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
        );
    }
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered"><strong>tracer</strong>-client</span></strong>) and consequent invocation of the service on the server side (service name<strong><span class="label label-default service-filter-label"><strong> tracer-</strong>server</span></strong><span class="label label-default service-filter-label">)</span> is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-1-39.png"></span></p><h3 id="UsingOpenTracing-Example#3:ClientandServertracewithtimeline.1">Example #3: Client and Server trace with timeline</h3><p>In this example server-side implementation of the JAX-RS service is going to add timeline to the active span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    tracer.timeline("Preparing Books");
    // Simulating some work using a delay of 100ms
    Thread.sleep(100);
         
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered">tracer-client</span></strong>) and consequent invocation of the service on the server side (service name<strong> <span class="label label-default service-filter-label">traceser-server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="920" src="using-opentracing.data/image2018-8-12_15-7-45.png"></span></p><h3 id="UsingOpenTracing-Example#4:ClientandServerwithannotations(key/value)">Example #4: Client and Server with annotations (key/value)</h3><p>In this example server-side implementation of the JAX-RS service is going to add key/value annotations to the active span. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Collection&lt;Book&gt; books = Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
         
    tracer.annotate("# of books", Integer.toString(books.size()));
    return books;
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong><span class="label label-default service-filter-label service-tag-filtered"><strong><span class="label label-default service-filter-label service-tag-filtered"><strong>tracer</strong></span></strong>-client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample server trace properties (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" height="250" src="using-opentracing.data/image2018-8-12_15-11-42.png"></span></p><h3 id="UsingOpenTracing-Example#5:ClientandServerwithparalleltrace(involvingthreadpools).1">Example #5: Client and Server with parallel trace (involving thread pools)</h3><p>In this example server-side implementation of the JAX-RS service is going to offload some work into thread pool and then return the response to the client, simulating parallel execution. The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks(@Context final TracerContext tracer) throws Exception {
    final Future&lt;Book&gt; book1 = executor.submit(
        tracer.wrap("Getting Book 1", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(100);
                     
                return new Book("Apache CXF Web Service Development", 
                    "Naveen Balani, Rajeev Hathi");
            }
        })
    );
         
    final Future&lt;Book&gt; book2 = executor.submit(
        tracer.wrap("Getting Book 2", new Traceable&lt;Book&gt;() {
            public Book call(final TracerContext context) throws Exception {
                // Simulating a delay of 100ms required to call external system
                Thread.sleep(200);
                     
                return new Book("Developing Web Services with Apache CXF and Axis2", 
                    "Kent Ka Iok Tong");
            }
        })
    );
        
    return Arrays.asList(book1.get(), book2.get());
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (process name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-13-13.png"></span></p><h3 id="UsingOpenTracing-Example#6:ClientandServerwithasynchronousJAX-RSservice(server-side).1">Example #6: Client and Server with asynchronous JAX-RS service (server-side)</h3><p>In this example server-side implementation of the JAX-RS service is going to be executed asynchronously. It poses a challenge from the tracing prospective as request and response are processed in different threads (in general). At the moment, <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> does not support the transparent tracing spans management (except for default use case) but provides the simple ways to do that (by letting to transfer spans from thread to thread). The client-side code stays unchanged.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public void getBooks(@Suspended final AsyncResponse response, @Context final TracerContext tracer) throws Exception {
    tracer.continueSpan(new Traceable&lt;Future&lt;Void&gt;&gt;() {
        public Future&lt;Void&gt; call(final TracerContext context) throws Exception {
            return executor.submit(
                tracer.wrap("Getting Book", new Traceable&lt;Void&gt;() {
                    public Void call(final TracerContext context) throws Exception {
                        // Simulating a processing delay of 50ms
                        Thread.sleep(50);
                             
                        response.resume(
                            Arrays.asList(
                                new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
                            )
                        );
                             
                        return null;
                    }
                })
            );
        }
    });
}</pre>
</div></div><p>The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-15-19.png"></span></p><h3 id="UsingOpenTracing-Example#7:ClientandServerwithasynchronousinvocation(client-side).1">Example #7: Client and Server with asynchronous invocation (client-side)</h3><p>In this example server-side implementation of the JAX-RS service is going to be the default one:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@Produces( { MediaType.APPLICATION_JSON } )
@GET
public Collection&lt;Book&gt; getBooks() {
    return Arrays.asList(
        new Book("Apache CXF Web Service Development", "Naveen Balani, Rajeev Hathi")
    );
}</pre>
</div></div><p>While the JAX-RS client&#160;implementation is going to perform the asynchronous invocation:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Future&lt;Response&gt; future = client
    .target("http://localhost:8282/books")
    .request()
    .accept(MediaType.APPLICATION_JSON)
    .async()
    .get();</pre>
</div></div><p>In this respect, there is no difference from the caller prospective however a bit more work is going under the hood to transfer the active tracing span from JAX-RS client request filter to client response filter as in general those are executed in different threads (similarly to server-side asynchronous JAX-RS resource invocation). The actual invocation of the request by the client (with service name <strong>tracer-<span class="label label-default service-filter-label service-tag-filtered">client</span></strong>) and consequent invocation of the service on the server side (service name<strong> tracer-<span class="label label-default service-filter-label">server</span></strong>) is going to generate the following sample traces (taken from <a shape="rect" class="external-link" href="https://github.com/uber/jaeger-ui" rel="nofollow">Jaeger UI</a>):</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image" width="1148" src="using-opentracing.data/image2018-8-12_15-17-38.png"></span></p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandJAX-WSsupport.1">Distributed Tracing with OpenTracing and JAX-WS support</h2><p>Distributed tracing in the <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> is build primarily around JAX-RS 2.x implementation. However, JAX-WS is also supported but it requires to write some boiler-plate code and use&#160;<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a>&#160;<a shape="rect" class="external-link" href="https://github.com/opentracing/opentracing-java" rel="nofollow">Java API</a> directly (the JAX-WS integration is going to be enhanced in the future). Essentially, from the server-side prospective the in/out interceptors, <strong>OpenTracingStartInterceptor</strong> and <strong><strong>OpenTracing</strong>StopInterceptor </strong>respectively, should be configured as part of interceptor chains, either manually or using <strong><strong>OpenTracing</strong>Feature</strong>. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer")
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration() 
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();;

final JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();
...
sf.getFeatures().add(new OpenTracingFeature(trace));
...
sf.create();</pre>
</div></div><p>Similarly to the server-side, client-side needs own set of out/in interceptors, <strong><strong>OpenTracing</strong>ClientStartInterceptor</strong> and <strong><strong>OpenTracing</strong>ClientStopInterceptor</strong> (or <strong><strong>OpenTracing</strong>ClientFeature</strong>). Please notice the difference from server-side:&#160; <strong><strong>OpenTracing</strong>ClientStartInterceptor</strong> becomes out-interceptor while <strong><strong>OpenTracing</strong>ClientStopInterceptor</strong> becomes in-interceptor. For example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">final Tracer tracer = new Configuration("tracer") 
    .withSampler(
        new SamplerConfiguration() 
            .withType(ConstSampler.TYPE) /* or any other Sampler */
            .withParam(1)
        )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration() /* or any other Sender configuration */
                    .withEndpoint("http://localhost:14268/api/traces")
            )
    )
    .getTracer();;
              
final JaxWsProxyFactoryBean sf = new JaxWsProxyFactoryBean();
...
sf.getFeatures().add(new OpenTracingClientFeature(tracer));
...
sf.create();

</pre>
</div></div><p>As it was mentioned before, you may use <strong>GlobalTracer</strong> utility class to pass the tracer around so, for example, any JAX-WS service will be able to retrieve the current tracer by invoking <strong>GlobalTracer.get()</strong> method.</p><h2 id="UsingOpenTracing-DistributedTracingwithOpenTracingandOSGi.1">Distributed Tracing with OpenTracing and OSGi</h2><p class="external-link">Most of the distributed tracers compatible with <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> API could be deployed into <strong>OSGi</strong> container and as such, the integration is fully available for <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a> services running inside the container. For a complete example please take a look on <a shape="rect" class="external-link" href="https://github.com/apache/cxf/master/distribution/src/main/release/samples/jax_rs_tracing_opentracing_osgi/README.txt" rel="nofollow">jax_rs_tracing_opentracing_osgi</a> sample project, but here is the typical <strong>OSGi</strong>&#160; Blueprint snippet in case of <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a>.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cxf="http://cxf.apache.org/blueprint/core"
       xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"

       xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
                           http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
                           http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;bean id="tracingFeature" class="org.apache.cxf.tracing.opentracing.jaxrs.OpenTracingFeature"&gt;
        &lt;argument index="0"&gt;
            &lt;bean factory-ref="withReporter" factory-method="getTracer" /&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;

    &lt;bean id="samplerBuilder" class="io.jaegertracing.Configuration.SamplerConfiguration" /&gt;
    
    &lt;bean id="withType" factory-ref="samplerBuilder" factory-method="withType"&gt;
        &lt;argument index="0" value="const"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sampler" factory-ref="withType" factory-method="withParam"&gt;
        &lt;argument index="0"&gt;
            &lt;bean class="java.lang.Integer"&gt;
                &lt;argument value="1" /&gt;
            &lt;/bean&gt;
        &lt;/argument&gt;
    &lt;/bean&gt;
    
    &lt;bean id="senderBuilder" class="io.jaegertracing.Configuration.SenderConfiguration" /&gt;
    
    &lt;bean id="sender" factory-ref="senderBuilder" factory-method="withEndpoint"&gt;
        &lt;argument index="0" value="http://localhost:14268/api/traces"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="reporterBuilder" class="io.jaegertracing.Configuration.ReporterConfiguration" /&gt;
    
    &lt;bean id="reporter" factory-ref="reporterBuilder" factory-method="withSender"&gt;
        &lt;argument index="0" ref="sender"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="builder" class="io.jaegertracing.Configuration"&gt;
        &lt;argument index="0" value="cxf-server" /&gt;
    &lt;/bean&gt;

    &lt;bean id="withSampler" factory-ref="builder" factory-method="withSampler"&gt;
        &lt;argument index="0" ref="sampler"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="withReporter" factory-ref="withSampler" factory-method="withReporter"&gt;
        &lt;argument index="0" ref="reporter"/&gt;
    &lt;/bean&gt;
    
    &lt;cxf:bus&gt;
        &lt;cxf:features&gt;
            &lt;cxf:logging /&gt;
        &lt;/cxf:features&gt;
    &lt;/cxf:bus&gt;

    &lt;jaxrs:server id="catalogServer" address="/"&gt;
        &lt;jaxrs:serviceBeans&gt;
            ...
        &lt;/jaxrs:serviceBeans&gt;
        &lt;jaxrs:providers&gt;
            &lt;ref component-id="tracingFeature" /&gt;
        &lt;/jaxrs:providers&gt;
    &lt;/jaxrs:server&gt;
&lt;/blueprint&gt;</pre>
</div></div><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>As of now, <a shape="rect" class="external-link" href="https://uber.github.io/jaeger/" rel="nofollow">Jaeger</a> tracer does not provide OSGi bundles and the service loader mechanism is not working very well. It is very likely that you may need to declare own sender configuration instance (overriding <strong>getSender</strong> method) or use system properties to pick the right one.</p></div></div><h2 id="UsingOpenTracing-Samples.1">Samples</h2><ul><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_camel</a></li><li><a shape="rect" class="external-link" href="https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi" rel="nofollow">https://github.com/apache/cxf/tree/master/distribution/src/main/release/samples/jax_rs/tracing_opentracing_osgi</a></li></ul><h1 id="UsingOpenTracing-AccessingOpenTracingAPIs">Accessing OpenTracing APIs</h1><p>The <a shape="rect" href="http://cxf.apache.org/">Apache CXF</a>&#160; abstracts as much of the tracer-specific APIs behind <strong>TracerContext</strong> as possible. However, sometimes there is a need to get access to&#160;<a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> APIs in order to leverages the rich set of available instrumentations. To make it possible, <strong>TracerContext</strong> has a dedicated <strong>unwrap</strong> method which returns underlying <strong>Tracer</strong> instance. The snippet below shows off how to use this API and use <a shape="rect" class="external-link" href="http://opentracing.io/" rel="nofollow">OpenTracing</a> instrumentation for <a shape="rect" class="external-link" href="https://github.com/OpenFeign/feign-opentracing" rel="nofollow">OpenFeign client</a>.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="brush: java; gutter: false; theme: Default">@GET
@Path("/search")
@Produces(MediaType.APPLICATION_JSON)
public JsonObject search(@QueryParam("q") final String query, @Context final TracerContext tracing) throws Exception {
    final GoogleBooksApi api = Feign.builder()
        .client(new TracingClient(new ApacheHttpClient(), tracing.unwrap(Tracer.class)))
        .target(GoogleBooksApi.class, "https://www.googleapis.com");

    final Response response = api.search(query);
    try (final Reader reader = response.body().asReader()) {
        return Json.createReader(reader).readObject();
    }
}</pre>
</div></div></div>
           </div>
           <!-- Content -->
         </td>
        </tr>
      </table>
   </td>
   <td id="cell-2-2" colspan="2">&nbsp;</td>
  </tr>
  <tr>
   <td id="cell-3-0">&nbsp;</td>
   <td id="cell-3-1">&nbsp;</td>
   <td id="cell-3-2">
     <div id="footer">
       <!-- Footer -->
       <div id="site-footer">
         <a href="http://cxf.apache.org/privacy-policy.html">Privacy Policy</a> - 
         (<a href="https://cwiki.apache.org/confluence/pages/editpage.action?pageId=73637478">edit page</a>) 
	 (<a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=73637478&amp;showComments=true&amp;showCommentArea=true#addcomment">add comment</a>)<br>
	Apache CXF, CXF, Apache, the Apache feather logo are trademarks of The Apache Software Foundation.<br>
        All other marks mentioned may be trademarks or registered trademarks of their respective owners.
       </div>
       <!-- Footer -->
     </div>
   </td>
   <td id="cell-3-3">&nbsp;</td>
   <td id="cell-3-4">&nbsp;</td>
  </tr>
  <tr>
    <td id="cell-4-0" colspan="2">&nbsp;</td>
    <td id="cell-4-1">&nbsp;</td>
    <td id="cell-4-2" colspan="2">&nbsp;</td>
  </tr>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4458903-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

